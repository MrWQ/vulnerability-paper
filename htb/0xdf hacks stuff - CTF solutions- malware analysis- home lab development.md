> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [0xdf.gitlab.io](https://0xdf.gitlab.io/)

*   Jan 1, 2021
    
    ### [Hackvent 2020 - leet(ish)](https://0xdf.gitlab.io/hackvent2020/leet)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackvent](https://0xdf.gitlab.io/tags.html#hackvent) [polyglot](https://0xdf.gitlab.io/tags.html#polyglot) [binwalk](https://0xdf.gitlab.io/tags.html#binwalk) [jsnice](https://0xdf.gitlab.io/tags.html#jsnice) [python](https://0xdf.gitlab.io/tags.html#python) [chef](https://0xdf.gitlab.io/tags.html#chef) [docker](https://0xdf.gitlab.io/tags.html#docker) [steghide](https://0xdf.gitlab.io/tags.html#steghide) [tomcat](https://0xdf.gitlab.io/tags.html#tomcat) [cve-2020-9484](https://0xdf.gitlab.io/tags.html#cve-2020-9484) [ysoserial](https://0xdf.gitlab.io/tags.html#ysoserial) [deserialization](https://0xdf.gitlab.io/tags.html#deserialization) [elf](https://0xdf.gitlab.io/tags.html#elf) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [lru-cache](https://0xdf.gitlab.io/tags.html#lru-cache) [ios](https://0xdf.gitlab.io/tags.html#ios) [itunes](https://0xdf.gitlab.io/tags.html#itunes) [itunes-backup2hashcat](https://0xdf.gitlab.io/tags.html#itunes-backup2hashcat) [fonepaw](https://0xdf.gitlab.io/tags.html#fonepaw) [rsa](https://0xdf.gitlab.io/tags.html#rsa) [rsactftool](https://0xdf.gitlab.io/tags.html#rsactftool) [wireshark](https://0xdf.gitlab.io/tags.html#wireshark) [pcap](https://0xdf.gitlab.io/tags.html#pcap) ![](https://0xdf.gitlab.io/img/hackvent2020-leet-cover.) 
    
    The leet challenges started on day 20, but then followed an additional three hard challenges before the second and final leet one. These were all really good challenges. My favorite was a binary and a PCAP of an attacker exploiting the binary, where I needed to reverse the crypto operations in the binary and the exploit to recover the data that was stolen. I really liked one that was another polyglot file where an image turned into an HTML page that dropped a Python script which pull out a docker image containing images that contained a flag. There was also more web exploitation of a Tomcat deserialization CVE, a really interesting ELF reversing challenge, and pulling data from an iOS backup.
    

*   Jan 1, 2021
    
    ### [Hackvent 2020 - Hard](https://0xdf.gitlab.io/hackvent2020/hard)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackvent](https://0xdf.gitlab.io/tags.html#hackvent) [xls](https://0xdf.gitlab.io/tags.html#xls) [excel](https://0xdf.gitlab.io/tags.html#excel) [forensic](https://0xdf.gitlab.io/tags.html#forensic) [cbc](https://0xdf.gitlab.io/tags.html#cbc) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [gimp](https://0xdf.gitlab.io/tags.html#gimp) [polyglot](https://0xdf.gitlab.io/tags.html#polyglot) [mbr](https://0xdf.gitlab.io/tags.html#mbr) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [ida](https://0xdf.gitlab.io/tags.html#ida) [bochs](https://0xdf.gitlab.io/tags.html#bochs) [python](https://0xdf.gitlab.io/tags.html#python) [flask](https://0xdf.gitlab.io/tags.html#flask) [command-injection](https://0xdf.gitlab.io/tags.html#command-injection) [injection](https://0xdf.gitlab.io/tags.html#injection) [rubiks](https://0xdf.gitlab.io/tags.html#rubiks) [stl](https://0xdf.gitlab.io/tags.html#stl) [rubik-cube](https://0xdf.gitlab.io/tags.html#rubik-cube) [ja3](https://0xdf.gitlab.io/tags.html#ja3) [go](https://0xdf.gitlab.io/tags.html#go) [ja3transport](https://0xdf.gitlab.io/tags.html#ja3transport) [jwt](https://0xdf.gitlab.io/tags.html#jwt) [ecryptfs](https://0xdf.gitlab.io/tags.html#ecryptfs) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [ecryptfs2john](https://0xdf.gitlab.io/tags.html#ecryptfs2john) [pyyaml](https://0xdf.gitlab.io/tags.html#pyyaml) [yaml-deserialization](https://0xdf.gitlab.io/tags.html#yaml-deserialization) [binwalk](https://0xdf.gitlab.io/tags.html#binwalk) ![](https://0xdf.gitlab.io/img/hackvent2020-hard-cover.) 
    
    The first seven hard challenges included my favorite challenge of the year, Santa’s Special GIFt, where the given file is both a GIF image and a master boot record. Handing it as such allowed me to reverse the code and emulate it to get two flags. There’s another challenge that looks at the failures of CBC on encrypting an raw bitmap image, three web exploitation challenges exploiting command injection, JA3 impresonation, and Python YAML deserialization, and another Rubik’s cube to solve.
    

*   Jan 1, 2021
    
    ### [Hackvent 2020 - Medium](https://0xdf.gitlab.io/hackvent2020/medium)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackvent](https://0xdf.gitlab.io/tags.html#hackvent) [rubiks](https://0xdf.gitlab.io/tags.html#rubiks) [py222](https://0xdf.gitlab.io/tags.html#py222) [pil](https://0xdf.gitlab.io/tags.html#pil) [scrambles](https://0xdf.gitlab.io/tags.html#scrambles) [python](https://0xdf.gitlab.io/tags.html#python) [dnspy](https://0xdf.gitlab.io/tags.html#dnspy) [perl](https://0xdf.gitlab.io/tags.html#perl) [obfuscation](https://0xdf.gitlab.io/tags.html#obfuscation) [ssti](https://0xdf.gitlab.io/tags.html#ssti) [jinja2](https://0xdf.gitlab.io/tags.html#jinja2) [flask](https://0xdf.gitlab.io/tags.html#flask) [werkzeug-debug](https://0xdf.gitlab.io/tags.html#werkzeug-debug) [colb](https://0xdf.gitlab.io/tags.html#colb) [networkx](https://0xdf.gitlab.io/tags.html#networkx) [graphs](https://0xdf.gitlab.io/tags.html#graphs) [cliques](https://0xdf.gitlab.io/tags.html#cliques) [mobilefish](https://0xdf.gitlab.io/tags.html#mobilefish) [rsa](https://0xdf.gitlab.io/tags.html#rsa) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [wiener](https://0xdf.gitlab.io/tags.html#wiener) [mpz](https://0xdf.gitlab.io/tags.html#mpz) ![](https://0xdf.gitlab.io/img/hackvent2020-medium-cover.) 
    
    Medium continues with another seven challenges over seven days. There’s a really good crypto challenge involving recovering RSA parameters recovered from a PCAP file and submitted to a Wiener attack, web hacking through an server-side template injection, dotNet reversing, a Rubik’s cube challenge, and what is becoming the annual obfuscated Perl game.
    

*   Jan 1, 2021
    
    ### [Hackvent 2020 - Easy](https://0xdf.gitlab.io/hackvent2020/easy)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackvent](https://0xdf.gitlab.io/tags.html#hackvent) [encoding](https://0xdf.gitlab.io/tags.html#encoding) [gimp](https://0xdf.gitlab.io/tags.html#gimp) [python](https://0xdf.gitlab.io/tags.html#python) [stegsolve](https://0xdf.gitlab.io/tags.html#stegsolve) [steganography](https://0xdf.gitlab.io/tags.html#steganography) [cyberchef](https://0xdf.gitlab.io/tags.html#cyberchef) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [known-plaintext](https://0xdf.gitlab.io/tags.html#known-plaintext) [bkcrack](https://0xdf.gitlab.io/tags.html#bkcrack) [binwalk](https://0xdf.gitlab.io/tags.html#binwalk) [steghide](https://0xdf.gitlab.io/tags.html#steghide) ![](https://0xdf.gitlab.io/img/hackvent2020-easy-cover.) 
    
    Hackvent started out early with a -1 day released on 29 November. There were seven easy challenges, including -1, one hidden, and five daily challenges. These challenges were heavy in crypto, image editing / steg, and encoding. My favorite in the group was Chinese Animals, where I spent way more figuring out what was going on after solving than actually solving.
    

*   Dec 26, 2020
    
    ### [Advent of Code 2020: Day 25](https://0xdf.gitlab.io/adventofcode2020/25)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [modular-arithmetic](https://0xdf.gitlab.io/tags.html#modular-arithmetic) ![](https://0xdf.gitlab.io/img/aoc2020-25-cover.) 
    
    Day 25 is an encryption problem using modular arithmetic. I’ve given two public keys, both of which are of the form 7d mod 20201227 where d is unknown. The challenge is to find each d.
    

*   Dec 24, 2020
    
    ### [Advent of Code 2020: Day 24](https://0xdf.gitlab.io/adventofcode2020/24)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-24-cover.) 
    
    The twist on day 24 is that it takes place on a grid of hexagons, so each tile has six neighbors, and a normal x,y or r,c coordinate system will be very difficult to use. I’ll use an x, y, z coordinate system to flip tiles based on some input and then watch it evolve based on it’s neighbors.
    

*   Dec 23, 2020
    
    ### [Advent of Code 2020: Day 23](https://0xdf.gitlab.io/adventofcode2020/23)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-23-cover.) 
    
    Today is another game. This time I’m given a list of numbers and asked to mix it according to some given rules a certain number of times. Today is also the first time this year where I wrote part one, and then completely started over given part two.
    

*   Dec 22, 2020
    
    ### [Advent of Code 2020: Day 22](https://0xdf.gitlab.io/adventofcode2020/22)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-22-cover.) 
    
    I’m asked to play out a game between two players that in part one looks like the classic card game of war, and in part two goes off in a different direction of “recursive combat”. Both parts came together pretty quickly, though part two had a few places where small mistakes made identifying mistakes difficult.
    

*   Dec 22, 2020
    
    ### [Advent of Code 2020: Day 21](https://0xdf.gitlab.io/adventofcode2020/21)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-21-cover.) 
    
    Day 21 was welcome relief after day 20. In this one, I’ll parse a list of foods, each with an ingredients list and a listing of some (not necessarily all) of the allergies. I’ll use that list to pair up allergens to ingredients.
    

*   Dec 22, 2020
    
    ### [Advent of Code 2020: Day 20](https://0xdf.gitlab.io/adventofcode2020/20)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-20-cover.) 
    
    Day 20 was almost the end of my 2020 Advent of Code. I managed to solve part one in 15 minutes, but then part two got me for days. I finally solved it, but I can’t promise pretty code.
    

*   Dec 19, 2020
    
    ### [Advent of Code 2020: Day 19](https://0xdf.gitlab.io/adventofcode2020/19)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-19-cover.) 
    
    Another day with a section of convoluted validation rules and a series of items to be validated. Today’s rules apply to a string, and I’ll actually use a recursive algorithm to generate a single regex string that can then be applied to each input to check validity. It gets slightly more difficult in the second part, where loops are introduced into the rules. In order to work around this, I’ll guess at a depth at which I can start to ignore further loops.
    

*   Dec 19, 2020
    
    ### [HTB: Laser](https://0xdf.gitlab.io/2020/12/19/htb-laser.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Laser](https://0xdf.gitlab.io/tags.html#laser) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ubuntu](https://0xdf.gitlab.io/tags.html#ubuntu) [jetdirect](https://0xdf.gitlab.io/tags.html#jetdirect) [pret](https://0xdf.gitlab.io/tags.html#pret) [printer](https://0xdf.gitlab.io/tags.html#printer) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [python](https://0xdf.gitlab.io/tags.html#python) [proto3](https://0xdf.gitlab.io/tags.html#proto3) [grpc](https://0xdf.gitlab.io/tags.html#grpc) [solr](https://0xdf.gitlab.io/tags.html#solr) [cve-2019-17558](https://0xdf.gitlab.io/tags.html#cve-2019-17558) [gopher](https://0xdf.gitlab.io/tags.html#gopher) [pspy](https://0xdf.gitlab.io/tags.html#pspy) [sshpass](https://0xdf.gitlab.io/tags.html#sshpass) [socat](https://0xdf.gitlab.io/tags.html#socat) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) ![](https://0xdf.gitlab.io/img/laser-cover.) 
    
    Laser starts without the typical attack paths, offering only SSH and two unusual ports. One of those is a printer, which gives the opportunity to leak data including a print job and the memory with the encryption key for that job. The PDF gives details of how the second port works, using protocol buffers over gRPC. I’ll use this spec to write my own client, and use that to build a port scanner and scan the box for other open ports on localhost. When I find Apache Solr, I’ll use create another exploit to go through the gRPC service and send a POST request using Gopher to exploit Solr and get code execution and a shell. To escalate to root, I’ll collect SSH credentials for the root user in a container, and then use socat to redirect a cron SCP and SSH job back at the host box and exploit that to get code execution and root.
    

*   Dec 18, 2020
    
    ### [Advent of Code 2020: Day 18](https://0xdf.gitlab.io/adventofcode2020/18)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-18-cover.) 
    
    Day 18 is reimplementing a simple math system with addition, multiplication, and parentheses, where the order of operations changes. I’ll write a single calc function that takes in the string to evaluate as well as the order of operations to apply.
    

*   Dec 17, 2020
    
    ### [Advent of Code 2020: Day 17](https://0xdf.gitlab.io/adventofcode2020/17)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [conway](https://0xdf.gitlab.io/tags.html#conway) [game-of-life](https://0xdf.gitlab.io/tags.html#game-of-life) ![](https://0xdf.gitlab.io/img/aoc2020-17-cover.) 
    
    Day 17 was a modified version of Conway’s Game of Life, played across three and four dimensions, where a cells state in the next time step is determined by the its current state and the state of its neighbors.
    

*   Dec 16, 2020
    
    ### [Advent of Code 2020: Day 16](https://0xdf.gitlab.io/adventofcode2020/16)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-16-cover.) 
    
    Day 16 was an interesting one to think about, as the algorithm for solving it wasn’t obvious. It wasn’t the case like some of the previous ones where there was an intuitive way to think about it but it would take too long. It was more a case of wrapping your head around the problem and how to organize the data so that you could match keys to values using validity rules and a bunch of examples. I made a guess that the data might clean up nicely in a certain way, and when it did, it made the second part much easier.
    

*   Dec 15, 2020
    
    ### [Advent of Code 2020: Day 15](https://0xdf.gitlab.io/adventofcode2020/15)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [defaultdict](https://0xdf.gitlab.io/tags.html#defaultdict) ![](https://0xdf.gitlab.io/img/aoc2020-15-cover.) 
    
    Day 15 is a game the elves play, where you have to remember the numbers said in a list, and append the next number based on when it was previously said. I’ll solve by storing the numbers not in a list and searching it each time, but rather in a dictionary of lists, where the key is the number and the value is a list of indexes. It still runs a bit slow in part two, but it works.
    

*   Dec 14, 2020
    
    ### [Advent of Code 2020: Day 14](https://0xdf.gitlab.io/adventofcode2020/14)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-14-cover.) 
    
    Part one of day 14 looked to be some basic binary masking and manipulation. But in part two, it got trickier, as now I need to handle Xs in the mask as both 0 and 1, meaning that there would be 2num X results. I used a recursive function to generate the list of indexes there.
    

*   Dec 13, 2020
    
    ### [Advent of Code 2020: Day 13](https://0xdf.gitlab.io/adventofcode2020/13)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [chinese-remainder-theorem](https://0xdf.gitlab.io/tags.html#chinese-remainder-theorem) ![](https://0xdf.gitlab.io/img/aoc2020-13-cover.) 
    
    Day 13 is looking at a series of buses that are running on their own time cycles, and trying to find times where the buses arrive in certain patterns. It brings in a somewhat obscure number theory concept called the Chinese Remainder Theorem, which has to do with solving a series of modular linear equations that all equal the same value.
    

*   Dec 12, 2020
    
    ### [HTB: OpenKeyS](https://0xdf.gitlab.io/2020/12/12/htb-openkeys.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [OpenKeyS](https://0xdf.gitlab.io/tags.html#openkeys) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [vim](https://0xdf.gitlab.io/tags.html#vim) [bsd](https://0xdf.gitlab.io/tags.html#bsd) [openbsd](https://0xdf.gitlab.io/tags.html#openbsd) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [php](https://0xdf.gitlab.io/tags.html#php) [auth_userokay](https://0xdf.gitlab.io/tags.html#auth-userokay) [CVE-2019-19521](https://0xdf.gitlab.io/tags.html#cve-2019-19521) [CVE-2019-19520](https://0xdf.gitlab.io/tags.html#cve-2019-19520) [CVE-2019-19522](https://0xdf.gitlab.io/tags.html#cve-2019-19522) [shared_object](https://0xdf.gitlab.io/tags.html#shared-object) [skey](https://0xdf.gitlab.io/tags.html#skey) [CVE-2020-7247](https://0xdf.gitlab.io/tags.html#cve-2020-7247) [OneTwoSeven](https://0xdf.gitlab.io/tags.html#onetwoseven) ![](https://0xdf.gitlab.io/img/openkeys-cover.) 
    
    OpenKeyS was all about a series of OpenBSD vulnerabilities published by Qualys in December 2019. I’ll enumerate a web page to find a vim swap file that provides some hints about how the login form is doing auth. I’ll use that to construct an attack that allows me to bypass the authentication and login as Jennifer, retrieving Jennifer’s SSH key. To root, I’ll exploit two more vulnerabilities, first to get access to the auth group using a shared library attack on xlock, and then abusing S/Key authentication. In Beyond Root, I’ll look at another OpenBSD vulnerability that was made public just after the box was released, and play with PHP and the $_REQUEST variable.
    

*   Dec 12, 2020
    
    ### [Advent of Code 2020: Day 12](https://0xdf.gitlab.io/adventofcode2020/12)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-12-cover.) 
    
    Day 12 is about moving a ship across a coordinate plane using directions and a way point that moves and rotates around the ship. There’s a bit of geometry, and I made a really dumb mistake that took me a long time to figure out.
    

*   Dec 11, 2020
    
    ### [Advent of Code 2020: Day 11](https://0xdf.gitlab.io/adventofcode2020/11)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-11-cover.) 
    
    Day 11 is grid-based challenge, where I’m giving a grid floor, empty seat, and occupied seat, and asked to step through time using rules that define how a seat will be occupied at time t+1 given the state of it and it’s neighbors at time t. My code gets really ugly today, but it solves.
    

*   Dec 10, 2020
    
    ### [Advent of Code 2020: Day 10](https://0xdf.gitlab.io/adventofcode2020/10)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [lru-cache](https://0xdf.gitlab.io/tags.html#lru-cache) ![](https://0xdf.gitlab.io/img/aoc2020-10-cover.) 
    
    Day 10 is about looking at a list of numbers. In the first part I’ll just need to make a histogram of the differences between the numbers when sorted. For part two, it’s the first challenge this year where I’ll need to come up with an efficient algorithm to handle it. I’m asked to come up with the number of valid combinations according to some constraints. I’ll use recursion to solve it, and it only works in reasonable time with caching on that recursion.
    

*   Dec 9, 2020
    
    ### [Advent of Code 2020: Day 9](https://0xdf.gitlab.io/adventofcode2020/9)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-9-cover.) 
    
    Day 9 is two challenges about looking across lists of ints to find pairs or slices with a given sum.
    

*   Dec 8, 2020
    
    ### [Advent of Code 2020: Day 8](https://0xdf.gitlab.io/adventofcode2020/8)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-8-cover.) 
    
    Today I’m asked to build a small three instruction computer, and parse a series of instructions (puzzle input). I’m told that the instructions form an infinate loop, which is easy to identify in this simple computer any time an instruction is executed a second time. I’ll look at finding where that infinate loop is entered, as well as finding the one instruction that can be patched to fix the code. I’ll create a class for the computer with the thinking that I might be coming back to use it again and build on it later.
    

*   Dec 7, 2020
    
    ### [Advent of Code 2020: Day 7](https://0xdf.gitlab.io/adventofcode2020/7)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [lru-cache](https://0xdf.gitlab.io/tags.html#lru-cache) [defaultdict](https://0xdf.gitlab.io/tags.html#defaultdict) ![](https://0xdf.gitlab.io/img/aoc2020-7-cover.) 
    
    Day 7 gives me a list of bags, and what bags must go into those bags. The two parts are based on looking for what can hold what and how many. I’ll use defaultdicts to manage the rules, and two recurrsive functions (including one that benefits from lru_cache) to solve the parts.
    

*   Dec 6, 2020
    
    ### [Advent of Code 2020: Day 6](https://0xdf.gitlab.io/adventofcode2020/6)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-6-cover.) 
    
    Day 6 was another text parsing challenge, breaking the input into groups and then counting across the users within each group. Both parts were similar, with the first counting if any user said yes to a given question, and the latter if every user said yes to a given question. Python makes this a breeze either way.
    

*   Dec 5, 2020
    
    ### [HTB: Unbalanced](https://0xdf.gitlab.io/2020/12/05/htb-unbalanced.html)
    
    [Unbalanced](https://0xdf.gitlab.io/tags.html#unbalanced) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [squid](https://0xdf.gitlab.io/tags.html#squid) [http-proxy](https://0xdf.gitlab.io/tags.html#http-proxy) [foxy-proxy](https://0xdf.gitlab.io/tags.html#foxy-proxy) [rsync](https://0xdf.gitlab.io/tags.html#rsync) [encfs](https://0xdf.gitlab.io/tags.html#encfs) [john](https://0xdf.gitlab.io/tags.html#john) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [squidclient](https://0xdf.gitlab.io/tags.html#squidclient) [xpath-injection](https://0xdf.gitlab.io/tags.html#xpath-injection) [python](https://0xdf.gitlab.io/tags.html#python) [pihole](https://0xdf.gitlab.io/tags.html#pihole) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [upload](https://0xdf.gitlab.io/tags.html#upload) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [password-reuse](https://0xdf.gitlab.io/tags.html#password-reuse) [Joker](https://0xdf.gitlab.io/tags.html#joker) [Zetta](https://0xdf.gitlab.io/tags.html#zetta) ![](https://0xdf.gitlab.io/img/unbalanced-cover.) 
    
    Unbalanced starts with a Squid proxy and RSync. I’ll use RSync to pull back the files that underpin an Encrypted Filesystem (EncFS) instance, and crack the password to gain access to the backup config files. In those files I’ll find the Squid config, which includes the internal site names, as well as the creds to manage the Squid. Looking at the proxy stats, I can find two internal IPs, and guess the existence of a third, which is currently out of order for security fixes. In the site on the third IP, I’ll find XPath injection allowing me to leak a bunch of usernames and passwords, one of which provides SSH access to the host. I’ll exploit into a Pi-Hole container using an exploit to upload a webshell, and find a script which contains the root creds for the host. In Beyond Root, I’ll look at why the searchsploit version of the PiHole exploit didn’t work.
    

*   Dec 5, 2020
    
    ### [Advent of Code 2020: Day 5](https://0xdf.gitlab.io/adventofcode2020/5)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-5-cover.) 
    
    Day 5 is wrapped in a story about plane ticket seat finding, but really it boils down to a simple binary to integer conversion, and then finding the difference of two sets and cleaning up what’s left based on some simple rules.
    

*   Dec 4, 2020
    
    ### [Advent of Code 2020: Day 4](https://0xdf.gitlab.io/adventofcode2020/4)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [regex](https://0xdf.gitlab.io/tags.html#regex) ![](https://0xdf.gitlab.io/img/aoc2020-4-cover.) 
    
    Day 4 presented another text parsing challenge. In the first part, I just needed to validate if each section contained a specific seven strings, which is easy enough to solve in Python. For part two, I need to now look at the text following each of these strings, and apply some validation rules. At first I thought I’d throw out my part 1 work and start processing all the data into a Python dict. But then I realized I could just write a regex for each validation, and use the same pattern.
    

*   Dec 3, 2020
    
    ### [Advent of Code 2020: Day 3](https://0xdf.gitlab.io/adventofcode2020/3)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-3-cover.) 
    
    Advent of code always dives into visual mapping in a way that makes you conceptualize 2D (or 3D) space and move through it. I’ve got a map that represents a slope with clear spaces and trees, and that repeats moving to the right. As this is an early challenge, it’s still relatively simple to handle the map with just an array of strings, which I’ll do to count the trees I encounter on different trajectories moving across the map.
    

*   Dec 2, 2020
    
    ### [Advent of Code 2020: Day 2](https://0xdf.gitlab.io/adventofcode2020/2)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-2-cover.) 
    
    Day 2 was about processing lines that contained two numbers, a character, and a string which is referred to as a password. Both parts are about using the numbers and the character to determine if the password is “valid”. How the numbers and character become a rule is different in parts 1 and 2.
    

*   Dec 1, 2020
    
    ### [Advent of Code 2020: Day 1](https://0xdf.gitlab.io/adventofcode2020/1)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2020-1-cover.) 
    
    Advent of Code is a CTF put on by Google every December, providing coding challenges, and it’s a favorite of mine to practice. There are 25 days to collect 50 stars. For Day 1, the puzzle was basically reading a list of numbers, and looking through them for a pair and a set of three that summed to 2020. For each part, I’ll multiple the identified numbers together to get the solution.
    

*   Nov 28, 2020
    
    ### [HTB: SneakyMailer](https://0xdf.gitlab.io/2020/11/28/htb-sneakymailer.html)
    
    [SneakyMailer](https://0xdf.gitlab.io/tags.html#sneakymailer) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [vhosts](https://0xdf.gitlab.io/tags.html#vhosts) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [phish](https://0xdf.gitlab.io/tags.html#phish) [swaks](https://0xdf.gitlab.io/tags.html#swaks) [Xen](https://0xdf.gitlab.io/tags.html#xen) [imap](https://0xdf.gitlab.io/tags.html#imap) [smtp](https://0xdf.gitlab.io/tags.html#smtp) [evolution](https://0xdf.gitlab.io/tags.html#evolution) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [php](https://0xdf.gitlab.io/tags.html#php) [pypi](https://0xdf.gitlab.io/tags.html#pypi) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [htpasswd](https://0xdf.gitlab.io/tags.html#htpasswd) [setup-py](https://0xdf.gitlab.io/tags.html#setup-py) [Chaos](https://0xdf.gitlab.io/tags.html#chaos) [Canape](https://0xdf.gitlab.io/tags.html#canape) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [pip](https://0xdf.gitlab.io/tags.html#pip) [service](https://0xdf.gitlab.io/tags.html#service) ![](https://0xdf.gitlab.io/img/sneakymailer-cover.) 
    
    SneakyMailer starts with web enumeration to find a list of email addresses, which I can use along with SMTP access to send phishing emails. One of the users will click on the link, and return a POST request with their login creds. That provides access to the IMAP inbox for that user, where I’ll find creds for FTP. The FTP access is in the web directory, and while there’s nothing interesting there, I can write a webshell and get execution, and a shell. To privesc, I’ll submit a malicious Python package to the local PyPi server, which provides execution and a shell as that user. For root, I’ll abuse a sudo rule to run pip, installing the same package again. In Beyond Root, I’ll look at the automation on the box running as services.
    

*   Nov 21, 2020
    
    ### [HTB: Buff](https://0xdf.gitlab.io/2020/11/21/htb-buff.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Buff](https://0xdf.gitlab.io/tags.html#buff) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [windows](https://0xdf.gitlab.io/tags.html#windows) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [gym-management-system](https://0xdf.gitlab.io/tags.html#gym-management-system) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [cloudme](https://0xdf.gitlab.io/tags.html#cloudme) [chisel](https://0xdf.gitlab.io/tags.html#chisel) [msfvenom](https://0xdf.gitlab.io/tags.html#msfvenom) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [defender](https://0xdf.gitlab.io/tags.html#defender) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/buff-cover.) 
    
    Buff is a really good OSCP-style box, where I’ll have to identify a web software running on the site, and exploit it using a public exploit to get execution through a webshell. To privesc, I’ll find another service I can exploit using a public exploit. I’ll update with my own shellcode to make a reverse shell, and set up a tunnel so that I can connect to the service that listens only on localhost. From there, the exploit script returns an administrator shell. In Beyond Root, I’ll step through the first script and perform the exploit manually, and look at how Defender was blocking some of my attempts.
    

*   Nov 14, 2020
    
    ### [HTB: Intense](https://0xdf.gitlab.io/2020/11/14/htb-intense.html)
    
    [Intense](https://0xdf.gitlab.io/tags.html#intense) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [snmp](https://0xdf.gitlab.io/tags.html#snmp) [snmpwalk](https://0xdf.gitlab.io/tags.html#snmpwalk) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [injection](https://0xdf.gitlab.io/tags.html#injection) [sqlite](https://0xdf.gitlab.io/tags.html#sqlite) [python](https://0xdf.gitlab.io/tags.html#python) [burp](https://0xdf.gitlab.io/tags.html#burp) [bruteforce](https://0xdf.gitlab.io/tags.html#bruteforce) [penglab](https://0xdf.gitlab.io/tags.html#penglab) [cookie](https://0xdf.gitlab.io/tags.html#cookie) [hash-extension](https://0xdf.gitlab.io/tags.html#hash-extension) [hash-extender](https://0xdf.gitlab.io/tags.html#hash-extender) [directory-traversal](https://0xdf.gitlab.io/tags.html#directory-traversal) [snmp-shell](https://0xdf.gitlab.io/tags.html#snmp-shell) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [bof](https://0xdf.gitlab.io/tags.html#bof) [logic-error](https://0xdf.gitlab.io/tags.html#logic-error) [Rope](https://0xdf.gitlab.io/tags.html#rope) [gdb](https://0xdf.gitlab.io/tags.html#gdb) [peda](https://0xdf.gitlab.io/tags.html#peda) ![](https://0xdf.gitlab.io/img/intense-cover.) 
    
    Intense presented some cool challenges. I’ll start by finding a SQL injection vulnerability into an SQLlite database. I’m able to leak the admin hash, but not crack it. Using the source code for the site, I’ll see that if I can use a hash extension attack, I can use the hash trick the site into providing admin access. From there, I’ll use a directory traversal bug in a log reading API to find SNMP read/write creds, which I’ll use to get a shell with snmp-shell. I can use that to find a custom binary listening on localhost, as well as it’s source code. I’ll use the snmp account to create an SSH tunnel, and exploit a logic bug in the code to overflow the buffer, bypass protections, and get a shell as root. In Beyond Root, I’ll look at why I didn’t have success with the system libc call in my ROP, figure out why, and fix it.
    

*   Nov 7, 2020
    
    ### [HTB: Tabby](https://0xdf.gitlab.io/2020/11/07/htb-tabby.html)
    
    [Tabby](https://0xdf.gitlab.io/tags.html#tabby) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [php](https://0xdf.gitlab.io/tags.html#php) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [tomcat](https://0xdf.gitlab.io/tags.html#tomcat) [host-manager](https://0xdf.gitlab.io/tags.html#host-manager) [tomcat-manager](https://0xdf.gitlab.io/tags.html#tomcat-manager) [war](https://0xdf.gitlab.io/tags.html#war) [msfvenom](https://0xdf.gitlab.io/tags.html#msfvenom) [password-reuse](https://0xdf.gitlab.io/tags.html#password-reuse) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [zip2john](https://0xdf.gitlab.io/tags.html#zip2john) [john](https://0xdf.gitlab.io/tags.html#john) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [penglab](https://0xdf.gitlab.io/tags.html#penglab) [lxc](https://0xdf.gitlab.io/tags.html#lxc) [lxd](https://0xdf.gitlab.io/tags.html#lxd) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [Jerry](https://0xdf.gitlab.io/tags.html#jerry) [Teacher](https://0xdf.gitlab.io/tags.html#teacher) [Popcorn](https://0xdf.gitlab.io/tags.html#popcorn) [Lightweight](https://0xdf.gitlab.io/tags.html#lightweight) [Sunday](https://0xdf.gitlab.io/tags.html#sunday) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/tabby-cover.) 
    
    Tabby was a well designed easy level box that required finding a local file include (LFI) in a website to leak the credentials for the Tomcat server on that same host. The user who’s creds I gain access to only has access to the command line manager API, not the GUI, but I can use that to upload a WAR file, get execution, and a shell. I’ll crack the password on a backup zip archive and then use that same password to change to the next user. That user is a member of the lxd group, which allows them to start containers. I’ve shown this root before, but this time I’ll include a really neat trick from m0noc that saves several steps. In Beyond Root, I’ll pull apart the WAR file and show what’s actually in it.
    

*   Nov 2, 2020
    
    ### [Flare-On 2020: break](https://0xdf.gitlab.io/flare-on-2020/break)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [break](https://0xdf.gitlab.io/tags.html#break) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [ptrace](https://0xdf.gitlab.io/tags.html#ptrace) [hook](https://0xdf.gitlab.io/tags.html#hook) [ldpreload](https://0xdf.gitlab.io/tags.html#ldpreload) [pre-main](https://0xdf.gitlab.io/tags.html#pre-main) [gdb](https://0xdf.gitlab.io/tags.html#gdb) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [feistel-cipher](https://0xdf.gitlab.io/tags.html#feistel-cipher) [unpack](https://0xdf.gitlab.io/tags.html#unpack) [modinv](https://0xdf.gitlab.io/tags.html#modinv) [python](https://0xdf.gitlab.io/tags.html#python) [Mischief](https://0xdf.gitlab.io/tags.html#mischief) [Obscurity](https://0xdf.gitlab.io/tags.html#obscurity) [Teacher](https://0xdf.gitlab.io/tags.html#teacher) [Popcorn](https://0xdf.gitlab.io/tags.html#popcorn) [Lightweight](https://0xdf.gitlab.io/tags.html#lightweight) [Sunday](https://0xdf.gitlab.io/tags.html#sunday) ![](https://0xdf.gitlab.io/img/flare2020-break-cover.) 
    
    break was an amazing challenge. Just looking at main, it looks like a simple comparison against a static flag. But there’s an init function that runs first, forking a child process that then attaches a debugger to the parent, hooking all of it’s system calls and crashes. The child itself forks a second child, which attaches to the first child, handling several intentional crash points in the first child’s code. The effectively prevents my debugging the parent for first child, as only one debugger can attach at a time. I’ll use two different approaches - hooking library calls and patching the second child’s functionality directly into the first child, allowing me to debug the first child. Using these techniques, I’ll wind through three parts of the flag, each successively more difficult to break out.
    

*   Nov 1, 2020
    
    ### [Flare-On 2020: crackinstaller](https://0xdf.gitlab.io/flare-on-2020/crackinstaller)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [crackinstaller](https://0xdf.gitlab.io/tags.html#crackinstaller) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [capcom-sys](https://0xdf.gitlab.io/tags.html#capcom-sys) [driver](https://0xdf.gitlab.io/tags.html#driver) [kernel-debug](https://0xdf.gitlab.io/tags.html#kernel-debug) ![](https://0xdf.gitlab.io/img/flare2020-crackinstaller-cover.) 
    
    crackinstaller.exe was a complicated binary that installed the Capcom.sys driver, and then exploited it to load another driver into memory. It also dropped and installed another DLL, a credential helper. I used kernel debugging to see how the second driver is loaded, and eventually find a password, which I can feed into the credential helper to get the flag. I spent over two of the six weeks working crackinstaller.exe, and unfortunately, I stopped taking meaningful notes very early in that process, so this won’t be much of a writeup, but rather a high level overview.
    

*   Nov 1, 2020
    
    ### [Flare-On 2020: Aardvark](https://0xdf.gitlab.io/flare-on-2020/aardvark)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [aardvark](https://0xdf.gitlab.io/tags.html#aardvark) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [wsl](https://0xdf.gitlab.io/tags.html#wsl) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [resource-hacker](https://0xdf.gitlab.io/tags.html#resource-hacker) [process-hacker](https://0xdf.gitlab.io/tags.html#process-hacker) [gdb](https://0xdf.gitlab.io/tags.html#gdb) [peda](https://0xdf.gitlab.io/tags.html#peda) [pwndbg](https://0xdf.gitlab.io/tags.html#pwndbg) ![](https://0xdf.gitlab.io/img/flare2020-aardvark-cover.) 
    
    Aardvark was a game of tik-tac-toe where the computer always goes first, and can’t lose. Instead of having the decision logic of the computer in the program, it drops an ELF binary to act as the computer, and communicates with it over a unix socket, all of which is possible on Windows with the Windows Subsystem for Linux (WSL). Once I understand how the computer is playing, I’ll modify the computers logic so that I can win, and get the flag. I’ll play with different ways to patch the binary, starting manually with gdb, and moving to patching the ELF resource a couple different ways.
    

*   Oct 31, 2020
    
    ### [HTB: Fuse](https://0xdf.gitlab.io/2020/10/31/htb-fuse.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Fuse](https://0xdf.gitlab.io/tags.html#fuse) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [windows](https://0xdf.gitlab.io/tags.html#windows) [ldap](https://0xdf.gitlab.io/tags.html#ldap) [ldapsearch](https://0xdf.gitlab.io/tags.html#ldapsearch) [rpc](https://0xdf.gitlab.io/tags.html#rpc) [smb](https://0xdf.gitlab.io/tags.html#smb) [winrm](https://0xdf.gitlab.io/tags.html#winrm) [evil-winrm](https://0xdf.gitlab.io/tags.html#evil-winrm) [crackmapexec](https://0xdf.gitlab.io/tags.html#crackmapexec) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap) [rpcclient](https://0xdf.gitlab.io/tags.html#rpcclient) [papercut](https://0xdf.gitlab.io/tags.html#papercut) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [cewl](https://0xdf.gitlab.io/tags.html#cewl) [hydra](https://0xdf.gitlab.io/tags.html#hydra) [smbpasswd](https://0xdf.gitlab.io/tags.html#smbpasswd) [rpcclient](https://0xdf.gitlab.io/tags.html#rpcclient) [capcom](https://0xdf.gitlab.io/tags.html#capcom) [driver](https://0xdf.gitlab.io/tags.html#driver) [visual-studio](https://0xdf.gitlab.io/tags.html#visual-studio) [eoploaddriver](https://0xdf.gitlab.io/tags.html#eoploaddriver) [msfvenom](https://0xdf.gitlab.io/tags.html#msfvenom) [scheduled-task](https://0xdf.gitlab.io/tags.html#scheduled-task) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/fuse-cover.) 
    
    Fuse was all about pulling information out of a printer admin page. I’ll collect usernames and use cewl to make a wordlist, which happens to find the password for a couple accounts. I’ll need to change the password on the account to use it, and then I can get RPC access, where I’ll find more creds in the comments. I can use those creds for WinRM access, where I’ll find myself with privileges to load a driver. I’ll use the popular Capcom.sys driver to load a payload that returns a shell as system. In Beyond Root, I’ll look at the scheduled tasks that are managing the users passwords and trying to uninstall drivers put in place by HTB players.
    

*   Oct 30, 2020
    
    ### [Flare-On 2020: RE Crowd](https://0xdf.gitlab.io/flare-on-2020/recrowd)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [recrowd](https://0xdf.gitlab.io/tags.html#recrowd) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [pcap](https://0xdf.gitlab.io/tags.html#pcap) [wireshark](https://0xdf.gitlab.io/tags.html#wireshark) [tshark](https://0xdf.gitlab.io/tags.html#tshark) [cve-2017-7269](https://0xdf.gitlab.io/tags.html#cve-2017-7269) [shellcode](https://0xdf.gitlab.io/tags.html#shellcode) [scdbg](https://0xdf.gitlab.io/tags.html#scdbg) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [python](https://0xdf.gitlab.io/tags.html#python) [x64dbg](https://0xdf.gitlab.io/tags.html#x64dbg) [cff-explorer](https://0xdf.gitlab.io/tags.html#cff-explorer) [cyberchef](https://0xdf.gitlab.io/tags.html#cyberchef) [procmon](https://0xdf.gitlab.io/tags.html#procmon) ![](https://0xdf.gitlab.io/img/flare2020-recrowd-cover.) 
    
    RE Crowd was a different kind of reversing challenge. I’m given a PCAP that includes someone trying to exploit an IIS webserver using CVE-2017-7269. This exploit uses alphanumeric shellcode to run on success. I’ll pull the shellcode and analyze it, seeing that it’s a Metasploit loader that connects to a host and then the host sends back an encrypted blob. The host then sends another encrypted blob back to the attcker. I’ll use what I can learn about the attacker’s commands to decrypt that exfil and find the flag.
    

*   Oct 29, 2020
    
    ### [Flare-On 2020: CodeIt](https://0xdf.gitlab.io/flare-on-2020/codeit)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [codeit](https://0xdf.gitlab.io/tags.html#codeit) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [autoit](https://0xdf.gitlab.io/tags.html#autoit) [exe2aut](https://0xdf.gitlab.io/tags.html#exe2aut) [upx](https://0xdf.gitlab.io/tags.html#upx) [myauttoexe](https://0xdf.gitlab.io/tags.html#myauttoexe) [script-obfuscation](https://0xdf.gitlab.io/tags.html#script-obfuscation) [crypto](https://0xdf.gitlab.io/tags.html#crypto) ![](https://0xdf.gitlab.io/img/flare2020-codeit-cover.) 
    
    The sixth Flare-On7 challenge was tricky in a way that’s hard to put on the page. It really was just a AutoIt script wrapped in a Windows exe. I’ll use a tool to revert it back to a large, obfuscated script, and then get to work deobfuscating it. Eventually I’ll see that it is looking for a specific hostname, and on switching my hostname to match, I get a QRcode that contains the flag.
    

*   Oct 28, 2020
    
    ### [Flare-On 2020: TKApp](https://0xdf.gitlab.io/flare-on-2020/tkapp)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [tkapp](https://0xdf.gitlab.io/tags.html#tkapp) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [tizen](https://0xdf.gitlab.io/tags.html#tizen) [tpk](https://0xdf.gitlab.io/tags.html#tpk) [dnspy](https://0xdf.gitlab.io/tags.html#dnspy) [dotnet](https://0xdf.gitlab.io/tags.html#dotnet) [emulation](https://0xdf.gitlab.io/tags.html#emulation) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/flare2020-tkapp-cover.) 
    
    TKApp was a Tizen mobile application that was made to run on a smart watch. Inside the archive, there’s a .NET dll that drives the application, so I can break it open with dnSpy. Four variables are initialized through different user actions or different aspects of the files on the watch, and then used to generate a key to decrypt a buffer. I’ll show both static analysis to pull the keys and then decrypt in Python, as well as how to emulate a watch and then go through the steps to get it to display the flag in the gallery.
    

*   Oct 27, 2020
    
    ### [Flare-On 2020: report.xls](https://0xdf.gitlab.io/flare-on-2020/report)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [report](https://0xdf.gitlab.io/tags.html#report) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [xls](https://0xdf.gitlab.io/tags.html#xls) [vba](https://0xdf.gitlab.io/tags.html#vba) [olevba](https://0xdf.gitlab.io/tags.html#olevba) [evil-clippy](https://0xdf.gitlab.io/tags.html#evil-clippy) [pcode](https://0xdf.gitlab.io/tags.html#pcode) [vba-stomp](https://0xdf.gitlab.io/tags.html#vba-stomp) [python](https://0xdf.gitlab.io/tags.html#python) [pcodedmp](https://0xdf.gitlab.io/tags.html#pcodedmp) [pcode2code](https://0xdf.gitlab.io/tags.html#pcode2code) [script-obfuscation](https://0xdf.gitlab.io/tags.html#script-obfuscation) ![](https://0xdf.gitlab.io/img/flare2020-report-cover.) 
    
    report.xls was my kind of challenge. It’s an Excel book with an macro with some relatively standard obfuscation and sandbox evasion. In analyzing the VBA, I see more and more hints that something odd is going on. Eventually I’ll extract an mp3 file with several more hints that the VBA has been stomped, replacing the p-code with something different from the VBA. When I dump the p-code and analyze it, I’ll find an image with the flag.
    

*   Oct 26, 2020
    
    ### [Flare-On 2020: wednesday](https://0xdf.gitlab.io/flare-on-2020/wednesday)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [wednesday](https://0xdf.gitlab.io/tags.html#wednesday) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [nimlang](https://0xdf.gitlab.io/tags.html#nimlang) [x64dbg](https://0xdf.gitlab.io/tags.html#x64dbg) [patching](https://0xdf.gitlab.io/tags.html#patching) ![](https://0xdf.gitlab.io/img/flare2020-wednesday-cover.) 
    
    wednesday was a game that involved getting my dude to the end jumping over and going under blocks. The game was written in Nim lang, and had a lot of complex functions to manage the game. It was a long way to go, so I patched it to just let me run through blocks and not worry about under vs over.
    

*   Oct 26, 2020
    
    ### [Flare-On 2020: garbage](https://0xdf.gitlab.io/flare-on-2020/garbage)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [garbage](https://0xdf.gitlab.io/tags.html#garbage) [upx](https://0xdf.gitlab.io/tags.html#upx) [pe](https://0xdf.gitlab.io/tags.html#pe) [cff-explorer](https://0xdf.gitlab.io/tags.html#cff-explorer) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [resource-hacker](https://0xdf.gitlab.io/tags.html#resource-hacker) ![](https://0xdf.gitlab.io/img/flare2020-garbage-cover.) 
    
    garbage was all about understanding the structure of an exe file, and how to repair it when the last few hundred bytes were truncated. I’ll troubleshoot the binary and eventually get it working to the point that I can unpack it, do static analysis, and get the flag. I’ll also show how to fix the binary so that it will just run and print the flag in a message box.
    

*   Oct 26, 2020
    
    ### [Flare-On 2020: Fidler](https://0xdf.gitlab.io/flare-on-2020/fidler)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [fidler](https://0xdf.gitlab.io/tags.html#fidler) [python](https://0xdf.gitlab.io/tags.html#python) [pygame](https://0xdf.gitlab.io/tags.html#pygame) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) ![](https://0xdf.gitlab.io/img/flare2020-fidler-cover.) 
    
    Flare-On 7 got off to an easy start with a Windows executable that was generated with PyGame, and included the Python source. That made this challenge more of a Python source code analysis exercise than a reversing challenge. I’ll find the password and the win conditions in the source, and win both by decrypting the flag and by modifying the source.
    

*   Oct 24, 2020
    
    ### [HTB: Dyplesher](https://0xdf.gitlab.io/2020/10/24/htb-dyplesher.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Dyplesher](https://0xdf.gitlab.io/tags.html#dyplesher) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [memcached](https://0xdf.gitlab.io/tags.html#memcached) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [gogs](https://0xdf.gitlab.io/tags.html#gogs) [git](https://0xdf.gitlab.io/tags.html#git) [gitdumper](https://0xdf.gitlab.io/tags.html#gitdumper) [memcached-binary](https://0xdf.gitlab.io/tags.html#memcached-binary) [memcached-auth](https://0xdf.gitlab.io/tags.html#memcached-auth) [memcached-cli](https://0xdf.gitlab.io/tags.html#memcached-cli) [memcat](https://0xdf.gitlab.io/tags.html#memcat) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [git-bundle](https://0xdf.gitlab.io/tags.html#git-bundle) [sqlite](https://0xdf.gitlab.io/tags.html#sqlite) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [bukkit](https://0xdf.gitlab.io/tags.html#bukkit) [minecraft](https://0xdf.gitlab.io/tags.html#minecraft) [spigot](https://0xdf.gitlab.io/tags.html#spigot) [intellij](https://0xdf.gitlab.io/tags.html#intellij) [java](https://0xdf.gitlab.io/tags.html#java) [jar](https://0xdf.gitlab.io/tags.html#jar) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [packet-capture](https://0xdf.gitlab.io/tags.html#packet-capture) [wireshark](https://0xdf.gitlab.io/tags.html#wireshark) [cuberite](https://0xdf.gitlab.io/tags.html#cuberite) [rabbitmq](https://0xdf.gitlab.io/tags.html#rabbitmq) [amqp-publish](https://0xdf.gitlab.io/tags.html#amqp-publish) [lua](https://0xdf.gitlab.io/tags.html#lua) ![](https://0xdf.gitlab.io/img/dyplesher-cover.) 
    
    Dyplesher pushed server modern technologies that are not common in CTFs I’ve done. Initial access requires finding a virtual host with a .git directory that allows me to find the credentials used for the memcache port. After learning about the binary memcache protocol that supports authentication, I’m able to connect and dump usernames and password from the cache, which provide access to a Gogs instance. In Gogs, I’ll find four git bundles (repo backups), one of which contains custom code with an SQLite db containing password hashes. One cracks, providing access to the web dashboard. In this dashboard, I’m able to upload and run Bukkit plugins. I’ll write a malicious one that successfully writes both a webshell and an SSH key, both of which provide access to the box as the same first user. This user has access to a dumpcap binary, which I’ll use to capture traffic finding Rabbit message queue traffic that contains the usernames and password for the next user. This user has instructions to send a url over the messaging queue, which will cause the box to download and run a cuberite plugin. I’ll figure out how to publish my host into the queue, and write a malicious Lua script that will provide root access. In Beyond Root, I’ll look more deeply at the binary memcache protocol.
    

*   Oct 17, 2020
    
    ### [HTB: Blunder](https://0xdf.gitlab.io/2020/10/17/htb-blunder.html)
    
    [Blunder](https://0xdf.gitlab.io/tags.html#blunder) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ubuntu](https://0xdf.gitlab.io/tags.html#ubuntu) [bludit](https://0xdf.gitlab.io/tags.html#bludit) [cms](https://0xdf.gitlab.io/tags.html#cms) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [github](https://0xdf.gitlab.io/tags.html#github) [cewl](https://0xdf.gitlab.io/tags.html#cewl) [bruteforce](https://0xdf.gitlab.io/tags.html#bruteforce) [python](https://0xdf.gitlab.io/tags.html#python) [upload](https://0xdf.gitlab.io/tags.html#upload) [filter](https://0xdf.gitlab.io/tags.html#filter) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [crackstation](https://0xdf.gitlab.io/tags.html#crackstation) [cve-2019-14287](https://0xdf.gitlab.io/tags.html#cve-2019-14287) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/blunder-cover.) 
    
    Blunder starts with a blog that I’ll find is hosted on the BludIt CMS. Some version enumeration and looking at releases on GitHub shows that this version is vulnerable to a bypass of the bruteforce protections, as well as an upload and execute filter bypass on the PHP site. I’ll write my own scripts for each of these, and use them to get a shell. From there, I’ll find creds for the next user, where I’ll find the first flag. Now I can also access sudo, where I’ll see I can run sudo to get a bash shell as any non-root user. I’ll exploit CVE-2019-14287 to run that as root, and get a root shell.
    

*   Oct 10, 2020
    
    ### [HTB: Cache](https://0xdf.gitlab.io/2020/10/10/htb-cache.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Cache](https://0xdf.gitlab.io/tags.html#cache) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ubuntu](https://0xdf.gitlab.io/tags.html#ubuntu) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [vhost](https://0xdf.gitlab.io/tags.html#vhost) [javascript](https://0xdf.gitlab.io/tags.html#javascript) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [password-reuse](https://0xdf.gitlab.io/tags.html#password-reuse) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [openemr](https://0xdf.gitlab.io/tags.html#openemr) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [authentication-bypass](https://0xdf.gitlab.io/tags.html#authentication-bypass) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [injection](https://0xdf.gitlab.io/tags.html#injection) [sqlmap](https://0xdf.gitlab.io/tags.html#sqlmap) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [memcached](https://0xdf.gitlab.io/tags.html#memcached) [docker](https://0xdf.gitlab.io/tags.html#docker) ![](https://0xdf.gitlab.io/img/cache-cover.) 
    
    Cache rates medium based on number of steps, none of which are particularly challenging. There’s a fair amount of enumeration of a website, first, to find a silly login page that has hardcoded credentials that I’ll store for later, and then to find a new VHost that hosts a vulnerable OpenEMR system. I’ll exploit that system three ways, first to bypass authentication, which provides access to a page vulnerable to SQL-injection, which I’ll use to dump the hashes. After cracking the hash, I’ll exploit the third vulnerability with a script from ExploitDB which provides authenticated code execution. That RCE provides a shell. I’ll escalate to the next user reusing the creds from the hardcoded website. I’ll find creds for the next user in memcached. This user is in the docker group, which I’ll exploit to get root access.
    

*   Oct 3, 2020
    
    ### [HTB: Blackfield](https://0xdf.gitlab.io/2020/10/03/htb-blackfield.html)
    
    [Blackfield](https://0xdf.gitlab.io/tags.html#blackfield) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [dns](https://0xdf.gitlab.io/tags.html#dns) [ldap](https://0xdf.gitlab.io/tags.html#ldap) [crackmapexec](https://0xdf.gitlab.io/tags.html#crackmapexec) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [as-rep-roast](https://0xdf.gitlab.io/tags.html#as-rep-roast) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [bloodhound](https://0xdf.gitlab.io/tags.html#bloodhound) [bloodhound-py](https://0xdf.gitlab.io/tags.html#bloodhound-py) [rpc-password-reset](https://0xdf.gitlab.io/tags.html#rpc-password-reset) [pypykatz](https://0xdf.gitlab.io/tags.html#pypykatz) [evil-winrm](https://0xdf.gitlab.io/tags.html#evil-winrm) [sebackupprivilege](https://0xdf.gitlab.io/tags.html#sebackupprivilege) [copy-filesepackupprivilege](https://0xdf.gitlab.io/tags.html#copy-filesepackupprivilege) [efs](https://0xdf.gitlab.io/tags.html#efs) [diskshadow](https://0xdf.gitlab.io/tags.html#diskshadow) [ntds](https://0xdf.gitlab.io/tags.html#ntds) [vss](https://0xdf.gitlab.io/tags.html#vss) [secretsdump](https://0xdf.gitlab.io/tags.html#secretsdump) [smbserver](https://0xdf.gitlab.io/tags.html#smbserver) [icacls](https://0xdf.gitlab.io/tags.html#icacls) [cipher](https://0xdf.gitlab.io/tags.html#cipher) [windows-sessions](https://0xdf.gitlab.io/tags.html#windows-sessions) [msf](https://0xdf.gitlab.io/tags.html#msf) [meterpreter](https://0xdf.gitlab.io/tags.html#meterpreter) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus) ![](https://0xdf.gitlab.io/img/blackfield-cover.) 
    
    Blackfield was a beautiful Windows Activity directory box where I’ll get to exploit AS-REP-roasting, discover privileges with bloodhound from my remote host using BloodHound.py, and then reset another user’s password over RPC. With access to another share, I’ll find a bunch of process memory dumps, one of which is lsass.exe, which I’ll use to dump hashes with pypykatz. Finally with a hash that gets a WinRM shell, I’ll abuse backup privileges to read the ntds.dit file that contains all the hashes for the domain (as well as a copy of the SYSTEM reg hive). I’ll use those to dump the hashes, and get access as the administrator. In Beyond Root, I’ll look at the EFS that prevented my reading root.txt using backup privs, as well as go down a rabbit hole into Windows sessions and why the cipher command was returning weird results.
    

*   Sep 26, 2020
    
    ### [HTB: Admirer](https://0xdf.gitlab.io/2020/09/26/htb-admirer.html)
    
    [Admirer](https://0xdf.gitlab.io/tags.html#admirer) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [debian](https://0xdf.gitlab.io/tags.html#debian) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [robots-text](https://0xdf.gitlab.io/tags.html#robots-text) [source-code](https://0xdf.gitlab.io/tags.html#source-code) [adminer](https://0xdf.gitlab.io/tags.html#adminer) [mysql](https://0xdf.gitlab.io/tags.html#mysql) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [pythonpath](https://0xdf.gitlab.io/tags.html#pythonpath) [path-hijack](https://0xdf.gitlab.io/tags.html#path-hijack) [python-library-hijack](https://0xdf.gitlab.io/tags.html#python-library-hijack) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/admirer-cover.) 
    
    Admirer provided a twist on abusing a web database interface, in that I don’t have creds to connect to any databases on Admirer, but I’ll instead connect to a database on myhost and use queries to get local file access to Admirer. Before getting there, I’ll do some web enumeration to find credentials for FTP which has some outdated source code that leads me to the Adminer web interface. From there, I can read the current source, and get a password which works for SSH access. To privesc, I’ll abuse sudo configured to allow me to pass in a PYTHONPATH, allowing a Python library hijack.
    

*   Sep 19, 2020
    
    ### [HTB: Multimaster](https://0xdf.gitlab.io/2020/09/19/htb-multimaster.html)
    
    [Multimaster](https://0xdf.gitlab.io/tags.html#multimaster) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [waf](https://0xdf.gitlab.io/tags.html#waf) [filter](https://0xdf.gitlab.io/tags.html#filter) [unicode](https://0xdf.gitlab.io/tags.html#unicode) [sqlmap](https://0xdf.gitlab.io/tags.html#sqlmap) [tamper](https://0xdf.gitlab.io/tags.html#tamper) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [crackmapexec](https://0xdf.gitlab.io/tags.html#crackmapexec) [cyberchef](https://0xdf.gitlab.io/tags.html#cyberchef) [python](https://0xdf.gitlab.io/tags.html#python) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [injections](https://0xdf.gitlab.io/tags.html#injections) [windows](https://0xdf.gitlab.io/tags.html#windows) [mssql](https://0xdf.gitlab.io/tags.html#mssql) [rid](https://0xdf.gitlab.io/tags.html#rid) [evil-winrm](https://0xdf.gitlab.io/tags.html#evil-winrm) [cef-debugging](https://0xdf.gitlab.io/tags.html#cef-debugging) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [bloodhound](https://0xdf.gitlab.io/tags.html#bloodhound) [amsi](https://0xdf.gitlab.io/tags.html#amsi) [powersploit](https://0xdf.gitlab.io/tags.html#powersploit) [as-rep-roast](https://0xdf.gitlab.io/tags.html#as-rep-roast) [server-operators](https://0xdf.gitlab.io/tags.html#server-operators) [service](https://0xdf.gitlab.io/tags.html#service) [service-hijack](https://0xdf.gitlab.io/tags.html#service-hijack) [sebackupprivilege](https://0xdf.gitlab.io/tags.html#sebackupprivilege) [serestoreprivilege](https://0xdf.gitlab.io/tags.html#serestoreprivilege) [robocopy](https://0xdf.gitlab.io/tags.html#robocopy) [cve-2020-1472](https://0xdf.gitlab.io/tags.html#cve-2020-1472) [zerologon](https://0xdf.gitlab.io/tags.html#zerologon) ![](https://0xdf.gitlab.io/img/multimaster-cover.) 
    
    Multimaster was a lot of steps, some of which were quite difficult. I’ll start by identifying a SQL injection in a website. I’ll have to figure out the WAF and find a way past that, dumping credentials but also writing a script to use MSSQL to enumerate the domain users. To pivot to the second user, I’ll exploit an instance of Visual Studio Code that’s left an open CEF debugging socket open. That user has access to a DLL in the web directory, in which I’ll find more credentials to pivot to another user. This user has GenericWrite privileges on another user, so I’ll abuse that to get a shell. This final user is in the Server Operators group, allowing me to modify services to get a shell as SYSTEM. I’ll show two alternative roots, abusing the last user’s SeBackupPrivilege and SeRestorePrivilege with robotcopy to read the flag, and using ZeroLogon to go right to administrator in one step.
    

*   Sep 17, 2020
    
    ### [ZeroLogon - Owning HTB machines with CVE-2020-1472](https://0xdf.gitlab.io/2020/09/17/zerologon-owning-htb-machines-with-cve-2020-1472.html)
    
    [cve-2020-1472](https://0xdf.gitlab.io/tags.html#cve-2020-1472) [exploit](https://0xdf.gitlab.io/tags.html#exploit) [domain-controller](https://0xdf.gitlab.io/tags.html#domain-controller) [Monteverde](https://0xdf.gitlab.io/tags.html#monteverde) [zerologon](https://0xdf.gitlab.io/tags.html#zerologon) [impacket](https://0xdf.gitlab.io/tags.html#impacket) [python](https://0xdf.gitlab.io/tags.html#python) [virtualenv](https://0xdf.gitlab.io/tags.html#virtualenv) [secretsdump](https://0xdf.gitlab.io/tags.html#secretsdump) ![](https://0xdf.gitlab.io/img/zero-cover.) 
    
    CVE-2020-1472 was patched in August 2020 by Microsoft, but it didn’t really make a splash until the last week when proof of concept exploits started hitting GutHub. It truly is a short path to domain admin. I’ll look at the exploit and own some machines from HTB with it.
    

*   Sep 12, 2020
    
    ### [HTB: Travel](https://0xdf.gitlab.io/2020/09/12/htb-travel.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Travel](https://0xdf.gitlab.io/tags.html#travel) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ubuntu](https://0xdf.gitlab.io/tags.html#ubuntu) [vhosts](https://0xdf.gitlab.io/tags.html#vhosts) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [wordpress](https://0xdf.gitlab.io/tags.html#wordpress) [awesome-rss](https://0xdf.gitlab.io/tags.html#awesome-rss) [simplepie](https://0xdf.gitlab.io/tags.html#simplepie) [git](https://0xdf.gitlab.io/tags.html#git) [gittools](https://0xdf.gitlab.io/tags.html#gittools) [gitdumper](https://0xdf.gitlab.io/tags.html#gitdumper) [source-code](https://0xdf.gitlab.io/tags.html#source-code) [memcached](https://0xdf.gitlab.io/tags.html#memcached) [ssrf](https://0xdf.gitlab.io/tags.html#ssrf) [filter](https://0xdf.gitlab.io/tags.html#filter) [deserialization](https://0xdf.gitlab.io/tags.html#deserialization) [php](https://0xdf.gitlab.io/tags.html#php) [gopher](https://0xdf.gitlab.io/tags.html#gopher) [gopherus](https://0xdf.gitlab.io/tags.html#gopherus) [payloadsallthethings](https://0xdf.gitlab.io/tags.html#payloadsallthethings) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [container](https://0xdf.gitlab.io/tags.html#container) [docker](https://0xdf.gitlab.io/tags.html#docker) [database](https://0xdf.gitlab.io/tags.html#database) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [password-reuse](https://0xdf.gitlab.io/tags.html#password-reuse) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [viminfo](https://0xdf.gitlab.io/tags.html#viminfo) [ldap](https://0xdf.gitlab.io/tags.html#ldap) [authorizedkeyscommand](https://0xdf.gitlab.io/tags.html#authorizedkeyscommand) [ldif](https://0xdf.gitlab.io/tags.html#ldif) [ldapadd](https://0xdf.gitlab.io/tags.html#ldapadd) [getent](https://0xdf.gitlab.io/tags.html#getent) ![](https://0xdf.gitlab.io/img/travel-cover.) 
    
    Travel was just a great box because it provided a complex and challenging puzzle with new pieces that were fun to explore. I’ll start off digging through various vhosts until I eventually find an exposed .git folder on one. That provides me the source for another, which includes a custom RSS feed that’s cached using memcache. I’ll evaluate that code to find a deserialization vulnerability on the read from memcache. I’ll create an exploit using a server-side request forgery attack to poison the memcache with a serialized PHP payload that will write a webshell, and then trigger it, gaining execution and eventually a shell inside a container. I’ll find a hash in the database which I can crack to get a password for the user on the main host. This user is also the LDAP administrator, and SSH is configured to check LDAP for logins. I’ll pick an arbitrary user and add an SSH private key, password, and the sudo group to their LDAP such that then when I log in as that user, I can just sudo to root. In Beyond Root I’ll explore a weird behavior I observed in the RSS feed.
    

*   Sep 10, 2020
    
    ### [HTB: Haircut](https://0xdf.gitlab.io/2020/09/10/htb-haircut.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Haircut](https://0xdf.gitlab.io/tags.html#haircut) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [php](https://0xdf.gitlab.io/tags.html#php) [upload](https://0xdf.gitlab.io/tags.html#upload) [comman-injection](https://0xdf.gitlab.io/tags.html#comman-injection) [parameter-injection](https://0xdf.gitlab.io/tags.html#parameter-injection) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [curl](https://0xdf.gitlab.io/tags.html#curl) [filter](https://0xdf.gitlab.io/tags.html#filter) [screen](https://0xdf.gitlab.io/tags.html#screen) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/haircut-cover.) 
    
    Haircut started with some web enumeration where I’ll find a PHP site invoking curl. I’ll use parameter injection to write a webshell to the server and get execution. I’ll also enumerate the filters and find a way to get command execution in the page itself. To jump to root, I’ll identify a vulnerable version of screen that is set SUID (which is normal). I’ll walk through this exploit. In Beyond Root, I’ll take a quick look at the filtering put in place in the PHP page.
    

*   Sep 8, 2020
    
    ### [RoguePotato on Remote](https://0xdf.gitlab.io/2020/09/08/roguepotato-on-remote.html)
    
    [Remote](https://0xdf.gitlab.io/tags.html#remote) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [windows](https://0xdf.gitlab.io/tags.html#windows) [seimpersonate](https://0xdf.gitlab.io/tags.html#seimpersonate) [roguepotato](https://0xdf.gitlab.io/tags.html#roguepotato) [lonelypotato](https://0xdf.gitlab.io/tags.html#lonelypotato) [juicypotato](https://0xdf.gitlab.io/tags.html#juicypotato) [ippsec](https://0xdf.gitlab.io/tags.html#ippsec) [socat](https://0xdf.gitlab.io/tags.html#socat) ![](https://0xdf.gitlab.io/img/roguepotato-remote-cover.) 
    
    JuicyPotato was a go-to exploit whenever I found myself with a Windows shell with SeImpersonatePrivilege, which typically was whenever there was some kind of webserver exploit. But Microsoft changed things in Server 2019 to brake JuicyPotato, so I was really excited when splinter_code and decoder came up with RoguePotato, a follow-on exploit that works around the protections put into place in Server 2019. When I originally solved Remote back in March, RoguePotato had not yet been released. I didn’t have time last week to add it to my Remote write-up, so I planned to do a follow up post to show it. While in the middle of this post, I also watched IppSec’s video where he tries to use RoguePotato on Remote in a way that worked but shouldn’t have, raising a real mystery. I’ll dig into that and show what happened as well.
    

*   Sep 5, 2020
    
    ### [HTB: Remote](https://0xdf.gitlab.io/2020/09/05/htb-remote.html)
    
    [Remote](https://0xdf.gitlab.io/tags.html#remote) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [nfs](https://0xdf.gitlab.io/tags.html#nfs) [umbraco](https://0xdf.gitlab.io/tags.html#umbraco) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [nishang](https://0xdf.gitlab.io/tags.html#nishang) [teamviewer](https://0xdf.gitlab.io/tags.html#teamviewer) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [evilwinrm](https://0xdf.gitlab.io/tags.html#evilwinrm) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/remote-cover.) 
    
    To own Remote, I’ll need to find a hash in a config file over NFS, crack the hash, and use it to exploit a Umbraco CMS system. From there, I’ll find TeamView Server running, and find where it stores credentials in the registry. After extracting the bytes, I’ll write a script to decrypt them providing the administrator user’s credentials, and a shell over WinRM or PSExec.
    

*   Sep 3, 2020
    
    ### [HTB: Mantis](https://0xdf.gitlab.io/2020/09/03/htb-mantis.html)
    
    [Mantis](https://0xdf.gitlab.io/tags.html#mantis) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [rcpclient](https://0xdf.gitlab.io/tags.html#rcpclient) [kerbrute](https://0xdf.gitlab.io/tags.html#kerbrute) [orchard-cms](https://0xdf.gitlab.io/tags.html#orchard-cms) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [mssql](https://0xdf.gitlab.io/tags.html#mssql) [mssqlclient](https://0xdf.gitlab.io/tags.html#mssqlclient) [dbeaver](https://0xdf.gitlab.io/tags.html#dbeaver) [crackmapexec](https://0xdf.gitlab.io/tags.html#crackmapexec) [ms14-068](https://0xdf.gitlab.io/tags.html#ms14-068) [kerberos](https://0xdf.gitlab.io/tags.html#kerberos) [golden-ticket](https://0xdf.gitlab.io/tags.html#golden-ticket) [goldenpac](https://0xdf.gitlab.io/tags.html#goldenpac) ![](https://0xdf.gitlab.io/img/mantis-cover.) 
    
    Mantis was one of those Windows targets where it’s just a ton of enumeration until you get a System shell. The only exploit on the box was something I remember reading about years ago, where a low level user was allowed to make a privileged Kerberos ticket. To get there, I’ll have to avoid a few rabit holes and eventually find creds for the SQL Server instance hidden on a webpage. The database has domain credentials for a user. I’ll use those to perform the attack, which will return SYSTEM access.
    

*   Aug 29, 2020
    
    ### [HTB: Quick](https://0xdf.gitlab.io/2020/08/29/htb-quick.html)
    
    [Quick](https://0xdf.gitlab.io/tags.html#quick) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ubuntu](https://0xdf.gitlab.io/tags.html#ubuntu) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [vhosts](https://0xdf.gitlab.io/tags.html#vhosts) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [quic](https://0xdf.gitlab.io/tags.html#quic) [http3](https://0xdf.gitlab.io/tags.html#http3) [curl](https://0xdf.gitlab.io/tags.html#curl) [edgeside-include-injection](https://0xdf.gitlab.io/tags.html#edgeside-include-injection) [esi](https://0xdf.gitlab.io/tags.html#esi) [injection](https://0xdf.gitlab.io/tags.html#injection) [race-condition](https://0xdf.gitlab.io/tags.html#race-condition) [cracking](https://0xdf.gitlab.io/tags.html#cracking) [python](https://0xdf.gitlab.io/tags.html#python) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [su](https://0xdf.gitlab.io/tags.html#su) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus) ![](https://0xdf.gitlab.io/img/quick-cover.) 
    
    Quick was a chance to play with two technologies that I was familiar with, but I had never put hands on with either. First it was finding a website hosted over Quic / HTTP version 3. I’ll build curl so that I can access that, and find creds to get into a ticketing system. In that system, I will exploit an edge side include injection to get execution, and with a bit more work, a shell. Next I’ll exploit a new website available on localhost and take advantage of a race condition that allows me to read and write arbitrary files as the next user. Finally, to get root I’ll find creds in a cached config file. In Beyond Root, I’ll use a root shell to trouble-shoot my difficulties getting a shell and determine where things were breaking.
    

*   Aug 27, 2020
    
    ### [HTB: Calamity](https://0xdf.gitlab.io/2020/08/27/htb-calamity.html)
    
    [Calamity](https://0xdf.gitlab.io/tags.html#calamity) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [scripting](https://0xdf.gitlab.io/tags.html#scripting) [filter](https://0xdf.gitlab.io/tags.html#filter) [phpbash](https://0xdf.gitlab.io/tags.html#phpbash) [steganography](https://0xdf.gitlab.io/tags.html#steganography) [audacity](https://0xdf.gitlab.io/tags.html#audacity) [lxd](https://0xdf.gitlab.io/tags.html#lxd) [bof](https://0xdf.gitlab.io/tags.html#bof) [gdb](https://0xdf.gitlab.io/tags.html#gdb) [peda](https://0xdf.gitlab.io/tags.html#peda) [checksec](https://0xdf.gitlab.io/tags.html#checksec) [nx](https://0xdf.gitlab.io/tags.html#nx) [mprotect](https://0xdf.gitlab.io/tags.html#mprotect) [python](https://0xdf.gitlab.io/tags.html#python) [exploit](https://0xdf.gitlab.io/tags.html#exploit) [pattern-create](https://0xdf.gitlab.io/tags.html#pattern-create) [ret2libc](https://0xdf.gitlab.io/tags.html#ret2libc) ![](https://0xdf.gitlab.io/img/calamity-cover.) 
    
    Calamity was released as Insane, but looking at the user ratings, it looked more like an easy/medium box. The user path to through the box was relatively easy. Some basic enumeration gives access to a page that will run arbitrary PHP, which provides execution and a shell. There’s an audio steg challenge to get the user password and a user shell. People likely rated the box because there was an unintended root using lxd. I’ve done that before, and won’t show it here. The intended path was a contrived but interesting pwn challenge that involved three stages of input, the first two exploiting a very short buffer overflow to get access to a longer buffer overflow and eventually a root shell. In Beyond Root, I’ll look at some more features of the source code for the final binary to figure out what some assembly did, and why a simple return to libc attack didn’t work.
    

*   Aug 22, 2020
    
    ### [HTB: Magic](https://0xdf.gitlab.io/2020/08/22/htb-magic.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Magic-htb](https://0xdf.gitlab.io/tags.html#magic-htb) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [injection](https://0xdf.gitlab.io/tags.html#injection) [upload](https://0xdf.gitlab.io/tags.html#upload) [filter](https://0xdf.gitlab.io/tags.html#filter) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [php](https://0xdf.gitlab.io/tags.html#php) [mysqldump](https://0xdf.gitlab.io/tags.html#mysqldump) [su](https://0xdf.gitlab.io/tags.html#su) [suid](https://0xdf.gitlab.io/tags.html#suid) [path-hijack](https://0xdf.gitlab.io/tags.html#path-hijack) [apache](https://0xdf.gitlab.io/tags.html#apache) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/magic-cover.) 
    
    Magic has two common steps, a SQLI to bypass login, and a webshell upload with a double extension to bypass filtering. From there I can get a shell, and find creds in the database to switch to user. To get root, there’s a binary that calls popen without a full path, which makes it vulnerable to a path hijack attack. In Beyond Root, I’ll look at the Apache config that led to execution of a .php.png file, the PHP code that filtered uploads, and the source for the suid binary.
    

*   Aug 15, 2020
    
    ### [HTB: Traceback](https://0xdf.gitlab.io/2020/08/15/htb-traceback.html)
    
    [Traceback](https://0xdf.gitlab.io/tags.html#traceback) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [vim](https://0xdf.gitlab.io/tags.html#vim) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [smevk](https://0xdf.gitlab.io/tags.html#smevk) [lua](https://0xdf.gitlab.io/tags.html#lua) [luvit](https://0xdf.gitlab.io/tags.html#luvit) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [motd](https://0xdf.gitlab.io/tags.html#motd) [linpeas](https://0xdf.gitlab.io/tags.html#linpeas) [linenum](https://0xdf.gitlab.io/tags.html#linenum) ![](https://0xdf.gitlab.io/img/traceback-cover.) 
    
    Traceback starts with finding a webshell that’s already one the server with some enumeration and a bit of open source research. From there, I’ll pivot to the next user with sudo that allows me to run Luvit, a Lua interpreter. To get root, I’ll notice that I can write to the message of the day directory. These scripts are run by root whenever a user logs in. I actually found this by seeing the cron that cleans up scripts dropped in this directory, but I’ll also show how to find it with some basic enumeration as well. In Beyond Root, I’ll take a quick look at the cron that’s cleaning up every thiry seconds.
    

*   Aug 13, 2020
    
    ### [HTB: Joker](https://0xdf.gitlab.io/2020/08/13/htb-joker.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Joker](https://0xdf.gitlab.io/tags.html#joker) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [udp](https://0xdf.gitlab.io/tags.html#udp) [tftp](https://0xdf.gitlab.io/tags.html#tftp) [squid](https://0xdf.gitlab.io/tags.html#squid) [http-proxy](https://0xdf.gitlab.io/tags.html#http-proxy) [foxyproxy](https://0xdf.gitlab.io/tags.html#foxyproxy) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [penglab](https://0xdf.gitlab.io/tags.html#penglab) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [python](https://0xdf.gitlab.io/tags.html#python) [werkzeug](https://0xdf.gitlab.io/tags.html#werkzeug) [iptables](https://0xdf.gitlab.io/tags.html#iptables) [socat](https://0xdf.gitlab.io/tags.html#socat) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [sudoedit](https://0xdf.gitlab.io/tags.html#sudoedit) [sudoedit-follow](https://0xdf.gitlab.io/tags.html#sudoedit-follow) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [tar](https://0xdf.gitlab.io/tags.html#tar) [cron](https://0xdf.gitlab.io/tags.html#cron) [wildcard](https://0xdf.gitlab.io/tags.html#wildcard) [symbolic-link](https://0xdf.gitlab.io/tags.html#symbolic-link) [checkpoint](https://0xdf.gitlab.io/tags.html#checkpoint) ![](https://0xdf.gitlab.io/img/joker-cover.) 
    
    Rooting Joker had three steps. The first was using TFTP to get the Squid Proxy config and creds that allowed access to a webserver listening on localhost that provided a Python console. To turn that into a shell, I’ll have to enumerate the firewall and find that I can use UDP. I’ll show two ways to abuse a sudo rule to make the second step. I can take advantage of the sudoedit_follow flag, or just abuse the wildcards in the rule. The final pivot to root exploits a cron running creating tar archives, and I’ll show three different ways to abuse it.
    

*   Aug 10, 2020
    
    ### [Tunneling with Chisel and SSF](https://0xdf.gitlab.io/2020/08/10/tunneling-with-chisel-and-ssf-update.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [chisel](https://0xdf.gitlab.io/tags.html#chisel) [ssf](https://0xdf.gitlab.io/tags.html#ssf) [Reddish](https://0xdf.gitlab.io/tags.html#reddish) ![](https://0xdf.gitlab.io/img/pipes-cover.png) 
    
    [Update 2020-08-10] Chisel now has a built in SOCKS proxy! I also added a cheat sheet since I reference this post too often. [Original] Having just [written up HTB Reddish](https://0xdf.gitlab.io/2019/01/26/htb-reddish.html), pivoting without SSH was at the top of my mind, and I’ve since learned of two programs that enable pivots, Chisel and Secure Socket Funneling (SSF). I learned about Chisel from Ippsec, and you can see [his using it to solve Reddish in his video](https://www.youtube.com/watch?v=Yp4oxoQIBAM&t=1469s). I wanted to play with it, and figured I’d document what I learned here. I learned about SSF from another HTB user, [jkr](https://www.hackthebox.eu/home/users/profile/77141), who not only introduced me to SSF, but pulled together the examples in this post.
    

*   Aug 8, 2020
    
    ### [HTB: Fatty](https://0xdf.gitlab.io/2020/08/08/htb-fatty.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Fatty](https://0xdf.gitlab.io/tags.html#fatty) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [java](https://0xdf.gitlab.io/tags.html#java) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ftp](https://0xdf.gitlab.io/tags.html#ftp) [update-alternatives](https://0xdf.gitlab.io/tags.html#update-alternatives) [jar](https://0xdf.gitlab.io/tags.html#jar) [wireshark](https://0xdf.gitlab.io/tags.html#wireshark) [procyon](https://0xdf.gitlab.io/tags.html#procyon) [javac](https://0xdf.gitlab.io/tags.html#javac) [directory-traversal](https://0xdf.gitlab.io/tags.html#directory-traversal) [filter](https://0xdf.gitlab.io/tags.html#filter) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [tar](https://0xdf.gitlab.io/tags.html#tar) [scp](https://0xdf.gitlab.io/tags.html#scp) [cron](https://0xdf.gitlab.io/tags.html#cron) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [injection](https://0xdf.gitlab.io/tags.html#injection) [union](https://0xdf.gitlab.io/tags.html#union) [deserialization](https://0xdf.gitlab.io/tags.html#deserialization) [ysoserial](https://0xdf.gitlab.io/tags.html#ysoserial) [pspy](https://0xdf.gitlab.io/tags.html#pspy) ![](https://0xdf.gitlab.io/img/fatty-cover.) 
    
    Fatty forced me way out of my comfort zone. The majority of the box was reversing and modifying a Java thick client. First I had to modify the client to get the client to connect. Then I’ll take advantage of a directory traversal vulnerability to get a copy of the server binary, which I can reverse as well. In that binary, first I’ll find a SQL injection that allows me to log in as an admin user, which gives me access to additional functionality. One of the new functions uses serialized objects, which I can exploit using a deserialization attack to get a shell in the container running the server. Escalation to root attacks a recurring process that is using SCP to copy an archive of log files off the container to the host. By guessing that the log files are extracted from the archive, I’m able to create a malicious archive that allows me over the course of two SCPs to overwrite the root authorized_keys file and then SSH into Fatty as root.
    

*   Aug 8, 2020
    
    ### [Jar Files: Analysis and Modifications](https://0xdf.gitlab.io/2020/08/08/jar-files-analysis-and-modifications.html)
    
    [java](https://0xdf.gitlab.io/tags.html#java) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [decompile](https://0xdf.gitlab.io/tags.html#decompile) [jar](https://0xdf.gitlab.io/tags.html#jar) [recompile](https://0xdf.gitlab.io/tags.html#recompile) [procyon](https://0xdf.gitlab.io/tags.html#procyon) [javac](https://0xdf.gitlab.io/tags.html#javac) ![](https://0xdf.gitlab.io/img/jar-cover.png) 
    
    I recently ran into a challenge where I was given a Java Jar file that I needed to analyze and patch to exploit. I didn’t find many good tutorials on how to do this, so I wanted to get my notes down. For now it’s just a cheat sheet table of commands. _Updated 8 Aug 2020_: Now that Fatty from HackTheBox has retired, I’ve updated this post to reflect some examples.
    

*   Aug 4, 2020
    
    ### [HTB Pwnbox Review](https://0xdf.gitlab.io/2020/08/04/htb-pwnbox-review.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [pwnbox](https://0xdf.gitlab.io/tags.html#pwnbox) [parrot](https://0xdf.gitlab.io/tags.html#parrot) [vm](https://0xdf.gitlab.io/tags.html#vm) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [scp](https://0xdf.gitlab.io/tags.html#scp) [tmux](https://0xdf.gitlab.io/tags.html#tmux) [api](https://0xdf.gitlab.io/tags.html#api) ![](https://0xdf.gitlab.io/img/pwnbox-cover.png) 
    
    I was recently talking with some of the folks over at HackTheBox, and they asked my thoughts about Pwnbox. My answer was that I’d never really used it, but that I would give it a look and provide feedback. The system is actually quite feature packed. It is only available to VIP members, but if you are VIP, it’s worth spending a few minutes setting up the customizations. That way, if you should find yourself in need of an attack VM, you have it, and you might even just switch there.
    

*   Aug 1, 2020
    
    ### [HTB: Oouch](https://0xdf.gitlab.io/2020/08/01/htb-oouch.html)
    
    [Oouch](https://0xdf.gitlab.io/tags.html#oouch) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [oauth](https://0xdf.gitlab.io/tags.html#oauth) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ftp](https://0xdf.gitlab.io/tags.html#ftp) [vsftpd](https://0xdf.gitlab.io/tags.html#vsftpd) [vhosts](https://0xdf.gitlab.io/tags.html#vhosts) [csrf](https://0xdf.gitlab.io/tags.html#csrf) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [api](https://0xdf.gitlab.io/tags.html#api) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [container](https://0xdf.gitlab.io/tags.html#container) [docker](https://0xdf.gitlab.io/tags.html#docker) [dbus](https://0xdf.gitlab.io/tags.html#dbus) [iptables](https://0xdf.gitlab.io/tags.html#iptables) [command-injection](https://0xdf.gitlab.io/tags.html#command-injection) [injection](https://0xdf.gitlab.io/tags.html#injection) [uwsgi](https://0xdf.gitlab.io/tags.html#uwsgi) [waf](https://0xdf.gitlab.io/tags.html#waf) [cron](https://0xdf.gitlab.io/tags.html#cron) ![](https://0xdf.gitlab.io/img/oouch-cover.) 
    
    The first half of Oouch built all around OAuth, a technology that is commonplace on the internet today, and yet I didn’t understand well coming into the challenge. This box forced me to gain an understanding, and writing this post cemented that even further. To get user, I’ll exploit an insecure implementation of OAuth via a CSRF twice. The first time to get access to qtc’s account on the consumer application, and then to get access to qtc’s data on the authorization server, which includes a private SSH key. With a shell, I’ll drop into the consumer application container and look at how the site was blocking XSS attacks, which includes some messaging over DBus leading to iptables blocks. I’ll pivot to the www-data user via a uWSGI exploit and then use command injection to get execution as root. In Beyond Root, I’ll look at the command injection in the root DBus server code.
    

*   Jul 29, 2020
    
    ### [HTB: Lazy](https://0xdf.gitlab.io/2020/07/29/htb-lazy.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Lazy](https://0xdf.gitlab.io/tags.html#lazy) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ubuntu](https://0xdf.gitlab.io/tags.html#ubuntu) [php](https://0xdf.gitlab.io/tags.html#php) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [cookies](https://0xdf.gitlab.io/tags.html#cookies) [python](https://0xdf.gitlab.io/tags.html#python) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [burp](https://0xdf.gitlab.io/tags.html#burp) [repeater](https://0xdf.gitlab.io/tags.html#repeater) [padding-oracle](https://0xdf.gitlab.io/tags.html#padding-oracle) [padbuster](https://0xdf.gitlab.io/tags.html#padbuster) [firefox](https://0xdf.gitlab.io/tags.html#firefox) [bit-flip](https://0xdf.gitlab.io/tags.html#bit-flip) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [suid](https://0xdf.gitlab.io/tags.html#suid) [path-hijack](https://0xdf.gitlab.io/tags.html#path-hijack) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [penglab](https://0xdf.gitlab.io/tags.html#penglab) [gdb](https://0xdf.gitlab.io/tags.html#gdb) [ltrace](https://0xdf.gitlab.io/tags.html#ltrace) [cyberchef](https://0xdf.gitlab.io/tags.html#cyberchef) [des](https://0xdf.gitlab.io/tags.html#des) [peda](https://0xdf.gitlab.io/tags.html#peda) [debug](https://0xdf.gitlab.io/tags.html#debug) ![](https://0xdf.gitlab.io/img/lazy-cover.) 
    
    Lazy was a really solid old HackTheBox machine. It’s a medium difficulty box that requires identifying a unique and interesting cookie value and messing with it to get access to the admin account. I’ll show both a padding oracle attack and a bit-flipping attack that each allow me to change the encrypted data to grant admin access. That access provides an SSH key and a shell. To privesc, there’s a SetUID binary that is vulnerable to a path hijack attack. In Beyond Root, I’ll poke at the PHP source for the site, identify a third way to get logged in as admin, and do a bit of debugging on the SetUID binary.
    

*   Jul 25, 2020
    
    ### [HTB: Cascade](https://0xdf.gitlab.io/2020/07/25/htb-cascade.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Cascade](https://0xdf.gitlab.io/tags.html#cascade) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [rpc](https://0xdf.gitlab.io/tags.html#rpc) [ldap](https://0xdf.gitlab.io/tags.html#ldap) [smb](https://0xdf.gitlab.io/tags.html#smb) [tightvnc](https://0xdf.gitlab.io/tags.html#tightvnc) [vncpwd](https://0xdf.gitlab.io/tags.html#vncpwd) [evil-winrm](https://0xdf.gitlab.io/tags.html#evil-winrm) [crackmapexec](https://0xdf.gitlab.io/tags.html#crackmapexec) [sqlite](https://0xdf.gitlab.io/tags.html#sqlite) [dnspy](https://0xdf.gitlab.io/tags.html#dnspy) [debug](https://0xdf.gitlab.io/tags.html#debug) [ad-recycle](https://0xdf.gitlab.io/tags.html#ad-recycle) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus) ![](https://0xdf.gitlab.io/img/cascade-cover.) 
    
    Cascade was an interesting Windows all about recovering credentials from Windows enumeration. I’ll find credentials for an account in LDAP results, and use that to gain SMB access, where I find a TightVNC config with a different users password. From there, I get a shell and access to a SQLite database and a program that reads and decrypts a password from it. That password allows access to an account that is a member of the AD Recycle group, which I can use to find a deleted temporary admin account with a password, which still works for the main administrator accoun, providing a shell.
    

*   Jul 22, 2020
    
    ### [HTB: Shrek](https://0xdf.gitlab.io/2020/07/22/htb-shrek.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Shrek](https://0xdf.gitlab.io/tags.html#shrek) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [php](https://0xdf.gitlab.io/tags.html#php) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [audacity](https://0xdf.gitlab.io/tags.html#audacity) [steganography](https://0xdf.gitlab.io/tags.html#steganography) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [ecc](https://0xdf.gitlab.io/tags.html#ecc) [seccure](https://0xdf.gitlab.io/tags.html#seccure) [python](https://0xdf.gitlab.io/tags.html#python) [chown](https://0xdf.gitlab.io/tags.html#chown) [wildcard](https://0xdf.gitlab.io/tags.html#wildcard) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [pspy](https://0xdf.gitlab.io/tags.html#pspy) [passwd](https://0xdf.gitlab.io/tags.html#passwd) [extended-attributes](https://0xdf.gitlab.io/tags.html#extended-attributes) [lsattr](https://0xdf.gitlab.io/tags.html#lsattr) [cron](https://0xdf.gitlab.io/tags.html#cron) [suid](https://0xdf.gitlab.io/tags.html#suid) ![](https://0xdf.gitlab.io/img/shrek-cover.png) 
    
    Shrek is another 2018 HackTheBox machine that is more a string of challenges as opposed to a box. I’ll find an uploads page in the website that doesn’t work, but then also find a bunch of malware (or malware-ish) files in the uploads directory. One of them contains a comment about a secret directory, which I’ll check to find an MP3 file. Credentials for the FTP server are hidden in a chunk of the file at the end. On the FTP server, there’s an encrypted SSH key, and a bunch of files full of base64-encoded data. Two have a passphrase and an encrypted blob, which I’ll decrypt to get the SSH key password, and use to get a shell. To privesc, I’ll find a process running chmod with a wildcard, and exploit that to change the ownership of the passwd file to my user, so I can edit it and get a root shell. In Beyond Root, I’ll examine the text file in the directory and why it doesn’t get it changed ownership, look at the automation and find a curious part I wasn’t expecting, and show an alternative root based on that automation (which may be the intended path).
    

*   Jul 18, 2020
    
    ### [HTB: Sauna](https://0xdf.gitlab.io/2020/07/18/htb-sauna.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Sauna](https://0xdf.gitlab.io/tags.html#sauna) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [windows](https://0xdf.gitlab.io/tags.html#windows) [ldap](https://0xdf.gitlab.io/tags.html#ldap) [kerberos](https://0xdf.gitlab.io/tags.html#kerberos) [seclists](https://0xdf.gitlab.io/tags.html#seclists) [as-rep-roast](https://0xdf.gitlab.io/tags.html#as-rep-roast) [getnpusers](https://0xdf.gitlab.io/tags.html#getnpusers) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [evil-winrm](https://0xdf.gitlab.io/tags.html#evil-winrm) [smbserver](https://0xdf.gitlab.io/tags.html#smbserver) [winpeas](https://0xdf.gitlab.io/tags.html#winpeas) [autologon-credentials](https://0xdf.gitlab.io/tags.html#autologon-credentials) [bloodhound](https://0xdf.gitlab.io/tags.html#bloodhound) [sharphound](https://0xdf.gitlab.io/tags.html#sharphound) [neo4j](https://0xdf.gitlab.io/tags.html#neo4j) [dcsync](https://0xdf.gitlab.io/tags.html#dcsync) [secretsdump](https://0xdf.gitlab.io/tags.html#secretsdump) [mimikatz](https://0xdf.gitlab.io/tags.html#mimikatz) [wmiexec](https://0xdf.gitlab.io/tags.html#wmiexec) [psexec](https://0xdf.gitlab.io/tags.html#psexec) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus) ![](https://0xdf.gitlab.io/img/sauna-cover.png) 
    
    Sauna was a neat chance to play with Windows Active Directory concepts packaged into an easy difficulty box. I’ll start by using a Kerberoast brute force on usernames to identify a handful of users, and then find that one of them has the flag set to allow me to grab their hash without authenticating to the domain. I’ll AS-REP Roast to get the hash, crack it, and get a shell. I’ll find the next users credentials in the AutoLogon registry key. BloodHound will show that user has privileges the allow it to perform a DC Sync attack, which provides all the domain hashes, including the administrators, which I’ll use to get a shell.
    

*   Jul 14, 2020
    
    ### [HTB: Tenten](https://0xdf.gitlab.io/2020/07/14/htb-tenten.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Tenten](https://0xdf.gitlab.io/tags.html#tenten) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [wordpress](https://0xdf.gitlab.io/tags.html#wordpress) [wpscan](https://0xdf.gitlab.io/tags.html#wpscan) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [wp-job-manager](https://0xdf.gitlab.io/tags.html#wp-job-manager) [cve-2015-6668](https://0xdf.gitlab.io/tags.html#cve-2015-6668) [python](https://0xdf.gitlab.io/tags.html#python) [steganography](https://0xdf.gitlab.io/tags.html#steganography) [steghide](https://0xdf.gitlab.io/tags.html#steghide) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [john](https://0xdf.gitlab.io/tags.html#john) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [mysql](https://0xdf.gitlab.io/tags.html#mysql) ![](https://0xdf.gitlab.io/img/tenten-cover.png) 
    
    Tenten had a lot of the much more CTF-like aspects that were more prevalent in the original HTB machine, like a uploaded hacker image file from which I will extract an SSH private key from it using steganography. I learned a really interesting lesson about wpscan and how to feed it an API key, and got to play with a busted WordPress plugin. In Beyond Root I’ll poke a bit at the WordPress database and see what was leaking via the plugin exploit.
    

*   Jul 11, 2020
    
    ### [HTB: Book](https://0xdf.gitlab.io/2020/07/11/htb-book.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Book](https://0xdf.gitlab.io/tags.html#book) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ubuntu](https://0xdf.gitlab.io/tags.html#ubuntu) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [sql-truncation](https://0xdf.gitlab.io/tags.html#sql-truncation) [sql](https://0xdf.gitlab.io/tags.html#sql) [xss](https://0xdf.gitlab.io/tags.html#xss) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [pspy](https://0xdf.gitlab.io/tags.html#pspy) [logrotate](https://0xdf.gitlab.io/tags.html#logrotate) [logrotten](https://0xdf.gitlab.io/tags.html#logrotten) [crontab](https://0xdf.gitlab.io/tags.html#crontab) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus) ![](https://0xdf.gitlab.io/img/book-cover.png) 
    
    Getting a foothold on Book involved identifying and exploiting a few vulnerabilities in a website for a library. First there’s a SQL truncation attack against the login form to gain access as the admin account. Then I’ll use a cross-site scripting (XSS) attack against a PDF export to get file read from the local system. This is interesting because typically I think of XSS as something that I present to another user, but in this case, it’s the PDF generate software. I’ll use this to find a private SSH key and get a shell on the system. To get root, I’ll exploit a regular logrotate cron using the logrotten exploit, which is a timing against against how logrotate worked. In Beyond Root, I’ll look at the various crons on the box and how they made it work and cleaned up.
    

*   Jul 7, 2020
    
    ### [HTB: Bank](https://0xdf.gitlab.io/2020/07/07/htb-bank.html)
    
    [Bank](https://0xdf.gitlab.io/tags.html#bank) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [vhosts](https://0xdf.gitlab.io/tags.html#vhosts) [dns](https://0xdf.gitlab.io/tags.html#dns) [dig](https://0xdf.gitlab.io/tags.html#dig) [zone-transfer](https://0xdf.gitlab.io/tags.html#zone-transfer) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [burp](https://0xdf.gitlab.io/tags.html#burp) [regex](https://0xdf.gitlab.io/tags.html#regex) [repeater](https://0xdf.gitlab.io/tags.html#repeater) [filter](https://0xdf.gitlab.io/tags.html#filter) [suid](https://0xdf.gitlab.io/tags.html#suid) [php](https://0xdf.gitlab.io/tags.html#php) ![](https://0xdf.gitlab.io/img/bank-cover.png) 
    
    Bank was an pretty straight forward box, though two of the major steps had unintended alternative methods. I’ll enumerate DNS to find a hostname, and use that to access a bank website. I can either find creds in a directory of data, or bypass creds all together by looking at the data in the HTTP 302 redirects. From there, I’ll upload a PHP webshell, bypassing filters, and get a shell. To get root, I can find a backdoor SUID copy of dash left by the administrator, or exploit write privileges in /etc/passwd. In Beyond Root, I’ll look at the coding mistake in the 302 redirects, and show how I determined the SUID binary was dash.
    

*   Jul 4, 2020
    
    ### [HTB: ForwardSlash](https://0xdf.gitlab.io/2020/07/04/htb-forwardslash.html)
    
    [ForwardSlash](https://0xdf.gitlab.io/tags.html#forwardslash) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ubuntu](https://0xdf.gitlab.io/tags.html#ubuntu) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [php](https://0xdf.gitlab.io/tags.html#php) [vhosts](https://0xdf.gitlab.io/tags.html#vhosts) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [burp](https://0xdf.gitlab.io/tags.html#burp) [repeater](https://0xdf.gitlab.io/tags.html#repeater) [rfi](https://0xdf.gitlab.io/tags.html#rfi) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [xxe](https://0xdf.gitlab.io/tags.html#xxe) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [suid](https://0xdf.gitlab.io/tags.html#suid) [python](https://0xdf.gitlab.io/tags.html#python) [luks](https://0xdf.gitlab.io/tags.html#luks) [crypto](https://0xdf.gitlab.io/tags.html#crypto) ![](https://0xdf.gitlab.io/img/forwardslash-cover.png) 
    
    ForwardSlash starts with enumeration of a hacked website to identify and exploit at least one of two LFI vulnerabilities (directly using filters to base64 encode or using XXE) to leak PHP source which includes a password which can be used to get a shell. From there, I’ll exploit a severely non-functional “backup” program to get file read as the other user. With this, I’ll find a backup of the website, and find different credentials in one of the pages, which I can use for a shell as the second user. To root, I’ll break a homespun encryption algorithm to load an encrypted disk image which contains root’s private SSH key. In Beyond Root, I’ll dig into the website source to understand a couple surprising things I found while enumerating.
    

*   Jun 30, 2020
    
    ### [HTB: Blocky](https://0xdf.gitlab.io/2020/06/30/htb-blocky.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Blocky](https://0xdf.gitlab.io/tags.html#blocky) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [wordpress](https://0xdf.gitlab.io/tags.html#wordpress) [java](https://0xdf.gitlab.io/tags.html#java) [jar](https://0xdf.gitlab.io/tags.html#jar) [decompile](https://0xdf.gitlab.io/tags.html#decompile) [jd-gui](https://0xdf.gitlab.io/tags.html#jd-gui) [phpmyadmin](https://0xdf.gitlab.io/tags.html#phpmyadmin) [wpscan](https://0xdf.gitlab.io/tags.html#wpscan) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [oswe-like](https://0xdf.gitlab.io/tags.html#oswe-like) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/blocky-cover.png) 
    
    Blocky really was an easy box, but did require some discipline when enumerating. It would be easy to miss the /plugins path that hosts two Java Jar files. From one of those files, I’ll find creds, which as reused by a user on the box, allowing me to get SSH access. To escalate to root, the user is allowed to run any command with sudo and password, which I’ll use to sudo su returning a session as root.
    

*   Jun 27, 2020
    
    ### [HTB: PlayerTwo](https://0xdf.gitlab.io/2020/06/27/htb-playertwo.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [PlayerTwo](https://0xdf.gitlab.io/tags.html#playertwo) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [vhosts](https://0xdf.gitlab.io/tags.html#vhosts) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [twirp](https://0xdf.gitlab.io/tags.html#twirp) [proto3](https://0xdf.gitlab.io/tags.html#proto3) [api](https://0xdf.gitlab.io/tags.html#api) [otp](https://0xdf.gitlab.io/tags.html#otp) [signing](https://0xdf.gitlab.io/tags.html#signing) [binwalk](https://0xdf.gitlab.io/tags.html#binwalk) [hexedit](https://0xdf.gitlab.io/tags.html#hexedit) [pspy](https://0xdf.gitlab.io/tags.html#pspy) [php](https://0xdf.gitlab.io/tags.html#php) [linux](https://0xdf.gitlab.io/tags.html#linux) [chisel](https://0xdf.gitlab.io/tags.html#chisel) [mqtt](https://0xdf.gitlab.io/tags.html#mqtt) [paho](https://0xdf.gitlab.io/tags.html#paho) [python](https://0xdf.gitlab.io/tags.html#python) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [exploit](https://0xdf.gitlab.io/tags.html#exploit) [Rope](https://0xdf.gitlab.io/tags.html#rope) [heap](https://0xdf.gitlab.io/tags.html#heap) [tcache](https://0xdf.gitlab.io/tags.html#tcache) [ldd](https://0xdf.gitlab.io/tags.html#ldd) [patchelf](https://0xdf.gitlab.io/tags.html#patchelf) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [checksec](https://0xdf.gitlab.io/tags.html#checksec) [gdb](https://0xdf.gitlab.io/tags.html#gdb) [pwntools](https://0xdf.gitlab.io/tags.html#pwntools) [type-juggling](https://0xdf.gitlab.io/tags.html#type-juggling) [pwngdb](https://0xdf.gitlab.io/tags.html#pwngdb) ![](https://0xdf.gitlab.io/img/playertwo-cover.png) 
    
    PlayerTwo was just a monster of a box. Enumeration across three virtual hosts reveals a Twirp API where I can leak some credentials. Another API can be enumerated to find backup codes for for the 2FA for the login. With creds and backup codes, I can log into the site, which has a firmware upload section. The example firmware is signed, but only the first roughly eight thousand bytes. I’ll find a way to modify the arguments to a call to system to get execution and a shell. With a shell, I see a MQTT message queue on localhost, and connecting to it, I’ll find a private SSH key being sent, which I can use to get a shell as the next user. Finally, to get to root, I’ll do a heap exploit against a root SUID binary to get a shell. In a Beyond Root section that could be its own blog post, I’ll dig into a few unintended ways to skips parts of the intended path, and dig deeper on others.
    

*   Jun 23, 2020
    
    ### [HTB: Popcorn](https://0xdf.gitlab.io/2020/06/23/htb-popcorn.html)
    
    [Popcorn](https://0xdf.gitlab.io/tags.html#popcorn) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ubuntu](https://0xdf.gitlab.io/tags.html#ubuntu) [karmic](https://0xdf.gitlab.io/tags.html#karmic) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [torrent-hoster](https://0xdf.gitlab.io/tags.html#torrent-hoster) [filter](https://0xdf.gitlab.io/tags.html#filter) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [php](https://0xdf.gitlab.io/tags.html#php) [upload](https://0xdf.gitlab.io/tags.html#upload) [cve-2010-0832](https://0xdf.gitlab.io/tags.html#cve-2010-0832) [arbitrary-write](https://0xdf.gitlab.io/tags.html#arbitrary-write) [passwd](https://0xdf.gitlab.io/tags.html#passwd) [dirtycow](https://0xdf.gitlab.io/tags.html#dirtycow) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [oswe-like](https://0xdf.gitlab.io/tags.html#oswe-like) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/popcorn-cover.png) 
    
    Popcorn was a medium box that, while not on TJ Null’s list, felt very OSCP-like to me. Some enumeration will lead to a torrent hosting system, where I can upload, and, bypassing filters, get a PHP webshell to run. From there, I will exploit CVE-2010-0832, a vulnerability in the linux authentication system (PAM) where I can get it to make my current user the owner of any file on the system. There’s a slick exploit script, but I’ll show manually exploiting it as well. I’ll quickly also show DirtyCow since it does work here.
    

*   Jun 20, 2020
    
    ### [HTB: ServMon](https://0xdf.gitlab.io/2020/06/20/htb-servmon.html)
    
    [ServMon](https://0xdf.gitlab.io/tags.html#servmon) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [windows](https://0xdf.gitlab.io/tags.html#windows) [ftp](https://0xdf.gitlab.io/tags.html#ftp) [nvms-1000](https://0xdf.gitlab.io/tags.html#nvms-1000) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [directory-traversal](https://0xdf.gitlab.io/tags.html#directory-traversal) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [crackmapexec](https://0xdf.gitlab.io/tags.html#crackmapexec) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [exploit-db](https://0xdf.gitlab.io/tags.html#exploit-db) [nsclient++](https://0xdf.gitlab.io/tags.html#nsclient) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/servmon-cover.png) 
    
    ServMon was an easy Windows box that required two exploits. There’s a hint in the anonymous FTP as to the location of a list of passwords. I can use a directory traversal bug in a NVMS 1000 web instance that will allow me to leak those passwords, and use one of them over SSH to get a shell. Then I can get the local config for the NSClient++ web instance running on TCP 8443, and use those credentials plus another exploit to get a SYSTEM shell.
    

*   Jun 17, 2020
    
    ### [HTB Endgame: XEN](https://0xdf.gitlab.io/2020/06/17/endgame-xen.html)
    
    [endgame](https://0xdf.gitlab.io/tags.html#endgame) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Xen](https://0xdf.gitlab.io/tags.html#xen) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [iis](https://0xdf.gitlab.io/tags.html#iis) [citrix](https://0xdf.gitlab.io/tags.html#citrix) [xenapp](https://0xdf.gitlab.io/tags.html#xenapp) [smtp](https://0xdf.gitlab.io/tags.html#smtp) [smtp-user-enum](https://0xdf.gitlab.io/tags.html#smtp-user-enum) [phishing](https://0xdf.gitlab.io/tags.html#phishing) [swaks](https://0xdf.gitlab.io/tags.html#swaks) [escape](https://0xdf.gitlab.io/tags.html#escape) [alwayinstallelevated](https://0xdf.gitlab.io/tags.html#alwayinstallelevated) [powerup](https://0xdf.gitlab.io/tags.html#powerup) [uac-bypass](https://0xdf.gitlab.io/tags.html#uac-bypass) [msfvenom](https://0xdf.gitlab.io/tags.html#msfvenom) [msf](https://0xdf.gitlab.io/tags.html#msf) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [kerberoast](https://0xdf.gitlab.io/tags.html#kerberoast) [getuserspns](https://0xdf.gitlab.io/tags.html#getuserspns) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [powerview](https://0xdf.gitlab.io/tags.html#powerview) [crackmapexec](https://0xdf.gitlab.io/tags.html#crackmapexec) [password-spray](https://0xdf.gitlab.io/tags.html#password-spray) [ppk](https://0xdf.gitlab.io/tags.html#ppk) [puttygen](https://0xdf.gitlab.io/tags.html#puttygen) [proxychains](https://0xdf.gitlab.io/tags.html#proxychains) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [kwprocessor](https://0xdf.gitlab.io/tags.html#kwprocessor) [keyboard-walks](https://0xdf.gitlab.io/tags.html#keyboard-walks) [netscaler](https://0xdf.gitlab.io/tags.html#netscaler) [tcpdump](https://0xdf.gitlab.io/tags.html#tcpdump) [packet-capture](https://0xdf.gitlab.io/tags.html#packet-capture) [scp](https://0xdf.gitlab.io/tags.html#scp) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [wireshark](https://0xdf.gitlab.io/tags.html#wireshark) [ldap](https://0xdf.gitlab.io/tags.html#ldap) [bloodhound](https://0xdf.gitlab.io/tags.html#bloodhound) [sharphound](https://0xdf.gitlab.io/tags.html#sharphound) [xfreerdp](https://0xdf.gitlab.io/tags.html#xfreerdp) [winrm](https://0xdf.gitlab.io/tags.html#winrm) [evil-winrm](https://0xdf.gitlab.io/tags.html#evil-winrm) [sebackupprivilege](https://0xdf.gitlab.io/tags.html#sebackupprivilege) [ntds](https://0xdf.gitlab.io/tags.html#ntds) [diskshadow](https://0xdf.gitlab.io/tags.html#diskshadow) [secretsdump](https://0xdf.gitlab.io/tags.html#secretsdump) [wmiexec](https://0xdf.gitlab.io/tags.html#wmiexec) [copy-filesebackupprivilege](https://0xdf.gitlab.io/tags.html#copy-filesebackupprivilege) ![](https://0xdf.gitlab.io/img/endgame-xen-cover.) 
    
    Endgame XEN is all about owning a small network behind a Citrix virtual desktop environment. I’ll phish creds for the Citrix instance from users in the sales department, and then use them to get a foothold. I’ll break out of the restrictions in that environment, and then get administrator access. From there I’ll pivot into the domain, finding a Kerberoastable user and breaking the hash to get access to an SMB share with an encrypted SSH key. I’ll break that, and get access to the NetScaler device, where I’ll capture network traffic to find service creds in LDAP traffic. I’ll spray those creds against the domain to find they also work for a backup service, which I’ll use to access the DC, and to exfil the Active Directory database, where I can find the domain administrator hash.
    

*   Jun 13, 2020
    
    ### [HTB: Monteverde](https://0xdf.gitlab.io/2020/06/13/htb-monteverde.html)
    
    [Monteverde](https://0xdf.gitlab.io/tags.html#monteverde) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [windows](https://0xdf.gitlab.io/tags.html#windows) [active-directory](https://0xdf.gitlab.io/tags.html#active-directory) [smb](https://0xdf.gitlab.io/tags.html#smb) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap) [rpc](https://0xdf.gitlab.io/tags.html#rpc) [rpcclient](https://0xdf.gitlab.io/tags.html#rpcclient) [crackmapexec](https://0xdf.gitlab.io/tags.html#crackmapexec) [password-spray](https://0xdf.gitlab.io/tags.html#password-spray) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [azure-active-directory](https://0xdf.gitlab.io/tags.html#azure-active-directory) [evil-winrm](https://0xdf.gitlab.io/tags.html#evil-winrm) [azure-connect](https://0xdf.gitlab.io/tags.html#azure-connect) [powershell](https://0xdf.gitlab.io/tags.html#powershell) [sqlcmd](https://0xdf.gitlab.io/tags.html#sqlcmd) [mssql](https://0xdf.gitlab.io/tags.html#mssql) ![](https://0xdf.gitlab.io/img/monteverde-cover.jpg) 
    
    For the third week in a row, a Windows box on the easier side of the spectrum with no web server retires. Monteverde was focused on Azure Active Directory. First I’ll look at RPC to get a list of users, and then check to see if any used their username as their password. With creds for SABatchJobs, I’ll gain access to SMB to find an XML config file with a password for one of the users on the box who happens to have WinRM permissions. From there, I can abuse the Azure active directory database to leak the administrator password. In Beyond Root, I’ll look deeper into two versions of the PowerShell script I used to leak the creds, and how they work or don’t work.
    

*   Jun 8, 2020
    
    ### [HTB Endgame: P.O.O.](https://0xdf.gitlab.io/2020/06/08/endgame-poo.html)
    
    [endgame](https://0xdf.gitlab.io/tags.html#endgame) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [poo](https://0xdf.gitlab.io/tags.html#poo) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [iis](https://0xdf.gitlab.io/tags.html#iis) [windows](https://0xdf.gitlab.io/tags.html#windows) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [ds-store](https://0xdf.gitlab.io/tags.html#ds-store) [iis-shortname](https://0xdf.gitlab.io/tags.html#iis-shortname) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [mssql](https://0xdf.gitlab.io/tags.html#mssql) [mssqlclient](https://0xdf.gitlab.io/tags.html#mssqlclient) [mssql-linked-servers](https://0xdf.gitlab.io/tags.html#mssql-linked-servers) [xp_cmdshell](https://0xdf.gitlab.io/tags.html#xp-cmdshell) [mssql-triggers](https://0xdf.gitlab.io/tags.html#mssql-triggers) [sp_execute_external_script](https://0xdf.gitlab.io/tags.html#sp-execute-external-script) [web-config](https://0xdf.gitlab.io/tags.html#web-config) [ipv6](https://0xdf.gitlab.io/tags.html#ipv6) [winrm](https://0xdf.gitlab.io/tags.html#winrm) [sharphound](https://0xdf.gitlab.io/tags.html#sharphound) [bloodhound](https://0xdf.gitlab.io/tags.html#bloodhound) [kerberoast](https://0xdf.gitlab.io/tags.html#kerberoast) [invoke-kerberoast](https://0xdf.gitlab.io/tags.html#invoke-kerberoast) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [powerview](https://0xdf.gitlab.io/tags.html#powerview) [juicypotato](https://0xdf.gitlab.io/tags.html#juicypotato) [active-directory](https://0xdf.gitlab.io/tags.html#active-directory) ![](https://0xdf.gitlab.io/img/endgame-poo-cover.) 
    
    Endgame Professional Offensive Operations (P.O.O.) was the first Endgame lab released by HTB. Endgame labs require at least Guru status to attempt (though now that P.O.O. is retired, it is available to all VIP). The lab contains two Windows hosts, and I’m given a single IP that represents the public facing part of the network. To collect all five flags, I’ll take advantage of DS_STORE files and Windows short filenames to get creds for the MSSQL instance, abuse trust within MSSQL to escalate my access to allow for code execution. Basic xp_cmdshell runs as a user without much access, but Python within MSSQL runs as a more privileged user, allowing me access to a config file with the administrator credentials. I’ll observe that WinRM is not blocked on IPv6, and get a shell. To pivot to the DC, I’ll run SharpHound and see that a kerberoastable user has Generic All on the Domain Admins group, get the hash, break it, and add that user to DA.
    

*   Jun 6, 2020
    
    ### [HTB: Nest](https://0xdf.gitlab.io/2020/06/06/htb-nest.html)
    
    [Nest](https://0xdf.gitlab.io/tags.html#nest) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [smb](https://0xdf.gitlab.io/tags.html#smb) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [vb](https://0xdf.gitlab.io/tags.html#vb) [visual-studio](https://0xdf.gitlab.io/tags.html#visual-studio) [dnspy](https://0xdf.gitlab.io/tags.html#dnspy) [dotnetfiddle](https://0xdf.gitlab.io/tags.html#dotnetfiddle) [crackmapexec](https://0xdf.gitlab.io/tags.html#crackmapexec) [alternative-data-streams](https://0xdf.gitlab.io/tags.html#alternative-data-streams) [psexec](https://0xdf.gitlab.io/tags.html#psexec) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus) ![](https://0xdf.gitlab.io/img/nest-cover.png) 
    
    Next was unique in that it was all about continually increasing SMB access, with a little bit of easy .NET RE thrown in. I probably would rate the box medium instead of easy, because of the RE, but that’s nitpicking. I’ll start with unauthenticated access to a share, and find a password for tempuser. With that access, I’ll find an encrypted password for C.Smith. I’ll also use a Notepad++ config to find a new directory I can access (inside one I can’t), which reveals a Visual Basic Visual Studio project that includes the code to decrypt the password. With access as C.Smith, I can find the debug password for a custom application listening on 4386, and use that to leak another encrypted password. This time I’ll debug the binary to read the decrpyted administrator password from memory, and use it to get a shell as SYSTEM with PSExec. When this box was first released, there was an error where the first user creds could successfully PSExec. I wrote a post on that back in January, but I’ve linked that post to this one on the left. In Beyond Root, I’ll take a quick look at why netcat can’t connect to the custom service on 4386, but telnet can.
    

*   Jun 1, 2020
    
    ### [Debugging CME, PSexec on HTB: Resolute](https://0xdf.gitlab.io/2020/06/01/resolute-more-beyond-root.html)
    
    [crackmapexec](https://0xdf.gitlab.io/tags.html#crackmapexec) [smb](https://0xdf.gitlab.io/tags.html#smb) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Resolute](https://0xdf.gitlab.io/tags.html#resolute) [windows](https://0xdf.gitlab.io/tags.html#windows) [scmanager](https://0xdf.gitlab.io/tags.html#scmanager) [sddl](https://0xdf.gitlab.io/tags.html#sddl) [dacl](https://0xdf.gitlab.io/tags.html#dacl) [psexec](https://0xdf.gitlab.io/tags.html#psexec) [github](https://0xdf.gitlab.io/tags.html#github) [source-code](https://0xdf.gitlab.io/tags.html#source-code) [metasploit](https://0xdf.gitlab.io/tags.html#metasploit) [wireshark smb](https://0xdf.gitlab.io/tags.html#wireshark-smb) [cyberchef](https://0xdf.gitlab.io/tags.html#cyberchef) [scdbg](https://0xdf.gitlab.io/tags.html#scdbg) ![](https://0xdf.gitlab.io/img/resolute-br-cover.) 
    
    When I ran CrackMapExec with ryan’s creds against Resolute, it returned Pwn3d!, which is weird, as none of the standard PSExec exploits I attempted worked. Beyond that, ryan wasn’t an administrator, and didn’t have any writable shares. I’ll explore the CME code to see why it returned Pwn3d!, look at the requirements for a standard PSExec, and then debug the Metasploit exploit that does go directly to SYSTEM with ryan’s creds.
    

*   May 30, 2020
    
    ### [HTB: Resolute](https://0xdf.gitlab.io/2020/05/30/htb-resolute.html)
    
    [Resolute](https://0xdf.gitlab.io/tags.html#resolute) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [smb](https://0xdf.gitlab.io/tags.html#smb) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [rpcclient](https://0xdf.gitlab.io/tags.html#rpcclient) [rpc](https://0xdf.gitlab.io/tags.html#rpc) [password-spray](https://0xdf.gitlab.io/tags.html#password-spray) [crackmapexec](https://0xdf.gitlab.io/tags.html#crackmapexec) [evil-winrm](https://0xdf.gitlab.io/tags.html#evil-winrm) [pstranscript](https://0xdf.gitlab.io/tags.html#pstranscript) [net-use](https://0xdf.gitlab.io/tags.html#net-use) [dnscmd](https://0xdf.gitlab.io/tags.html#dnscmd) [msfvenom](https://0xdf.gitlab.io/tags.html#msfvenom) [smbserver](https://0xdf.gitlab.io/tags.html#smbserver) [lolbas](https://0xdf.gitlab.io/tags.html#lolbas) [winrm](https://0xdf.gitlab.io/tags.html#winrm) ![](https://0xdf.gitlab.io/img/resolute-cover.png) 
    
    It’s always interesting when the initial nmap scan shows no web ports as was the case in Resolute. The attack starts with enumeration of user accounts using Windows RPC, including a list of users and a default password in a comment. That password works for one of the users over WinRM. From there I find the next users creds in a PowerShell transcript file. That user is in the DnsAdmins group, which allows for an attack against dnscmd to get SYSTEM. In beyond root, I’ll identify the tool the box creator used to connect to the box and generate the PowerShell transcript.
    

*   May 28, 2020
    
    ### [HTB: Grandpa](https://0xdf.gitlab.io/2020/05/28/htb-grandpa.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Grandpa](https://0xdf.gitlab.io/tags.html#grandpa) [windows-2003](https://0xdf.gitlab.io/tags.html#windows-2003) [iis](https://0xdf.gitlab.io/tags.html#iis) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [webdav](https://0xdf.gitlab.io/tags.html#webdav) [davtest](https://0xdf.gitlab.io/tags.html#davtest) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [msfvenom](https://0xdf.gitlab.io/tags.html#msfvenom) [cve-2017-7269](https://0xdf.gitlab.io/tags.html#cve-2017-7269) [explodingcan](https://0xdf.gitlab.io/tags.html#explodingcan) [metasploit](https://0xdf.gitlab.io/tags.html#metasploit) [icacls](https://0xdf.gitlab.io/tags.html#icacls) [systeminfo](https://0xdf.gitlab.io/tags.html#systeminfo) [windows-exploit-suggester](https://0xdf.gitlab.io/tags.html#windows-exploit-suggester) [seimpresonate](https://0xdf.gitlab.io/tags.html#seimpresonate) [churrasco](https://0xdf.gitlab.io/tags.html#churrasco) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/grandpa-cover.png) 
    
    Grandpa was one of the really early HTB machines. It’s the kind of box that wouldn’t show up in HTB today, and frankly, isn’t as fun as modern targets. Still, it’s a great proxy for the kind of things that you’ll see in OSCP, and does teach some valuable lessons, especially if you try to work without Metasploit. With Metasploit, this box can probably be solved in a few minutes. Typically, the value in avoiding Metasploit comes from being able to really understand the exploits and what’s going on. In this case, it’s more about the struggle of moving files, finding binarys, etc.
    

*   May 23, 2020
    
    ### [HTB: Rope](https://0xdf.gitlab.io/2020/05/23/htb-rope.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Rope](https://0xdf.gitlab.io/tags.html#rope) [directory-traversal](https://0xdf.gitlab.io/tags.html#directory-traversal) [format-string](https://0xdf.gitlab.io/tags.html#format-string) [pwntools](https://0xdf.gitlab.io/tags.html#pwntools) [bruteforce](https://0xdf.gitlab.io/tags.html#bruteforce) [pwn](https://0xdf.gitlab.io/tags.html#pwn) [python](https://0xdf.gitlab.io/tags.html#python) [ida](https://0xdf.gitlab.io/tags.html#ida) [aslr](https://0xdf.gitlab.io/tags.html#aslr) [pie](https://0xdf.gitlab.io/tags.html#pie) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [library](https://0xdf.gitlab.io/tags.html#library) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [canary](https://0xdf.gitlab.io/tags.html#canary) [rop](https://0xdf.gitlab.io/tags.html#rop) ![](https://0xdf.gitlab.io/img/rope-cover.png) 
    
    Rope was all about binary exploitation. For initial access, I’ll use a directory traversal bug in the custom webserver to get a copy of that webserver as well as it’s memory space. From there, I can use a format string vulnerability to get a shell. To get to the next user, I’ll take advantage of an unsafe library load in a program that the current user can run with sudo. Finally, for root, I’ll exploit a locally running piece of software that requires brute forcing the canary, RBP, and return addresses to allows for an overflow and defeat PIE, and then doing a ROP libc leak to get past ASLR, all to send another ROP which provides a shell.
    

*   May 19, 2020
    
    ### [HTB: Arctic](https://0xdf.gitlab.io/2020/05/19/htb-arctic.html)
    
    [Arctic](https://0xdf.gitlab.io/tags.html#arctic) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [coldfusion](https://0xdf.gitlab.io/tags.html#coldfusion) [javascript](https://0xdf.gitlab.io/tags.html#javascript) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [jsp](https://0xdf.gitlab.io/tags.html#jsp) [upload](https://0xdf.gitlab.io/tags.html#upload) [msf](https://0xdf.gitlab.io/tags.html#msf) [directory-traversal](https://0xdf.gitlab.io/tags.html#directory-traversal) [crackstation](https://0xdf.gitlab.io/tags.html#crackstation) [windows-exploit-suggester](https://0xdf.gitlab.io/tags.html#windows-exploit-suggester) [ms10-095](https://0xdf.gitlab.io/tags.html#ms10-095) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/arctic-cover.png) 
    
    Arctic would have been much more interesting if not for the 30-second lag on each HTTP request. Still, there’s enough of an interface for me to find a ColdFusion webserver. There are two different paths to getting a shell, either an unauthenticated file upload, or leaking the login hash, cracking or using it to log in, and then uploading a shell jsp. From there, I’ll use MS10-059 to get a root shell.
    

*   May 16, 2020
    
    ### [HTB: Patents](https://0xdf.gitlab.io/2020/05/16/htb-patents.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Patents](https://0xdf.gitlab.io/tags.html#patents) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [upload](https://0xdf.gitlab.io/tags.html#upload) [libreoffice](https://0xdf.gitlab.io/tags.html#libreoffice) [xxe](https://0xdf.gitlab.io/tags.html#xxe) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [docx](https://0xdf.gitlab.io/tags.html#docx) [custom-folder](https://0xdf.gitlab.io/tags.html#custom-folder) [sans-holiday-hack](https://0xdf.gitlab.io/tags.html#sans-holiday-hack) [dtd](https://0xdf.gitlab.io/tags.html#dtd) [log-poisoning](https://0xdf.gitlab.io/tags.html#log-poisoning) [directory-traversal](https://0xdf.gitlab.io/tags.html#directory-traversal) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [docker](https://0xdf.gitlab.io/tags.html#docker) [pspy](https://0xdf.gitlab.io/tags.html#pspy) [password-reuse](https://0xdf.gitlab.io/tags.html#password-reuse) [git](https://0xdf.gitlab.io/tags.html#git) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [bof](https://0xdf.gitlab.io/tags.html#bof) [exploit](https://0xdf.gitlab.io/tags.html#exploit) [python](https://0xdf.gitlab.io/tags.html#python) [pwntools](https://0xdf.gitlab.io/tags.html#pwntools) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [pwn](https://0xdf.gitlab.io/tags.html#pwn) [onegadget](https://0xdf.gitlab.io/tags.html#onegadget) [rop](https://0xdf.gitlab.io/tags.html#rop) [libc](https://0xdf.gitlab.io/tags.html#libc) [libc-database](https://0xdf.gitlab.io/tags.html#libc-database) [df](https://0xdf.gitlab.io/tags.html#df) [mount](https://0xdf.gitlab.io/tags.html#mount) [cyberchef](https://0xdf.gitlab.io/tags.html#cyberchef) [php](https://0xdf.gitlab.io/tags.html#php) [payloadsallthethings](https://0xdf.gitlab.io/tags.html#payloadsallthethings) ![](https://0xdf.gitlab.io/img/patents-cover.png) 
    
    Patents was a really tough box, that probably should have been rated insane. I’ll find two listening services, a webserver and a custom service. I’ll exploit XXE in Libre Office that’s being used to convert docx files to PDFs to leak a configuration file, which uncovers another section of the site. In that section, there is a directory traversal vulnerability that allows me to use log poisoning to get execution and a shell in the web docker container. To get root in that container, I’ll find a password in the process list. As root, I get access to an application that’s communicating with the custom service on the host machine. I’ll also find a Git repo with the server binary, which I can reverse and find an exploit in, resulting in a shell as root on the host machine. In Beyond Root, I’ll look at chaining PHP filters to exfil larger data over XXE.
    

*   May 12, 2020
    
    ### [ngrok FTW](https://0xdf.gitlab.io/2020/05/12/ngrok-ftw.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [ngrok](https://0xdf.gitlab.io/tags.html#ngrok) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) ![](https://0xdf.gitlab.io/img/ngrok-cover.) 
    
    When I did the COVID-19 CTF, I needed a way to exploit one of the targets and have it callback to me. I spent a lot of time trying to get socket reuse shellcode to work, and if I had just tried a reverse shell payload, I would have gotten there a lot sooner. But getting the connection back to me seemed hard. I’d heard of ngrok for years as some kind of tunneling service. I’d seen malware use it. But I never really looked into how it worked or how I could use it, and it turns out to be super handy and really dead simple. This is barely worth a blog post, and it won’t help with HackTheBox, but it’s just one of those things that when you have a need for it, it’s so easy and useful.
    

*   May 9, 2020
    
    ### [HTB: Obscurity](https://0xdf.gitlab.io/2020/05/09/htb-obscurity.html)
    
    [Obscurity](https://0xdf.gitlab.io/tags.html#obscurity) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [python](https://0xdf.gitlab.io/tags.html#python) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [dirsearch](https://0xdf.gitlab.io/tags.html#dirsearch) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [python-injection](https://0xdf.gitlab.io/tags.html#python-injection) [command-injection](https://0xdf.gitlab.io/tags.html#command-injection) [code-analysis](https://0xdf.gitlab.io/tags.html#code-analysis) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [race-condition](https://0xdf.gitlab.io/tags.html#race-condition) [injection](https://0xdf.gitlab.io/tags.html#injection) [lxd](https://0xdf.gitlab.io/tags.html#lxd) [lxc](https://0xdf.gitlab.io/tags.html#lxc) [arbitrary-write](https://0xdf.gitlab.io/tags.html#arbitrary-write) [python-path](https://0xdf.gitlab.io/tags.html#python-path) ![](https://0xdf.gitlab.io/img/obscurity-cover.jpg) 
    
    Obscuirt was a medium box that centered on finding bugs in Python implementions of things - a webserver, an encryption scheme, and an SSH client. I’ll start by locating the source for the custom Python webserver, and injecting into it to get code execution and a shell. I’ll pivot to the next user abusing a poor custom cipher to decrypt a password. To get root, I’ll show four different ways. Two involve an SSH-like script that I can abuse both via a race condition to leak the system hashes and via injection to run a command as root instead of the authed user. The other two were patches after the box was released, but I’ll show them, exploiting the Python path, and exploiting the lxd group.
    

*   May 4, 2020
    
    ### [COVID-19 CTF: CovidScammers](https://0xdf.gitlab.io/2020/05/04/covid-19-ctf-covidscammers.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [wireshark](https://0xdf.gitlab.io/tags.html#wireshark) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [ltrace](https://0xdf.gitlab.io/tags.html#ltrace) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [python](https://0xdf.gitlab.io/tags.html#python) [pwntools](https://0xdf.gitlab.io/tags.html#pwntools) [fuzz](https://0xdf.gitlab.io/tags.html#fuzz) [bof](https://0xdf.gitlab.io/tags.html#bof) [pattern-create](https://0xdf.gitlab.io/tags.html#pattern-create) [shellcode](https://0xdf.gitlab.io/tags.html#shellcode) [dup2](https://0xdf.gitlab.io/tags.html#dup2) ![](https://0xdf.gitlab.io/img/covid19ctf-cover.) 
    
    Last Friday I competed with the Neutrino Cannon CTF team in the COVID-19 CTF created by Threat Simulations and RunCode as a part of DERPCON 2020. I focused much of my efforts on a section named CovidScammers. It was a really interesting challenge that encompassed forensics, reverseing, programming, fuzzing, and exploitation. I managed to get a shell on the C2 server just as I had to sign off for the day, so I didn’t complete the next steps that unlocked after that. Still, I really enjoyed the challenge and wanted to show the steps up to that point.
    

*   May 2, 2020
    
    ### [HTB: OpenAdmin](https://0xdf.gitlab.io/2020/05/02/htb-openadmin.html)
    
    [OpenAdmin](https://0xdf.gitlab.io/tags.html#openadmin) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [opennetadmin](https://0xdf.gitlab.io/tags.html#opennetadmin) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [password-reuse](https://0xdf.gitlab.io/tags.html#password-reuse) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [john](https://0xdf.gitlab.io/tags.html#john) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [gtfobins](https://0xdf.gitlab.io/tags.html#gtfobins) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/openadmin-cover.png) 
    
    OpenAdmin provided a straight forward easy box. There’s some enumeration to find an instance of OpenNetAdmin, which has a remote coded execution exploit that I’ll use to get a shell as www-data. The database credentials are reused by one of the users. Next I’ll pivot to the second user via an internal website which I can either get code execution on or bypass the login to get an SSH key. Finally, for root, there’s a sudo on nano that allows me to get a root shell using GTFObins.
    

*   Apr 30, 2020
    
    ### [HTB: SolidState](https://0xdf.gitlab.io/2020/04/30/htb-solidstate.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [SolidState](https://0xdf.gitlab.io/tags.html#solidstate) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [james](https://0xdf.gitlab.io/tags.html#james) [pop3](https://0xdf.gitlab.io/tags.html#pop3) [smtp](https://0xdf.gitlab.io/tags.html#smtp) [bash-completion](https://0xdf.gitlab.io/tags.html#bash-completion) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [rbash](https://0xdf.gitlab.io/tags.html#rbash) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [directory-traversal](https://0xdf.gitlab.io/tags.html#directory-traversal) [cron](https://0xdf.gitlab.io/tags.html#cron) [pspy](https://0xdf.gitlab.io/tags.html#pspy) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/solidstate-cover.png) 
    
    The biggest trick with SolidState was not focusing on the website but rather moving to a vulnerable James mail client. In fact, if I take advantage of a restrictred shell escape, I don’t even need to exploit James, but rather just use the admin interface with default creds to gain access to the various mailboxes, find SSH creds, escape rbash, and continue from there. But I will also show how to exploit James using a directory traversal vulnerability to write a bash completion script and then trigger that with a SSH login. For root, there’s a cron running an writable python script, which I can add a reverse shell to. In Beyond Root, I’ll look at payloads for the James exploit, both exploring what didn’t work, and improving the OPSEC.
    

*   Apr 25, 2020
    
    ### [HTB: Control](https://0xdf.gitlab.io/2020/04/25/htb-control.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Control](https://0xdf.gitlab.io/tags.html#control) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [mysql](https://0xdf.gitlab.io/tags.html#mysql) [http-header](https://0xdf.gitlab.io/tags.html#http-header) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [injection](https://0xdf.gitlab.io/tags.html#injection) [mysql-file-write](https://0xdf.gitlab.io/tags.html#mysql-file-write) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [powershell-run-as](https://0xdf.gitlab.io/tags.html#powershell-run-as) [winpeas](https://0xdf.gitlab.io/tags.html#winpeas) [registry-win](https://0xdf.gitlab.io/tags.html#registry-win) [services](https://0xdf.gitlab.io/tags.html#services) [powershell](https://0xdf.gitlab.io/tags.html#powershell) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus) ![](https://0xdf.gitlab.io/img/control-cover.png) 
    
    Control was a bit painful for someone not comfortable looking deep at Windows objects and permissions. It starts off simply enough, with a website where I’ll have to forge an HTTP header to get into the admin section, and then identify an SQL injection to write a webshell and dump user hashes. I can use the webshell to get a shell, and then one of the cracked hashes to pivot to a different user. From there, I’ll find that users can write the registry keys associated with Services. I’ll construct some PowerShell to find potential services that I can restart, and then modify them to run NetCat to return a shell.
    

*   Apr 22, 2020
    
    ### [HTB: Nineveh](https://0xdf.gitlab.io/2020/04/22/htb-nineveh.html)
    
    [Nineveh](https://0xdf.gitlab.io/tags.html#nineveh) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [vhosts](https://0xdf.gitlab.io/tags.html#vhosts) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [phpinfo](https://0xdf.gitlab.io/tags.html#phpinfo) [bruteforce](https://0xdf.gitlab.io/tags.html#bruteforce) [phpliteadmin](https://0xdf.gitlab.io/tags.html#phpliteadmin) [sql](https://0xdf.gitlab.io/tags.html#sql) [sqlite](https://0xdf.gitlab.io/tags.html#sqlite) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [hydra](https://0xdf.gitlab.io/tags.html#hydra) [directory-traversal](https://0xdf.gitlab.io/tags.html#directory-traversal) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [strings](https://0xdf.gitlab.io/tags.html#strings) [binwalk](https://0xdf.gitlab.io/tags.html#binwalk) [tar](https://0xdf.gitlab.io/tags.html#tar) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [port-knocking](https://0xdf.gitlab.io/tags.html#port-knocking) [knockd](https://0xdf.gitlab.io/tags.html#knockd) [chkrootkit](https://0xdf.gitlab.io/tags.html#chkrootkit) [pspy](https://0xdf.gitlab.io/tags.html#pspy) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/nineveh-cover.png) 
    
    There were several parts about Nineveh that don’t fit with what I expect in a modern HTB machine - steg, brute forcing passwords, and port knocking. Still, there were some really neat attacks. I’ll show two ways to get a shell, by writing a webshell via phpLiteAdmin, and by abusing PHPinfo. From there I’ll use my shell to read the knockd config and port knock to open SSH and gain access using the key pair I obtained from the steg image. To get root, I’ll exploit chkroot, which is running on a cron.
    

*   Apr 18, 2020
    
    ### [HTB: Mango](https://0xdf.gitlab.io/2020/04/18/htb-mango.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Mango](https://0xdf.gitlab.io/tags.html#mango) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [certificate](https://0xdf.gitlab.io/tags.html#certificate) [subdomains](https://0xdf.gitlab.io/tags.html#subdomains) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [nosql](https://0xdf.gitlab.io/tags.html#nosql) [mongo](https://0xdf.gitlab.io/tags.html#mongo) [injection](https://0xdf.gitlab.io/tags.html#injection) [nosql-injection](https://0xdf.gitlab.io/tags.html#nosql-injection) [python](https://0xdf.gitlab.io/tags.html#python) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [password-reuse](https://0xdf.gitlab.io/tags.html#password-reuse) [jjs](https://0xdf.gitlab.io/tags.html#jjs) [gtfobins](https://0xdf.gitlab.io/tags.html#gtfobins) [sudoers](https://0xdf.gitlab.io/tags.html#sudoers) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus) [oswe-like](https://0xdf.gitlab.io/tags.html#oswe-like) ![](https://0xdf.gitlab.io/img/mango-cover.png) 
    
    Mango’s focus was exploiting a NoSQL document database to bypass an authorization page and to leak database information. Once I had the users and passwords from the database, password reuse allowed me to SSH as one of the users, and then su to the other. From there, I’ll take advantage of a SUID binary associated with Java, jjs. I’ll show both file read and get a shell by writing a public SSH key into root’s authorized keys file.
    

*   Apr 14, 2020
    
    ### [HTB: Cronos](https://0xdf.gitlab.io/2020/04/14/htb-cronos.html)
    
    [Cronos](https://0xdf.gitlab.io/tags.html#cronos) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [dns](https://0xdf.gitlab.io/tags.html#dns) [nslookup](https://0xdf.gitlab.io/tags.html#nslookup) [zone-transfer](https://0xdf.gitlab.io/tags.html#zone-transfer) [dig](https://0xdf.gitlab.io/tags.html#dig) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [vhosts](https://0xdf.gitlab.io/tags.html#vhosts) [subdomain](https://0xdf.gitlab.io/tags.html#subdomain) [laravel](https://0xdf.gitlab.io/tags.html#laravel) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [injection](https://0xdf.gitlab.io/tags.html#injection) [command-injection](https://0xdf.gitlab.io/tags.html#command-injection) [burp](https://0xdf.gitlab.io/tags.html#burp) [linpeas](https://0xdf.gitlab.io/tags.html#linpeas) [cron](https://0xdf.gitlab.io/tags.html#cron) [php](https://0xdf.gitlab.io/tags.html#php) [mysql](https://0xdf.gitlab.io/tags.html#mysql) [cve-2018-15133](https://0xdf.gitlab.io/tags.html#cve-2018-15133) [metasploit](https://0xdf.gitlab.io/tags.html#metasploit) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/cronos-cover.png) 
    
    Cronos didn’t provide anything too challenging, but did present a good intro to many useful concepts. I’ll enumerate DNS to get the admin subdomain, and then bypass a login form using SQL injection to find another form where I could use command injections to get code execution and a shell. For privesc, I’ll take advantage of a root cron job which executes a file I have write privileges on, allowing me to modify it to get a reverse shell. In Beyond Root, I’ll look at the website and check in on how I was able to do both the SQLi and the command injection, as well as fail to exploit the machine with a Laravel PHP framework deserialization bug, and determine why.
    

*   Apr 11, 2020
    
    ### [HTB: Traverxec](https://0xdf.gitlab.io/2020/04/11/htb-traverxec.html)
    
    [Traverxec](https://0xdf.gitlab.io/tags.html#traverxec) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [nostromo](https://0xdf.gitlab.io/tags.html#nostromo) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [metasploit](https://0xdf.gitlab.io/tags.html#metasploit) [htpasswd](https://0xdf.gitlab.io/tags.html#htpasswd) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [john](https://0xdf.gitlab.io/tags.html#john) [gtfobins](https://0xdf.gitlab.io/tags.html#gtfobins) [journalctrl](https://0xdf.gitlab.io/tags.html#journalctrl) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/traverxec-cover.png) 
    
    Traverxec was a relatively easy box that involved enumerating and exploiting a less popular webserver, Nostromo. I’ll take advantage of a RCE vulnerability to get a shell on the host. I could only find a Metasploit script, but it was a simple HTTP request I could recreate with curl. Then I’ll pivot into the users private files based on his use of a web home directory on the server. To get root, I’ll exploit sudo used with journalctrl.
    

*   Apr 9, 2020
    
    ### [HTB: Sniper Beyond Root](https://0xdf.gitlab.io/2020/04/09/htb-sniper-beyondroot.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Sniper](https://0xdf.gitlab.io/tags.html#sniper) [cron](https://0xdf.gitlab.io/tags.html#cron) [scheduled-task](https://0xdf.gitlab.io/tags.html#scheduled-task) [persistence](https://0xdf.gitlab.io/tags.html#persistence) [powershell](https://0xdf.gitlab.io/tags.html#powershell) [startup](https://0xdf.gitlab.io/tags.html#startup) [magic](https://0xdf.gitlab.io/tags.html#magic)
    
    ![](https://0xdf.gitlab.io/img/sniper-br-cover.png)In Sniper, the administrator user is running CHM files that are dropped into c:\docs, and this is the path from the chris user to administrator. I was asked on Twitter how the CHM was executed, so I went back to take a look.
    

*   Apr 8, 2020
    
    ### [HTB: More Lame](https://0xdf.gitlab.io/2020/04/08/htb-lame-more.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Lame](https://0xdf.gitlab.io/tags.html#lame) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [distcc](https://0xdf.gitlab.io/tags.html#distcc) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [cve-2004-2687](https://0xdf.gitlab.io/tags.html#cve-2004-2687) [cve-2008-0166](https://0xdf.gitlab.io/tags.html#cve-2008-0166) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [rsa](https://0xdf.gitlab.io/tags.html#rsa) [suid](https://0xdf.gitlab.io/tags.html#suid) [gtfobins](https://0xdf.gitlab.io/tags.html#gtfobins) [wireshark](https://0xdf.gitlab.io/tags.html#wireshark) [python](https://0xdf.gitlab.io/tags.html#python) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    ![](https://0xdf.gitlab.io/img/lame-more-cover.png)After I put out a Lame write-up yesterday, it was pointed out that I skipped an access path entirely - distcc. Yet another vulnerable service on this box, which, unlike the Samba exploit, provides a shell as a user, providing the opportunity to look for PrivEsc paths. This box is so old, I’m sure there are a ton of kernel exploits available. I’ll skip those for now focusing on ~two~ three paths to root - finding a weak public SSH key, using SUID nmap, and backdoored UnrealIRCd.
    

*   Apr 7, 2020
    
    ### [HTB: Lame](https://0xdf.gitlab.io/2020/04/07/htb-lame.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Lame](https://0xdf.gitlab.io/tags.html#lame) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ftp](https://0xdf.gitlab.io/tags.html#ftp) [vsftpd](https://0xdf.gitlab.io/tags.html#vsftpd) [samba](https://0xdf.gitlab.io/tags.html#samba) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [exploit](https://0xdf.gitlab.io/tags.html#exploit) [msf](https://0xdf.gitlab.io/tags.html#msf) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/lame-cover.png) 
    
    Lame was the first box released on HTB (as far as I can tell), which was before I started playing. It’s a super easy box, easily knocked over with a Metasploit script directly to a root shell. Still, it has some very OSCP-like aspects to it, so I’ll show it with and without Metasploit, and analyze the exploits. It does throw one head-fake with a VSFTPd server that is a vulnerable version, but with the box configured to not allow remote exploitation. I’ll dig into VSFTPd in Beyond Root.
    

*   Apr 4, 2020
    
    ### [HTB: Registry](https://0xdf.gitlab.io/2020/04/04/htb-registry.html)
    
    [Registry](https://0xdf.gitlab.io/tags.html#registry) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [subdomain](https://0xdf.gitlab.io/tags.html#subdomain) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [zcat](https://0xdf.gitlab.io/tags.html#zcat) [docker](https://0xdf.gitlab.io/tags.html#docker) [bolt-cms](https://0xdf.gitlab.io/tags.html#bolt-cms) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [api](https://0xdf.gitlab.io/tags.html#api) [docker-fetch](https://0xdf.gitlab.io/tags.html#docker-fetch) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [sqlite](https://0xdf.gitlab.io/tags.html#sqlite) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [firewall](https://0xdf.gitlab.io/tags.html#firewall) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [restic](https://0xdf.gitlab.io/tags.html#restic) [cron](https://0xdf.gitlab.io/tags.html#cron) ![](https://0xdf.gitlab.io/img/registry-cover.png) 
    
    Registry provided the chance to play with a private Docker registry that wasn’t protected by anything other than a weak set of credentials. I’ll move past that to get the container and the SSH key and password inside. From there, I’ll exploit an instance of Bolt CMS to pivot to the www-data user. As www-data, I can access the Restic backup agent as root, and exploit that to get both the root flag and a root ssh key.
    

*   Apr 2, 2020
    
    ### [Jar Files: Modification Cheat Sheet](https://0xdf.gitlab.io/2020/04/02/jar-files-analysis-and-modifications.html)
    
    [java](https://0xdf.gitlab.io/tags.html#java) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [decompile](https://0xdf.gitlab.io/tags.html#decompile) [jar](https://0xdf.gitlab.io/tags.html#jar) [recompile](https://0xdf.gitlab.io/tags.html#recompile) ![](https://0xdf.gitlab.io/img/jar-cover.) 
    
    I recently ran into a challenge where I was given a Java Jar file that I needed to analyze and patch to exploit. I didn’t find many good tutorials on how to do this, so I wanted to get my notes down. For now it’s just a cheat sheet table of commands. When the challenge ends, I’ll update with some narrative.
    

*   Mar 28, 2020
    
    ### [HTB: Sniper](https://0xdf.gitlab.io/2020/03/28/htb-sniper.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Sniper](https://0xdf.gitlab.io/tags.html#sniper) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [commando](https://0xdf.gitlab.io/tags.html#commando) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [rfi](https://0xdf.gitlab.io/tags.html#rfi) [wireshark](https://0xdf.gitlab.io/tags.html#wireshark) [samba](https://0xdf.gitlab.io/tags.html#samba) [log-poisoning](https://0xdf.gitlab.io/tags.html#log-poisoning) [powershell](https://0xdf.gitlab.io/tags.html#powershell) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [powershell-run-as](https://0xdf.gitlab.io/tags.html#powershell-run-as) [chm](https://0xdf.gitlab.io/tags.html#chm) [nishang](https://0xdf.gitlab.io/tags.html#nishang) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus) ![](https://0xdf.gitlab.io/img/sniper-cover.png) 
    
    Sniper involved utilizing a relatively obvious file include vulnerability in a web page to get code execution and then a shell. The first privesc was a common credential reuse issue. The second involved poisoning a `.chm` file to get code execution as the administrator.
    

*   Mar 25, 2020
    
    ### [update-alternatives](https://0xdf.gitlab.io/2020/03/25/update-alternatives.html)
    
    [linux](https://0xdf.gitlab.io/tags.html#linux) [update-alternatives](https://0xdf.gitlab.io/tags.html#update-alternatives) [nc](https://0xdf.gitlab.io/tags.html#nc) [java](https://0xdf.gitlab.io/tags.html#java) [namei](https://0xdf.gitlab.io/tags.html#namei) [bash](https://0xdf.gitlab.io/tags.html#bash) ![](https://0xdf.gitlab.io/icons/Linux.) 
    
    Debian Linux (and its derivatives like Ubuntu and Kali) has a system called alternatives that’s designed to manage having different version of some software, or aliasing different commands to different versions within the system. Most of the time, this is managed by the package management system. When you run apt install x, it may do some of this behind the scenes for you. But there are times when it is really useful to know how to interact with this yourself. For example, I’m currently working on a challenge that requires using an older version of Java to interact with a file. I’ll use update-altneratives to install the new Java version, and then to change what version java, javac, jar, etc utilize.
    

*   Mar 21, 2020
    
    ### [HTB: Forest](https://0xdf.gitlab.io/2020/03/21/htb-forest.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Forest](https://0xdf.gitlab.io/tags.html#forest) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [active-directory](https://0xdf.gitlab.io/tags.html#active-directory) [dig](https://0xdf.gitlab.io/tags.html#dig) [dns](https://0xdf.gitlab.io/tags.html#dns) [rpc](https://0xdf.gitlab.io/tags.html#rpc) [rpcclient](https://0xdf.gitlab.io/tags.html#rpcclient) [as-rep-roast](https://0xdf.gitlab.io/tags.html#as-rep-roast) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [winrm](https://0xdf.gitlab.io/tags.html#winrm) [evil-winrm](https://0xdf.gitlab.io/tags.html#evil-winrm) [sharphound](https://0xdf.gitlab.io/tags.html#sharphound) [smbserver](https://0xdf.gitlab.io/tags.html#smbserver) [bloodhound](https://0xdf.gitlab.io/tags.html#bloodhound) [dcsync](https://0xdf.gitlab.io/tags.html#dcsync) [aclpwn](https://0xdf.gitlab.io/tags.html#aclpwn) [wireshark](https://0xdf.gitlab.io/tags.html#wireshark) [scheduled-task](https://0xdf.gitlab.io/tags.html#scheduled-task) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/forest-cover.png) 
    
    One of the neat things about HTB is that it exposes Windows concepts unlike any CTF I’d come across before it. Forest is a great example of that. It is a domain controller that allows me to enumerate users over RPC, attack Kerberos with AS-REP Roasting, and use Win-RM to get a shell. Then I can take advantage of the permissions and accesses of that user to get DCSycn capabilities, allowing me to dump hashes for the administrator user and get a shell as the admin. In Beyond Root, I’ll look at what DCSync looks like on the wire, and look at the automated task cleaning up permissions.
    

*   Mar 14, 2020
    
    ### [HTB: Postman](https://0xdf.gitlab.io/2020/03/14/htb-postman.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Postman](https://0xdf.gitlab.io/tags.html#postman) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [webmin](https://0xdf.gitlab.io/tags.html#webmin) [redis](https://0xdf.gitlab.io/tags.html#redis) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [john](https://0xdf.gitlab.io/tags.html#john) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [cve-2019-12840](https://0xdf.gitlab.io/tags.html#cve-2019-12840) [metasploit](https://0xdf.gitlab.io/tags.html#metasploit) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/postman-cover.png) 
    
    Postman was a good mix of easy challenges providing a chance to play with Redis and exploit Webmin. I’ll gain initial access by using Redis to write an SSH public key into an authorized_keys file. Then I’ll pivot to Matt by cracking his encrypted SSH key and using the password. That same password provides access to the Webmin instance, which is running as root, and can be exploited to get a shell. In Beyond Root, I’ll look at a Metasploit Redis exploit and why it failed on this box.
    

*   Mar 7, 2020
    
    ### [HTB: Bankrobber](https://0xdf.gitlab.io/2020/03/07/htb-bankrobber.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Bankrobber](https://0xdf.gitlab.io/tags.html#bankrobber) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [mysql](https://0xdf.gitlab.io/tags.html#mysql) [smb](https://0xdf.gitlab.io/tags.html#smb) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [cookies](https://0xdf.gitlab.io/tags.html#cookies) [xss](https://0xdf.gitlab.io/tags.html#xss) [csrf](https://0xdf.gitlab.io/tags.html#csrf) [xsrf](https://0xdf.gitlab.io/tags.html#xsrf) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [injection](https://0xdf.gitlab.io/tags.html#injection) [bof](https://0xdf.gitlab.io/tags.html#bof) [ida](https://0xdf.gitlab.io/tags.html#ida) [chisel](https://0xdf.gitlab.io/tags.html#chisel) [python](https://0xdf.gitlab.io/tags.html#python) [msf](https://0xdf.gitlab.io/tags.html#msf) [pattern-create](https://0xdf.gitlab.io/tags.html#pattern-create) [phantom-js](https://0xdf.gitlab.io/tags.html#phantom-js) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/bankrobber-cover.png) 
    
    BankRobber was neat because it required exploiting the same exploit twice. I’ll find a XSS vulnerability that I can use to leak the admin user’s cookie, giving me access to the admin section of the site. From there, I’ll use a SQL injection to leak the source for one of the PHP pages which shows it can provide code execution, but only accepts requests from localhost. I’ll use the same XSS vulnerability to get the admin to send that request from Bankrobber, returning a shell. To privesc to SYSTEM, I’ll find a binary running as SYSTEM and listening only on localhost. I’m not able to grab a copy of the binary as my current user, but I can create a tunnel and poke at it directly. First I’ll brute force a 4-digit pin, and then I’ll discover a simple buffer overflow that allows me to overwrite a string that is the path to an executable that’s later run. I can overwrite that myself to get a shell. In Beyond Root, I’ll look at how the XSS was automated and at the executable now that I have access.
    

*   Feb 29, 2020
    
    ### [HTB: Scavenger](https://0xdf.gitlab.io/2020/02/29/htb-scavenger.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Scavenger](https://0xdf.gitlab.io/tags.html#scavenger) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [whois](https://0xdf.gitlab.io/tags.html#whois) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [injection](https://0xdf.gitlab.io/tags.html#injection) [zone-transfer](https://0xdf.gitlab.io/tags.html#zone-transfer) [exim](https://0xdf.gitlab.io/tags.html#exim) [cve-2019-10149](https://0xdf.gitlab.io/tags.html#cve-2019-10149) [vhosts](https://0xdf.gitlab.io/tags.html#vhosts) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [dirsearch](https://0xdf.gitlab.io/tags.html#dirsearch) [wpscan](https://0xdf.gitlab.io/tags.html#wpscan) [mantisbt](https://0xdf.gitlab.io/tags.html#mantisbt) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [ir](https://0xdf.gitlab.io/tags.html#ir) [python](https://0xdf.gitlab.io/tags.html#python) [python-cmd](https://0xdf.gitlab.io/tags.html#python-cmd) [mkfifo-shell](https://0xdf.gitlab.io/tags.html#mkfifo-shell) [hydra](https://0xdf.gitlab.io/tags.html#hydra) [rootkit](https://0xdf.gitlab.io/tags.html#rootkit) [ida](https://0xdf.gitlab.io/tags.html#ida) [iptables](https://0xdf.gitlab.io/tags.html#iptables) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) ![](https://0xdf.gitlab.io/img/scavenger-cover.png) 
    
    Scavenger required a ton of enumeration, and I was able to solve it without ever getting a typical shell. The box is all about enumerating the different sites on the box (and using an SQL injection in whois to get them all), and finding one is hacked and a webshell is left behind. The firewall rules make getting a reverse shell impossible, but I’ll use the RCE to enumerate the box (and build a stateful Python shell in the process, though it’s not necessary). Enumerating will turn up several usernames and passwords, which I’ll use for FTP access to get more creds, the user flag, and a copy of a rootkit that’s running on the box. A combination of finding the rootkit described on a webpage via Googling and reversing to see how it’s changed gives me the ability to trigger any session to root. In Beyond Root, I’ll look more in-depth at the SQLi in the whois server, examine the iptables rules that made getting a reverse shell impossible, and show how to use CVE-2019-10149 against the EXIM mail server to get execution as root as well.
    

*   Feb 22, 2020
    
    ### [HTB: Zetta](https://0xdf.gitlab.io/2020/02/22/htb-zetta.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Zetta](https://0xdf.gitlab.io/tags.html#zetta) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ftp-bounce](https://0xdf.gitlab.io/tags.html#ftp-bounce) [rfc-2428](https://0xdf.gitlab.io/tags.html#rfc-2428) [ipv6](https://0xdf.gitlab.io/tags.html#ipv6) [rsync](https://0xdf.gitlab.io/tags.html#rsync) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [tudu](https://0xdf.gitlab.io/tags.html#tudu) [syslog](https://0xdf.gitlab.io/tags.html#syslog) [git](https://0xdf.gitlab.io/tags.html#git) [postgres](https://0xdf.gitlab.io/tags.html#postgres) [sqli](https://0xdf.gitlab.io/tags.html#sqli) ![](https://0xdf.gitlab.io/img/zetta-cover.png) 
    
    Zetta starts off different fromt the start, using FTP Bounce attacks to identify the IPv6 address of the box, and then finding RSync listening on IPv6 only. I’ll use limited RSync access to get the size of a user’s password, and then brute force it to get access to the roy home directory, where I can write my key to the authorized keys file to get SSH access. I’ll escalate to the postgres user with an SQL injection into Syslog, where the box author cleverly uses Git to show the config but not the most recent password. Finally, I’ll recover the password for root using some logic and the postgres user’s password. In Beyond Root, I’ll look at the authentication for the FTP server that allowed any 32 character user with the username as the password, dig into the RSync config, and look at the bits of the Syslog config that were hidden from me.
    

*   Feb 15, 2020
    
    ### [HTB: Json](https://0xdf.gitlab.io/2020/02/15/htb-json.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Json](https://0xdf.gitlab.io/tags.html#json) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [commando](https://0xdf.gitlab.io/tags.html#commando) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [deserialization](https://0xdf.gitlab.io/tags.html#deserialization) [.NET](https://0xdf.gitlab.io/tags.html#net) [javascript](https://0xdf.gitlab.io/tags.html#javascript) [deobfuscation](https://0xdf.gitlab.io/tags.html#deobfuscation) [jsnice](https://0xdf.gitlab.io/tags.html#jsnice) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [oauth](https://0xdf.gitlab.io/tags.html#oauth) [ysoserial.net](https://0xdf.gitlab.io/tags.html#ysoserial-net) [filezilla](https://0xdf.gitlab.io/tags.html#filezilla) [chisel](https://0xdf.gitlab.io/tags.html#chisel) [ftp](https://0xdf.gitlab.io/tags.html#ftp) [dnspy](https://0xdf.gitlab.io/tags.html#dnspy) [python](https://0xdf.gitlab.io/tags.html#python) [des](https://0xdf.gitlab.io/tags.html#des) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [juicypotato](https://0xdf.gitlab.io/tags.html#juicypotato) [potato](https://0xdf.gitlab.io/tags.html#potato) [oswe-like](https://0xdf.gitlab.io/tags.html#oswe-like) ![](https://0xdf.gitlab.io/img/json-cover.png) 
    
    Json involved exploiting a .NET deserialization vulnerability to get initial access, and then going one of three ways to get root.txt. I’ll show each of the three ways I’m aware of to escalate: Connecting to the FileZilla Admin interface and changing the users password; reversing a custom application to understand how to decrypt a username and password, which can then be used over the same FTP interface; and JuicyPotato to get a SYSTEM shell. Since this is a Windows host, I’ll work it almost entirely from my Windows Commando VM.
    

*   Feb 1, 2020
    
    ### [HTB: RE](https://0xdf.gitlab.io/2020/02/01/htb-re.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [RE](https://0xdf.gitlab.io/tags.html#re) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [vhosts](https://0xdf.gitlab.io/tags.html#vhosts) [jekyll](https://0xdf.gitlab.io/tags.html#jekyll) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap) [ods](https://0xdf.gitlab.io/tags.html#ods) [macro](https://0xdf.gitlab.io/tags.html#macro) [invoke-obfuscation](https://0xdf.gitlab.io/tags.html#invoke-obfuscation) [nishang](https://0xdf.gitlab.io/tags.html#nishang) [zipslip](https://0xdf.gitlab.io/tags.html#zipslip) [winrar](https://0xdf.gitlab.io/tags.html#winrar) [cron](https://0xdf.gitlab.io/tags.html#cron) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [xxe](https://0xdf.gitlab.io/tags.html#xxe) [responder](https://0xdf.gitlab.io/tags.html#responder) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [evil-winrm](https://0xdf.gitlab.io/tags.html#evil-winrm) [winrm](https://0xdf.gitlab.io/tags.html#winrm) [chisel](https://0xdf.gitlab.io/tags.html#chisel) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [usosvc](https://0xdf.gitlab.io/tags.html#usosvc) [accesschk](https://0xdf.gitlab.io/tags.html#accesschk) [service](https://0xdf.gitlab.io/tags.html#service) [service-hijack](https://0xdf.gitlab.io/tags.html#service-hijack) [diaghub](https://0xdf.gitlab.io/tags.html#diaghub) [esf](https://0xdf.gitlab.io/tags.html#esf) [mimikatz](https://0xdf.gitlab.io/tags.html#mimikatz) [hashes-org](https://0xdf.gitlab.io/tags.html#hashes-org) ![](https://0xdf.gitlab.io/img/re-cover.png) 
    
    RE was a box I was really excited about, and I was crushed when the final privesc didn’t work on initial deployment. Still, it got patched, and two unintended paths came about as well, and everything turned out ok. I’ll approach this write-up how I expected people to solve it, and call out the alternative paths (and what mistakes on my part allowed them) as well. I’ll upload a malicious ods file to a malware sandbox where it is run as long as it is obfuscated. From there, I’ll abuse WinRar slip vulnerability to write a webshell. Now as IIS user, I can access a new folder where Ghidra project files can be dropped to exploit an XXE in Ghidra. There’s two unintended paths from IIS to SYSTEM using the UsoSvc and Zipslip and Diaghub, where then I have to get coby’s creds to read root.txt. I’ll show all of these, and look at some of the automation scripts (including what didn’t work on initial deployment) in Beyond Root.
    

*   Jan 26, 2020
    
    ### [Digging into PSExec with HTB Nest](https://0xdf.gitlab.io/2020/01/26/digging-into-psexec-with-htb-nest.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Nest](https://0xdf.gitlab.io/tags.html#nest) [psexec](https://0xdf.gitlab.io/tags.html#psexec) [smb](https://0xdf.gitlab.io/tags.html#smb) [windows](https://0xdf.gitlab.io/tags.html#windows) [scmanager](https://0xdf.gitlab.io/tags.html#scmanager) [sddl](https://0xdf.gitlab.io/tags.html#sddl) [dacl](https://0xdf.gitlab.io/tags.html#dacl) [sacl](https://0xdf.gitlab.io/tags.html#sacl) [ace](https://0xdf.gitlab.io/tags.html#ace) [icacls](https://0xdf.gitlab.io/tags.html#icacls) ![](https://0xdf.gitlab.io/img/nest-unintended-cover.) 
    
    “You have to have administrator to PSExec.” That’s what I’d always heard. Nest released on HTB yesterday, and on release, it had an unintended path where a low-priv user was able to PSExec, providing a shell as SYSTEM. This has now been patched, but I thought it was interesting to see what was configured that allowed this non-admin user to get a shell with PSExec. Given this is a live box, I won’t go into any of the details that still matter, saving that for a write-up in 20ish weeks or so.
    

*   Jan 25, 2020
    
    ### [HTB: AI](https://0xdf.gitlab.io/2020/01/25/htb-ai.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [AI](https://0xdf.gitlab.io/tags.html#ai) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [text2speech](https://0xdf.gitlab.io/tags.html#text2speech) [flite](https://0xdf.gitlab.io/tags.html#flite) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [tomcat](https://0xdf.gitlab.io/tags.html#tomcat) [jdwp](https://0xdf.gitlab.io/tags.html#jdwp) [jdb](https://0xdf.gitlab.io/tags.html#jdb) [jwdp-shellifier](https://0xdf.gitlab.io/tags.html#jwdp-shellifier) ![](https://0xdf.gitlab.io/img/ai-cover.png) 
    
    AI was a really clever box themed after smart speakers like Echo and Google Home. I’ll find a web interface that accepts sound files, and use that to find SQL injection that I have to pass using words. Of course I’ll script the creation of the audio files, and use that to dump credentials from the database that I can use to access the server. For privesc, I’ll find an open Java Debug port on Tomcat running as root, and use that to get a shell.
    

*   Jan 18, 2020
    
    ### [HTB: Player](https://0xdf.gitlab.io/2020/01/18/htb-player.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Player](https://0xdf.gitlab.io/tags.html#player) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [vhosts](https://0xdf.gitlab.io/tags.html#vhosts) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [burp](https://0xdf.gitlab.io/tags.html#burp) [jwt](https://0xdf.gitlab.io/tags.html#jwt) [codiad](https://0xdf.gitlab.io/tags.html#codiad) [bfac](https://0xdf.gitlab.io/tags.html#bfac) [ffmpeg](https://0xdf.gitlab.io/tags.html#ffmpeg) [lshell](https://0xdf.gitlab.io/tags.html#lshell) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [include](https://0xdf.gitlab.io/tags.html#include) [deserialization](https://0xdf.gitlab.io/tags.html#deserialization) [php](https://0xdf.gitlab.io/tags.html#php) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [escape](https://0xdf.gitlab.io/tags.html#escape) ![](https://0xdf.gitlab.io/img/player-cover.png) 
    
    Player involved a lot of recon, and pulling together pieces to go down multiple different paths to user and root. I’ll start identifying and enumerating four different virtual hosts. Eventually I’ll find a backup file with PHP source on one, and use it to get access to a private area. From there, I can use a flaw in FFMPEG to leak videos that contain the text contents of various files on Player. I can use that information to get credentials where I can SSH, but only with a _very_ limited shell. However, I can use an SSH exploit to get code execution that provides limited and partial file read, which leads to more credentials. Those credentials are good for a Codiad instance running on another of the virtual hosts, which allows me to get a shell as www-data. There’s a PHP script running as a cron as root that I can exploit either by overwriting a file include, or by writing serialized PHP data. In Beyond Root, I’ll look at two more altnerative paths, one jumping right to shell against Codiad, and the other bypassing lshell.
    

*   Jan 14, 2020
    
    ### [Holiday Hack 2019: KringleCon2](https://0xdf.gitlab.io/holidayhack2019/)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [sans-holiday-hack](https://0xdf.gitlab.io/tags.html#sans-holiday-hack) ![](https://0xdf.gitlab.io/img/hh19-cover.) 
    
    The 2019 SANS Holiday Hack Challenge presented a twisted take on how a villain, the Tooth Fairy, tried to take down Santa and ruin Christmas. It all takes place at the second annual Kringle Con, where the worlds leading security practitioners show up to hear talks and solve puzzles. Hosted at Elf-U, this years conference included [14 talks from leaders in information security](https://www.youtube.com/playlist?list=PLjLd1hNA7YVzyhhqBQaW-tF45xnS6oHAP), as well as 11 terminals / in-game puzzles and 13 objectives to figure out. In solving all of these, the Tooth Fairy’s plot was foiled, and Santa was able to deliver presents on Christmas. As usual, the challenges were interesting and set up in such a way that it was very beginner friendly, with lots of hints and talks to ensure that you learned something while solving. While last year really started the trend of defensive themed challenges, 2019 had a ton of interesting defensive challenges, with hands on with machine learning as well as tools like Splunk and Graylog.
    

*   Jan 11, 2020
    
    ### [HTB: Bitlab](https://0xdf.gitlab.io/2020/01/11/htb-bitlab.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Bitlab](https://0xdf.gitlab.io/tags.html#bitlab) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [bookmark](https://0xdf.gitlab.io/tags.html#bookmark) [javascript](https://0xdf.gitlab.io/tags.html#javascript) [obfuscation](https://0xdf.gitlab.io/tags.html#obfuscation) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [git](https://0xdf.gitlab.io/tags.html#git) [gitlab](https://0xdf.gitlab.io/tags.html#gitlab) [docker](https://0xdf.gitlab.io/tags.html#docker) [ping-sweep](https://0xdf.gitlab.io/tags.html#ping-sweep) [chisel](https://0xdf.gitlab.io/tags.html#chisel) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [psql](https://0xdf.gitlab.io/tags.html#psql) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [ida](https://0xdf.gitlab.io/tags.html#ida) [x64dbg](https://0xdf.gitlab.io/tags.html#x64dbg) [git-hooks](https://0xdf.gitlab.io/tags.html#git-hooks) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus) ![](https://0xdf.gitlab.io/img/bitlab-cover.png) 
    
    Bitlab was a box centered around automation of things, even if the series challenges were each rather unrealistic. It starts with a Gitlab instance where the help link has been changed to give access to javascript encoded credentials. Once logged in, I have access to the codebase for the custom profile pages use in this instance, and there’s automation in place such that when I merge a change into master, it goes live right away. So I can add a webshell and get access to the box. In the database, I’ll find the next users credentials for SSH access. For Root, I’ll reverse engineer a Windows executable which is executing Putty with credentials, and use those creds to get root. In Beyond Root, I’ll look at an unintended path from www-data to root using git hooks, and explore a call to `GetUserNameW` that is destined to fail.
    

*   Jan 4, 2020
    
    ### [HTB: Craft](https://0xdf.gitlab.io/2020/01/04/htb-craft.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Craft](https://0xdf.gitlab.io/tags.html#craft) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gogs](https://0xdf.gitlab.io/tags.html#gogs) [api](https://0xdf.gitlab.io/tags.html#api) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [flask](https://0xdf.gitlab.io/tags.html#flask) [python](https://0xdf.gitlab.io/tags.html#python) [eval](https://0xdf.gitlab.io/tags.html#eval) [git](https://0xdf.gitlab.io/tags.html#git) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [vault-project](https://0xdf.gitlab.io/tags.html#vault-project) [jwt](https://0xdf.gitlab.io/tags.html#jwt) [john](https://0xdf.gitlab.io/tags.html#john) [jwtcat](https://0xdf.gitlab.io/tags.html#jwtcat) ![](https://0xdf.gitlab.io/img/craft-cover.png) 
    
    Craft was a really well designed medium box, with lots of interesting things to poke at, none of which were too difficult. I’ll find credentials for the API in the Gogs instance, as well as the API source, which allows me to identify a vulnerability in the API that gives code execution. Then I’ll use the shell on the API container to find creds that allow me access to private repos back on Gogs, which include an SSH key. With SSH access to the host, I’ll target the vault project software to get SSH access as root. In Beyond Root, I’ll look at the JWT, and my failed attempts to crack the secret.
    

*   Jan 1, 2020
    
    ### [Hackvent 2019 - leet](https://0xdf.gitlab.io/hackvent2019/leet)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackvent](https://0xdf.gitlab.io/tags.html#hackvent) [arduino](https://0xdf.gitlab.io/tags.html#arduino) [hex-file](https://0xdf.gitlab.io/tags.html#hex-file) [avr-simulator](https://0xdf.gitlab.io/tags.html#avr-simulator) [binascii](https://0xdf.gitlab.io/tags.html#binascii) [python](https://0xdf.gitlab.io/tags.html#python) [burp](https://0xdf.gitlab.io/tags.html#burp) [php](https://0xdf.gitlab.io/tags.html#php) [john](https://0xdf.gitlab.io/tags.html#john) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [arm](https://0xdf.gitlab.io/tags.html#arm) [ioctl](https://0xdf.gitlab.io/tags.html#ioctl) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) ![](https://0xdf.gitlab.io/img/hackvent2019-leet-cover.) 
    
    There were only three leet challenges, but they were not trivial, and IOT focused. First, I’ll reverse a Arduino binary from hexcode. Then, there’s a web hacking challenge that quickly morphs into a crypto challenge, which I can solve by reimplementing the leaked PRNG from Ida Pro to generate a valid password. Finally, there’s a firmware for a Broadcom wireless chip that I’ll need to find the hooked ioctl function and pull the flag from it.
    

*   Jan 1, 2020
    
    ### [Hackvent 2019 - Hard](https://0xdf.gitlab.io/hackvent2019/hard)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackvent](https://0xdf.gitlab.io/tags.html#hackvent) [websocket](https://0xdf.gitlab.io/tags.html#websocket) [mqtt](https://0xdf.gitlab.io/tags.html#mqtt) [cve-2017-7650](https://0xdf.gitlab.io/tags.html#cve-2017-7650) [x32dbg](https://0xdf.gitlab.io/tags.html#x32dbg) [patching](https://0xdf.gitlab.io/tags.html#patching) [unicode](https://0xdf.gitlab.io/tags.html#unicode) [php](https://0xdf.gitlab.io/tags.html#php) [sql](https://0xdf.gitlab.io/tags.html#sql) [mach-o](https://0xdf.gitlab.io/tags.html#mach-o) [deb](https://0xdf.gitlab.io/tags.html#deb) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [salsa20](https://0xdf.gitlab.io/tags.html#salsa20) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [emojicode](https://0xdf.gitlab.io/tags.html#emojicode) [ps4](https://0xdf.gitlab.io/tags.html#ps4) [ecc](https://0xdf.gitlab.io/tags.html#ecc) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) ![](https://0xdf.gitlab.io/img/hackvent2019-hard-cover.) 
    
    The hard levels of Hackvent conitnued with more web hacking, reverse engineering, crypto, and an esoteric programming language. In the reversing challenges, there was not only an iPhone debian package, but also a PS4 update file.
    

*   Jan 1, 2020
    
    ### [Hackvent 2019 - Medium](https://0xdf.gitlab.io/hackvent2019/medium)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackvent](https://0xdf.gitlab.io/tags.html#hackvent) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [sql](https://0xdf.gitlab.io/tags.html#sql) [credit-cards](https://0xdf.gitlab.io/tags.html#credit-cards) [rule-30](https://0xdf.gitlab.io/tags.html#rule-30) [gimp](https://0xdf.gitlab.io/tags.html#gimp) [strace](https://0xdf.gitlab.io/tags.html#strace) [ltrace](https://0xdf.gitlab.io/tags.html#ltrace) [jwt](https://0xdf.gitlab.io/tags.html#jwt) [python](https://0xdf.gitlab.io/tags.html#python) [vb](https://0xdf.gitlab.io/tags.html#vb) [x32dbg](https://0xdf.gitlab.io/tags.html#x32dbg) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [jsf](https://0xdf.gitlab.io/tags.html#jsf) [perl](https://0xdf.gitlab.io/tags.html#perl) [obfuscation](https://0xdf.gitlab.io/tags.html#obfuscation) [deparse](https://0xdf.gitlab.io/tags.html#deparse) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) ![](https://0xdf.gitlab.io/img/hackvent2019-medium-cover.) 
    
    The medium levels brought the first reverse enginnering challenges, the first web hacking challenges, some image manipulation, and of course, some obfuscated Perl.
    

*   Dec 31, 2019
    
    ### [Hackvent 2019 - Easy](https://0xdf.gitlab.io/hackvent2019/easy)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackvent](https://0xdf.gitlab.io/tags.html#hackvent) [forensics](https://0xdf.gitlab.io/tags.html#forensics) [stereolithography](https://0xdf.gitlab.io/tags.html#stereolithography) [stl](https://0xdf.gitlab.io/tags.html#stl) [clara-io](https://0xdf.gitlab.io/tags.html#clara-io) [aztec-code](https://0xdf.gitlab.io/tags.html#aztec-code) [hodor](https://0xdf.gitlab.io/tags.html#hodor) [ahk](https://0xdf.gitlab.io/tags.html#ahk) [autohotkey](https://0xdf.gitlab.io/tags.html#autohotkey) [steganography](https://0xdf.gitlab.io/tags.html#steganography) [python](https://0xdf.gitlab.io/tags.html#python) [pil](https://0xdf.gitlab.io/tags.html#pil) [bacon](https://0xdf.gitlab.io/tags.html#bacon) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [stegsnow](https://0xdf.gitlab.io/tags.html#stegsnow) [base58](https://0xdf.gitlab.io/tags.html#base58) ![](https://0xdf.gitlab.io/img/hackvent2019-easy-cover.) 
    
    Hackvent is a fun CTF, offering challenges that start off quite easy and build to much harder over the course of 24 days, with bonus points for submitting the flag within the first 24 hours for each challenge. This was the first year I made it past day 12, and I was excited to finish all the challenges with all time bonuses! I’ll break the solutions into four parts. The first is the easy challenges, days 1-7, which provided some basic image forensics, some interesting file types, an esoteric programming language, and two hidden flags.
    

*   Dec 14, 2019
    
    ### [Advent of Code 2019: Day 14](https://0xdf.gitlab.io/adventofcode2019/14)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [defaultdict](https://0xdf.gitlab.io/tags.html#defaultdict) ![](https://0xdf.gitlab.io/img/aoc2019-14-cover.) 
    
    Day 14 is all about stacking requirements and then working them to understand the inputs required to get the output desired. I’ll need to organize my list of reactions in such a way that I can work back from the desired end output to how much ore is required to get there.
    

*   Dec 14, 2019
    
    ### [HTB: Smasher2](https://0xdf.gitlab.io/2019/12/14/htb-smasher2.html)
    
    [Smasher2](https://0xdf.gitlab.io/tags.html#smasher2) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [exploit](https://0xdf.gitlab.io/tags.html#exploit) [auth-bypass](https://0xdf.gitlab.io/tags.html#auth-bypass) [logic-error](https://0xdf.gitlab.io/tags.html#logic-error) [python](https://0xdf.gitlab.io/tags.html#python) [reference-counting](https://0xdf.gitlab.io/tags.html#reference-counting) [kernal-driver](https://0xdf.gitlab.io/tags.html#kernal-driver) [mmap](https://0xdf.gitlab.io/tags.html#mmap) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) ![](https://0xdf.gitlab.io/img/smasher2-cover.png) 
    
    Like the first Smasher, Smasher2 was focused on exploitation. However this one didn’t have a buffer overflow or what I typically think of as binary exploitation. It starts with finding a vulnerability in a compiled Python module (written in C) to get access to an API key. Then I’ll have to bypass a WAF to use that API to get execution and then a shell onSmasher2. For PrivEsc, I’ll need to exploit a kernel driver to get a root shell.
    

*   Dec 13, 2019
    
    ### [Advent of Code 2019: Day 13](https://0xdf.gitlab.io/adventofcode2019/13)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [intcode-computer](https://0xdf.gitlab.io/tags.html#intcode-computer) [defaultdict](https://0xdf.gitlab.io/tags.html#defaultdict) ![](https://0xdf.gitlab.io/img/aoc2019-13-cover.) 
    
    Continuing with the computer, now I’m using it to power an arcade game. I’ll use the given intcodes to run the game, and I’m responsible for moving the joystick via input to the game. This challenge was awesome. I made a video of the game running in my terminal, which wasn’t necessary, but turned out pretty good.
    

*   Dec 12, 2019
    
    ### [Advent of Code 2019: Day 12](https://0xdf.gitlab.io/adventofcode2019/12)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2019-12-cover.) 
    
    Day 12 asks me to look at moons and calculate their positions based on a simplified gravity between them. In the first part, I’ll run the system for 1000 steps and return a calculation (“energy”) based on each moons position and velocity at that point. In the second part, I’ll have to find when the positions repeat, which I can do by recognizing that the three axes are independent of each other, and that I can find the cycle time for each axis, and then find the least common multiple of them to get when all three are in order.
    

*   Dec 11, 2019
    
    ### [Advent of Code 2019: Day 11](https://0xdf.gitlab.io/adventofcode2019/11)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [intcode-computer](https://0xdf.gitlab.io/tags.html#intcode-computer) [defaultdict](https://0xdf.gitlab.io/tags.html#defaultdict) ![](https://0xdf.gitlab.io/img/aoc2019-11-cover.) 
    
    Continuing with the computer, now I’m using it to power a robot. My robot will walk around, reading the current color, submitting that to the program, and getting back the color to paint the current square and instructions for where to move next.
    

*   Dec 10, 2019
    
    ### [Advent of Code 2019: Day 10](https://0xdf.gitlab.io/adventofcode2019/10)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2019-10-cover.) 
    
    This challenge gives me a map of asteroids. I’ll need to play with different ways to find which ones are directly in the path of others, first to see which asteroids can see the most others, and then to destroy them one by one with a laser.
    

*   Dec 9, 2019
    
    ### [Advent of Code 2019: Day 9](https://0xdf.gitlab.io/adventofcode2019/9)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [intcode-computer](https://0xdf.gitlab.io/tags.html#intcode-computer) [defaultdict](https://0xdf.gitlab.io/tags.html#defaultdict) ![](https://0xdf.gitlab.io/img/aoc2019-9-cover.) 
    
    More computer work in day 9, this time adding what is kind of a stack pointer and an opcode to adjust that pointer. Now I can add a relative address mode, getting positions relative to the stack pointer.
    

*   Dec 8, 2019
    
    ### [Advent of Code 2019: Day 8](https://0xdf.gitlab.io/adventofcode2019/8)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2019-8-cover.) 
    
    After spending hours on day 7, I finished day 8 in about 15 minutes. It was simply reading in a series of numbers which represented pixels in various layers in an email. In part one I’ll break the pixels into layers, and evaluate each one. In part two, I’ll actually create the image.
    

*   Dec 8, 2019
    
    ### [Advent of Code 2019: Day 7](https://0xdf.gitlab.io/adventofcode2019/7)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [intcode-computer](https://0xdf.gitlab.io/tags.html#intcode-computer) ![](https://0xdf.gitlab.io/img/aoc2019-7-cover.) 
    
    The computer is back again, and this time, I’m chaining it and using it as an amplifier. In the each part, I’ll find the way to get maximum thrust from five amplifiers given that each can take one of five given phases. In part two, there’s a loop of amplification.
    

*   Dec 7, 2019
    
    ### [HTB: Wall](https://0xdf.gitlab.io/2019/12/07/htb-wall.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Wall](https://0xdf.gitlab.io/tags.html#wall) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [hydra](https://0xdf.gitlab.io/tags.html#hydra) [centreon](https://0xdf.gitlab.io/tags.html#centreon) [cve-2019-13024](https://0xdf.gitlab.io/tags.html#cve-2019-13024) [waf](https://0xdf.gitlab.io/tags.html#waf) [filter](https://0xdf.gitlab.io/tags.html#filter) [python](https://0xdf.gitlab.io/tags.html#python) [uncompyle](https://0xdf.gitlab.io/tags.html#uncompyle) [screen](https://0xdf.gitlab.io/tags.html#screen) [modsecurity](https://0xdf.gitlab.io/tags.html#modsecurity) [htaccess](https://0xdf.gitlab.io/tags.html#htaccess) ![](https://0xdf.gitlab.io/img/wall-cover.png) 
    
    Wall presented a series of challenges wrapped around two public exploits. The first exploit was a CVE in Centreon software. But to find it, I had to take advantage of a misconfigured webserver that only requests authenticatoin on GET requests, allowing POST requests to proceed, which leads to the path to the Centreon install. Next, I’ll use the public exploit, but it fails because there’s a WAF blocking requests with certain keywords. I’ll probe to identify the blocks workds, which includes the space character, and use the Linux environment variable ${IFS} instead of space to get command injection. Once I have that, I can get a shell on the box. There’s a compiled Python file in the users home directory, which I can decompile to find the password for the second user. From either of these users, I can exploit SUID screen to get a root shell. In Beyond Root, I’ll look at the webserver configuration, the WAF, improve the exploit script, and look at some trolls the author left around.
    

*   Dec 6, 2019
    
    ### [Advent of Code 2019: Day 6](https://0xdf.gitlab.io/adventofcode2019/6)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [recursion](https://0xdf.gitlab.io/tags.html#recursion) [defaultdict](https://0xdf.gitlab.io/tags.html#defaultdict) ![](https://0xdf.gitlab.io/img/aoc2019-6-cover.) 
    
    This was a fun challenge, because it seemed really hard at first, but once I figured out how to think about it, it was quite simple. I’m given a set of pairings, each of which contains two objects, the second orbits around the first. I’ll play with counting the number of orbits going on, as well as working a path through the orbits. This was the first time I brought out recurrisive programming this year, and it really fit well.
    

*   Dec 5, 2019
    
    ### [Advent of Code 2019: Day 5](https://0xdf.gitlab.io/adventofcode2019/5)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [intcode-computer](https://0xdf.gitlab.io/tags.html#intcode-computer) ![](https://0xdf.gitlab.io/img/aoc2019-5-cover.) 
    
    Today I’m tasked with building on the simple computer I built in [day 2](https://0xdf.gitlab.io/adventofcode2019/2). I’ll add new instructions for input / output and comparisons / branching. I’ll also get parameter modes, so in addition to reading values from other positions, I can now handle constants (known in computer architecture as immediates).
    

*   Dec 3, 2019
    
    ### [Advent of Code 2019: Day 4](https://0xdf.gitlab.io/adventofcode2019/4)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2019-4-cover.) 
    
    I solved day 4 much faster than day 3, probably because it moved away from spacial reasoning and just into input validation. I’m given a range of 6-digit numbers, and asked to pick ones that meet certain criteria.
    

*   Dec 3, 2019
    
    ### [Advent of Code 2019: Day 3](https://0xdf.gitlab.io/adventofcode2019/3)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2019-3-cover.) 
    
    I always start to struggle when AOC moves into spacial challenges, and this is where the code starts to get a bit ugly. In this challenge, I have to think about two wires moving across a coordinate plane, and look for positions where they intersect. Then I’ll score each intersection, first by Manhattan distance to the origin, and then by total number of steps from the origin along both wires, and return the minimum.
    

*   Dec 2, 2019
    
    ### [Advent of Code 2019: Day 2](https://0xdf.gitlab.io/adventofcode2019/2)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) [intcode-computer](https://0xdf.gitlab.io/tags.html#intcode-computer) ![](https://0xdf.gitlab.io/img/aoc2019-2-cover.) 
    
    This puzzle is to implement a little computer with three op codes, add, multiply, and finish. In the first part, I’m given two starting register values, 12 and 2. In the second part, I need to brute force those values to find a given target output.
    

*   Dec 1, 2019
    
    ### [Advent of Code 2019: Day 1](https://0xdf.gitlab.io/adventofcode2019/1)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python) ![](https://0xdf.gitlab.io/img/aoc2019-1-cover.) 
    
    This puzzle was basically reading a list of numbers, performing some basic arithmetic, and summing the results. For part two, there’s a twist in that I’ll need to do that same math on the results, and add then as long as they are greater than 0.
    

*   Nov 30, 2019
    
    ### [HTB: Heist](https://0xdf.gitlab.io/2019/11/30/htb-heist.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Heist](https://0xdf.gitlab.io/tags.html#heist) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [cisco](https://0xdf.gitlab.io/tags.html#cisco) [john](https://0xdf.gitlab.io/tags.html#john) [cisco-type-7](https://0xdf.gitlab.io/tags.html#cisco-type-7) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap) [crackmapexec](https://0xdf.gitlab.io/tags.html#crackmapexec) [rpcclient](https://0xdf.gitlab.io/tags.html#rpcclient) [ipc](https://0xdf.gitlab.io/tags.html#ipc) [lookupsids](https://0xdf.gitlab.io/tags.html#lookupsids) [evil-winrm](https://0xdf.gitlab.io/tags.html#evil-winrm) [powershell](https://0xdf.gitlab.io/tags.html#powershell) [docker](https://0xdf.gitlab.io/tags.html#docker) [firefox](https://0xdf.gitlab.io/tags.html#firefox) [procdump](https://0xdf.gitlab.io/tags.html#procdump) [out-minidump](https://0xdf.gitlab.io/tags.html#out-minidump) [mimikittenz](https://0xdf.gitlab.io/tags.html#mimikittenz) [credentials](https://0xdf.gitlab.io/tags.html#credentials) ![](https://0xdf.gitlab.io/img/heist-cover.png) 
    
    Heist brought new concepts I hadn’t seen on HTB before, yet keep to the easy difficulty. I’ll start by find a Cisco config on the website, which has some usernames and password hashes. After recovering the passwords, I’ll find that one works to get RPC access, which I’ll use to find more usernames. One of those usernames with one of the original passwords works to get a WinRM session on the Heist. From there, I’ll notice that Firefox is running, and dump the process memory to find the password for the original website, which is also the administrator password for the box.
    

*   Nov 26, 2019
    
    ### [LD_PRELOAD Rootkit on Chainsaw](https://0xdf.gitlab.io/2019/11/26/htb-chainsaw-rootkit.html)
    
    [Chainsaw](https://0xdf.gitlab.io/tags.html#chainsaw) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [rootkit](https://0xdf.gitlab.io/tags.html#rootkit) [ldpreload](https://0xdf.gitlab.io/tags.html#ldpreload) [ida](https://0xdf.gitlab.io/tags.html#ida) [nm](https://0xdf.gitlab.io/tags.html#nm) [strace](https://0xdf.gitlab.io/tags.html#strace) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) ![](https://0xdf.gitlab.io/img/chainsaw-rootkit-cover.) 
    
    There was something a bit weird going on with Chainsaw from HackTheBox. It turns out there’s a LD_PRELOAD rootkit running to hide the NodeJS processes that serve the smart contracts. Why? I have no idea. But since it’s a really neat concept, I wanted to pull it apart. Big thanks to jkr for helping me get started in this rabbit hole (the good kind), and to h0mbre for his recent blog post about these rootkits.
    

*   Nov 23, 2019
    
    ### [HTB: Chainsaw](https://0xdf.gitlab.io/2019/11/23/htb-chainsaw.html)
    
    [Chainsaw](https://0xdf.gitlab.io/tags.html#chainsaw) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ftp](https://0xdf.gitlab.io/tags.html#ftp) [solididy](https://0xdf.gitlab.io/tags.html#solididy) [python](https://0xdf.gitlab.io/tags.html#python) [web3](https://0xdf.gitlab.io/tags.html#web3) [remix](https://0xdf.gitlab.io/tags.html#remix) [command-injection](https://0xdf.gitlab.io/tags.html#command-injection) [injection](https://0xdf.gitlab.io/tags.html#injection) [ipfs](https://0xdf.gitlab.io/tags.html#ipfs) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [email](https://0xdf.gitlab.io/tags.html#email) [john](https://0xdf.gitlab.io/tags.html#john) [path-hijack](https://0xdf.gitlab.io/tags.html#path-hijack) [suid](https://0xdf.gitlab.io/tags.html#suid) [bmap](https://0xdf.gitlab.io/tags.html#bmap) [df](https://0xdf.gitlab.io/tags.html#df) [debugfs](https://0xdf.gitlab.io/tags.html#debugfs) [ida](https://0xdf.gitlab.io/tags.html#ida) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [pyinstaller](https://0xdf.gitlab.io/tags.html#pyinstaller) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) ![](https://0xdf.gitlab.io/img/chainsaw-cover.png) 
    
    Chainsaw was centered around blockchain and smart contracts, with a bit of InterPlanetary File System thrown in. I’ll get the details of a Solididy smart contract over an open FTP server, and find command injection in it to get a shell. I’ll find an SSH key for the bobby user in IPFS files. bobby has access to a SUID binary that I can interact with two ways to get a root shell. But even as root, the flag is hidden, so I’ll have to dig into the slack space around root.txt to find the flag. In Beyond root, I’ll look at the ChainsawClub binaries to see how they apply the same Web3 techniques I used to get into the box in the first place.
    

*   Nov 16, 2019
    
    ### [HTB: Networked](https://0xdf.gitlab.io/2019/11/16/htb-networked.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Networked](https://0xdf.gitlab.io/tags.html#networked) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [apache](https://0xdf.gitlab.io/tags.html#apache) [dirsearch](https://0xdf.gitlab.io/tags.html#dirsearch) [php](https://0xdf.gitlab.io/tags.html#php) [upload](https://0xdf.gitlab.io/tags.html#upload) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [filter](https://0xdf.gitlab.io/tags.html#filter) [command-injection](https://0xdf.gitlab.io/tags.html#command-injection) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [ifcfg](https://0xdf.gitlab.io/tags.html#ifcfg) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/networked-cover.png) 
    
    Networked involved abusing an Apache misconfiguration that allowed me to upload an image containing a webshell with a double extension. With that, I got a shell as www-data, and then did two privescs. The first abused command injection into a script that was running to clean up the uploads directory. Then I used access to an ifcfg script to get command execution as root. In Beyond Root, I’ll look a bit more at that Apache configuration.
    

*   Nov 9, 2019
    
    ### [HTB: Jarvis](https://0xdf.gitlab.io/2019/11/09/htb-jarvis.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Jarvis](https://0xdf.gitlab.io/tags.html#jarvis) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [waf](https://0xdf.gitlab.io/tags.html#waf) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [injection](https://0xdf.gitlab.io/tags.html#injection) [sqlmap](https://0xdf.gitlab.io/tags.html#sqlmap) [phpmyadmin](https://0xdf.gitlab.io/tags.html#phpmyadmin) [cve-2018-12613](https://0xdf.gitlab.io/tags.html#cve-2018-12613) [python](https://0xdf.gitlab.io/tags.html#python) [systemctl](https://0xdf.gitlab.io/tags.html#systemctl) [service](https://0xdf.gitlab.io/tags.html#service) [gtfobins](https://0xdf.gitlab.io/tags.html#gtfobins) [command-injection](https://0xdf.gitlab.io/tags.html#command-injection) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/jarvis-cover.png) 
    
    Jarvis provide three steps that were all relatively basic. First, there’s an SQL injection with a WAF that breaks `sqlmap`, at least in it’s default configuration. Then there’s a command injection into a Python script. And finally there’s creating a malicious service. In Beyond root, I’ll look at the WAF and the cleanup script.
    

*   Nov 2, 2019
    
    ### [HTB: Haystack](https://0xdf.gitlab.io/2019/11/02/htb-haystack.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Haystack](https://0xdf.gitlab.io/tags.html#haystack) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [steganography](https://0xdf.gitlab.io/tags.html#steganography) [elasticsearch](https://0xdf.gitlab.io/tags.html#elasticsearch) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [kibana](https://0xdf.gitlab.io/tags.html#kibana) [cve-2018-17246](https://0xdf.gitlab.io/tags.html#cve-2018-17246) [javascript](https://0xdf.gitlab.io/tags.html#javascript) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [logstash](https://0xdf.gitlab.io/tags.html#logstash) [herokuapp](https://0xdf.gitlab.io/tags.html#herokuapp) ![](https://0xdf.gitlab.io/img/haystack-cover.png) 
    
    Haystack wasn’t a realistic pentesting box, but it did provide insight into tools that are common on the blue side of things with Elastic Stack. I’ll find a hint in an image on a webpage, an use that to find credentials in an elastic search instance. Those creds allow SSH access to Haystack, and access to a local Kibana instance. I’ll use a CVE against Kibana to get execution as kibana. From there, I have access to the LogStash config, which is misconfigured to allow a execution via a properly configured log as root.
    

*   Oct 26, 2019
    
    ### [HTB: Safe](https://0xdf.gitlab.io/2019/10/26/htb-safe.html)
    
    [Safe](https://0xdf.gitlab.io/tags.html#safe) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [rop](https://0xdf.gitlab.io/tags.html#rop) [pwntools](https://0xdf.gitlab.io/tags.html#pwntools) [bof](https://0xdf.gitlab.io/tags.html#bof) [python](https://0xdf.gitlab.io/tags.html#python) [exploit](https://0xdf.gitlab.io/tags.html#exploit) [keepass](https://0xdf.gitlab.io/tags.html#keepass) [kpcli](https://0xdf.gitlab.io/tags.html#kpcli) [john](https://0xdf.gitlab.io/tags.html#john) ![](https://0xdf.gitlab.io/img/safe-cover.png) 
    
    Safe was two steps - a relatively simple ROP, followed by cracking a Keepass password database. Personally I don’t believe binary exploitation belongs in a 20-point box, but it is what it is. I’ll show three different ROP strategies to get a shell.
    

*   Oct 19, 2019
    
    ### [HTB: Ellingson](https://0xdf.gitlab.io/2019/10/19/htb-ellingson.html)
    
    [Ellingson](https://0xdf.gitlab.io/tags.html#ellingson) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [werkzeug](https://0xdf.gitlab.io/tags.html#werkzeug) [python](https://0xdf.gitlab.io/tags.html#python) [flask](https://0xdf.gitlab.io/tags.html#flask) [debugger](https://0xdf.gitlab.io/tags.html#debugger) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [bash](https://0xdf.gitlab.io/tags.html#bash) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [bof](https://0xdf.gitlab.io/tags.html#bof) [rop](https://0xdf.gitlab.io/tags.html#rop) [pwntools](https://0xdf.gitlab.io/tags.html#pwntools) [aslr](https://0xdf.gitlab.io/tags.html#aslr) [gdb](https://0xdf.gitlab.io/tags.html#gdb) [peda](https://0xdf.gitlab.io/tags.html#peda) [ret2libc](https://0xdf.gitlab.io/tags.html#ret2libc) [checksec](https://0xdf.gitlab.io/tags.html#checksec) [pattern-create](https://0xdf.gitlab.io/tags.html#pattern-create) [onegadget](https://0xdf.gitlab.io/tags.html#onegadget) [cron](https://0xdf.gitlab.io/tags.html#cron) ![](https://0xdf.gitlab.io/img/ellingson-cover.png) 
    
    Ellingson was a really solid hard box. I’ll start with ssh and http open, and find that they’ve left the Python debugger running on the webpage, giving me the opporutunity to execute commands. I’ll use that access to write my ssh key to the authorized_keys file, and get a shell as hal. I’ll find that hal has access to the shadow.bak file, and from there, I can break margo’s password. Once sshed in as margo, I will find a suid binary that I can overflow to get a root shell. In Beyond Root, I’ll explore two cronjobs. The first breaks the privesc from hal to margo, resetting the permissions on the shadow.bak file to a safe configuration. The second looks like a hint that was disabled, or maybe forgotten.
    

*   Oct 12, 2019
    
    ### [HTB: Writeup](https://0xdf.gitlab.io/2019/10/12/htb-writeup.html)
    
    [Writeup](https://0xdf.gitlab.io/tags.html#writeup) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [cmsms](https://0xdf.gitlab.io/tags.html#cmsms) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [injection](https://0xdf.gitlab.io/tags.html#injection) ![](https://0xdf.gitlab.io/img/writeup-cover.png) 
    
    Writeup was a great easy box. Neither of the steps were hard, but both were interesting. To get an initial shell, I’ll exploit a blind SQLI vulnerability in CMS Made Simple to get credentials, which I can use to log in with SSH. From there, I’ll abuse access to the staff group to write code to a path that’s running when someone SSHes into the box, and SSH in to trigger it. In Beyond Root, I’ll look at other ways to try to hijack the root process.
    

*   Oct 10, 2019
    
    ### [Flare-On 2019: wopr](https://0xdf.gitlab.io/flare-on-2019/wopr.html)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [wopr](https://0xdf.gitlab.io/tags.html#wopr) [python](https://0xdf.gitlab.io/tags.html#python) [pyinstaller](https://0xdf.gitlab.io/tags.html#pyinstaller) [python-exe-unpacker](https://0xdf.gitlab.io/tags.html#python-exe-unpacker) [uncompyle](https://0xdf.gitlab.io/tags.html#uncompyle) [pdb](https://0xdf.gitlab.io/tags.html#pdb) [exe](https://0xdf.gitlab.io/tags.html#exe) [z3](https://0xdf.gitlab.io/tags.html#z3) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) ![](https://0xdf.gitlab.io/img/flare2019-7-cover.) 
    
    wopr was like an onion - the layers kept peeling back revealing more layers. I’m given an exe which was created by PyInstaller, which I’ll unpack to get to the Python code. That code has a layer of unpacking based on a binary implementation of tabs and spaces in the doc strings. Once I get to the next layer, I need to calculate the hash of the text segment for the currently running binary, and use that as a key to some equations. Using a solver to solve the system, I can find the input necessary to return the flag.
    

*   Oct 9, 2019
    
    ### [Flare-On 2019: bmphide](https://0xdf.gitlab.io/flare-on-2019/bmphide.html)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [bmphide](https://0xdf.gitlab.io/tags.html#bmphide) [dnspy](https://0xdf.gitlab.io/tags.html#dnspy) [.NET](https://0xdf.gitlab.io/tags.html#net) [anti-debug](https://0xdf.gitlab.io/tags.html#anti-debug) [steganography](https://0xdf.gitlab.io/tags.html#steganography) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) ![](https://0xdf.gitlab.io/img/flare2019-6-cover.) 
    
    bmphide was my favorite challenge this year (that I got to). It was challenging, yet doable and interesting. I’m given a bitmap image and a Windows .NET executable. That executable is used to hide information in the low bits of the image. I’ll have to reverse the exe to understand how to extract the data. I’ll also have to work around some anti-debug.
    

*   Oct 6, 2019
    
    ### [Flare-On 2019: demo](https://0xdf.gitlab.io/flare-on-2019/demo.html)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [demo](https://0xdf.gitlab.io/tags.html#demo) [x64dbg](https://0xdf.gitlab.io/tags.html#x64dbg) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) ![](https://0xdf.gitlab.io/img/flare2019-5-cover.) 
    
    demo really threw me, to the point that I almost skipped writing it up. The file given is a demoscene, which is a kind of competition to get the best visual performce out of an executable limited in size. To achieve this, packers are used to compress the binary. In the exe for this challenge, a 3D Flare logo comes up and spins, but the flag is missing. I’ll have to unpack the binary and start messing with random DirectX functions until I find two ways to make the flag show up.
    

*   Oct 5, 2019
    
    ### [HTB: Ghoul](https://0xdf.gitlab.io/2019/10/05/htb-ghoul.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Ghoul](https://0xdf.gitlab.io/tags.html#ghoul) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [hydra](https://0xdf.gitlab.io/tags.html#hydra) [zipslip](https://0xdf.gitlab.io/tags.html#zipslip) [tomcat](https://0xdf.gitlab.io/tags.html#tomcat) [docker](https://0xdf.gitlab.io/tags.html#docker) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [pivot](https://0xdf.gitlab.io/tags.html#pivot) [cewl](https://0xdf.gitlab.io/tags.html#cewl) [john](https://0xdf.gitlab.io/tags.html#john) [gogs](https://0xdf.gitlab.io/tags.html#gogs) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [gogsownz](https://0xdf.gitlab.io/tags.html#gogsownz) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [suid](https://0xdf.gitlab.io/tags.html#suid) [git](https://0xdf.gitlab.io/tags.html#git) [ssh-agent-hijack](https://0xdf.gitlab.io/tags.html#ssh-agent-hijack) [cron](https://0xdf.gitlab.io/tags.html#cron) ![](https://0xdf.gitlab.io/img/ghoul-cover.png) 
    
    Ghoul was a long box, that involved pioviting between multiple docker containers exploiting things and collecting information to move to the next step. With a level of pivoting not seen in HackTheBox since [Reddish](https://0xdf.gitlab.io/2019/01/26/htb-reddish.html), I’ll need to pay careful attention to various passwords and other bits of information as I move through the containers. I’ll exploit a webapp using the ZipSlip vulnerability to get a webshell up and get a shell as www-data, only to find that the exploited webserver is running as root, and with another ZipSlip, I can escalte to root. Still with no flags, I’ll crack an ssh key and pivot to the second container. From there, I can access a third container hosting the self hosted git solution, gogs. With some password reuse and the gogsownz exploit, I’ll get a shell on that container, and use a suid binary to get root. That provides access to a git repo that has a password I can use for root on the second container. As root, I can see ssh sessions connecting through this container and to the main host using ssh agent forwarding, and I’ll hijack that to get root on the final host. In beyond root, I’ll explore the ssh situation on the final host and get myself persistence, look at the crons running to simulate the user using ssh agent forwarding, and show a network map of the entire system.
    

*   Oct 4, 2019
    
    ### [Flare-On 2019: DNS Chess](https://0xdf.gitlab.io/flare-on-2019/dnschess.html)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [dnschess](https://0xdf.gitlab.io/tags.html#dnschess) [peda](https://0xdf.gitlab.io/tags.html#peda) [gdb](https://0xdf.gitlab.io/tags.html#gdb) [wireshark](https://0xdf.gitlab.io/tags.html#wireshark) [python](https://0xdf.gitlab.io/tags.html#python) [dns](https://0xdf.gitlab.io/tags.html#dns) [ida](https://0xdf.gitlab.io/tags.html#ida) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) ![](https://0xdf.gitlab.io/img/flare2019-4-cover.) 
    
    DNS Chess was really fun. I’m given a pcap, and elf executable, and an elf shared library. The two binaries form a game of chess, where commands are sent to an AI over DNS. I’ll need to figure out how to spoof valid moves by reversing the binary, and then use valid moves to win the game.
    

*   Oct 2, 2019
    
    ### [Flare-On 2019: Flarebear](https://0xdf.gitlab.io/flare-on-2019/flarebear.html)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [flarebear](https://0xdf.gitlab.io/tags.html#flarebear) [apk](https://0xdf.gitlab.io/tags.html#apk) [genymotion](https://0xdf.gitlab.io/tags.html#genymotion) [android](https://0xdf.gitlab.io/tags.html#android) [jadx](https://0xdf.gitlab.io/tags.html#jadx) [algebra](https://0xdf.gitlab.io/tags.html#algebra) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) ![](https://0xdf.gitlab.io/img/flare2019-3-cover.) 
    
    Flarebear wsa the first Android challenge, and I’m glad to see it at the beginning while it’s still not too hard. I’ll use GenyMotion cloud to emunlate the application, and then jadx to decompile it and see what the win condition is. Once I find that, I can get the flag.
    

*   Sep 30, 2019
    
    ### [Flare-On 2019: Overlong](https://0xdf.gitlab.io/flare-on-2019/overlong.html)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [overlong](https://0xdf.gitlab.io/tags.html#overlong) [x64dbg](https://0xdf.gitlab.io/tags.html#x64dbg) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) ![](https://0xdf.gitlab.io/img/flare2019-2-cover.) 
    
    Overlong was a challenge that could lead to complex rabbit holes, or, with some intelligent guess work, be solved quite quickly. From the start, with the title and the way that the word _overlong_ was bolded in the prompt, I was looking for an integer to overflow or change in some way. That, plus additional clues, made this one pretty quick work.
    

*   Sep 28, 2019
    
    ### [HTB: SwagShop](https://0xdf.gitlab.io/2019/09/28/htb-swagshop.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [SwagShop](https://0xdf.gitlab.io/tags.html#swagshop) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [magento](https://0xdf.gitlab.io/tags.html#magento) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [deserialization](https://0xdf.gitlab.io/tags.html#deserialization) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/swagshop-cover.png) 
    
    SwagShop was a nice beginner / easy box centered around a Magento online store interface. I’ll use two exploits to get a shell. The first is an authentication bypass that allows me to add an admin user to the CMS. Then I can use an authenticated PHP Object Injection to get RCE. I’ll also show how got RCE with a malicious Magento package. RCE leads to shell and user. To privesc to root, it’s a simple exploit of `sudo vi`.
    

*   Sep 28, 2019
    
    ### [Flare-On 2019: Memecat Battlestation [Shareware Demo Edition]](https://0xdf.gitlab.io/flare-on-2019/memecat-battlestation.html)
    
    [flare-on](https://0xdf.gitlab.io/tags.html#flare-on) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [memecat-battlestation](https://0xdf.gitlab.io/tags.html#memecat-battlestation) [dnspy](https://0xdf.gitlab.io/tags.html#dnspy) [dotnet](https://0xdf.gitlab.io/tags.html#dotnet) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) ![](https://0xdf.gitlab.io/img/flare2019-1-cover.) 
    
    Memecat Battlestation [Shareware Demo Edition] was a really simple challenge that really involed opening a .NET executable in a debugger and reading the correct phrases from the code. It was a good beginner challenge.
    

*   Sep 21, 2019
    
    ### [HTB: Kryptos](https://0xdf.gitlab.io/2019/09/21/htb-kryptos.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Kryptos](https://0xdf.gitlab.io/tags.html#kryptos) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [php](https://0xdf.gitlab.io/tags.html#php) [burp](https://0xdf.gitlab.io/tags.html#burp) [mysql](https://0xdf.gitlab.io/tags.html#mysql) [wireshark](https://0xdf.gitlab.io/tags.html#wireshark) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [rc4](https://0xdf.gitlab.io/tags.html#rc4) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [python](https://0xdf.gitlab.io/tags.html#python) [python-cmd](https://0xdf.gitlab.io/tags.html#python-cmd) [disable-functions](https://0xdf.gitlab.io/tags.html#disable-functions) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [sqlite](https://0xdf.gitlab.io/tags.html#sqlite) [vimcrypt](https://0xdf.gitlab.io/tags.html#vimcrypt) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [python-eval](https://0xdf.gitlab.io/tags.html#python-eval) [filter](https://0xdf.gitlab.io/tags.html#filter) ![](https://0xdf.gitlab.io/img/kryptos-cover.png) 
    
    Kryptos feels different from most insane boxes. It brought an element of math / crypt into most of the challenges in a way that I really enjoyed. But it still layered challenges so that each step involved multiple exploits / bypasses, like all good insane boxes do. I’ll start by getting access to a web page by telling the page to validate logins against a database on my box. The website gives me that ability to return encrypted webpage content that Kryptos can retrieve. I’ll break the encryption to access pages I’m not able to access on my own, finding a sqlite test page that I can inject into to write a webshell that can access the file system. With file system access, I’ll retrieve a Vim-crypted password backup, and crack that to get ssh access to the system. On the system, I’ll access an API available only on localhost and take advantage of a weak random number generator to sign my own commands, bypassing python protections to get code execution as root.
    

*   Sep 14, 2019
    
    ### [HTB: Luke](https://0xdf.gitlab.io/2019/09/14/htb-luke.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Luke](https://0xdf.gitlab.io/tags.html#luke) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [api](https://0xdf.gitlab.io/tags.html#api) [nodejs](https://0xdf.gitlab.io/tags.html#nodejs) [jwt](https://0xdf.gitlab.io/tags.html#jwt) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [ajenti](https://0xdf.gitlab.io/tags.html#ajenti) [hydra](https://0xdf.gitlab.io/tags.html#hydra) ![](https://0xdf.gitlab.io/img/luke-cover.png) 
    
    Luke was a recon heavy box. In fact, the entire writeup for Luke could reasonably go into the Recon section. I’m presented with three different web interfaces, which I enumerate and bounce between to eventually get credentials for an Ajenti administrator login. Once I’m in Ajenti, I have access to a root shell, and both flags.
    

*   Sep 11, 2019
    
    ### [HTB: Holiday](https://0xdf.gitlab.io/2019/09/11/htb-holiday.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Holiday](https://0xdf.gitlab.io/tags.html#holiday) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [nodejs](https://0xdf.gitlab.io/tags.html#nodejs) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [dirsearch](https://0xdf.gitlab.io/tags.html#dirsearch) [burp](https://0xdf.gitlab.io/tags.html#burp) [xss](https://0xdf.gitlab.io/tags.html#xss) [filter](https://0xdf.gitlab.io/tags.html#filter) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [command-injection](https://0xdf.gitlab.io/tags.html#command-injection) [npm](https://0xdf.gitlab.io/tags.html#npm) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [oswe-plus](https://0xdf.gitlab.io/tags.html#oswe-plus) ![](https://0xdf.gitlab.io/img/holiday-cover.png) 
    
    Holiday was a fun, hard, old box. The path to getting a shell involved SQL injection, cross site scripting, and command injection. The root was a bit simpler, taking advantage of a sudo on node package manager install to install a malicious node package.
    

*   Sep 7, 2019
    
    ### [HTB: Bastion](https://0xdf.gitlab.io/2019/09/07/htb-bastion.html)
    
    [Bastion](https://0xdf.gitlab.io/tags.html#bastion) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [smb](https://0xdf.gitlab.io/tags.html#smb) [vhd](https://0xdf.gitlab.io/tags.html#vhd) [mount](https://0xdf.gitlab.io/tags.html#mount) [guestmount](https://0xdf.gitlab.io/tags.html#guestmount) [secretsdump](https://0xdf.gitlab.io/tags.html#secretsdump) [crackstation](https://0xdf.gitlab.io/tags.html#crackstation) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [windows](https://0xdf.gitlab.io/tags.html#windows) [mremoteng](https://0xdf.gitlab.io/tags.html#mremoteng) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like) ![](https://0xdf.gitlab.io/img/bastion-cover.png) 
    
    Bastion was a solid easy box with some simple challenges like mounting a VHD from a file share, and recovering passwords from a password vault program. It starts, somewhat unusually, without a website, but rather with vhd images on an SMB share, that, once mounted, provide access to the registry hive necessary to pull out credentials. These creds provide the ability to ssh into the host as the user. To get administrator access, I’ll exploit the mRemoteNG installation, pulling the profile data and encrypted data, and show several ways to decrypt those. Once I break out the administrator password, I can ssh in as administrator.
    

*   Aug 31, 2019
    
    ### [HTB: OneTwoSeven](https://0xdf.gitlab.io/2019/08/31/htb-onetwoseven.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [OneTwoSeven](https://0xdf.gitlab.io/tags.html#onetwoseven) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [sftp](https://0xdf.gitlab.io/tags.html#sftp) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [chroot](https://0xdf.gitlab.io/tags.html#chroot) [vim](https://0xdf.gitlab.io/tags.html#vim) [crackstation](https://0xdf.gitlab.io/tags.html#crackstation) [php](https://0xdf.gitlab.io/tags.html#php) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [apt](https://0xdf.gitlab.io/tags.html#apt) [mitm](https://0xdf.gitlab.io/tags.html#mitm)
    
    ![](https://0xdf.gitlab.io/img/onetwoseven-cover.png) OneTwoSeven was a very cleverly designed box. There were lots of steps, some enumeration, all of which was do-able and fun. I’ll start by finding a hosting provider that gives me SFTP access to their system. I’ll use that to tunnel into the box, and gain access to the admin panel. I’ll find creds for that using symlinks over SFTP. From there, I’ll exploit a logic error in the plugin upload to install a webshell. To get root, I’ll take advantage of my user’s ability to run apt update and apt upgrade as root, and man-in-the-middle the connection to install a backdoored package.
    

*   Aug 24, 2019
    
    ### [HTB: Unattended](https://0xdf.gitlab.io/2019/08/24/htb-unattended.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Unattended](https://0xdf.gitlab.io/tags.html#unattended) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [sqlmap](https://0xdf.gitlab.io/tags.html#sqlmap) [nginx](https://0xdf.gitlab.io/tags.html#nginx) [nginx-aliases](https://0xdf.gitlab.io/tags.html#nginx-aliases) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [session-poisoning](https://0xdf.gitlab.io/tags.html#session-poisoning) [socat](https://0xdf.gitlab.io/tags.html#socat) [hidepid](https://0xdf.gitlab.io/tags.html#hidepid) [noexec](https://0xdf.gitlab.io/tags.html#noexec) [mysql](https://0xdf.gitlab.io/tags.html#mysql) [initrd](https://0xdf.gitlab.io/tags.html#initrd) [cpio](https://0xdf.gitlab.io/tags.html#cpio) [ida](https://0xdf.gitlab.io/tags.html#ida) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [oswe-like](https://0xdf.gitlab.io/tags.html#oswe-like)
    
    ![](https://0xdf.gitlab.io/img/unattended-cover.jpg)Users rated Unattended much harder than the Medium rating it was released under. I think that’s because the SQLI vulnerability was easy to find, but dumping the database would take forever. So the trick was knowing when to continue looking and identify the NGINX vulnerability to leak the source code. At that point, the SQLI was much more manageable, providing LFI which I used with PHP session variables to get RCE and a shell. From there, it was injecting into some commands being taken from the database to move to the next user. And in the final step, examining an initrd file to get the root password. In Beyond Root, I’ll reverse the binary that generates the password, and give some references for initrd backdoors.
    

*   Aug 17, 2019
    
    ### [HTB: Helpline](https://0xdf.gitlab.io/2019/08/17/htb-helpline.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Helpline](https://0xdf.gitlab.io/tags.html#helpline) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [manageengine](https://0xdf.gitlab.io/tags.html#manageengine) [servicedesk](https://0xdf.gitlab.io/tags.html#servicedesk) [default-creds](https://0xdf.gitlab.io/tags.html#default-creds) [password](https://0xdf.gitlab.io/tags.html#password) [excel](https://0xdf.gitlab.io/tags.html#excel) [cve-2017-9362](https://0xdf.gitlab.io/tags.html#cve-2017-9362) [xxe](https://0xdf.gitlab.io/tags.html#xxe) [responder](https://0xdf.gitlab.io/tags.html#responder) [cve-2017-11511](https://0xdf.gitlab.io/tags.html#cve-2017-11511) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat)
    
    ![](https://0xdf.gitlab.io/img/helpline-cover.png) Helpline was a really difficult box, and it was an even more difficult writeup. It has _so_ many paths, and yet all were difficult in some way. It was also one that really required Windows as an attack platform to do the intended way. I got lucky in that this was the box I had chosen to try out [Commando VM](https://0xdf.gitlab.io/2019/04/15/commando-vm-lessons.html). Give the two completely different attack paths on Windows and Kali, I’ll break this into three posts. In the first post, I’ll do enumeration up to an initial shell. Then in one post I’ll show how I solved it from Commando (Windows) using the intended paths. In the other post, I’ll show how to go right to a shell as SYSTEM, and work backwards to get the root flag and eventually the user flag.
    

*   Aug 10, 2019
    
    ### [HTB: Arkham](https://0xdf.gitlab.io/2019/08/10/htb-arkham.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Arkham](https://0xdf.gitlab.io/tags.html#arkham) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [faces](https://0xdf.gitlab.io/tags.html#faces) [jsf](https://0xdf.gitlab.io/tags.html#jsf) [deserialization](https://0xdf.gitlab.io/tags.html#deserialization) [smb](https://0xdf.gitlab.io/tags.html#smb) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap) [luks](https://0xdf.gitlab.io/tags.html#luks) [bruteforce-luks](https://0xdf.gitlab.io/tags.html#bruteforce-luks) [cryptsetup](https://0xdf.gitlab.io/tags.html#cryptsetup) [hmac](https://0xdf.gitlab.io/tags.html#hmac) [Canape](https://0xdf.gitlab.io/tags.html#canape) [ysoserial](https://0xdf.gitlab.io/tags.html#ysoserial) [python](https://0xdf.gitlab.io/tags.html#python) [burp](https://0xdf.gitlab.io/tags.html#burp) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [nc](https://0xdf.gitlab.io/tags.html#nc) [http.server](https://0xdf.gitlab.io/tags.html#http-server) [password](https://0xdf.gitlab.io/tags.html#password) [smbserver](https://0xdf.gitlab.io/tags.html#smbserver) [ost](https://0xdf.gitlab.io/tags.html#ost) [readpst](https://0xdf.gitlab.io/tags.html#readpst) [mbox](https://0xdf.gitlab.io/tags.html#mbox) [mutt](https://0xdf.gitlab.io/tags.html#mutt) [pssession](https://0xdf.gitlab.io/tags.html#pssession) [rlwrap](https://0xdf.gitlab.io/tags.html#rlwrap) [winrm](https://0xdf.gitlab.io/tags.html#winrm) [chisel](https://0xdf.gitlab.io/tags.html#chisel) [evil-winrm](https://0xdf.gitlab.io/tags.html#evil-winrm) [uac](https://0xdf.gitlab.io/tags.html#uac) [meterpreter](https://0xdf.gitlab.io/tags.html#meterpreter) [greatsct](https://0xdf.gitlab.io/tags.html#greatsct) [msbuild](https://0xdf.gitlab.io/tags.html#msbuild) [msfconsole](https://0xdf.gitlab.io/tags.html#msfconsole) [cmstp](https://0xdf.gitlab.io/tags.html#cmstp) [systempropretiesadvanced](https://0xdf.gitlab.io/tags.html#systempropretiesadvanced) [dll](https://0xdf.gitlab.io/tags.html#dll) [mingw32](https://0xdf.gitlab.io/tags.html#mingw32) [oswe-plus](https://0xdf.gitlab.io/tags.html#oswe-plus)
    
    ![](https://0xdf.gitlab.io/img/arkham-cover.png)In my opinion, Arkham was the most difficult Medium level box on HTB, as it could have easily been Hard and wouldn’t have been out of place at Insane. But it is still a great box. I’ll start with an encrypted LUKZ disk image, which I have to crack. On it I’ll find the config for a Java Server Faces (JSF) site, which provides the keys that allow me to perform a deserialization attack on the ViewState, providing an initial shell. I’ll find an email file with the password for a user in the administrators group. Once I have that shell, I’ll have to bypass UAC to grab root.txt.
    

*   Aug 3, 2019
    
    ### [HTB: Fortune](https://0xdf.gitlab.io/2019/08/03/htb-fortune.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Fortune](https://0xdf.gitlab.io/tags.html#fortune) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [certificate](https://0xdf.gitlab.io/tags.html#certificate) [certificate-authority](https://0xdf.gitlab.io/tags.html#certificate-authority) [sslyze](https://0xdf.gitlab.io/tags.html#sslyze) [command-injection](https://0xdf.gitlab.io/tags.html#command-injection) [repeater](https://0xdf.gitlab.io/tags.html#repeater) [firewall](https://0xdf.gitlab.io/tags.html#firewall) [python](https://0xdf.gitlab.io/tags.html#python) [python-cmd](https://0xdf.gitlab.io/tags.html#python-cmd) [authpf](https://0xdf.gitlab.io/tags.html#authpf) [openssl](https://0xdf.gitlab.io/tags.html#openssl) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [nfs](https://0xdf.gitlab.io/tags.html#nfs) [pgadmin](https://0xdf.gitlab.io/tags.html#pgadmin) [postgresql](https://0xdf.gitlab.io/tags.html#postgresql) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [sqlite](https://0xdf.gitlab.io/tags.html#sqlite) [pfctl](https://0xdf.gitlab.io/tags.html#pfctl) [tcpdump](https://0xdf.gitlab.io/tags.html#tcpdump)
    
    ![](https://0xdf.gitlab.io/img/fortune-cover.png)Fortune was a different kind of insane box, focused on taking advantage things like authpf and nfs. I’ll start off using command injection to find a key and certificate that allow access to an HTTPS site. On that site, I get instructions and an ssh key to connect via authpf, which doesn’t provide a shell, but opens up new ports in the firewall. From there I can find nfs access to `/home`, which I can use with uid spoofing to get ssh access. For privesc, I’ll find credentials in pgadmin’s database which I can use to get a root shell. In Beyond Root, I’ll look the firewall configuration and why I couldn’t turn command injection into a shell.
    

*   Aug 2, 2019
    
    ### [Bypassing PHP disable_functions with Chankro](https://0xdf.gitlab.io/2019/08/02/bypassing-php-disable_functions-with-chankro.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [LaCasaDePapel](https://0xdf.gitlab.io/tags.html#lacasadepapel) [chankro](https://0xdf.gitlab.io/tags.html#chankro) [php](https://0xdf.gitlab.io/tags.html#php) [disable-functions](https://0xdf.gitlab.io/tags.html#disable-functions) [Hackback](https://0xdf.gitlab.io/tags.html#hackback)
    
    ![](https://0xdf.gitlab.io/img/chankro-cover.png)I was reading [Alamot’s LaCasaDePapel writeup](https://alamot.github.io/lacasadepapel_writeup/#getting-dali-shell-by-escaping-php-restrictions), and they went a different way once they got the php shell. Instead of just using the php functions to find the certificate and key needed to read the private members https page, Alamot uses Chankro to bypass the disabled execution functions and run arbitrary code anyway. I had to try it.
    

*   Jul 27, 2019
    
    ### [HTB: LaCasaDePapel](https://0xdf.gitlab.io/2019/07/27/htb-lacasadepapel.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [LaCasaDePapel](https://0xdf.gitlab.io/tags.html#lacasadepapel) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [vsftpd](https://0xdf.gitlab.io/tags.html#vsftpd) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [python](https://0xdf.gitlab.io/tags.html#python) [psy](https://0xdf.gitlab.io/tags.html#psy) [php](https://0xdf.gitlab.io/tags.html#php) [disable-functions](https://0xdf.gitlab.io/tags.html#disable-functions) [certificate](https://0xdf.gitlab.io/tags.html#certificate) [client-certificate](https://0xdf.gitlab.io/tags.html#client-certificate) [openssl](https://0xdf.gitlab.io/tags.html#openssl) [path-traversal](https://0xdf.gitlab.io/tags.html#path-traversal) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [pspy](https://0xdf.gitlab.io/tags.html#pspy) [supervisord](https://0xdf.gitlab.io/tags.html#supervisord) [cron](https://0xdf.gitlab.io/tags.html#cron) [metasploit](https://0xdf.gitlab.io/tags.html#metasploit) [ida](https://0xdf.gitlab.io/tags.html#ida) [iptables](https://0xdf.gitlab.io/tags.html#iptables) [js](https://0xdf.gitlab.io/tags.html#js) [certificate-authority](https://0xdf.gitlab.io/tags.html#certificate-authority) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus)
    
    ![](https://0xdf.gitlab.io/img/lacasadepapel-cover.jpg)LaCasaDePapel was a fun easy box that required quite a few steps for a 20 point box, but none of which were too difficult. I’ll start off exploiting a classic backdoor bug in VSFTPd 2.3.4 which has been modified to return a shell in Psy, a php based debugging tool. From there, I can collect a key file which I’ll use to sign a client certificate, gaining access to the private website. I’ll exploit a path traversal bug in the site to get an ssh key for one of the users. To privesc, I’ll find a file that’s controlling how a cron is being run by root. The file is not writable and owned by root, but sits in a directory my current user owns, which allows me to delete the file and then create a new one. In Beyond Root, I’ll look at the modified VSFTPd server and show an alternative path that allows me to skip the certificate generation to get access to the private website.
    

*   Jul 20, 2019
    
    ### [HTB: CTF](https://0xdf.gitlab.io/2019/07/20/htb-ctf.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [CTF-htb](https://0xdf.gitlab.io/tags.html#ctf-htb) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ldap](https://0xdf.gitlab.io/tags.html#ldap) [ldap-injection](https://0xdf.gitlab.io/tags.html#ldap-injection) [second-order](https://0xdf.gitlab.io/tags.html#second-order) [second-order-ldap-injection](https://0xdf.gitlab.io/tags.html#second-order-ldap-injection) [python-cmd](https://0xdf.gitlab.io/tags.html#python-cmd) [python](https://0xdf.gitlab.io/tags.html#python) [otp](https://0xdf.gitlab.io/tags.html#otp) [stoken](https://0xdf.gitlab.io/tags.html#stoken) [7z](https://0xdf.gitlab.io/tags.html#7z) [listfile](https://0xdf.gitlab.io/tags.html#listfile)
    
    ![](https://0xdf.gitlab.io/img/ctf-cover.jpg) CTF was hard in a much more straight-forward way than some of the recent insane boxes. It had steps that were difficult to pull off, and not even that many. But it was still quite challenging. I’ll start using ldap injection to determine a username and a seed for a one time password token. Then I’ll use that to log in. On seeing a command page, I’ll need to go back and log-in again, this time with a username that allows me a second-order ldap injection to bypass the user check. Once I do, I can run commands, and find a user password in the php pages. With an SSH shell, I’ll find a backup script that uses Sevenzip in a way that I can hijack to read the root flag. In Beyond root, I’ll look at little bit at SELinux, build a small shell to make running commands over the webpage easier, and look at the actual ldap queries I injected into.
    

*   Jul 13, 2019
    
    ### [HTB: FriendZone](https://0xdf.gitlab.io/2019/07/13/htb-friendzone.html)
    
    [FriendZone](https://0xdf.gitlab.io/tags.html#friendzone) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [zone-transfer](https://0xdf.gitlab.io/tags.html#zone-transfer) [dns](https://0xdf.gitlab.io/tags.html#dns) [dig](https://0xdf.gitlab.io/tags.html#dig) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [php](https://0xdf.gitlab.io/tags.html#php) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [pspy](https://0xdf.gitlab.io/tags.html#pspy) [python-library-hijack](https://0xdf.gitlab.io/tags.html#python-library-hijack) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    ![](https://0xdf.gitlab.io/img/friendzone-cover.jpg)FriendZone was a relatively easy box, but as far as easy boxes go, it had a lot of enumeration and garbage trolls to sort through. In all the enumeration, I’ll find a php page with an LFI, and use SMB to read page source and upload a webshell. I’ll uprivesc to the next user with creds from a database conf file, and then to root using a writable python module to exploit a root cron job calling a python script.
    

*   Jul 6, 2019
    
    ### [HTB: Hackback](https://0xdf.gitlab.io/2019/07/06/htb-hackback.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Hackback](https://0xdf.gitlab.io/tags.html#hackback) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [jq](https://0xdf.gitlab.io/tags.html#jq) [gophish](https://0xdf.gitlab.io/tags.html#gophish) [php](https://0xdf.gitlab.io/tags.html#php) [disable-functions](https://0xdf.gitlab.io/tags.html#disable-functions) [aspx](https://0xdf.gitlab.io/tags.html#aspx) [rot13](https://0xdf.gitlab.io/tags.html#rot13) [javascript](https://0xdf.gitlab.io/tags.html#javascript) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [tio-run](https://0xdf.gitlab.io/tags.html#tio-run) [log-poisoning](https://0xdf.gitlab.io/tags.html#log-poisoning) [python](https://0xdf.gitlab.io/tags.html#python) [python-cmd](https://0xdf.gitlab.io/tags.html#python-cmd) [regeorge](https://0xdf.gitlab.io/tags.html#regeorge) [winrm](https://0xdf.gitlab.io/tags.html#winrm) [proxychains](https://0xdf.gitlab.io/tags.html#proxychains) [cron](https://0xdf.gitlab.io/tags.html#cron) [named-pipe](https://0xdf.gitlab.io/tags.html#named-pipe) [seimpresonate](https://0xdf.gitlab.io/tags.html#seimpresonate) [command-injection](https://0xdf.gitlab.io/tags.html#command-injection) [service](https://0xdf.gitlab.io/tags.html#service) [arbitrary-write](https://0xdf.gitlab.io/tags.html#arbitrary-write) [diaghub](https://0xdf.gitlab.io/tags.html#diaghub) [visual-studio](https://0xdf.gitlab.io/tags.html#visual-studio) [dll](https://0xdf.gitlab.io/tags.html#dll) [ads](https://0xdf.gitlab.io/tags.html#ads) [alternative-data-streams](https://0xdf.gitlab.io/tags.html#alternative-data-streams) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [rdesktop](https://0xdf.gitlab.io/tags.html#rdesktop) [rdp](https://0xdf.gitlab.io/tags.html#rdp) [oswe-plus](https://0xdf.gitlab.io/tags.html#oswe-plus)
    
    ![](https://0xdf.gitlab.io/img/hackback-cover.png)Hackback is the hardest box that I’ve done on HTB. By far. Without question. If you’d like data to back that up, the first blood times of over 1.5 and 2.5 days! I remember vividly working on this box with all my free time, and being the 5th to root it (7th root counting the two box authors) in the 6th day. I’ll start by finding a hosts whose main attack point is a GoPhish interface. This interface gives up some domain names for fake phishing sites on the same host, which I can use to find an admin interface which I can abuse to get file system access via log poisoning. Unfortunately, all the functions I need to get RCE via PHP or ASPX are disabled. I can however upload reGeorge and use it to tunnel a connection to WinRM, where I can use some creds I find in a config file. I’ll then use a named pipe to execute nc as the next user. From there I can abuse a faulty service that allows me to write as SYSTEM wherever I want to overwrite a file in SYSTEM32, and then use DiagHub to get a SYSTEM shell. In Beyond Root, I’ll look at an unintended way to get root.txt as hacker, explore why an aspx webshell fails and find a work around to get it working, check out the PowerShell source for the web server listening on 6666, and look into an RDP connection.
    

*   Jul 1, 2019
    
    ### [Darling: Running MacOS Binaries on Linux](https://0xdf.gitlab.io/2019/07/01/darling-running-macos-binaries-on-linux.html)
    
    [tools](https://0xdf.gitlab.io/tags.html#tools) [bsides-london](https://0xdf.gitlab.io/tags.html#bsides-london) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [darling](https://0xdf.gitlab.io/tags.html#darling) [python](https://0xdf.gitlab.io/tags.html#python) [mach-o](https://0xdf.gitlab.io/tags.html#mach-o) [macos](https://0xdf.gitlab.io/tags.html#macos)
    
    `![](https://0xdf.gitlab.io/img/darling-cover.png)I attended BSides London almost a month ago now, and of course took a look at the CTF. There were a handful of reversing challenges, but multiple of them were MacOS (Mach-O) binaries. As I looked down at my Windows laptop and my Kali VM, I felt at a bit of a disadvantage. While I was able to solve one of the challenges just with IDA, I went looking for a way to run Mac binaries on a Linux OS. And I found Darwin. It took basically the rest of the day to install, so I didn’t get to any of the additional challenges, but I am happy to be semi-equiped the next time the need comes up.
    

*   Jun 29, 2019
    
    ### [HTB: Netmon](https://0xdf.gitlab.io/2019/06/29/htb-netmon.html)
    
    [Netmon](https://0xdf.gitlab.io/tags.html#netmon) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [ftp](https://0xdf.gitlab.io/tags.html#ftp) [shared-password](https://0xdf.gitlab.io/tags.html#shared-password) [prtg](https://0xdf.gitlab.io/tags.html#prtg) [command-injection](https://0xdf.gitlab.io/tags.html#command-injection) [psexec.py](https://0xdf.gitlab.io/tags.html#psexec-py) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus)
    
    ![](https://0xdf.gitlab.io/img/netmon-cover.png)Netmon rivals [Jerry](https://0xdf.gitlab.io/2018/11/17/htb-jerry.html) and Blue for the shortest box I’ve done. The user first blood went in less than 2 minutes, and that’s probably longer than it should have been as the hackthebox page crashed right at open with so many people trying to submit flags. The host presents the full file system over anonymous FTP, which is enough to grab the user flag. It also hosts an instance of PRTG Network Monitor on port 80. I’ll use the FTP access to find old creds in a backup configuration file, and use those to guess the current creds. From there, I can use a command injection vulnerability in PRTG to get a shell as SYSTEM, and the root flag.
    

*   Jun 22, 2019
    
    ### [HTB: Querier](https://0xdf.gitlab.io/2019/06/22/htb-querier.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Querier](https://0xdf.gitlab.io/tags.html#querier) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [windows](https://0xdf.gitlab.io/tags.html#windows) [smb](https://0xdf.gitlab.io/tags.html#smb) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [olevba](https://0xdf.gitlab.io/tags.html#olevba) [macros](https://0xdf.gitlab.io/tags.html#macros) [vba](https://0xdf.gitlab.io/tags.html#vba) [mssql](https://0xdf.gitlab.io/tags.html#mssql) [mssqlclient](https://0xdf.gitlab.io/tags.html#mssqlclient) [xp_dirtree](https://0xdf.gitlab.io/tags.html#xp-dirtree) [net-ntlmv2](https://0xdf.gitlab.io/tags.html#net-ntlmv2) [responder](https://0xdf.gitlab.io/tags.html#responder) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [xpcmdshell](https://0xdf.gitlab.io/tags.html#xpcmdshell) [powerup](https://0xdf.gitlab.io/tags.html#powerup) [gpp](https://0xdf.gitlab.io/tags.html#gpp) [smbserver](https://0xdf.gitlab.io/tags.html#smbserver) [nc](https://0xdf.gitlab.io/tags.html#nc) [wmiexec](https://0xdf.gitlab.io/tags.html#wmiexec) [service](https://0xdf.gitlab.io/tags.html#service) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus)
    
    ![](https://0xdf.gitlab.io/img/querier-cover.png) Querier was a fun medium box that involved some simple document forensices, mssql access, responder, and some very basic Windows Privesc steps. I’ll show how to grab the Excel macro-enabled workbook from an open SMB share, and find database credentials in the macros. I’ll use those credentials to connect to the host’s MSSQL as a limited user. I can use that limited access to get a Net-NTLMv2 hash with responder, which provides enough database access to run commands. That’s enough to provide a shell. For privesc, running PowerUp.ps1 provides administrator credentials from a GPP file. In Beyond Root, I’ll look at the other four things that PowerUp points out, and show how one of them will also provide a shell as SYSTEM.
    

*   Jun 15, 2019
    
    ### [HTB: FluJab](https://0xdf.gitlab.io/2019/06/15/htb-flujab.html)
    
    [FluJab](https://0xdf.gitlab.io/tags.html#flujab) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [openssl](https://0xdf.gitlab.io/tags.html#openssl) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [cookies](https://0xdf.gitlab.io/tags.html#cookies) [python](https://0xdf.gitlab.io/tags.html#python) [scripting](https://0xdf.gitlab.io/tags.html#scripting) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [injection](https://0xdf.gitlab.io/tags.html#injection) [python-cmd](https://0xdf.gitlab.io/tags.html#python-cmd) [python](https://0xdf.gitlab.io/tags.html#python) [ajenti](https://0xdf.gitlab.io/tags.html#ajenti) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [cve-2008-0166](https://0xdf.gitlab.io/tags.html#cve-2008-0166) [tcp-wrapper](https://0xdf.gitlab.io/tags.html#tcp-wrapper) [rbash](https://0xdf.gitlab.io/tags.html#rbash) [gtfobins](https://0xdf.gitlab.io/tags.html#gtfobins) [make](https://0xdf.gitlab.io/tags.html#make) [screen](https://0xdf.gitlab.io/tags.html#screen) [arbitrary-write](https://0xdf.gitlab.io/tags.html#arbitrary-write)
    
    ![](https://0xdf.gitlab.io/img/flujab-cover.png) FluJab was a long and difficult box, with several complicated steps which require multiple pieces working together and careful enumeration. I’ll start by enumerating a host that hosts websites for many different customers, and is meant to be like a CloudFlare ip. Once identifying the host I’m targeting, I’ll find some weird cookie values that I can manipulate to get access to configuration pages. There I can configure the SMTP to go through my host, and use an SQL injection in one of the forms where I can read the results over email. Information in the database credentials and new subdomain, where I can access an instance of Ajenti server admin panel. That allows me to identify weak ssh keys, and to add my host to an ssh TCP Wrapper whitelist. Then I can ssh in with the weak private key. From there, I’ll find a vulnerable version of screen which I can use to get a root shell. In Beyond Root, I’ll show an unintended path to get a shell through Ajenti using the API, look at the details of the screen exploit, explore the box’s clean up crons, and point out an oddity with nurse jackie.
    

*   Jun 8, 2019
    
    ### [HTB: Help](https://0xdf.gitlab.io/2019/06/08/htb-help.html)
    
    [Help](https://0xdf.gitlab.io/tags.html#help) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [graphql](https://0xdf.gitlab.io/tags.html#graphql) [curl](https://0xdf.gitlab.io/tags.html#curl) [crackstation](https://0xdf.gitlab.io/tags.html#crackstation) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [helpdeskz](https://0xdf.gitlab.io/tags.html#helpdeskz) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [exploit-db](https://0xdf.gitlab.io/tags.html#exploit-db) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [blindsqli](https://0xdf.gitlab.io/tags.html#blindsqli) [sqlmap](https://0xdf.gitlab.io/tags.html#sqlmap) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [filter](https://0xdf.gitlab.io/tags.html#filter) [php](https://0xdf.gitlab.io/tags.html#php) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [exploit](https://0xdf.gitlab.io/tags.html#exploit) [cve-2017-16995](https://0xdf.gitlab.io/tags.html#cve-2017-16995) [cve-2017-5899](https://0xdf.gitlab.io/tags.html#cve-2017-5899) [oswe-like](https://0xdf.gitlab.io/tags.html#oswe-like)
    
    ![](https://0xdf.gitlab.io/img/help-cover.png)Help was an easy box with some neat challenges. As far as I can tell, most people took the unintended route which allowed for skipping the initial section. I’ll either enumerate a GraphQL API to get credentials for a HelpDeskZ instance. I’ll use those creds to exploit an authenticated SQLi vulnerability and dump the database. In the database, I’ll find creds which work to ssh into the box. Alternatively, I can use an unauthenticated upload bypass in HelpDeskZ to upload a webshell and get a shell from there. For root, it’s kernel exploits.
    

*   Jun 1, 2019
    
    ### [HTB: Sizzle](https://0xdf.gitlab.io/2019/06/01/htb-sizzle.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Sizzle](https://0xdf.gitlab.io/tags.html#sizzle) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [smb](https://0xdf.gitlab.io/tags.html#smb) [ftp](https://0xdf.gitlab.io/tags.html#ftp) [regex](https://0xdf.gitlab.io/tags.html#regex) [regex101](https://0xdf.gitlab.io/tags.html#regex101) [responder](https://0xdf.gitlab.io/tags.html#responder) [scf](https://0xdf.gitlab.io/tags.html#scf) [netntlmv2](https://0xdf.gitlab.io/tags.html#netntlmv2) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [ldapdomaindump](https://0xdf.gitlab.io/tags.html#ldapdomaindump) [ldap](https://0xdf.gitlab.io/tags.html#ldap) [certsrv](https://0xdf.gitlab.io/tags.html#certsrv) [certificate](https://0xdf.gitlab.io/tags.html#certificate) [firefox](https://0xdf.gitlab.io/tags.html#firefox) [openssl](https://0xdf.gitlab.io/tags.html#openssl) [winrm](https://0xdf.gitlab.io/tags.html#winrm) [constrained-language-mode](https://0xdf.gitlab.io/tags.html#constrained-language-mode) [PSByPassCLM](https://0xdf.gitlab.io/tags.html#psbypassclm) [metasploit](https://0xdf.gitlab.io/tags.html#metasploit) [meterpreter](https://0xdf.gitlab.io/tags.html#meterpreter) [installutil](https://0xdf.gitlab.io/tags.html#installutil) [msbuild](https://0xdf.gitlab.io/tags.html#msbuild) [msfvenom](https://0xdf.gitlab.io/tags.html#msfvenom) [kerberoast](https://0xdf.gitlab.io/tags.html#kerberoast) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [rubeus](https://0xdf.gitlab.io/tags.html#rubeus) [chisel](https://0xdf.gitlab.io/tags.html#chisel) [bloodhound](https://0xdf.gitlab.io/tags.html#bloodhound) [smbserver](https://0xdf.gitlab.io/tags.html#smbserver) [dcsync](https://0xdf.gitlab.io/tags.html#dcsync) [secretsdump](https://0xdf.gitlab.io/tags.html#secretsdump) [crackmapexec](https://0xdf.gitlab.io/tags.html#crackmapexec) [wmiexec](https://0xdf.gitlab.io/tags.html#wmiexec) [cron](https://0xdf.gitlab.io/tags.html#cron) [ntlm-http](https://0xdf.gitlab.io/tags.html#ntlm-http) [burp](https://0xdf.gitlab.io/tags.html#burp) [Active](https://0xdf.gitlab.io/tags.html#active) [Reel](https://0xdf.gitlab.io/tags.html#reel) [certificate-authority](https://0xdf.gitlab.io/tags.html#certificate-authority) [client-certificate](https://0xdf.gitlab.io/tags.html#client-certificate) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus)
    
    ![](https://0xdf.gitlab.io/img/sizzle-cover.png)I _loved_ Sizzle. It was just a really tough box that reinforced Windows concepts that I hear about from pentesters in the real world. I’ll start with some SMB access, use a .scf file to capture a users NetNTLM hash, and crack it to get creds. From there I can create a certificate for the user and then authenticate over WinRM. I’ll Kerberoast to get a second user, who is able to run the DCSync attack, leading to an admin shell. I’ll have two beyond root sections, the first to show two unintended paths, and the second to exploit NTLM authentication over HTTP, and how Burp breaks it.
    

*   May 25, 2019
    
    ### [HTB: Chaos](https://0xdf.gitlab.io/2019/05/25/htb-chaos.html)
    
    [Chaos](https://0xdf.gitlab.io/tags.html#chaos) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [webmin](https://0xdf.gitlab.io/tags.html#webmin) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [wordpress](https://0xdf.gitlab.io/tags.html#wordpress) [wpscan](https://0xdf.gitlab.io/tags.html#wpscan) [imap](https://0xdf.gitlab.io/tags.html#imap) [openssl](https://0xdf.gitlab.io/tags.html#openssl) [roundcube](https://0xdf.gitlab.io/tags.html#roundcube) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [python](https://0xdf.gitlab.io/tags.html#python) [LaTeX](https://0xdf.gitlab.io/tags.html#latex) [pdfTeX](https://0xdf.gitlab.io/tags.html#pdftex) [rbash](https://0xdf.gitlab.io/tags.html#rbash) [gtfobins](https://0xdf.gitlab.io/tags.html#gtfobins) [tar](https://0xdf.gitlab.io/tags.html#tar) [shared-password](https://0xdf.gitlab.io/tags.html#shared-password) [firefox](https://0xdf.gitlab.io/tags.html#firefox)
    
    ![](https://0xdf.gitlab.io/img/chaos-cover.jpg)Choas provided a couple interesting aspects that I had not worked with before. After some web enumeration and password guessing, I found myself with webmail credentials, which I could use on a webmail domain or over IMAP to get access to the mailbox. In the mailbox was an encrypted message, that once broken, directed me to a secret url where I could exploit an instance of pdfTeX to get a shell. From there, I used a shared password to switch to another user, performed an restricted shell escape, and found the root password in the user’s firefox saved passwords. That password was actually for a Webmin instance, which I’ll exploit in Beyond Root.
    

*   May 22, 2019
    
    ### [Malware Analysis: Pivoting In VT](https://0xdf.gitlab.io/2019/05/22/emotet-pivot.html)
    
    [malware](https://0xdf.gitlab.io/tags.html#malware) [emotet](https://0xdf.gitlab.io/tags.html#emotet) [olevba](https://0xdf.gitlab.io/tags.html#olevba) [oledump](https://0xdf.gitlab.io/tags.html#oledump) [powershell](https://0xdf.gitlab.io/tags.html#powershell) [virustotal](https://0xdf.gitlab.io/tags.html#virustotal)
    
    ![](https://0xdf.gitlab.io/img/emotet0-pivot-cover.png) After pulling apart an Emotet phishing doc in the [previous post](https://0xdf.gitlab.io/2019/05/21/malware-analysis-unnamed-emotet-doc.html), I wanted to see if I could find similar docs from the same phishing campaign, and perhaps even different docs from previous phishing campaigns based on artifacts in the seed document. With access to a paid VirusTotal account, this is not difficult to do.
    

*   May 21, 2019
    
    ### [Malware Analysis: Unnamed Emotet Doc](https://0xdf.gitlab.io/2019/05/21/malware-analysis-unnamed-emotet-doc.html)
    
    [malware](https://0xdf.gitlab.io/tags.html#malware) [emotet](https://0xdf.gitlab.io/tags.html#emotet) [olevba](https://0xdf.gitlab.io/tags.html#olevba) [oledump](https://0xdf.gitlab.io/tags.html#oledump) [powershell](https://0xdf.gitlab.io/tags.html#powershell) [virustotal](https://0xdf.gitlab.io/tags.html#virustotal) [cyberchef](https://0xdf.gitlab.io/tags.html#cyberchef) [urlscan](https://0xdf.gitlab.io/tags.html#urlscan)
    
    ![](https://0xdf.gitlab.io/img/emotet-20190521-cover.png) I decided to do some VT roulette and check out some recent phishing docs in VT. I searched for documents with only few (5-12) detections, and the top item was an Emotet word doc. The Emotet group continues to tweak their strategy to avoid AV. In this doc, they use TextBox objects to hold both the base64 encoded PowerShell and the PowerShell command line itself, in a way that actually makes it hard to follow with olevba. I’ll use oledump to show the parts that olevba misses.
    

*   May 18, 2019
    
    ### [HTB: Conceal](https://0xdf.gitlab.io/2019/05/18/htb-conceal.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Conceal](https://0xdf.gitlab.io/tags.html#conceal) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [snmp](https://0xdf.gitlab.io/tags.html#snmp) [snmpwalk](https://0xdf.gitlab.io/tags.html#snmpwalk) [ike](https://0xdf.gitlab.io/tags.html#ike) [ipsec](https://0xdf.gitlab.io/tags.html#ipsec) [ike-scan](https://0xdf.gitlab.io/tags.html#ike-scan) [strongswan](https://0xdf.gitlab.io/tags.html#strongswan) [iis](https://0xdf.gitlab.io/tags.html#iis) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [upload](https://0xdf.gitlab.io/tags.html#upload) [nishang](https://0xdf.gitlab.io/tags.html#nishang) [juicypotato](https://0xdf.gitlab.io/tags.html#juicypotato) [potato](https://0xdf.gitlab.io/tags.html#potato) [watson](https://0xdf.gitlab.io/tags.html#watson) [windows](https://0xdf.gitlab.io/tags.html#windows) [windows10](https://0xdf.gitlab.io/tags.html#windows10) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    > ![](https://0xdf.gitlab.io/img/conceal-cover.png) Conceal brought something to HTB that I hadn’t seen before - connecting via an IPSEC VPN to get access to the host. I’ll use clues from SNMP and a lot of guessing and trial and error to get connected, and then it’s a realtively basic Windows host, uploading a webshell over FTP, and then using JuicyPotato to get SYSTEM priv. The box is very much unpatched, so I’ll show Watson as well, and leave exploiting those vulnerabilities as an exercise for the reader. It actually blows my mind that it only took 7 hours for user first blood, but then an additional 16.5 hours to root.
    

*   May 11, 2019
    
    ### [HTB: Lightweight](https://0xdf.gitlab.io/2019/05/11/htb-lightweight.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Lightweight](https://0xdf.gitlab.io/tags.html#lightweight) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [php](https://0xdf.gitlab.io/tags.html#php) [linux](https://0xdf.gitlab.io/tags.html#linux) [Centos](https://0xdf.gitlab.io/tags.html#centos) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [fail2ban](https://0xdf.gitlab.io/tags.html#fail2ban) [ldap](https://0xdf.gitlab.io/tags.html#ldap) [tcpdump](https://0xdf.gitlab.io/tags.html#tcpdump) [wireshark](https://0xdf.gitlab.io/tags.html#wireshark) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [bruteforce](https://0xdf.gitlab.io/tags.html#bruteforce) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [capabilities](https://0xdf.gitlab.io/tags.html#capabilities) [openssl](https://0xdf.gitlab.io/tags.html#openssl) [Ethereal](https://0xdf.gitlab.io/tags.html#ethereal) [sudoers](https://0xdf.gitlab.io/tags.html#sudoers) [arbitrary-write](https://0xdf.gitlab.io/tags.html#arbitrary-write) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus)
    
    ![](https://0xdf.gitlab.io/img/lightweight-cover.png) Lightweight was relatively easy for a medium box. The biggest trick was figuring out that you needed to capture ldap traffic on localhost to get credentials, and getting that traffic to generate. The box actually starts off with creating an ssh account for me when I visit the webpage. From there I can capture plaintext creds from ldap to escalate to the first user. I’ll crack a backup archive to get creds to the second user, and finally use a copy of `openssl` with full Linux capabilities assigned to it to escalate to root. In Beyond root, I’ll look at the backup site and the real one, and how they don’t match, as well as look at the script for creating users based on http visits.
    

*   May 4, 2019
    
    ### [HTB: BigHead](https://0xdf.gitlab.io/2019/05/04/htb-bighead.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [BigHead](https://0xdf.gitlab.io/tags.html#bighead) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [windows](https://0xdf.gitlab.io/tags.html#windows) [2k8sp2](https://0xdf.gitlab.io/tags.html#2k8sp2) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [phpinfo](https://0xdf.gitlab.io/tags.html#phpinfo) [dirsearch](https://0xdf.gitlab.io/tags.html#dirsearch) [nginx](https://0xdf.gitlab.io/tags.html#nginx) [github](https://0xdf.gitlab.io/tags.html#github) [john](https://0xdf.gitlab.io/tags.html#john) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [zip](https://0xdf.gitlab.io/tags.html#zip) [7z](https://0xdf.gitlab.io/tags.html#7z) [bof](https://0xdf.gitlab.io/tags.html#bof) [exploit](https://0xdf.gitlab.io/tags.html#exploit) [python](https://0xdf.gitlab.io/tags.html#python) [bitvise](https://0xdf.gitlab.io/tags.html#bitvise) [reg](https://0xdf.gitlab.io/tags.html#reg) [plink](https://0xdf.gitlab.io/tags.html#plink) [chisel](https://0xdf.gitlab.io/tags.html#chisel) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [bvshell](https://0xdf.gitlab.io/tags.html#bvshell) [include](https://0xdf.gitlab.io/tags.html#include) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [keepass](https://0xdf.gitlab.io/tags.html#keepass) [bash](https://0xdf.gitlab.io/tags.html#bash) [kpcli](https://0xdf.gitlab.io/tags.html#kpcli) [ads](https://0xdf.gitlab.io/tags.html#ads) [alternative-data-streams](https://0xdf.gitlab.io/tags.html#alternative-data-streams)
    
    ![](https://0xdf.gitlab.io/img/bighead-cover.png)BigHead required you to earn your 50 points. The enumeration was a ton. There was an really fun but challenging buffer overflow to get initial access. Then some pivoting across the same host using SSH and the a php vulnerability. And then finding a hidden KeePass database with a keyfile in an ADS stream which gave me the root flag.
    

*   May 4, 2019
    
    ### [BigHead Exploit Dev](https://0xdf.gitlab.io/2019/05/04/htb-bighead-bof.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [BigHead](https://0xdf.gitlab.io/tags.html#bighead) [bof](https://0xdf.gitlab.io/tags.html#bof) [exploit](https://0xdf.gitlab.io/tags.html#exploit) [python](https://0xdf.gitlab.io/tags.html#python) [pwntools](https://0xdf.gitlab.io/tags.html#pwntools) [immunity](https://0xdf.gitlab.io/tags.html#immunity) [mona](https://0xdf.gitlab.io/tags.html#mona) [ida](https://0xdf.gitlab.io/tags.html#ida) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [MinGW](https://0xdf.gitlab.io/tags.html#mingw) [nginx](https://0xdf.gitlab.io/tags.html#nginx) [pattern-create](https://0xdf.gitlab.io/tags.html#pattern-create) [egg-hunter](https://0xdf.gitlab.io/tags.html#egg-hunter)
    
    ![](https://0xdf.gitlab.io/img/bighead-bof-cover.png) As my buffer overflow experience on Windows targets is relatively limited (only the basic vulnserver jmp esp type exploit previously), BigHeadWebSrv was probably the most complicate exploit chain I’ve written for a Windows target. The primary factor that takes this above something like a basic jmp esp is the space I have to write to is small. I got to learn a new technique, Egg Hunter, which is a small amount of code that will look for a marker I drop into memory earlier and run the shellcode after it.
    

*   Apr 27, 2019
    
    ### [HTB: Irked](https://0xdf.gitlab.io/2019/04/27/htb-irked.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [irked](https://0xdf.gitlab.io/tags.html#irked) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [exploit-db](https://0xdf.gitlab.io/tags.html#exploit-db) [hexchat](https://0xdf.gitlab.io/tags.html#hexchat) [irc](https://0xdf.gitlab.io/tags.html#irc) [python](https://0xdf.gitlab.io/tags.html#python) [steganography](https://0xdf.gitlab.io/tags.html#steganography) [steghide](https://0xdf.gitlab.io/tags.html#steghide) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [su](https://0xdf.gitlab.io/tags.html#su) [shared-password](https://0xdf.gitlab.io/tags.html#shared-password) [metasploit](https://0xdf.gitlab.io/tags.html#metasploit) [exim](https://0xdf.gitlab.io/tags.html#exim) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    ![](https://0xdf.gitlab.io/img/irked-cover.png)Irked was another beginner level box from HackTheBox that provided an opportunity to do some simple exploitation without too much enumeration. First blood for user fell in minutes, and root in 19. I’ll start by exploring an IRC server, and not finding any conversation, I’ll exploit it with some command injection. That leads me to a hint to look for steg with a password, which I’ll find on the image on the web server. That password gets me access as the user. I’ll find an setuid binary that’s trying to run a script out of /tmp that doesn’t exist. I’ll add code to that to get a shell. In Beyond Root, I’ll look at the Metasploit Payload for the IRC exploit, as well as some failed privesc exploits.
    

*   Apr 20, 2019
    
    ### [HTB: Teacher](https://0xdf.gitlab.io/2019/04/20/htb-teacher.html)
    
    [Teacher](https://0xdf.gitlab.io/tags.html#teacher) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [debian](https://0xdf.gitlab.io/tags.html#debian) [stretch](https://0xdf.gitlab.io/tags.html#stretch) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [skipfish](https://0xdf.gitlab.io/tags.html#skipfish) [hydra](https://0xdf.gitlab.io/tags.html#hydra) [python](https://0xdf.gitlab.io/tags.html#python) [cve-2018-1133](https://0xdf.gitlab.io/tags.html#cve-2018-1133) [crackstation](https://0xdf.gitlab.io/tags.html#crackstation) [mysql](https://0xdf.gitlab.io/tags.html#mysql) [pspy](https://0xdf.gitlab.io/tags.html#pspy) [su](https://0xdf.gitlab.io/tags.html#su) [cron](https://0xdf.gitlab.io/tags.html#cron) [chmod](https://0xdf.gitlab.io/tags.html#chmod) [passwd](https://0xdf.gitlab.io/tags.html#passwd) [arbitrary-write](https://0xdf.gitlab.io/tags.html#arbitrary-write)
    
    ![](https://0xdf.gitlab.io/img/teacher-cover.png) Teacher was 20-point box (despite the yellow avatar). At the start, it required enumerating a website and finding a png file that was actually a text file that revealed most of a password. I’ll use hydra to brute force the last character of the password, and gain access to a Moodle instance, software designed for online learning. I’ll abuse a PHP injection in the quiz feature to get code execution and a shell on the box. Then, I’ll find an md5 in the database that is the password for the main user on the box. From there, I’ll take advantage of a root cron that’s running a backup script, and give myself write access to whatever I want, which I’ll use to get root.
    

*   Apr 15, 2019
    
    ### [Commando VM: Lessons Learned](https://0xdf.gitlab.io/2019/04/15/commando-vm-lessons.html)
    
    [home-lab](https://0xdf.gitlab.io/tags.html#home-lab) [commando](https://0xdf.gitlab.io/tags.html#commando) [fireeye](https://0xdf.gitlab.io/tags.html#fireeye) [smb](https://0xdf.gitlab.io/tags.html#smb) [net-view](https://0xdf.gitlab.io/tags.html#net-view) [net-use](https://0xdf.gitlab.io/tags.html#net-use) [firewall](https://0xdf.gitlab.io/tags.html#firewall) [python](https://0xdf.gitlab.io/tags.html#python) [winrm](https://0xdf.gitlab.io/tags.html#winrm) [responder](https://0xdf.gitlab.io/tags.html#responder)
    
    ![](https://0xdf.gitlab.io/img/commando-lessons-cover.png) I worked a HackTheBox target over the last week using CommandoVM as my attack station. I was pleasantly surprised with how much I liked it. In fact, only once on this box did I need to fire up my Kali workstation. Because the target was Windows, there we parts that were made easier (and in one case made possible!). There were a couple additional struggles that arose, and I’m still in search of a good tmux equivalent. I’ll walk through some of the lessons learned from working in this distro.
    

*   Apr 13, 2019
    
    ### [HTB: RedCross](https://0xdf.gitlab.io/2019/04/13/htb-redcross.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [RedCross](https://0xdf.gitlab.io/tags.html#redcross) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [linux](https://0xdf.gitlab.io/tags.html#linux) [debian](https://0xdf.gitlab.io/tags.html#debian) [php](https://0xdf.gitlab.io/tags.html#php) [cookie](https://0xdf.gitlab.io/tags.html#cookie) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [xss](https://0xdf.gitlab.io/tags.html#xss) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [sqlmap](https://0xdf.gitlab.io/tags.html#sqlmap) [command-injection](https://0xdf.gitlab.io/tags.html#command-injection) [injection](https://0xdf.gitlab.io/tags.html#injection) [postgresql](https://0xdf.gitlab.io/tags.html#postgresql) [haraka](https://0xdf.gitlab.io/tags.html#haraka) [exploit-db](https://0xdf.gitlab.io/tags.html#exploit-db) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [suid](https://0xdf.gitlab.io/tags.html#suid) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [sudoers](https://0xdf.gitlab.io/tags.html#sudoers) [nss](https://0xdf.gitlab.io/tags.html#nss) [jail](https://0xdf.gitlab.io/tags.html#jail) [bof](https://0xdf.gitlab.io/tags.html#bof) [exploit](https://0xdf.gitlab.io/tags.html#exploit) [python](https://0xdf.gitlab.io/tags.html#python) [pwntools](https://0xdf.gitlab.io/tags.html#pwntools) [socat](https://0xdf.gitlab.io/tags.html#socat) [rop](https://0xdf.gitlab.io/tags.html#rop) [aslr](https://0xdf.gitlab.io/tags.html#aslr)
    
    ![](https://0xdf.gitlab.io/img/redcross-cover.png)RedCross was a maze, with a lot to look at and multiple paths at each stage. I’ll start by enumerating a website, and showing two different ways to get a cookie to use to gain access to the admin panel. Then, I’ll get a shell on the box as penelope, either via an exploit in the Haraka SMPT server or via injection in the webpage and the manipulation of the database that controls the users in the ssh jail. Finally, I’ll show escalation to root three different ways, using the database again in two different ways, and via a buffer overflow in a setuid binary. In Beyond Root, I’ll dig into the SQL injection and check out how the ssh jail is configured.
    

*   Apr 10, 2019
    
    ### [Commando VM: Looking Around](https://0xdf.gitlab.io/2019/04/10/commando-vm-overview.html)
    
    [home-lab](https://0xdf.gitlab.io/tags.html#home-lab) [commando](https://0xdf.gitlab.io/tags.html#commando) [fireeye](https://0xdf.gitlab.io/tags.html#fireeye) [openvpn](https://0xdf.gitlab.io/tags.html#openvpn) [burp](https://0xdf.gitlab.io/tags.html#burp) [7zip](https://0xdf.gitlab.io/tags.html#7zip) [winrar](https://0xdf.gitlab.io/tags.html#winrar) [cmder](https://0xdf.gitlab.io/tags.html#cmder) [greenshot](https://0xdf.gitlab.io/tags.html#greenshot) [windump](https://0xdf.gitlab.io/tags.html#windump) [payloadsallthethings](https://0xdf.gitlab.io/tags.html#payloadsallthethings) [seclists](https://0xdf.gitlab.io/tags.html#seclists) [fuzzdb](https://0xdf.gitlab.io/tags.html#fuzzdb) [foxyproxy](https://0xdf.gitlab.io/tags.html#foxyproxy) [x64dbg](https://0xdf.gitlab.io/tags.html#x64dbg) [dnspy](https://0xdf.gitlab.io/tags.html#dnspy) [ida](https://0xdf.gitlab.io/tags.html#ida) [ghidra](https://0xdf.gitlab.io/tags.html#ghidra) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz)
    
    ![](https://0xdf.gitlab.io/img/commando-overview-cover.png)Having built my CommandoVM in a [previous post](https://0xdf.gitlab.io/2019/04/09/commando-vm-installation.html), now I am going to look at what’s installed, and what else I might want to add to the distribution. I’ll start with some tweaks I made to get the box into shape, check out what tools are present, and add some that I notice missing. After this, in I’ll use the VM to work a HTB target, and report back on in a future post.
    

*   Apr 9, 2019
    
    ### [Commando VM: Installation](https://0xdf.gitlab.io/2019/04/09/commando-vm-installation.html)
    
    [home-lab](https://0xdf.gitlab.io/tags.html#home-lab) [commando](https://0xdf.gitlab.io/tags.html#commando) [fireeye](https://0xdf.gitlab.io/tags.html#fireeye)
    
    ![](https://0xdf.gitlab.io/img/commando-install-cover.png)Ever since Fireeye announced their new CommandoVM, the “Complete Mandiant Offensive VM”, I’d figured next time I had an occasion to target a Windows host, I would try to build a VM and give it a spin. This post is focused on getting up and running. I suspect additional posts on how it works out will follow.
    

*   Apr 6, 2019
    
    ### [HTB: Vault](https://0xdf.gitlab.io/2019/04/06/htb-vault.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Vault](https://0xdf.gitlab.io/tags.html#vault) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [php](https://0xdf.gitlab.io/tags.html#php) [upload](https://0xdf.gitlab.io/tags.html#upload) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [pivot](https://0xdf.gitlab.io/tags.html#pivot) [qemu](https://0xdf.gitlab.io/tags.html#qemu) [spice](https://0xdf.gitlab.io/tags.html#spice) [openvpn](https://0xdf.gitlab.io/tags.html#openvpn) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [rbash](https://0xdf.gitlab.io/tags.html#rbash) [gpg](https://0xdf.gitlab.io/tags.html#gpg) [remmina](https://0xdf.gitlab.io/tags.html#remmina) [ubuntu](https://0xdf.gitlab.io/tags.html#ubuntu) [linux](https://0xdf.gitlab.io/tags.html#linux) [iptables](https://0xdf.gitlab.io/tags.html#iptables) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [filter](https://0xdf.gitlab.io/tags.html#filter) [oswe-like](https://0xdf.gitlab.io/tags.html#oswe-like)
    
    ![](https://0xdf.gitlab.io/img/vault-cover.png)Vault was a a really neat box in that it required pivoting from a host into various VMs to get to the vault, at least the intended way. There’s an initial php upload filter bypass that gives me execution. Then a pivot with an OpenVPN config RCE. From there I’ll find SSH creds, and need to figure out how to pass through a firewall to get to the vault. Once in the vault, I find the flag encrypted with GPG, and I’ll need to move it back to the host to get the decryption keys to get the flag. In Beyond Root, I’ll look at a couple of unintended paths, including a firewall bypass by adding an IP address, and a way to bypass the entire thing by connecting to the Spice ports, rebooting the VMs into recovery, resetting the root password, and then logging in.
    

*   Apr 3, 2019
    
    ### [Wizard Labs: DevLife](https://0xdf.gitlab.io/2019/04/03/wl-devlife.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [wizard-labs](https://0xdf.gitlab.io/tags.html#wizard-labs) [devlife](https://0xdf.gitlab.io/tags.html#devlife) [linux](https://0xdf.gitlab.io/tags.html#linux) [debian](https://0xdf.gitlab.io/tags.html#debian) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [python](https://0xdf.gitlab.io/tags.html#python) [credentials](https://0xdf.gitlab.io/tags.html#credentials)
    
    ![](https://0xdf.gitlab.io/img/wl-devlife-cover.png) Another Wizard Lab’s host retired, DevLife. This was another really easy box, that required some simple web enumeration to find a python panel that would run python commands, and display the output. From there, I could get a shell and the first flag. Then, more enumeration to find a python script in a hidden directory that contained the root password. With that, I can escalate to root. There was also a swp file in the hidden directory that I’ll attempt to recover (and then figure out is actually nano), and I’ll look at how the php page runs python commands, and show an injection in that.
    

*   Mar 30, 2019
    
    ### [HTB: Curling](https://0xdf.gitlab.io/2019/03/30/htb-curling.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Curling](https://0xdf.gitlab.io/tags.html#curling) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [Joomla](https://0xdf.gitlab.io/tags.html#joomla) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [cron](https://0xdf.gitlab.io/tags.html#cron) [pspy](https://0xdf.gitlab.io/tags.html#pspy) [curl](https://0xdf.gitlab.io/tags.html#curl) [suid](https://0xdf.gitlab.io/tags.html#suid) [cve-2019-7304](https://0xdf.gitlab.io/tags.html#cve-2019-7304) [dirty-sock](https://0xdf.gitlab.io/tags.html#dirty-sock) [ubuntu](https://0xdf.gitlab.io/tags.html#ubuntu) [exploit](https://0xdf.gitlab.io/tags.html#exploit) [Sunday](https://0xdf.gitlab.io/tags.html#sunday) [arbitrary-write](https://0xdf.gitlab.io/tags.html#arbitrary-write)
    
    ![](https://0xdf.gitlab.io/img/curling-cover.png)Curling was a solid box easy box that provides a chance to practice some basic enumeration to find a password, using that password to get access to a Joomla instance, and using the access to get a shell. With a shell, I’ll find a compressed and encoded backup file, that after a bit of unpacking, gives a password to privesc to the next user. As that user, I’ll find a root cron running curl with the option to use a configuration file. It happens that I can control that file, and use it to get the root flag and a root shell. In Beyond root, I’ll look at how setuid applies to scripts on most Linux flavors (and how it’s different from Solaris as I showed with Sunday), and how the Dirty Sock snapd vulnerability from a couple months ago will work here to go to root.
    

*   Mar 27, 2019
    
    ### [Analyzing Document Macros with Yara](https://0xdf.gitlab.io/2019/03/27/analyzing-document-macros-with-yara.html)
    
    [phishing](https://0xdf.gitlab.io/tags.html#phishing) [vbscript](https://0xdf.gitlab.io/tags.html#vbscript) [Yara](https://0xdf.gitlab.io/tags.html#yara) [documents](https://0xdf.gitlab.io/tags.html#documents) [metasploit](https://0xdf.gitlab.io/tags.html#metasploit) [powershell](https://0xdf.gitlab.io/tags.html#powershell)
    
    ![](https://0xdf.gitlab.io/img/yara-cover.png) This post is actually inspired by a box I’m building for HTB, so if it ever gets released, some of you may see this post again. But Yara is also something I’ve used a ton professionally, and it is super useful. I’ll introduce Yara, a pattern matching tool which is super useful for malware analysis, and just a general use tool that’s useful to know. I’ll also look at the file format for both Microsoft Office and Libre Office documents, and how to decompress them to identify their contents. I’ll show how for Libre Office files, Yara can be applied to the unzipped document to identify macro contents.
    

*   Mar 26, 2019
    
    ### [HTB: October](https://0xdf.gitlab.io/2019/03/26/htb-october.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [October](https://0xdf.gitlab.io/tags.html#october) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [ubuntu](https://0xdf.gitlab.io/tags.html#ubuntu) [linux](https://0xdf.gitlab.io/tags.html#linux) [bof](https://0xdf.gitlab.io/tags.html#bof) [exploit](https://0xdf.gitlab.io/tags.html#exploit) [file-upload](https://0xdf.gitlab.io/tags.html#file-upload) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus)
    
    ![](https://0xdf.gitlab.io/img/october-cover.png)October was interesting because it paired a very straight-forward initial access with a simple buffer overflow for privesc. To gain access, I’ll learn about a extension blacklist by pass against the October CMS, allowing me to upload a webshell and get execution. Then I’ll find a SetUID binary that I can overflow to get root. While the buffer overflow exploit was on the more straight-forward side, it still requires a level of skill beyond many of the other easy early boxes I’ve done so far.
    

*   Mar 23, 2019
    
    ### [HTB: Frolic](https://0xdf.gitlab.io/2019/03/23/htb-frolic.html)
    
    [Frolic](https://0xdf.gitlab.io/tags.html#frolic) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [nodered](https://0xdf.gitlab.io/tags.html#nodered) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [php](https://0xdf.gitlab.io/tags.html#php) [playsms](https://0xdf.gitlab.io/tags.html#playsms) [javascript](https://0xdf.gitlab.io/tags.html#javascript) [ook!](https://0xdf.gitlab.io/tags.html#ook) [python](https://0xdf.gitlab.io/tags.html#python) [brainfuck](https://0xdf.gitlab.io/tags.html#brainfuck) [fcrackzip](https://0xdf.gitlab.io/tags.html#fcrackzip) [xxd](https://0xdf.gitlab.io/tags.html#xxd) [cve-2017-9101](https://0xdf.gitlab.io/tags.html#cve-2017-9101) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [bof](https://0xdf.gitlab.io/tags.html#bof) [ret2libc](https://0xdf.gitlab.io/tags.html#ret2libc) [peda](https://0xdf.gitlab.io/tags.html#peda) [metasploit](https://0xdf.gitlab.io/tags.html#metasploit) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    ![](https://0xdf.gitlab.io/img/frolic-cover.png) Frolic was more a string of challenges and puzzles than the more typical HTB experiences. Enumeration takes me through a series of puzzles that eventually unlock the credentials to a PlaySMS web interface. With that access, I can exploit the service to get execution and a shell. To gain root, I’ll find a setuid binary owned by root, and overflow it with a simple ret2libc attack. In Beyond Root, I’ll at the Metasploit version of the PlaySMS exploit and reverse it’s payload. I’ll also glance through the Bash history files of the two users on the box and see how the author built the box.
    

*   Mar 16, 2019
    
    ### [HTB: Carrier](https://0xdf.gitlab.io/2019/03/16/htb-carrier.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Carrier](https://0xdf.gitlab.io/tags.html#carrier) [injection](https://0xdf.gitlab.io/tags.html#injection) [command-injection](https://0xdf.gitlab.io/tags.html#command-injection) [bgp-hijack](https://0xdf.gitlab.io/tags.html#bgp-hijack) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [snmp](https://0xdf.gitlab.io/tags.html#snmp) [snmpwalk](https://0xdf.gitlab.io/tags.html#snmpwalk) [pivot](https://0xdf.gitlab.io/tags.html#pivot) [container](https://0xdf.gitlab.io/tags.html#container) [tcpdump](https://0xdf.gitlab.io/tags.html#tcpdump) [lxc](https://0xdf.gitlab.io/tags.html#lxc) [lxd](https://0xdf.gitlab.io/tags.html#lxd) [ssh](https://0xdf.gitlab.io/tags.html#ssh)
    
    ![](https://0xdf.gitlab.io/img/carrier-cover.png)Carrier was awesome, not because it super hard, but because it provided an opportunity to do something that I hear about all the time in the media, but have never been actually tasked with doing - BGP Hijacking. I’ll use SMNP to find a serial number which can be used to log into a management status interface for an ISP network. From there, I’ll find command injection which actually gives me execution on a router. The management interface also reveals tickets indicting some high value FTP traffic moving between two other ASNs, so I’ll use BGP hijacking to route the traffic through my current access, gaining access to the plaintext credentials. In Beyond Root, I’ll look at an unintended way to skip the BGP hijack, getting a root shell and how the various containers were set up, why I only had to hijack one side of the conversation to get both sides, the website and router interaction and how to log commands sent over ssh, and what “secretdata” really was.
    

*   Mar 15, 2019
    
    ### [Applocker Bypass: COR Profiler](https://0xdf.gitlab.io/2019/03/15/htb-ethereal-cor.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Ethereal](https://0xdf.gitlab.io/tags.html#ethereal) [windows](https://0xdf.gitlab.io/tags.html#windows) [applocker](https://0xdf.gitlab.io/tags.html#applocker) [meterpreter](https://0xdf.gitlab.io/tags.html#meterpreter) [metasploit](https://0xdf.gitlab.io/tags.html#metasploit) [beryllium](https://0xdf.gitlab.io/tags.html#beryllium) [visualstudio](https://0xdf.gitlab.io/tags.html#visualstudio) [.NET](https://0xdf.gitlab.io/tags.html#net) [cor-profiler](https://0xdf.gitlab.io/tags.html#cor-profiler)
    
    ![](https://0xdf.gitlab.io/img/ethereal-cor-cover.png)On of the challenges in Ethereal was having to use a shell comprised of two OpenSSL connections over different ports. And each time I wanted to exploit some user action, I had to set my trap in place, kill my shell, start two listeners, and wait. Things would have been a lot better if I could have just gotten a shell to connect back to me over one of the two open ports, but AppLocker made that nearly impossible. IppSec demoed a method to bypass those filters using COR Profiling. I wanted to play with it myself, and get some notes down (in the form of this post).
    

*   Mar 12, 2019
    
    ### [HTB: Bastard](https://0xdf.gitlab.io/2019/03/12/htb-bastard.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Bastard](https://0xdf.gitlab.io/tags.html#bastard) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [web](https://0xdf.gitlab.io/tags.html#web) [drupal](https://0xdf.gitlab.io/tags.html#drupal) [drupalgeddon2](https://0xdf.gitlab.io/tags.html#drupalgeddon2) [drupalgeddon3](https://0xdf.gitlab.io/tags.html#drupalgeddon3) [droopescan](https://0xdf.gitlab.io/tags.html#droopescan) [dirsearch](https://0xdf.gitlab.io/tags.html#dirsearch) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [windows](https://0xdf.gitlab.io/tags.html#windows) [searchsploit](https://0xdf.gitlab.io/tags.html#searchsploit) [nishang](https://0xdf.gitlab.io/tags.html#nishang) [ms15-051](https://0xdf.gitlab.io/tags.html#ms15-051) [smbserver](https://0xdf.gitlab.io/tags.html#smbserver) [Devel](https://0xdf.gitlab.io/tags.html#devel) [Granny](https://0xdf.gitlab.io/tags.html#granny) [php](https://0xdf.gitlab.io/tags.html#php) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    ![](https://0xdf.gitlab.io/img/bastard-cover.png)Bastard was the 7th box on HTB, and it presented a Drupal instance with a known vulnerability at the time it was released. I’ll play with that one, as well as two more, Drupalgeddon2 and Drupalgeddon3, and use each to get a shell on the box. The privesc was very similar to other early Windows challenges, as the box is unpatched, and vulnerable to kernel exploits.
    

*   Mar 9, 2019
    
    ### [HTB: Ethereal](https://0xdf.gitlab.io/2019/03/09/htb-ethereal.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Ethereal](https://0xdf.gitlab.io/tags.html#ethereal) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [pbox](https://0xdf.gitlab.io/tags.html#pbox) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [injection](https://0xdf.gitlab.io/tags.html#injection) [hydra](https://0xdf.gitlab.io/tags.html#hydra) [python](https://0xdf.gitlab.io/tags.html#python) [shell](https://0xdf.gitlab.io/tags.html#shell) [dns-c2](https://0xdf.gitlab.io/tags.html#dns-c2) [firewall](https://0xdf.gitlab.io/tags.html#firewall) [nslookup](https://0xdf.gitlab.io/tags.html#nslookup) [openssl](https://0xdf.gitlab.io/tags.html#openssl) [lnk](https://0xdf.gitlab.io/tags.html#lnk) [pylnker](https://0xdf.gitlab.io/tags.html#pylnker) [LNKUp](https://0xdf.gitlab.io/tags.html#lnkup) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [ca](https://0xdf.gitlab.io/tags.html#ca) [msi](https://0xdf.gitlab.io/tags.html#msi) [windows](https://0xdf.gitlab.io/tags.html#windows)
    
    ![](https://0xdf.gitlab.io/img/ethereal-cover.png)Ethereal was quite difficult, and up until a few weeks ago, potentially the hardest on HTB. Still, it was hard in a fun way. The path through the box was relatively clear, and yet, each step presented a technical challenge to figure out what was going on and how I could use it to get what I wanted. I’ll start by breaking into an old password vault that I find on FTP, and using that to authenticate to a website. That site has code injection, and I’ll use that to get exfil and eventually a weak shell over DNS. I’ll discover OpenSSL, and use that to get a more stable shell. From there, I’ll replace a shortcut to escalate to the next user. Then I’ll user CA certs that I find on target to sign an MSI file to give me shell as the administrator. I’ll also attach two additional posts, one going into how I attacked pbox, and another on how I developed a shell over blind command injection and dns.
    

*   Mar 9, 2019
    
    ### [HTB: Ethereal Attacking Password Box](https://0xdf.gitlab.io/2019/03/09/htb-ethereal-pbox.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Ethereal](https://0xdf.gitlab.io/tags.html#ethereal) [windows](https://0xdf.gitlab.io/tags.html#windows) [pbox](https://0xdf.gitlab.io/tags.html#pbox) [freebasic](https://0xdf.gitlab.io/tags.html#freebasic) [bruteforce](https://0xdf.gitlab.io/tags.html#bruteforce) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [basic](https://0xdf.gitlab.io/tags.html#basic)
    
    ![](https://0xdf.gitlab.io/img/ethereal-pbox-cover.png)For Ethereal, I found a DOS application, `pbox.exe`, and a `pbox.dat` file. These were associated with a program called PasswordBox, which was an early password manager program. To solve this box, most people likely just guessed the password, “password”. But what if I had needed to brute force it? The program was not friendly to taking input from stdin, or from running inside python. So I downloaded the source code, installed the FreeBasic compiler, and started hacking at the source until it ran in a way that I could brute force test 1000 passwords in 5 seconds. I’ll walk through my steps and thought process in this post.
    

*   Mar 9, 2019
    
    ### [HTB: Ethereal Shell Development](https://0xdf.gitlab.io/2019/03/09/htb-ethereal-shell.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Ethereal](https://0xdf.gitlab.io/tags.html#ethereal) [windows](https://0xdf.gitlab.io/tags.html#windows) [dns-c2](https://0xdf.gitlab.io/tags.html#dns-c2) [python](https://0xdf.gitlab.io/tags.html#python) [pdb](https://0xdf.gitlab.io/tags.html#pdb) [python-cmd](https://0xdf.gitlab.io/tags.html#python-cmd) [python-scapy](https://0xdf.gitlab.io/tags.html#python-scapy) [injection](https://0xdf.gitlab.io/tags.html#injection) [python-requests](https://0xdf.gitlab.io/tags.html#python-requests)
    
    ![](https://0xdf.gitlab.io/img/ethereal-shell-cover.png)It would have been possible to get through the initial enumeration of Ethereal with just Burp Repeater and tcpdump, or using responder to read the DNS requests. But writing a shell is much more fun and good coding practice. I’ll develop around primary two modules from Python, scapy to listen for and process DNS packets, and cmd to create a shell user interface, with requests to make the http injections. In this post I’ll show how I built the shell step by step.
    

*   Mar 6, 2019
    
    ### [HTB: Granny](https://0xdf.gitlab.io/2019/03/06/htb-granny.html)
    
    [Granny](https://0xdf.gitlab.io/tags.html#granny) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [webdav](https://0xdf.gitlab.io/tags.html#webdav) [aspx](https://0xdf.gitlab.io/tags.html#aspx) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [Devel](https://0xdf.gitlab.io/tags.html#devel) [meterpreter](https://0xdf.gitlab.io/tags.html#meterpreter) [windows](https://0xdf.gitlab.io/tags.html#windows) [ms14-058](https://0xdf.gitlab.io/tags.html#ms14-058) [local_exploit_suggester](https://0xdf.gitlab.io/tags.html#local-exploit-suggester) [pwk](https://0xdf.gitlab.io/tags.html#pwk) [cadaver](https://0xdf.gitlab.io/tags.html#cadaver) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    ![](https://0xdf.gitlab.io/img/granny-cover.png)As I’m continuing to work through older boxes, I came to Granny, another easy Windows host involving webshells. In this case, I’ll use WebDAV to get a webshell on target, which is something I haven’t written about before, but that I definitely ran into while doing PWK. In this case, WebDav blocks aspx uploads, but it doesn’t prevent me from uploading as a txt file, and then using the HTTP Move to move the file to an aspx. I’ll show how to get a simple webshell, and how to get meterpreter. For privesc, I’ll use a Windows local exploit to get SYSTEM access.
    

*   Mar 5, 2019
    
    ### [HTB: Devel](https://0xdf.gitlab.io/2019/03/05/htb-devel.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Devel](https://0xdf.gitlab.io/tags.html#devel) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [aspx](https://0xdf.gitlab.io/tags.html#aspx) [meterpreter](https://0xdf.gitlab.io/tags.html#meterpreter) [metasploit](https://0xdf.gitlab.io/tags.html#metasploit) [msfvenom](https://0xdf.gitlab.io/tags.html#msfvenom) [ms11-046](https://0xdf.gitlab.io/tags.html#ms11-046) [ftp](https://0xdf.gitlab.io/tags.html#ftp) [nishang](https://0xdf.gitlab.io/tags.html#nishang) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [watson](https://0xdf.gitlab.io/tags.html#watson) [smbserver](https://0xdf.gitlab.io/tags.html#smbserver) [upload](https://0xdf.gitlab.io/tags.html#upload) [windows](https://0xdf.gitlab.io/tags.html#windows) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    ![](https://0xdf.gitlab.io/img/devel-cover.png) Another one of the first boxes on HTB, and another simple beginner Windows target. In this case, I’ll use anonymous access to FTP that has it’s root in the webroot of the machine. I can upload a webshell, and use it to get execution and then a shell on the machine. Then I’ll use one of many available Windows kernel exploits to gain system. I’ll do it all without Metasploit, and then with Metasploit.
    

*   Mar 2, 2019
    
    ### [HTB: Access](https://0xdf.gitlab.io/2019/03/02/htb-access.html)
    
    [Access](https://0xdf.gitlab.io/tags.html#access) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [mdbtools](https://0xdf.gitlab.io/tags.html#mdbtools) [readpst](https://0xdf.gitlab.io/tags.html#readpst) [mutt](https://0xdf.gitlab.io/tags.html#mutt) [telnet](https://0xdf.gitlab.io/tags.html#telnet) [runas](https://0xdf.gitlab.io/tags.html#runas) [cached-creds](https://0xdf.gitlab.io/tags.html#cached-creds) [dpapi](https://0xdf.gitlab.io/tags.html#dpapi) [mimikatz](https://0xdf.gitlab.io/tags.html#mimikatz) [pylnker](https://0xdf.gitlab.io/tags.html#pylnker)
    
    ![](https://0xdf.gitlab.io/img/access-cover.png)Access was an easy Windows box, which is really nice to have around, since it’s hard to find places for beginners on Windows. And, unlike most Windows boxes, it didn’t involve SMB. I’ll start using anonymous FTP access to get a zip file and an Access database. I’ll use command line tools to find a password in the database that works for the zip file, and find an Outlook mail file inside. I’ll read the email to find the password for an account on the box, and connect with telnet. From there, I’ll take advantage of cached administrator credentials two different ways to get root.txt. In Beyond Root, I’ll look at ways to get more details out of lnk files, both with PowerShell and pylnker.
    

*   Feb 27, 2019
    
    ### [Playing with Jenkins RCE Vulnerability](https://0xdf.gitlab.io/2019/02/27/playing-with-jenkins-rce-vulnerability.html)
    
    [exploit](https://0xdf.gitlab.io/tags.html#exploit) [cve-2019-1003000](https://0xdf.gitlab.io/tags.html#cve-2019-1003000) [jenkins](https://0xdf.gitlab.io/tags.html#jenkins) [jeeves](https://0xdf.gitlab.io/tags.html#jeeves) [powershell](https://0xdf.gitlab.io/tags.html#powershell) [nishang](https://0xdf.gitlab.io/tags.html#nishang) [windows](https://0xdf.gitlab.io/tags.html#windows)
    
    ![](https://0xdf.gitlab.io/img/jenkins-exploit-cover.jpg)Orange Tsai published a really interesting writeup on their discovery of CVE-2019-1003000, an Unathenticated remote code exeuction (RCE) in Jenkins. There was a box from HackTheBox.eu that ran Jenkins, and while the configuration wasn’t perfect for this kind of test, I decided to play with it and see what I could figure out. I’ll get the exploit working with a new payload so that it runs on the Windows environment.
    

*   Feb 23, 2019
    
    ### [HTB: Zipper](https://0xdf.gitlab.io/2019/02/23/htb-zipper.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Zipper](https://0xdf.gitlab.io/tags.html#zipper) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [zabbix](https://0xdf.gitlab.io/tags.html#zabbix) [api](https://0xdf.gitlab.io/tags.html#api) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [path-hijack](https://0xdf.gitlab.io/tags.html#path-hijack) [docker](https://0xdf.gitlab.io/tags.html#docker) [ltrace](https://0xdf.gitlab.io/tags.html#ltrace) [service-hijack](https://0xdf.gitlab.io/tags.html#service-hijack) [exploit-db](https://0xdf.gitlab.io/tags.html#exploit-db) [jq](https://0xdf.gitlab.io/tags.html#jq) [openssl](https://0xdf.gitlab.io/tags.html#openssl) [php](https://0xdf.gitlab.io/tags.html#php) [pivot](https://0xdf.gitlab.io/tags.html#pivot) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [linux](https://0xdf.gitlab.io/tags.html#linux) [ubuntu](https://0xdf.gitlab.io/tags.html#ubuntu) [oswe-like](https://0xdf.gitlab.io/tags.html#oswe-like)
    
    ![](https://0xdf.gitlab.io/img/zipper-cover.png) Zipper was a pretty straight-forward box, especially compared to some of the more recent 40 point boxes. The main challenge involved using the API for a product called Zabbix, used to manage and inventory computers in an environment. I’ll show way too many ways to abuse Zabbix to get a shell. Then for privesc, I’ll show two methods, using a suid binary that makes a call to system without providing a full path, allowing me to change the path and get a root shell, and identifying a writable service file that I can hijack to gain root privlege. In Beyond Root, I’ll dig into the shell from Exploit-DB, figure out how it works, and make a few improvements.
    

*   Feb 22, 2019
    
    ### [Wizard Labs: Dummy](https://0xdf.gitlab.io/2019/02/22/wl-dummy.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [wizard-labs](https://0xdf.gitlab.io/tags.html#wizard-labs) [dummy](https://0xdf.gitlab.io/tags.html#dummy) [windows](https://0xdf.gitlab.io/tags.html#windows) [ms17-010](https://0xdf.gitlab.io/tags.html#ms17-010) [smb](https://0xdf.gitlab.io/tags.html#smb) [msfvenom](https://0xdf.gitlab.io/tags.html#msfvenom) [Win7](https://0xdf.gitlab.io/tags.html#win7)
    
    ![](https://0xdf.gitlab.io/img/wl-dummy-cover.png)I had an opportunity to check out [Wizard Labs](https://labs.wizard-security.net/) recently. It’s a recently launched service much like HackTheBox. Their user interface isn’t as polished or feature rich as HTB, but they have 16 vulnerable machines online right now to attack. The box called Dummy recently retired from their system, so I can safely give it a walk-through. It’s a bit of bad luck that I looked at this just after doing [Legacy](https://0xdf.gitlab.io/2019/02/21/htb-legacy.html), as they were very similar boxes. Seems popular to start a service with a Windows SMB vulnerability. This was a Windows 7 box, vulnerable to MS17-010. I’ll use a different python script, and give the Metasploit exploit a spin and fail.
    

*   Feb 21, 2019
    
    ### [HTB: Legacy](https://0xdf.gitlab.io/2019/02/21/htb-legacy.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [legacy](https://0xdf.gitlab.io/tags.html#legacy) [windows](https://0xdf.gitlab.io/tags.html#windows) [ms08-067](https://0xdf.gitlab.io/tags.html#ms08-067) [ms17-010](https://0xdf.gitlab.io/tags.html#ms17-010) [smb](https://0xdf.gitlab.io/tags.html#smb) [msfvenom](https://0xdf.gitlab.io/tags.html#msfvenom) [xp](https://0xdf.gitlab.io/tags.html#xp) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    ![](https://0xdf.gitlab.io/img/legacy-cover.png)Since I’m caught up on all the live boxes, challenges, and labs, I’ve started looking back at retired boxes from before I joined HTB. The top of the list was legacy, a box that seems like it was one of the first released on HTB. It’s a very easy Windows box, vulnerable to two SMB bugs that are easily exploited with Metasploit. I’ll show how to exploit both of them without Metasploit, generating shellcode and payloads with msfvenom, and modifying public scripts to get shells. In beyond root, I’ll take a quick look at the lack of whoami on XP systems.
    

*   Feb 16, 2019
    
    ### [HTB: Giddy](https://0xdf.gitlab.io/2019/02/16/htb-giddy.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Giddy](https://0xdf.gitlab.io/tags.html#giddy) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [sqlmap](https://0xdf.gitlab.io/tags.html#sqlmap) [winrm](https://0xdf.gitlab.io/tags.html#winrm) [net-ntlmv2](https://0xdf.gitlab.io/tags.html#net-ntlmv2) [responder](https://0xdf.gitlab.io/tags.html#responder) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [unifivideo](https://0xdf.gitlab.io/tags.html#unifivideo) [defender](https://0xdf.gitlab.io/tags.html#defender) [ebowla](https://0xdf.gitlab.io/tags.html#ebowla) [smbserver](https://0xdf.gitlab.io/tags.html#smbserver) [applocker](https://0xdf.gitlab.io/tags.html#applocker)
    
    ![](https://0xdf.gitlab.io/img/giddy-cover.png)I thought Giddy was a ton of fun. It was a relateively straight forward box, but I learned two really neat things working it (each of which inspired [other](https://0xdf.gitlab.io/2018/11/08/powershell-history-file.html) [posts](https://0xdf.gitlab.io/2019/01/13/getting-net-ntlm-hases-from-windows.html)). The box starts with some enumeration that leads to a site that gives inventory. I’ll abuse an SQL-Injection vulnerability to get the host to make an SMB connect back to me, where I can collect Net-NTLMv2 challenge response, and crack it to get a password. I can then use either the web PowerShell console or WinRM to get a shell. To get system, I’ll take advantage of a vulnerability in Ubiquiti UniFi Video.
    

*   Feb 13, 2019
    
    ### [Playing with Dirty Sock](https://0xdf.gitlab.io/2019/02/13/playing-with-dirty-sock.html)
    
    [snapd](https://0xdf.gitlab.io/tags.html#snapd) [cve-2019-7304](https://0xdf.gitlab.io/tags.html#cve-2019-7304) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ubuntu](https://0xdf.gitlab.io/tags.html#ubuntu) [exploit](https://0xdf.gitlab.io/tags.html#exploit) [dirty-sock](https://0xdf.gitlab.io/tags.html#dirty-sock) [Canape](https://0xdf.gitlab.io/tags.html#canape)
    
    ![](https://0xdf.gitlab.io/img/dirtysock-cover.png) A local privilege escalation exploit against a vulnerability in the snapd server on Ubuntu was released today by Shenanigans Labs under the name Dirty Sock. Snap is an attempt by Ubuntu to simplify packaging and software distribution, and there’s a vulnerability in the REST API which is attached to a local UNIX socket that allowed multiple methods to get root access. I decided to give it a run, both on a VM locally and on some of the [HackTheBox.eu](https://www.hackthebox.eu/) machines.
    

*   Feb 9, 2019
    
    ### [HTB: Ypuffy](https://0xdf.gitlab.io/2019/02/09/htb-ypuffy.html)
    
    [Ypuffy](https://0xdf.gitlab.io/tags.html#ypuffy) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [ldap](https://0xdf.gitlab.io/tags.html#ldap) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [ssh-keygen](https://0xdf.gitlab.io/tags.html#ssh-keygen) [doas](https://0xdf.gitlab.io/tags.html#doas) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [certificate](https://0xdf.gitlab.io/tags.html#certificate) [certificate-authority](https://0xdf.gitlab.io/tags.html#certificate-authority) [wireshark](https://0xdf.gitlab.io/tags.html#wireshark) [cve-2018-14665](https://0xdf.gitlab.io/tags.html#cve-2018-14665) [python](https://0xdf.gitlab.io/tags.html#python) [flask](https://0xdf.gitlab.io/tags.html#flask) [wsgi](https://0xdf.gitlab.io/tags.html#wsgi) [authorizedkeyscommand](https://0xdf.gitlab.io/tags.html#authorizedkeyscommand)
    
    ![](https://0xdf.gitlab.io/img/ypuffy-cover.gif)Ypuffy was an OpenBSD box, but the author said it could have really been any OS, and I get that. The entire thing was about protocols that operate on any environment. I’ll use ldap to get a hash, which I can use to authenticate an SMB share. There I find an SSH key that gets me a user shell. From there, I’ll abuse my doas privilege with ssh-keygen to create a signed certificate that I can use to authenticate to the box as root for ssh. In Beyond root, I’ll look at the Xorg privesc vulnerability that became public a month or so after Ypuffy was released, and also explore the web server configuration used in the ssh auth.
    

*   Feb 2, 2019
    
    ### [HTB: Dab](https://0xdf.gitlab.io/2019/02/02/htb-dab.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Dab](https://0xdf.gitlab.io/tags.html#dab) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [flask](https://0xdf.gitlab.io/tags.html#flask) [python](https://0xdf.gitlab.io/tags.html#python) [nginx](https://0xdf.gitlab.io/tags.html#nginx) [wsgi](https://0xdf.gitlab.io/tags.html#wsgi) [memcached](https://0xdf.gitlab.io/tags.html#memcached) [bruteforce](https://0xdf.gitlab.io/tags.html#bruteforce) [hydra](https://0xdf.gitlab.io/tags.html#hydra) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [ldd](https://0xdf.gitlab.io/tags.html#ldd) [ldconfig](https://0xdf.gitlab.io/tags.html#ldconfig) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering) [ida](https://0xdf.gitlab.io/tags.html#ida)
    
    ![](https://0xdf.gitlab.io/img/dab-cover.png)Dab had some really neat elements, with a few trolls thrown in. I’ll start by ignoring a steg troll in an open FTP and looking at two web apps. As I’m able to brute force my way into one, it populates a memcached instance, that I’m then able to query using the other as a proxy. From that instance, I’m able to dump users with md5 password hashes. After cracking twelve of them, one gives me ssh access to the box. From there, I’ll take advantage of my having root level access to the tool that configures how dynamic run-time linking occurs, and use that to pivot to a root shell. In Beyond Root, I’ll look at the web apps and how they are configured, one of the troll binaries, and a cleanup cron job I found but managed to avoid by accident.
    

*   Jan 28, 2019
    
    ### [PWK Notes: Tunneling and Pivoting [Updated]](https://0xdf.gitlab.io/2019/01/28/pwk-notes-tunneling-update1.html)
    
    [pwk](https://0xdf.gitlab.io/tags.html#pwk) [oscp](https://0xdf.gitlab.io/tags.html#oscp) [pivot](https://0xdf.gitlab.io/tags.html#pivot) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [sshuttle](https://0xdf.gitlab.io/tags.html#sshuttle) [meterpreter](https://0xdf.gitlab.io/tags.html#meterpreter)
    
    ![](https://0xdf.gitlab.io/img/tunneling-cover.jpg) That beautiful feeling of shell on a box is such a high. But once you realize that you need to pivot through that host deeper into the network, it can take you a bit out of your comfort zone. I’ve run into this in Sans Netwars, Hackthebox, and now in PWK. In this post I’ll attempt to document the different methods I’ve used for pivoting and tunneling, including different ways to use SSH, sshuttle, and meterpreter, as well as some strategies for how to live from the host you are currently working through. Updated on 28 Jan 2018 to add references to two additional tools, Chisel and SSF.
    

*   Jan 26, 2019
    
    ### [HTB: Reddish](https://0xdf.gitlab.io/2019/01/26/htb-reddish.html)
    
    [Reddish](https://0xdf.gitlab.io/tags.html#reddish) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [node-red](https://0xdf.gitlab.io/tags.html#node-red) [nodejs](https://0xdf.gitlab.io/tags.html#nodejs) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel) [php](https://0xdf.gitlab.io/tags.html#php) [redis](https://0xdf.gitlab.io/tags.html#redis) [rsync](https://0xdf.gitlab.io/tags.html#rsync) [docker](https://0xdf.gitlab.io/tags.html#docker)
    
    ![](https://0xdf.gitlab.io/img/reddish-cover.png)Reddish is one of my favorite boxes on HTB. The exploitation wasn’t that difficult, but it required tunneling communications through multiple networks, and operate in bare-bones environments without the tools I’ve come to expect. Reddish was initially released as a medium difficulty (30 point) box, and after the initial user blood took 9.5 hours, and root blood took 16.5 hours, it was raised to hard (40). Later, it was upped again to insane (50). To get root on this box, I’ll start with an instance of node-red, a javscript browser-based editor to set up flows for IoT. I’ll use that to get a remote shell into a container. From there I’ll pivot using three other containers, escalating privilege in one, before eventually ending up in the host system. Throughout this process, I’ll only have connectivity to the initial container, so I’ll have to maintain tunnels for communication.
    

*   Jan 19, 2019
    
    ### [HTB: SecNotes](https://0xdf.gitlab.io/2019/01/19/htb-secnotes.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [SecNotes](https://0xdf.gitlab.io/tags.html#secnotes) [csrf](https://0xdf.gitlab.io/tags.html#csrf) [xsrf](https://0xdf.gitlab.io/tags.html#xsrf) [second-order-sqli](https://0xdf.gitlab.io/tags.html#second-order-sqli) [second-order](https://0xdf.gitlab.io/tags.html#second-order) [smb](https://0xdf.gitlab.io/tags.html#smb) [wsl](https://0xdf.gitlab.io/tags.html#wsl) [bash.exe](https://0xdf.gitlab.io/tags.html#bash-exe) [winexe](https://0xdf.gitlab.io/tags.html#winexe) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    ![](https://0xdf.gitlab.io/img/secnotes-cover.png)SecNotes is a bit different to write about, since I built it. The goal was to make an easy Windows box that, though the HTB team decided to release it as a medium Windows box. It was the first box I ever submitted to HackTheBox, and overall, it was a great experience. I’ll talk about what I wanted to box to look like from the HTB user’s point of view in Beyond Root. SecNotes had a neat XSRF in the site that was completely bypassed by most people using an unintentional second order SQL injection. Either way, after gaining SMB credentials, it allowed the attacker to upload a webshell, and get a shell on the host. Privesc involved diving into the Linux Subsystem for Windows, finding the history file, and getting the admin creds from there.
    

*   Jan 15, 2019
    
    ### [Holiday Hack 2018: KringleCon](https://0xdf.gitlab.io/holidayhack2018/)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [sans-holiday-hack](https://0xdf.gitlab.io/tags.html#sans-holiday-hack)
    
    ![](https://0xdf.gitlab.io/img/hh18-cover.png) The [Sans Holiday Hack](https://www.holidayhackchallenge.com/) is one of the events I most look forward to each year. This year’s event is based around [KringleCon](https://kringlecon.com/), an infosec conference organized by Santa as a response to the fact that there have been so many attempts to hack Christmas over the last few years. This conference even has a [bunch of talks](https://www.youtube.com/channel/UCNiR-C_VXv_TCFgww5Vczag), some quite useful for completing the challenge, but others that as just interesting as on their own. To complete the Holiday Hack Challenge, I’m asked to enter this virtual conference, walk around, and solve a series of technical challenges. As usual, the challenges were interesting and set up in such a way that it was very beginner friendly, with lots of hints and talks to ensure that you learned something while solving. The designers also implemented several more defensive / forensic challenges this year, which was neat to see.
    

*   Jan 13, 2019
    
    ### [Getting Creds via NTLMv2](https://0xdf.gitlab.io/2019/01/13/getting-net-ntlm-hases-from-windows.html)
    
    [responder](https://0xdf.gitlab.io/tags.html#responder) [mitm](https://0xdf.gitlab.io/tags.html#mitm) [net-ntlmv2](https://0xdf.gitlab.io/tags.html#net-ntlmv2) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [llmnr](https://0xdf.gitlab.io/tags.html#llmnr) [wpad](https://0xdf.gitlab.io/tags.html#wpad) [xp_dirtree](https://0xdf.gitlab.io/tags.html#xp-dirtree)
    
    ![](https://0xdf.gitlab.io/img/responder-cover.png)One of the authentication protocols Windows machines use to authenticate across the network is a challenge / response / validation called Net-NTLMv2. If can get a Windows machine to engage my machine with one of these requests, I can perform an offline cracking to attempt to retrieve their password. In some cases, I could also do a relay attack to authenticate directly to some other server in the network. I’ve run into an interesting case of this recently that were worth sharing. In this post, I’ll focus on ways to get a host to send you a challenge / response. If you’re interested in relaying, leave a command and I’ll consider that too.
    

*   Jan 12, 2019
    
    ### [HTB: Oz](https://0xdf.gitlab.io/2019/01/12/htb-oz.html)
    
    [Oz](https://0xdf.gitlab.io/tags.html#oz) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [api](https://0xdf.gitlab.io/tags.html#api) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [ssti](https://0xdf.gitlab.io/tags.html#ssti) [jinja2](https://0xdf.gitlab.io/tags.html#jinja2) [payloadallthethings](https://0xdf.gitlab.io/tags.html#payloadallthethings) [docker](https://0xdf.gitlab.io/tags.html#docker) [container](https://0xdf.gitlab.io/tags.html#container) [pivot](https://0xdf.gitlab.io/tags.html#pivot) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [port-knocking](https://0xdf.gitlab.io/tags.html#port-knocking) [portainer](https://0xdf.gitlab.io/tags.html#portainer) [tplmap](https://0xdf.gitlab.io/tags.html#tplmap) [jwt](https://0xdf.gitlab.io/tags.html#jwt)
    
    ![](https://0xdf.gitlab.io/img/oz-cover.png) Oz was long. There was a bunch of enumeration at the front, but once you get going, it presented a relatively straight forward yet technically interesting path through two websites, a Server-Side Template Injection, using a database to access an SSH key, and then using the key to get access to the main host. To privesc, I’ll go back into a different container and take advatnage of a vulnarbility in the docker management software to get root access.
    

*   Jan 8, 2019
    
    ### [HTB: Mischief Additional Roots](https://0xdf.gitlab.io/2019/01/08/htb-mischief-more-root.html)
    
    [Mischief](https://0xdf.gitlab.io/tags.html#mischief) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [cve-2018-18955](https://0xdf.gitlab.io/tags.html#cve-2018-18955) [policykit](https://0xdf.gitlab.io/tags.html#policykit) [polkit](https://0xdf.gitlab.io/tags.html#polkit) [pkexec](https://0xdf.gitlab.io/tags.html#pkexec) [pkttyagent](https://0xdf.gitlab.io/tags.html#pkttyagent)
    
    Since publishing my [write-up on Mischief](https://0xdf.gitlab.io/2019/01/05/htb-mischief.html) from HackTheBox, I’ve learned of two additional ways to privesc to root once I have access as loki. The first is another method to get around the fact the `su` was blocked on the host using PolicyKit with the root password. The second was to take advantage of a kernel bug that was publicly released in November, well after Mischief went live. I’ll quickly show both those methods.
    

*   Jan 5, 2019
    
    ### [HTB: Mischief](https://0xdf.gitlab.io/2019/01/05/htb-mischief.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Mischief](https://0xdf.gitlab.io/tags.html#mischief) [ipv6](https://0xdf.gitlab.io/tags.html#ipv6) [snmp](https://0xdf.gitlab.io/tags.html#snmp) [snmpwalk](https://0xdf.gitlab.io/tags.html#snmpwalk) [enyx](https://0xdf.gitlab.io/tags.html#enyx) [command-injection](https://0xdf.gitlab.io/tags.html#command-injection) [hydra](https://0xdf.gitlab.io/tags.html#hydra) [filter](https://0xdf.gitlab.io/tags.html#filter) [facl](https://0xdf.gitlab.io/tags.html#facl) [getfacl](https://0xdf.gitlab.io/tags.html#getfacl) [systemd-run](https://0xdf.gitlab.io/tags.html#systemd-run) [lxc](https://0xdf.gitlab.io/tags.html#lxc) [lxd](https://0xdf.gitlab.io/tags.html#lxd) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [xxd](https://0xdf.gitlab.io/tags.html#xxd) [iptables](https://0xdf.gitlab.io/tags.html#iptables) [color-print](https://0xdf.gitlab.io/tags.html#color-print)
    
    ![](https://0xdf.gitlab.io/img/mischief-cover.png)Mishcief was one of the easier 50 point boxes, but it still provided a lot of opportunity to enumerate things, and forced the attacker to think about and work with IPv6, which is something that likely don’t come naturally to most of us. I’ll use snmp to get both the IPv6 address of the host and credentials from the webserver. From there, I can use those creds to log in and get more creds. The other creds work on a website hosted only on IPv6. That site has command injection, which gives me code execution, a shell as www-data, and creds for loki. loki’s bash history gives me the root password, which I can use to get root, once I get around the fact that file access control lists are used to prevent loki from running su. In beyond root, I’ll look at how I could get RCE without the creds to the website, how I might have exfiled data via ping if there wasn’t a way to see output, the filtering that site did, and the iptables rules.
    

*   Dec 31, 2018
    
    ### [Hackvent 2018: Days 1-12](https://0xdf.gitlab.io/hackvent2018/)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackvent](https://0xdf.gitlab.io/tags.html#hackvent) [jab](https://0xdf.gitlab.io/tags.html#jab) [qrcode](https://0xdf.gitlab.io/tags.html#qrcode) [14-segment-display](https://0xdf.gitlab.io/tags.html#14-segment-display) [javascript](https://0xdf.gitlab.io/tags.html#javascript) [dial-a-pirate](https://0xdf.gitlab.io/tags.html#dial-a-pirate) [certificate-transparency](https://0xdf.gitlab.io/tags.html#certificate-transparency) [piet](https://0xdf.gitlab.io/tags.html#piet) [perl](https://0xdf.gitlab.io/tags.html#perl) [deobfuscation](https://0xdf.gitlab.io/tags.html#deobfuscation) [steganography](https://0xdf.gitlab.io/tags.html#steganography) [stegsolve](https://0xdf.gitlab.io/tags.html#stegsolve) [nodejs](https://0xdf.gitlab.io/tags.html#nodejs) [sandbox-escape](https://0xdf.gitlab.io/tags.html#sandbox-escape) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [telegram](https://0xdf.gitlab.io/tags.html#telegram) [sqli](https://0xdf.gitlab.io/tags.html#sqli)
    
    ![](https://0xdf.gitlab.io/img/hackvent2018-cover.png) Hackvent is a great CTF, where a different challenge is presented each day, and the techniques necessary to solve each challenge vary widely. Like Advent of Code, I only made it through the first half before a combination of increased difficulty, travel for the holidays, and Holiday Hack (and, of course, [winning NetWars TOC](https://twitter.com/0xdf_/status/1074880711285448705)) all led to my stopping Hackvent mid-way. Still, even the first 12 challenges has some neat stuff, and were interesting enough to write up.
    

*   Dec 19, 2018
    
    ### [You Need To Know jq](https://0xdf.gitlab.io/2018/12/19/jq.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [sans-holiday-hack](https://0xdf.gitlab.io/tags.html#sans-holiday-hack) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [jq](https://0xdf.gitlab.io/tags.html#jq) [Waldo](https://0xdf.gitlab.io/tags.html#waldo) [ja3](https://0xdf.gitlab.io/tags.html#ja3) [malware](https://0xdf.gitlab.io/tags.html#malware)
    
    ![](https://0xdf.gitlab.io/img/jq-cover.png)jq is such a nifty tool that not nealry enough people know about. If you’re working with json data, even just small bits here and there, it’s worth knowing the basics to make some simple data manipulations possible. And if you want to become a full on jq wizard, all the better. In this post, I’ll walk through three examples of varying levels of complexity to show off jq. I’ll detail what I did in Waldo, show an example from the 2017 Sans Holiday Hack Challenge, and conclude with a real-world example where I’m looking at SSL/TLS fingerprints.
    

*   Dec 15, 2018
    
    ### [HTB: Waldo](https://0xdf.gitlab.io/2018/12/15/htb-waldo.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Waldo](https://0xdf.gitlab.io/tags.html#waldo) [docker](https://0xdf.gitlab.io/tags.html#docker) [php](https://0xdf.gitlab.io/tags.html#php) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [rbash](https://0xdf.gitlab.io/tags.html#rbash) [capabilities](https://0xdf.gitlab.io/tags.html#capabilities)
    
    ![](https://0xdf.gitlab.io/img/waldo-cover.png) Waldo was a pretty straight forward box, with a few twists that weren’t too difficult to circumvent. First, I’ll take advantage of a php website, that allows me to leak its source. I’ll use that to bypass filters to read files outside the webroot. In doing so, I’ll find an ssh key that gets me into a container. I’ll notice that I can actually ssh back into localhost again to get out of the container, but with a restricted rbash shell. After escaping, I’ll find the tac program will the linux capability set to allow for full system read, giving me full read access over the entire system, including the flag.
    

*   Dec 12, 2018
    
    ### [Advent of Code 2018: Days 1-12](https://0xdf.gitlab.io/adventofcode2018/)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [advent-of-code](https://0xdf.gitlab.io/tags.html#advent-of-code) [python](https://0xdf.gitlab.io/tags.html#python)
    
    ![](https://0xdf.gitlab.io/img/aoc2018-cover.png)Advent of Code is a fun CTF because it forces you to program, and to think about data structures and efficiency. It starts off easy enough, and gets really hard by the end. It’s also a neat learning opportunity, as it’s one of the least competitive CTFs I know of. After the first 20 people solve and the leaderboard is full, people start to post answers on reddit on other places, and you can see how others solved it, or help yourself when you get stuck. I’m going to create one post and just keep updating it with my answers as far as I get.
    

*   Dec 8, 2018
    
    ### [HTB: Active](https://0xdf.gitlab.io/2018/12/08/htb-active.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Active](https://0xdf.gitlab.io/tags.html#active) [active-directory](https://0xdf.gitlab.io/tags.html#active-directory) [gpp-password](https://0xdf.gitlab.io/tags.html#gpp-password) [gpp-decrypt](https://0xdf.gitlab.io/tags.html#gpp-decrypt) [smb](https://0xdf.gitlab.io/tags.html#smb) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [enum4linux](https://0xdf.gitlab.io/tags.html#enum4linux) [GetUserSPNS.py](https://0xdf.gitlab.io/tags.html#getuserspns-py) [kerberoast](https://0xdf.gitlab.io/tags.html#kerberoast) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [psexec.py](https://0xdf.gitlab.io/tags.html#psexec-py) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    ![](https://0xdf.gitlab.io/img/active-cover.png) Active was an example of an easy box that still provided a lot of opportunity to learn. The box was centered around common vulnerabilities associated with Active Directory. There’s a good chance to practice SMB enumeration. It also gives the opportunity to use Kerberoasting against a Windows Domain, which, if you’re not a pentester, you may not have had the chance to do before.
    

*   Dec 2, 2018
    
    ### [PWK Notes: SMB Enumeration Checklist [Updated]](https://0xdf.gitlab.io/2018/12/02/pwk-notes-smb-enumeration-checklist-update1.html)
    
    [oscp](https://0xdf.gitlab.io/tags.html#oscp) [pwk](https://0xdf.gitlab.io/tags.html#pwk) [enumeration](https://0xdf.gitlab.io/tags.html#enumeration) [smb](https://0xdf.gitlab.io/tags.html#smb) [nmblookup](https://0xdf.gitlab.io/tags.html#nmblookup) [smbclient](https://0xdf.gitlab.io/tags.html#smbclient) [rpcclient](https://0xdf.gitlab.io/tags.html#rpcclient) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [enum4linux](https://0xdf.gitlab.io/tags.html#enum4linux) [smbmap](https://0xdf.gitlab.io/tags.html#smbmap)
    
    [Update 2018-12-02] I just learned about smbmap, which is just great. Adding it to the original post. Beyond the enumeration I show here, it will also help enumerate shares that are readable, and can ever execute commands on writable shares. [Original] As I’ve been working through PWK/OSCP for the last month, one thing I’ve noticed is that enumeration of SMB is tricky, and different tools fail / succeed on different hosts. With some input from the NetSecFocus group, I’m building out an SMB enumeration check list here. I’ll include examples, but where I use [PWK labs](https://www.offensive-security.com/information-security-training/penetration-testing-training-kali-linux/), I’ll anonymize the data per their rules. If I’m missing something, leave a comment.
    

*   Nov 30, 2018
    
    ### [HTB: Hawk](https://0xdf.gitlab.io/2018/11/30/htb-hawk.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hawk](https://0xdf.gitlab.io/tags.html#hawk) [drupal](https://0xdf.gitlab.io/tags.html#drupal) [ftp](https://0xdf.gitlab.io/tags.html#ftp) [openssl](https://0xdf.gitlab.io/tags.html#openssl) [openssl-bruteforce](https://0xdf.gitlab.io/tags.html#openssl-bruteforce) [php](https://0xdf.gitlab.io/tags.html#php) [credentials](https://0xdf.gitlab.io/tags.html#credentials) [h2](https://0xdf.gitlab.io/tags.html#h2) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus)
    
    ![](https://0xdf.gitlab.io/img/hawk-cover.png)Hawk was a pretty easy box, that provided the challenge to decrypt a file with openssl, then use those credentials to get admin access to a Drupal website. I’ll use that access to gain execution on the host via php. Credential reuse by the daniel user allows me to escalate to that user. From there, I’ll take advantage of a H2 database to first get arbitrary file read as root, and then target a different vulnerability to get RCE and a root shell. In Beyond Root, I’ll explore the two other listening ports associated with H2, 5435 and 9092.
    

*   Nov 24, 2018
    
    ### [HTB: Smasher](https://0xdf.gitlab.io/2018/11/24/htb-smasher.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [smasher](https://0xdf.gitlab.io/tags.html#smasher) [bof](https://0xdf.gitlab.io/tags.html#bof) [pwntools](https://0xdf.gitlab.io/tags.html#pwntools) [timing-attack](https://0xdf.gitlab.io/tags.html#timing-attack) [padding-oracle](https://0xdf.gitlab.io/tags.html#padding-oracle) [AES](https://0xdf.gitlab.io/tags.html#aes) [path-traversal](https://0xdf.gitlab.io/tags.html#path-traversal)
    
    ![](https://0xdf.gitlab.io/img/smasher-cover.png) Smasher is a really hard box with three challenges that require a detailed understanding of how the code you’re intereacting with works. It starts with an instance of shenfeng tiny-web-server running on port 1111. I’ll use a path traversal vulnerability to access to the root file system. I’ll use that to get a copy of the source and binary for the running web server. With that, I’ll write a buffer overflow exploit to get a reverse shell. Next, I’ll exploit a padding oracle vulnerability to get a copy of the smasher user’s password. From there, I’ll take advantage of a timing vulnerability in setuid binary to read the contents of root.txt. I think it’s possible to get a root shell exploiting a buffer overflow, but I wasn’t able to pull it off (yet). In Beyond Root, I’ll check out the AES script, and show how I patched the checker binary.
    

*   Nov 24, 2018
    
    ### [Buffer Overflow in HTB Smasher](https://0xdf.gitlab.io/2018/11/24/htb-smasher-bof.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [smasher](https://0xdf.gitlab.io/tags.html#smasher) [gdb](https://0xdf.gitlab.io/tags.html#gdb) [bof](https://0xdf.gitlab.io/tags.html#bof) [pwntools](https://0xdf.gitlab.io/tags.html#pwntools)
    
    ![](https://0xdf.gitlab.io/img/smasher-bof-cover.jpg) There was so much to write about for Smasher, it seemed that the buffer overflow in tiny deserved its own post. I’ll walk through my process, code analysis and debugging, through development of a small ROP chain, and show how I trouble shot when things didn’t work. I’ll also show off pwntools along the way.
    

*   Nov 17, 2018
    
    ### [HTB: Jerry](https://0xdf.gitlab.io/2018/11/17/htb-jerry.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Jerry](https://0xdf.gitlab.io/tags.html#jerry) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [tomcat](https://0xdf.gitlab.io/tags.html#tomcat) [war](https://0xdf.gitlab.io/tags.html#war) [msfvenom](https://0xdf.gitlab.io/tags.html#msfvenom) [jar](https://0xdf.gitlab.io/tags.html#jar) [jsp](https://0xdf.gitlab.io/tags.html#jsp) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    ![](https://0xdf.gitlab.io/img/jerry-cover.png) Jerry is quite possibly the easiest box I’ve done on HackTheBox (maybe rivaled only by Blue). In fact, it was rooted in just over 6 minutes! There’s a Tomcat install with a default password for the Web Application Manager. I’ll use that to upload a malicious war file, which returns a system shell, and access to both flags.
    

*   Nov 13, 2018
    
    ### [Malware Analysis: Phishing Docs from HTB Reel](https://0xdf.gitlab.io/2018/11/13/malware-analysis-phishing-docs-from-htb-reel.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Reel](https://0xdf.gitlab.io/tags.html#reel) [malware](https://0xdf.gitlab.io/tags.html#malware) [rtf](https://0xdf.gitlab.io/tags.html#rtf) [hta](https://0xdf.gitlab.io/tags.html#hta) [msfvenom](https://0xdf.gitlab.io/tags.html#msfvenom) [rtfdump](https://0xdf.gitlab.io/tags.html#rtfdump) [oledump](https://0xdf.gitlab.io/tags.html#oledump) [scdbg](https://0xdf.gitlab.io/tags.html#scdbg) [powershell](https://0xdf.gitlab.io/tags.html#powershell) [vbscript](https://0xdf.gitlab.io/tags.html#vbscript) [shellcode](https://0xdf.gitlab.io/tags.html#shellcode)
    
    ![](https://0xdf.gitlab.io/img/reel-malware-cover.png)I regularly use tools like msfvenom or scripts from GitHub to create attacks in HackTheBox or PWK. I wanted to take a minute and look under the hood of the phishing documents I generated to gain access to Reel in HTB, to understand what they are doing. By the end, we’ll understand how the RTF abuses a COM object to download and launch a remote HTA. In the HTA, we’ll see layers of script calling each other, until I find some shellcode loaded into memory by PowerShell and run. I’ll do some initial analysis of that shellcode to see the network connection attempts.
    

*   Nov 10, 2018
    
    ### [HTB: Reel](https://0xdf.gitlab.io/2018/11/10/htb-reel.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Reel](https://0xdf.gitlab.io/tags.html#reel) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [ftp](https://0xdf.gitlab.io/tags.html#ftp) [cve-2017-0199](https://0xdf.gitlab.io/tags.html#cve-2017-0199) [rtf](https://0xdf.gitlab.io/tags.html#rtf) [hta](https://0xdf.gitlab.io/tags.html#hta) [phish](https://0xdf.gitlab.io/tags.html#phish) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [bloodhound](https://0xdf.gitlab.io/tags.html#bloodhound) [powerview](https://0xdf.gitlab.io/tags.html#powerview) [active-directory](https://0xdf.gitlab.io/tags.html#active-directory) [metasploit](https://0xdf.gitlab.io/tags.html#metasploit)
    
    ![](https://0xdf.gitlab.io/img/reel-cover.png)Reel was an awesome box because it presents challenges rarely seen in CTF environments, phishing and Active Directory. Rather than initial access coming through a web exploit, to gain an initial foothold on Reel, I’ll use some documents collected from FTP to craft a malicious rtf file and phishing email that will exploit the host and avoid the protections put into place. Then I’ll pivot through different AD users and groups, taking advantage of their different rights to eventually escalate to administrator. In Beyond Root, I’ll explore remnants of a second path to root that didn’t make the final cut, look at the ACLs on root.txt, examine the script that opens attachments as nico.
    

*   Nov 8, 2018
    
    ### [PowerShell History File](https://0xdf.gitlab.io/2018/11/08/powershell-history-file.html)
    
    [powershell](https://0xdf.gitlab.io/tags.html#powershell) [psreadline](https://0xdf.gitlab.io/tags.html#psreadline) [history](https://0xdf.gitlab.io/tags.html#history)
    
    I came across a situation where I discovered a user’s PSReadline ConsoleHost_history.txt file, and it ended up giving me the information I needed at the time. Most people are aware of the `.bash_history` file. But did you know that the PowerShell equivalent is enabled by default starting in PowerShell v5 on Windows 10? This means this file will become more present over time as systems upgrade.
    

*   Nov 3, 2018
    
    ### [HTB: Dropzone](https://0xdf.gitlab.io/2018/11/03/htb-dropzone.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Dropzone](https://0xdf.gitlab.io/tags.html#dropzone) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [xp](https://0xdf.gitlab.io/tags.html#xp) [tftp](https://0xdf.gitlab.io/tags.html#tftp) [mof](https://0xdf.gitlab.io/tags.html#mof) [wmi](https://0xdf.gitlab.io/tags.html#wmi) [stuxnet](https://0xdf.gitlab.io/tags.html#stuxnet) [ads](https://0xdf.gitlab.io/tags.html#ads) [alternative-data-streams](https://0xdf.gitlab.io/tags.html#alternative-data-streams) [sysinternals](https://0xdf.gitlab.io/tags.html#sysinternals)
    
    ![](https://0xdf.gitlab.io/img/Parachute-win.png) Dropzone was unique in many ways. Right off the bat, an initial nmap scan shows no TCP ports open. I’ll find unauthenticated TFTP on UDP 69, and use that access identify the host OS as Windows XP. From there, I’ll use TFTP to drop a malicious mof file where it will automatically compiled, giving me code execution, in a technique made well know by Stuxnet (though not via TFTP, but rather a SMB 0-day). This technique provides a system shell, but there’s one more twist, as I’ll have to find the flags in alternative data streams of a text file on the desktop. I’ll also take this opportunity to dive in on WMI / MOF and how they were used in Stuxnet.
    

*   Oct 27, 2018
    
    ### [HTB: Bounty](https://0xdf.gitlab.io/2018/10/27/htb-bounty.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Bounty](https://0xdf.gitlab.io/tags.html#bounty) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [asp](https://0xdf.gitlab.io/tags.html#asp) [upload](https://0xdf.gitlab.io/tags.html#upload) [nishang](https://0xdf.gitlab.io/tags.html#nishang) [lonelypotato](https://0xdf.gitlab.io/tags.html#lonelypotato) [potato](https://0xdf.gitlab.io/tags.html#potato) [meterpreter](https://0xdf.gitlab.io/tags.html#meterpreter) [ms10-051](https://0xdf.gitlab.io/tags.html#ms10-051) [ms16-014](https://0xdf.gitlab.io/tags.html#ms16-014) [web-config](https://0xdf.gitlab.io/tags.html#web-config) [Sherlock](https://0xdf.gitlab.io/tags.html#sherlock) [watson](https://0xdf.gitlab.io/tags.html#watson) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    ![](https://0xdf.gitlab.io/img/bounty-cover.png) Bounty was one of the easier boxes I’ve done on HTB, but it still showcased a neat trick for initial access that involved embedding ASP code in a web.config file that wasn’t subject to file extension filtering. Initial shell provides access as an unprivileged user on a relatively unpatched host, vulnerable to several kernel exploits, as well as a token privilege attack. I’ll show a handful of ways to enumerate and to escalate privilege, including a really neat new tool, Watson. When I first wrote this post, Watson wouldn’t run on Bounty, but thanks to some quick work from Rasta Mouse and Mark S, I was able to update the post to include it.
    

*   Oct 21, 2018
    
    ### [HTB TartarSauce: backuperer Follow-Up](https://0xdf.gitlab.io/2018/10/21/htb-tartarsauce-part-2-backuperer-follow-up.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [TartarSauce](https://0xdf.gitlab.io/tags.html#tartarsauce) [tar](https://0xdf.gitlab.io/tags.html#tar) [diff](https://0xdf.gitlab.io/tags.html#diff)
    
    I always watch IppSec’s videos on the retired box, because even if I completed the box, I typically learn something. Watching [IppSec’s TartarSauce video](https://www.youtube.com/watch?v=9MeBiP637ZA) yesterday left me with three things I wanted to play with a bit more in depth, each related to the `backuperer` script. First, the issue of a bash if statement, and how it evaluates on exit status. Next, how Linux handles permissions and ownership between hosts and in and out of archives. Finally, I was wrong in thinking there wasn’t a way to get a root shell… so of course I have to do that.
    

*   Oct 20, 2018
    
    ### [HTB: TartarSauce](https://0xdf.gitlab.io/2018/10/20/htb-tartarsauce.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [TartarSauce](https://0xdf.gitlab.io/tags.html#tartarsauce) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [wordpress](https://0xdf.gitlab.io/tags.html#wordpress) [wpscan](https://0xdf.gitlab.io/tags.html#wpscan) [php](https://0xdf.gitlab.io/tags.html#php) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [rfi](https://0xdf.gitlab.io/tags.html#rfi) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [tar](https://0xdf.gitlab.io/tags.html#tar) [pspy](https://0xdf.gitlab.io/tags.html#pspy) [monstra](https://0xdf.gitlab.io/tags.html#monstra) [cron](https://0xdf.gitlab.io/tags.html#cron) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    ![](https://0xdf.gitlab.io/img/tartar-cover.png)TartarSauce was a box with lots of steps, and an interesting focus around two themes: trolling us, and the tar binary. For initial access, I’ll find a barely functional WordPress site with a plugin vulnerable to remote file include. After abusing that RFI to get a shell, I’ll privesc twice, both times centered around tar; once through sudo tar, and once needing to manipulate an archive before a sleep runs out. In beyond root, I’ll look at some of the rabbit holes I went down, and show a short script I created to quickly get initial access and do the first privesc in one step.
    

*   Oct 13, 2018
    
    ### [HTB: DevOops](https://0xdf.gitlab.io/2018/10/13/htb-devoops.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [DevOops](https://0xdf.gitlab.io/tags.html#devoops) [xxe](https://0xdf.gitlab.io/tags.html#xxe) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [git](https://0xdf.gitlab.io/tags.html#git) [pickle](https://0xdf.gitlab.io/tags.html#pickle) [deserialization](https://0xdf.gitlab.io/tags.html#deserialization) [Canape](https://0xdf.gitlab.io/tags.html#canape) [rss](https://0xdf.gitlab.io/tags.html#rss) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus)
    
    ![](https://0xdf.gitlab.io/img/devoops-cover.png)DevOops was a really fun box that did a great job of providing interesting challenges that weren’t too difficult to solve. I’ll show how to gain access using XXE to leak the users SSH key, and then how I get root by discovering the root SSH key in an old git commit. In Beyond Root, I’ll show an alternative path to user shell exploiting a python pickle deserialization bug.
    

*   Oct 11, 2018
    
    ### [PWK Notes: Post-Exploitation Windows File Transfers with SMB](https://0xdf.gitlab.io/2018/10/11/pwk-notes-post-exploitation-windows-file-transfers.html)
    
    [pwk](https://0xdf.gitlab.io/tags.html#pwk) [oscp](https://0xdf.gitlab.io/tags.html#oscp) [smb](https://0xdf.gitlab.io/tags.html#smb) [impacket](https://0xdf.gitlab.io/tags.html#impacket) [exfil](https://0xdf.gitlab.io/tags.html#exfil) [upload](https://0xdf.gitlab.io/tags.html#upload)
    
    Moving files to and from a compromised Linux machine is, in general, pretty easy. You’ve got nc, wget, curl, and if you get really desperate, base64 copy and paste. Windows, is another issue all together. PowerShell makes this somewhat easier, but for a lot of the PWK labs, the systems are too old to have PowerShell. The course material goes over a few ways to achieve this, but they don’t cover my favorite - SMB. This may be less realistic in an environment where you have to connect from a victim machine back to your attacker box over the public internet (where SMB could be blocked), but for environments like PWK labs and HTB where you are vpned into the same LAN as your targets, it works great.
    

*   Sep 29, 2018
    
    ### [HTB: Sunday](https://0xdf.gitlab.io/2018/09/29/htb-sunday.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Sunday](https://0xdf.gitlab.io/tags.html#sunday) [finger](https://0xdf.gitlab.io/tags.html#finger) [hashcat](https://0xdf.gitlab.io/tags.html#hashcat) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [wget](https://0xdf.gitlab.io/tags.html#wget) [shadow](https://0xdf.gitlab.io/tags.html#shadow) [sudoers](https://0xdf.gitlab.io/tags.html#sudoers) [gtfobins](https://0xdf.gitlab.io/tags.html#gtfobins) [arbitrary-write](https://0xdf.gitlab.io/tags.html#arbitrary-write) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    Sunday is definitely one of the easier boxes on HackTheBox. It had a lot of fun concepts, but on a crowded server, they step on each other. We start by using finger to brute-force enumerate users, though once once person logs in, the answer is given to anyone working that host. I’m never a huge fan of asking people to just guess obvious passwords, but after that, there are a couple more challenges, including a troll that proves useful later, some password cracking, and a ton of neat opportunities to complete the final privesc using wget. I’ll show 6 ways to use wget to get root. Finally, in Beyond Root, I’ll explore the overwrite script being run by root, finger for file transfer, and execution without read.
    

*   Sep 22, 2018
    
    ### [HTB: Olympus](https://0xdf.gitlab.io/2018/09/22/htb-olympus.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Olympus](https://0xdf.gitlab.io/tags.html#olympus) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [zonetransfer](https://0xdf.gitlab.io/tags.html#zonetransfer) [Xdebug](https://0xdf.gitlab.io/tags.html#xdebug) [aircrack-ng](https://0xdf.gitlab.io/tags.html#aircrack-ng) [802-11](https://0xdf.gitlab.io/tags.html#802-11) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [port-knocking](https://0xdf.gitlab.io/tags.html#port-knocking) [docker](https://0xdf.gitlab.io/tags.html#docker) [cve-2018-15473](https://0xdf.gitlab.io/tags.html#cve-2018-15473)
    
    Olympus was, for the most part, a really fun box, where we got to bounce around between different containers, and a clear path of challenges was presented to us. The creator did a great job of getting interesting challenges such as dns and wifi cracking into a HTB format. There was one jump I wasn’t too excited to have to make, but overall, this box was a lot of fun to attack.
    

*   Sep 15, 2018
    
    ### [HTB: Canape](https://0xdf.gitlab.io/2018/09/15/htb-canape.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [python](https://0xdf.gitlab.io/tags.html#python) [pickle](https://0xdf.gitlab.io/tags.html#pickle) [deserialization](https://0xdf.gitlab.io/tags.html#deserialization) [couchdb](https://0xdf.gitlab.io/tags.html#couchdb) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Canape](https://0xdf.gitlab.io/tags.html#canape) [flask](https://0xdf.gitlab.io/tags.html#flask) [pip](https://0xdf.gitlab.io/tags.html#pip) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [cve-2017-12635](https://0xdf.gitlab.io/tags.html#cve-2017-12635) [cve-1017-12636](https://0xdf.gitlab.io/tags.html#cve-1017-12636) [cve-2018-8007](https://0xdf.gitlab.io/tags.html#cve-2018-8007) [erl](https://0xdf.gitlab.io/tags.html#erl) [erlang](https://0xdf.gitlab.io/tags.html#erlang)
    
    Canape is one of my favorite boxes on HTB. There is a flask website with a pickle deserialization bug. I find that bug by taking advantage of an exposed git repo on the site. With a user shell, we can exploit CouchDB to gain admin access, where we get homer’s password. I went down several rabbit holes trying to get code execution through couchdb, succeeding with EMPD, succeeding with one config change as root for CVE-2018-8007, and failing with CVE-2017-12636. Finally, I’ll take advantage of our user having sudo rights to run pip, and first get a copy of the flag, and then take it all the way to root shell.
    

*   Sep 15, 2018
    
    ### [Malware Analysis: BMW_Of_Sterlin.doc](https://0xdf.gitlab.io/2018/09/15/malware-analysis-bmw_of_sterlindoc.html)
    
    [malware](https://0xdf.gitlab.io/tags.html#malware) [vba](https://0xdf.gitlab.io/tags.html#vba) [doc](https://0xdf.gitlab.io/tags.html#doc) [powershell](https://0xdf.gitlab.io/tags.html#powershell) [dosfuscation](https://0xdf.gitlab.io/tags.html#dosfuscation) [olevba](https://0xdf.gitlab.io/tags.html#olevba)
    
    Someone on an InfoSec group I participate in asked for help looking at a potentially malicious word doc. I took a quick look, and when I sent back the command line that came out, he asked if I could share how I was able to de-obfuscate quickly. In writing it up for him, I figured it might help others as well, so I’ll post it here as an example.
    

*   Sep 12, 2018
    
    ### [Malware Analysis: YourExploit.pdf](https://0xdf.gitlab.io/2018/09/12/malware-analysis-yourexploitpdf.html)
    
    [malware](https://0xdf.gitlab.io/tags.html#malware) [pdf](https://0xdf.gitlab.io/tags.html#pdf) [pdf-parser](https://0xdf.gitlab.io/tags.html#pdf-parser) [pdfid](https://0xdf.gitlab.io/tags.html#pdfid) [nanocore](https://0xdf.gitlab.io/tags.html#nanocore) [vbscript](https://0xdf.gitlab.io/tags.html#vbscript)
    
    Pretty simple PDF file was uploaded to VT today, and only 11 of our 59 vendors mark is as malicious, despite it’s being pretty tiny and clearly bad. The file makes no effort at showing any real cover, and could even be a test upload from the malicious actor. The file writes a vbs script which downloads the next stage, and then runs the script and then the resulting binary. The stage two is still up, so I got a copy, which I was able to identify as nanocore, and do some basic dynamic analysis of that as well.
    

*   Sep 8, 2018
    
    ### [HTB: Poison](https://0xdf.gitlab.io/2018/09/08/htb-poison.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Poison](https://0xdf.gitlab.io/tags.html#poison) [log-poisoning](https://0xdf.gitlab.io/tags.html#log-poisoning) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [vnc](https://0xdf.gitlab.io/tags.html#vnc) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    Poison was one of the first boxes I attempted on HTB. The discovery of a relatively obvious local file include vulnerability drives us towards a web shell via log poisoning. From there, we can find a users password out in the clear, albeit lightly obfuscated, and use that to get ssh access. With our ssh access, we find VNC listening as root on localhost, and
    

*   Sep 1, 2018
    
    ### [HTB: Stratosphere](https://0xdf.gitlab.io/2018/09/01/htb-stratosphere.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Stratosphere](https://0xdf.gitlab.io/tags.html#stratosphere) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [python](https://0xdf.gitlab.io/tags.html#python) [struts](https://0xdf.gitlab.io/tags.html#struts) [cve](https://0xdf.gitlab.io/tags.html#cve) [cve-2017-9805](https://0xdf.gitlab.io/tags.html#cve-2017-9805) [cve-2017-5638](https://0xdf.gitlab.io/tags.html#cve-2017-5638)
    
    Stratosphere is a super fun box, with an Apache Struts vulnerability that we can exploit to get single command execution, but not a legit full shell. I’ll use the Ippsec mkfifo pipe method to write my own shell. Then there’s a python script that looks like it will give us the root flag if we only crack some hashes. However, we actually have to exploit the script, to get a root shell.
    

*   Aug 25, 2018
    
    ### [SecNotes now live on HackTheBox](https://0xdf.gitlab.io/2018/08/25/secnotes-now-live-on-hackthebox.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [SecNotes](https://0xdf.gitlab.io/tags.html#secnotes) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [windows](https://0xdf.gitlab.io/tags.html#windows)
    
    My first submission to HTB, SecNotes, went live today! I was aiming for an easy (20 pt) Windows box, but it released as a medium (30 pt) box. First blood for user just fell, 1 hour and 9 minutes in. Still waiting on root. I hope people enjoy, and if you do the box, please reach out to me on the forums or direct message and let me know what you thought of it, and how you solved it. I’d be very excited to hear if there were any unintended paths discovered.
    

*   Aug 25, 2018
    
    ### [HTB: Celestial](https://0xdf.gitlab.io/2018/08/25/htb-celestial.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Celestial](https://0xdf.gitlab.io/tags.html#celestial) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nodejs](https://0xdf.gitlab.io/tags.html#nodejs) [deserialization](https://0xdf.gitlab.io/tags.html#deserialization) [Aragog](https://0xdf.gitlab.io/tags.html#aragog) [pspy](https://0xdf.gitlab.io/tags.html#pspy) [cron](https://0xdf.gitlab.io/tags.html#cron) [oswe-like](https://0xdf.gitlab.io/tags.html#oswe-like)
    
    Celestial is a fairly easy box that gives us a chance to play with deserialization vulnerabilities in Node.js. Weather it’s in struts, or python’s pickle, or in Node.js, deserialization of user input is almost always a bad idea, and here’s we’ll show why. To escalate, we’ll take advantage of a cron running the user’s code as root.
    

*   Aug 9, 2018
    
    ### [Malware Analysis: dotanFile.doc](https://0xdf.gitlab.io/2018/08/09/malware-analysis-dotanfiledoc.html)
    
    [malware](https://0xdf.gitlab.io/tags.html#malware)
    
    On first finding this sample, I was excited to think that I had found something interesting, rarely detected, and definitely malicious so close to when it was potentially used in a phishing attack. The more analysis I did, the more it became clear this was more likely a testing document, used by a security team evaluating their employees or an endpoint product. Still, it was an interesting sample to play with, and understand how it does interesting things like C2 protocol detection and Sandbox detection.
    

*   Aug 7, 2018
    
    ### [Malware Analysis: Penn National Health and Wellness Program 2018.doc](https://0xdf.gitlab.io/2018/08/07/malware-analysis-penn-national-health-and-wellness-program-2018doc.html)
    
    [malware](https://0xdf.gitlab.io/tags.html#malware) [doc](https://0xdf.gitlab.io/tags.html#doc) [vba](https://0xdf.gitlab.io/tags.html#vba) [msbuild](https://0xdf.gitlab.io/tags.html#msbuild) [csproj](https://0xdf.gitlab.io/tags.html#csproj) [dns](https://0xdf.gitlab.io/tags.html#dns) [document-variables](https://0xdf.gitlab.io/tags.html#document-variables) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [c#](https://0xdf.gitlab.io/tags.html#c) [oledump](https://0xdf.gitlab.io/tags.html#oledump)
    
    This word document contains a short bit of VBA that’s obfuscated using Word document variables to store the strings that might be identified in email filters and by AV. This seems to be effective, given the VT dection ratio. In fact, I came across this sample in conversation with someone who worked for one of the few products that was catching this sample. The VBA drops a Visual Basic C# project file, and runs it with msbuild, which executes a compilation Task. This code uses DNS TXT records to decrypt a next stage payload. Unfortunately, since the DNS record is no longer present.
    

*   Aug 6, 2018
    
    ### [Malware Analysis: inovoice-019338.pdf](https://0xdf.gitlab.io/2018/08/06/malware-analysis-inovoice-019338pdf.html)
    
    [malware](https://0xdf.gitlab.io/tags.html#malware) [pdf](https://0xdf.gitlab.io/tags.html#pdf) [pdfid](https://0xdf.gitlab.io/tags.html#pdfid) [pdf-parser](https://0xdf.gitlab.io/tags.html#pdf-parser) [powershell](https://0xdf.gitlab.io/tags.html#powershell) [settingcontent-ms](https://0xdf.gitlab.io/tags.html#settingcontent-ms) [FlawedAmmyy](https://0xdf.gitlab.io/tags.html#flawedammyy)
    
    This is a neat PDF sample that I saw mentioned on [@c0d3inj3cT](https://twitter.com/c0d3inj3cT/status/1017553433128103936)’s Twitter, and wanted to take a look for myself. As [@c0d3inj3cT](https://twitter.com/c0d3inj3cT/status/1017553433128103936) says, it is a PDF that drops a SettingsContent-ms file, which then uses PowerShell to download and execute the next stage. I had been on the lookout for PDFs that try to run code to play with, so this seemed like a good place to dive in.
    

*   Aug 4, 2018
    
    ### [HTB: Silo](https://0xdf.gitlab.io/2018/08/04/htb-silo.html)
    
    [Silo](https://0xdf.gitlab.io/tags.html#silo) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Oracle](https://0xdf.gitlab.io/tags.html#oracle) [odat](https://0xdf.gitlab.io/tags.html#odat) [sqlplus](https://0xdf.gitlab.io/tags.html#sqlplus) [nishang](https://0xdf.gitlab.io/tags.html#nishang) [aspx](https://0xdf.gitlab.io/tags.html#aspx) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [volatility](https://0xdf.gitlab.io/tags.html#volatility) [passthehash](https://0xdf.gitlab.io/tags.html#passthehash) [RottenPotato](https://0xdf.gitlab.io/tags.html#rottenpotato) [potato](https://0xdf.gitlab.io/tags.html#potato) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    Silo was the first time I’ve had the opportunity to play around with exploiting a Oracle database. After the struggle of getting the tools installed and learning the ins and outs of using them, we can take advantage of this database to upload a webshell to the box. Then with the webshell, we can get a powershell shell access as a low-priv user. To privesc, we’ll have to break out our memory forensics skillset to get a hash out of a memory dump, which then we can pass back in a pass the hash attack to get a system shell. That’s all if we decided not to take the shortcut and just use the Oracle database (running as system) to read both flag files.
    

*   Jul 31, 2018
    
    ### [Malware Analysis: mud.doc](https://0xdf.gitlab.io/2018/07/31/malware-analysis-muddoc.html)
    
    [doc](https://0xdf.gitlab.io/tags.html#doc) [vba](https://0xdf.gitlab.io/tags.html#vba) [malware](https://0xdf.gitlab.io/tags.html#malware) [crypto](https://0xdf.gitlab.io/tags.html#crypto) [phish](https://0xdf.gitlab.io/tags.html#phish) [wmi](https://0xdf.gitlab.io/tags.html#wmi)
    
    This phishing document was interesting for not only its lure / cover, but also for the way it used encryption to target users who had a domain with certain key words in it. While brute forcing the domains only results in some potentially financial key words, the stage 2 domain acts as a pivot to find an original phish email in VT, which shows this was quite targeted after all.
    

*   Jul 28, 2018
    
    ### [HTB: Valentine](https://0xdf.gitlab.io/2018/07/28/htb-valentine.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Valentine](https://0xdf.gitlab.io/tags.html#valentine) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [heartbleed](https://0xdf.gitlab.io/tags.html#heartbleed) [tmux](https://0xdf.gitlab.io/tags.html#tmux) [dirtycow](https://0xdf.gitlab.io/tags.html#dirtycow) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    Valentine was one of the first hosts I solved on hack the box. We’ll use heartbleed to get the password for an SSH key that we find through enumeration. There’s two paths to privesc, but I’m quite partial to using the root tmux session. The box is very much on the easier side for HTB.
    

*   Jul 24, 2018
    
    ### [SANS SEC599 Review](https://0xdf.gitlab.io/2018/07/24/sans-sec599-review.html)
    
    [training](https://0xdf.gitlab.io/tags.html#training) [review](https://0xdf.gitlab.io/tags.html#review) [purple-team](https://0xdf.gitlab.io/tags.html#purple-team)
    
    I had the chance to take [SANS SEC599](https://www.sans.org/course/defeating-advanced-adversaries-kill-chain-defenses), “Defeating Advanced Adversaries - Purple Team Tactics & Kill Chain Defenses” last week at SANSFIRE. The class is one of the newer SANS offerings, and so I suspect it will be changing and updating rapidly. There are some things I would change about the class, but overall, I enjoyed the class, definitely learned things that I didn’t know before, and got to meet some really smart people.
    

*   Jul 21, 2018
    
    ### [HTB: Aragog](https://0xdf.gitlab.io/2018/07/21/htb-aragog.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [Aragog](https://0xdf.gitlab.io/tags.html#aragog) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [xxe](https://0xdf.gitlab.io/tags.html#xxe) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [pspy](https://0xdf.gitlab.io/tags.html#pspy) [wordpress](https://0xdf.gitlab.io/tags.html#wordpress) [cron](https://0xdf.gitlab.io/tags.html#cron)
    
    Aragog provided a chance to play with XML External Entity (XXE) vulnerabilities, as well as a chance to modify a running website to capture user credentials.
    

*   Jul 15, 2018
    
    ### [HTB: Bart](https://0xdf.gitlab.io/2018/07/15/htb-bart.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Bart](https://0xdf.gitlab.io/tags.html#bart) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [nmap](https://0xdf.gitlab.io/tags.html#nmap) [gobuster](https://0xdf.gitlab.io/tags.html#gobuster) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [cewl](https://0xdf.gitlab.io/tags.html#cewl) [bruteforce](https://0xdf.gitlab.io/tags.html#bruteforce) [log-poisoning](https://0xdf.gitlab.io/tags.html#log-poisoning) [php](https://0xdf.gitlab.io/tags.html#php) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [nishang](https://0xdf.gitlab.io/tags.html#nishang) [winlogon](https://0xdf.gitlab.io/tags.html#winlogon) [powershell-run-as](https://0xdf.gitlab.io/tags.html#powershell-run-as) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus)
    
    Bart starts simple enough, only listening on port 80. Yet it ends up providing a path to user shell that requires enumeration of two different sites, bypassing two logins, and then finding a file upload / LFI webshell. The privesc is relateively simple, yet I ran into an interesting issue that caused me to miss it at first. Overall, a fun box with lots to play with.
    

*   Jul 7, 2018
    
    ### [Second Order SQL-Injection on HTB Nightmare](https://0xdf.gitlab.io/2018/07/07/second-order-sql-injection-on-htb-nightmare.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Nightmare](https://0xdf.gitlab.io/tags.html#nightmare) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [sqlmap](https://0xdf.gitlab.io/tags.html#sqlmap) [tamper](https://0xdf.gitlab.io/tags.html#tamper) [second-order-sqli](https://0xdf.gitlab.io/tags.html#second-order-sqli) [second-order](https://0xdf.gitlab.io/tags.html#second-order)
    
    Nightmare just retired, and it was a insanely difficult box. Rather than do a full walkthrough, I wanted to focus on a write-up of the second-order SQL injection necessary as a first step for this host.
    

*   Jul 7, 2018
    
    ### [Malware Analysis: Faktura_VAT_115590300178.js](https://0xdf.gitlab.io/2018/07/07/malware-analysis-faktura_vat_115590300178js.html)
    
    [malware](https://0xdf.gitlab.io/tags.html#malware) [javascript](https://0xdf.gitlab.io/tags.html#javascript) [procmon](https://0xdf.gitlab.io/tags.html#procmon) [procdot](https://0xdf.gitlab.io/tags.html#procdot) [process-hacker](https://0xdf.gitlab.io/tags.html#process-hacker) [logging](https://0xdf.gitlab.io/tags.html#logging) [powershell](https://0xdf.gitlab.io/tags.html#powershell)
    
    I spent some time looking at this javascript sample from VT. Based on both the file extension and the fact that I couldn’t get it to run in `spidermonkey` or `internet explorer`, it seems likely that this was a `.js` file sent as a phishing attachment that acts as a downloader to get the next stage from the c2 server. I show how to use Process Hacker, ProcMon, ProcDot, and Windows loggings to observer the PowerShell commands, and thus determine what the mawlare was doing.
    

*   Jun 30, 2018
    
    ### [HTB: Nibbles](https://0xdf.gitlab.io/2018/06/30/htb-nibbles.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Nibbles](https://0xdf.gitlab.io/tags.html#nibbles) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [meterpreter](https://0xdf.gitlab.io/tags.html#meterpreter) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [cve](https://0xdf.gitlab.io/tags.html#cve) [cve-2015-6967](https://0xdf.gitlab.io/tags.html#cve-2015-6967) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    Nibbles is one of the easier boxes on HTB. It hosts a vulnerable instance of [nibbleblog](http://www.nibbleblog.com/). There’s a Metasploit exploit for it, but it’s also easy to do without MSF, so I’ll show both. The privesc involves abusing `sudo` on a file that is world-writable.
    

*   Jun 23, 2018
    
    ### [HTB: Falafel](https://0xdf.gitlab.io/2018/06/23/htb-falafel.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Falafel](https://0xdf.gitlab.io/tags.html#falafel) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [sqlmap](https://0xdf.gitlab.io/tags.html#sqlmap) [sqli](https://0xdf.gitlab.io/tags.html#sqli) [type-juggling](https://0xdf.gitlab.io/tags.html#type-juggling) [php](https://0xdf.gitlab.io/tags.html#php) [file-upload](https://0xdf.gitlab.io/tags.html#file-upload) [webshell](https://0xdf.gitlab.io/tags.html#webshell) [framebuffer](https://0xdf.gitlab.io/tags.html#framebuffer) [/dev/fb0](https://0xdf.gitlab.io/tags.html#dev-fb0) [debugfs](https://0xdf.gitlab.io/tags.html#debugfs) [oscp-plus](https://0xdf.gitlab.io/tags.html#oscp-plus) [oswe-like](https://0xdf.gitlab.io/tags.html#oswe-like)
    
    Falafel is one of the best put together boxes on HTB. The author does a great job of creating a path with lots of technical challenges that are both not that hard and require a good deal of learning and understanding what’s going on. And there are hints distributed to us along the way.
    

*   Jun 18, 2018
    
    ### [HTB: Chatterbox](https://0xdf.gitlab.io/2018/06/18/htb-chatterbox.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Chatterbox](https://0xdf.gitlab.io/tags.html#chatterbox) [ctf](https://0xdf.gitlab.io/tags.html#ctf) [msfvenom](https://0xdf.gitlab.io/tags.html#msfvenom) [meterpreter](https://0xdf.gitlab.io/tags.html#meterpreter) [AChat](https://0xdf.gitlab.io/tags.html#achat) [AutoRunScript](https://0xdf.gitlab.io/tags.html#autorunscript) [nishang](https://0xdf.gitlab.io/tags.html#nishang) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    Chatterbox is one of the easier rated boxes on HTB. Overall, this box was both easy and frustrating, as there was really only one exploit to get all the way to system, but yet there were many annoyances along the way. While I typically try to avoid Meterpreter, I’ll use it here because it’s an interesting chance to learn / play with the Metasploit AutoRunScript to migrate immediately after exploitation, so that I could maintain a stable shell.
    

*   Jun 10, 2018
    
    ### [Intro to SSH Tunneling](https://0xdf.gitlab.io/2018/06/10/intro-to-ssh-tunneling.html)
    
    [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [ssh](https://0xdf.gitlab.io/tags.html#ssh) [tunnel](https://0xdf.gitlab.io/tags.html#tunnel)
    
    I came across a situation on a [htb](https://www.hackthebox.eu/) box today where I needed IE to get a really slow, older, OWA page to fully function and do what I needed to do. I had a Windows vm around, but it was relatively isolated, and no able to talk directly to my kali vm. SSH tunneling turned out to be the easiest solution here, and since I get questions about SSH tunneling all the time, I figured it would be good to write up a short description.
    

*   Jun 8, 2018
    
    ### [PSDecode, follow-on analysis of Emotet samples](https://0xdf.gitlab.io/2018/06/08/malware-analysis-facture-impayee-30-mai0730-04071885doc.html)
    
    [emotet](https://0xdf.gitlab.io/tags.html#emotet) [malware](https://0xdf.gitlab.io/tags.html#malware) [doc](https://0xdf.gitlab.io/tags.html#doc) [powershell](https://0xdf.gitlab.io/tags.html#powershell) [invoke-obfuscation](https://0xdf.gitlab.io/tags.html#invoke-obfuscation) [PSDecode](https://0xdf.gitlab.io/tags.html#psdecode)
    
    In [my analysis of an emotet sample](https://0xdf.gitlab.io/2018/06/04/emotet-doc-sample.html), I came across [PSDecode](https://github.com/R3MRUM/PSDecode), and, after some back and forth with the author and a couple updates, got it working on this sample. The tool is very cool. What follows is analysis of a different emotet phishing document similar to the other one I was looking at, as well as `PSDecode` output for the previous sample.
    

*   Jun 4, 2018
    
    ### [Malware: Facture-impayee-30-mai#0730-04071885.doc](https://0xdf.gitlab.io/2018/06/04/emotet-doc-sample.html)
    
    [malware](https://0xdf.gitlab.io/tags.html#malware) [doc](https://0xdf.gitlab.io/tags.html#doc) [vba](https://0xdf.gitlab.io/tags.html#vba) [powershell](https://0xdf.gitlab.io/tags.html#powershell) [emotet](https://0xdf.gitlab.io/tags.html#emotet) [invoke-obfuscation](https://0xdf.gitlab.io/tags.html#invoke-obfuscation)
    
    Interesting sample from VT which ends up being a phishing document for the Emotet malware.
    

*   Jun 3, 2018
    
    ### [HTB: CrimeStoppers](https://0xdf.gitlab.io/2018/06/03/htb-crimestoppers.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [CrimeStoppers](https://0xdf.gitlab.io/tags.html#crimestoppers) [php](https://0xdf.gitlab.io/tags.html#php) [php-wrapper](https://0xdf.gitlab.io/tags.html#php-wrapper) [lfi](https://0xdf.gitlab.io/tags.html#lfi) [ida](https://0xdf.gitlab.io/tags.html#ida) [reverse-engineering](https://0xdf.gitlab.io/tags.html#reverse-engineering)
    
    This is one of my favorite boxes on HTB. It’s got a good flow, and I learned a bunch doing it. We got to tackle an LFI that allows us to get source for the site, and then we turn that LFI into RCE toget access. From there we get access to a Mozilla profile, which allows privesc to a user, and from there we find someone’s already left a modified rootme apache module in place. We can RE that mod to get root on the system.
    

*   May 12, 2018
    
    ### [HTB: FluxCapacitor](https://0xdf.gitlab.io/2018/05/12/htb-fluxcapacitor.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [FluxCapacitor](https://0xdf.gitlab.io/tags.html#fluxcapacitor) [waf](https://0xdf.gitlab.io/tags.html#waf) [wfuzz](https://0xdf.gitlab.io/tags.html#wfuzz) [sudo](https://0xdf.gitlab.io/tags.html#sudo)
    
    Probably my least favorite box on HTB, largely because it involved a lot of guessing. I did enjoy looking for privesc without having a shell on the host.
    

*   Apr 29, 2018
    
    ### [HTB: Bashed](https://0xdf.gitlab.io/2018/04/29/htb-bashed.html)
    
    [ctf](https://0xdf.gitlab.io/tags.html#ctf) [hackthebox](https://0xdf.gitlab.io/tags.html#hackthebox) [Bashed](https://0xdf.gitlab.io/tags.html#bashed) [php](https://0xdf.gitlab.io/tags.html#php) [sudo](https://0xdf.gitlab.io/tags.html#sudo) [cron](https://0xdf.gitlab.io/tags.html#cron) [oscp-like](https://0xdf.gitlab.io/tags.html#oscp-like)
    
    Bashed retired from hackthebox.eu today. Here’s my notes transformed into a walkthrough. These notes are from a couple months ago, and they are a bit raw, but posting here anyway.
    

*   Jan 15, 2018
    
    ### [Home Lab On The Super Cheap - ESXi](https://0xdf.gitlab.io/2018/01/15/home-lab-on-the-super-cheap-esxi.html)
    
    [MacPro](https://0xdf.gitlab.io/tags.html#macpro) [home-lab](https://0xdf.gitlab.io/tags.html#home-lab) [ESXi](https://0xdf.gitlab.io/tags.html#esxi)
    
    Getting the hypervisor installed is the next step.
    

*   Jan 15, 2018
    
    ### [Home Lab On The Super Cheap - The Hardware](https://0xdf.gitlab.io/2018/01/15/home-lab-on-the-super-cheap-the-hardware.html)
    
    [Ebay](https://0xdf.gitlab.io/tags.html#ebay) [MacPro](https://0xdf.gitlab.io/tags.html#macpro) [home-lab](https://0xdf.gitlab.io/tags.html#home-lab)
    
    The benefits of a home lab are numerous to anyone into infosec, CTFs, and/or malware analysis. Here’s how I approached it on the cheap.