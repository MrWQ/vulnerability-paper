> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [tttang.com](https://tttang.com/archive/1726/)

> 跳跳糖 - 安全与分享社区

[一、JDBC 拼接不当造成 sql 注入](#toc_jdbcsql)
------------------------------------

​ JDBC 存在两种方法执行 SQL 语句，分别为 PreparedStatement 和 Statement，相比 Statement ，PreparedStatement 会对 SQL 语句进行预编译，Statement 会直接拼接 sql 语句造成 SQL 注入漏洞

### [1.Statement](#toc_1statement)

​ 示例代码中直接使用 statement.executeQuery(sql)，存在 sql 注入漏洞

```
@RequestMapping("/jdbc/vuln")
public String jdbc_sqli_vul(@RequestParam("username") String username) {
    StringBuilder result = new StringBuilder();
    try {
        Class.forName(driver);
        Connection con = DriverManager.getConnection(url, user, password);
        // sqli vuln code
        Statement statement = con.createStatement();
        String sql = "select * from users where username = '" + username + "'";
        logger.info(sql);
        ResultSet rs = statement.executeQuery(sql);
        while (rs.next()) {
            String res_name = rs.getString("username");
            String res_pwd = rs.getString("password");
            String info = String.format("%s: %s\n", res_name, res_pwd);
            result.append(info);
            logger.info(info);
        }
        rs.close();
        con.close();
    } catch (ClassNotFoundException e) {
        logger.error("Sorry,can`t find the Driver!");
    } catch (SQLException e) {
        logger.error(e.toString());
    }
    return result.toString();
}
```

​ 此处存在 sql 注入漏洞，执行 SQL 语句为 select * from users where username = 'joychoun' or '1' = '1'

[![](https://storage.tttang.com/media/attachment/2022/08/30/9ae54354-5008-4008-8f43-b53cfeaaa7df.png)](https://storage.tttang.com/media/attachment/2022/08/30/9ae54354-5008-4008-8f43-b53cfeaaa7df.png)  
[![](https://storage.tttang.com/media/attachment/2022/08/30/c020cb7a-c323-4015-b701-af3b38abc68c.png)](https://storage.tttang.com/media/attachment/2022/08/30/c020cb7a-c323-4015-b701-af3b38abc68c.png)

### [2.PreparedStatement](#toc_2preparedstatement)

​ 与 Statement 的区别在于 PrepareStatement 会对 SQL 语句进行预编译，预编译的好处不仅在于在一定程度上防止了 sql 注入，还减少了 sql 语句的编译次数，提高了性能，其原理是先去编译 sql 语句，无论最后输入为何，预编译的语句只是作为字符串来执行，而 SQL 注入只对编译过程有破坏作用，执行阶段只是把输入串作为数据处理，不需要再对 SQL 语句进行解析，因此解决了注入问题。

​ PrepareStatement 防御预编译的写法是使用? 作为占位符然后将 SQL 语句进行预编译，由于 "?" 作为占位符已经告诉数据库整个 SQL 语句的结构，即? 处传入的是参数，而不会是 sql 语句，所以即使攻击者传入 sql 语句也不会被数据库解析。

```
@RequestMapping("/jdbc/sec")
public String jdbc_sqli_sec(@RequestParam("username") String username) {
    StringBuilder result = new StringBuilder();
    try {
        Class.forName(driver);
        Connection con = DriverManager.getConnection(url, user, password);
        if (!con.isClosed())
            System.out.println("Connecting to Database successfully.");
        // fix code
        String sql = "select * from users where username = ?";
        PreparedStatement st = con.prepareStatement(sql);
        st.setString(1, username);
        logger.info(st.toString());  // sql after prepare statement
        ResultSet rs = st.executeQuery();
        while (rs.next()) {
            String res_name = rs.getString("username");
            String res_pwd = rs.getString("password");
            String info = String.format("%s: %s\n", res_name, res_pwd);
            result.append(info);
            logger.info(info);
        }
        rs.close();
        con.close();

    } catch (ClassNotFoundException e) {
        logger.error("Sorry, can`t find the Driver!");
        e.printStackTrace();
    } catch (SQLException e) {
        logger.error(e.toString());
    }
    return result.toString();
}
```

​ 此时不存在 SQL 注入漏洞，传入的 payload 已进行转义

[![](https://storage.tttang.com/media/attachment/2022/08/30/223bd571-ba98-48fe-b7ed-477dc1164522.png)](https://storage.tttang.com/media/attachment/2022/08/30/223bd571-ba98-48fe-b7ed-477dc1164522.png)

[![](https://storage.tttang.com/media/attachment/2022/08/30/48240d60-2b82-4775-9a79-4db4ce12b05d.png)](https://storage.tttang.com/media/attachment/2022/08/30/48240d60-2b82-4775-9a79-4db4ce12b05d.png)

### [3.JDBC 易产生漏洞点](#toc_3jdbc)

#### [3.1. 未使用占位符](#toc_31)

​ PreparedStatement 只有在使用 "?" 作为占位符才能预防 sql 注入，直接拼接仍会存在 sql 注入漏洞

#### [3.2. 使用 in 语句](#toc_32in)

​ 删除语句中可能会存在此类语句, 由于无法确定 delIds 含有对象个数而直接拼接 sql 语句，造成 sql 注入。

```
String sql = "delete from users where id in("+delIds+"); //存在sql注入
```

​ 解决方法为遍历传入的 对象个数，使用 “?” 占位符。

#### [3.3. 使用 like 语句](#toc_33like)

​ 使用 like 语句直接拼接会造成 sql 注入

```
String sql = "select * from users where password like '%" + con + "%'"; //存在sql注入
```

#### [3.4.% 和_](#toc_34_)

​ 没有手动过滤 %。预编译是不能处理这个符号的， 所以需要手动过滤，否则会造成慢查询，造成 dos。

#### [3.5.Order by、from 等无法预编译](#toc_35order-byfrom)

​ 通过上面对使用 in 关键字和 like 关键字发现，只需要对要传参的位置使用占位符进行预编译时似乎就可以完全防止 SQL 注入，然而事实并非如此，当使用 order by 语句时是无法使用预编译的，原因是 order by 子句后面需要加字段名或者字段位置，而字段名是不能带引号的，否则就会被认为是一个字符串而不是字段名，然而使用 PreapareStatement 将会强制给参数加上'，所以，在使用 order by 语句时就必须得使用拼接的 Statement，所以就会造成 SQL 注入，需要进行手动过滤，否则存在 sql 注入。

​ `String sql = "Select * from news where title =?" + "order by '" + time + "' asc"`

[二. Mybatis 框架下的 sql 注入](#toc_mybatissql)
-----------------------------------------

​ Mybatis 使用 parameterType 向 sql 语句传参，在 sql 引用传参可以使用 #{Parameter} 和 ${Parameter} 两种方式

### [1 .${Parameter} 方式](#toc_1-parameter)

​ ${Parameter} 采用拼接的方式构造 SQL 语句，在对用户输入过滤不严格的前提下，存在 sql 注入漏洞

```
//Mybatis 
@Select("select * from users where username = '${username}'")
List<User> findByUserNameVuln01(@Param("username") String username);
```

```
@GetMapping("/mybatis/vuln01")
public List<User> mybatisVuln01(@RequestParam("username") String username) {
    return userMapper.findByUserNameVuln01(username);
}
```

[![](https://storage.tttang.com/media/attachment/2022/08/30/90de4f00-6463-40c3-b6d7-72977655f813.png)](https://storage.tttang.com/media/attachment/2022/08/30/90de4f00-6463-40c3-b6d7-72977655f813.png)

[![](https://storage.tttang.com/media/attachment/2022/08/30/cd1566fc-0a42-4033-a101-a1529f2ac28e.png)](https://storage.tttang.com/media/attachment/2022/08/30/cd1566fc-0a42-4033-a101-a1529f2ac28e.png)

### [2.#{Parameter} 方式](#toc_2parameter)

​ #{Parameter} 采用预编译的方式构造 SQL 语句，避免了 SQL 注入的产生

```
@GetMapping("/mybatis/sec01")
public User mybatisSec01(@RequestParam("username") String username) {
    return userMapper.findByUserName(username);
}
```

```
//Mybatis 
@Select("select * from users where username = #{username}")
User findByUserName(@Param("username") String username);
```

[![](https://storage.tttang.com/media/attachment/2022/08/30/2fb71066-732f-4e82-9877-28973a1ee1f8.png)](https://storage.tttang.com/media/attachment/2022/08/30/2fb71066-732f-4e82-9877-28973a1ee1f8.png)

[![](https://storage.tttang.com/media/attachment/2022/08/30/a3e6d9a0-a84c-45f6-afc3-a3ae5f0ba8c3.png)](https://storage.tttang.com/media/attachment/2022/08/30/a3e6d9a0-a84c-45f6-afc3-a3ae5f0ba8c3.png)

### [3.MyBatis 易产生 SQL 注入的三种情况](#toc_3mybatissql)

#### [3.1 模糊查询](#toc_32)

​ 在这种情况下使用 #{} 程序会报错，新手程序员就把 #号改成了 $, 这样如果 java 代码层面没有对用户输入的内容做处理势必会产生 SQL 注入漏洞。

```
<select id="findByUserNameVuln02" parameterType="String" resultMap="User">
    select * from users where username like '%${_parameter}%'
</select>
```

[![](https://storage.tttang.com/media/attachment/2022/08/30/94f4b8cf-533d-4371-bdfa-441c69a95954.png)](https://storage.tttang.com/media/attachment/2022/08/30/94f4b8cf-533d-4371-bdfa-441c69a95954.png)

[![](https://storage.tttang.com/media/attachment/2022/08/30/fa2241df-0501-46fc-a718-dfb5a985ef3e.png)](https://storage.tttang.com/media/attachment/2022/08/30/fa2241df-0501-46fc-a718-dfb5a985ef3e.png)

​ 正确写法如下：

```
<select id="findByUserNamesec" parameterType="String" resultMap="User">
    select * from users where username like concat('%',#{_parameter}, '%')
</select>
```

​ 这样拼接就不会存在 sql 注入。  
[![](https://storage.tttang.com/media/attachment/2022/08/30/9c8cf36c-172e-44ff-9e91-21a0b3eb66e4.png)](https://storage.tttang.com/media/attachment/2022/08/30/9c8cf36c-172e-44ff-9e91-21a0b3eb66e4.png)

[![](https://storage.tttang.com/media/attachment/2022/08/30/39844fe6-a3c7-42d3-a572-81c8ebb64f36.png)](https://storage.tttang.com/media/attachment/2022/08/30/39844fe6-a3c7-42d3-a572-81c8ebb64f36.png)

​ 正确写法：

```
mysql:
    select * from users where username like concat('%',#{username},'%')
oracle:
    select * from users where username like '%'||#{username}||'%'
sqlserver:
    select * from users where username like '%'+#{username}+'%'
```

#### [3.2 使用 in 语句](#toc_32-in)

​ 使用 in 语句时直接使用 #{} 会报错，可能会存在使用 ${} 直接拼接，造成 sql 注入

```
<select id="findByUserNameVuln04" parameterType="String" resultMap="User">
    select * from users where id in (${id})
</select>
```

```
// http://localhost:8080/sqli/mybatis/vuln04?id=1)%20AND%201=1%23
@GetMapping("/mybatis/vuln04")
public List<User> mybatisVuln04(@RequestParam("id") String id) {
    return userMapper.findByUserNameVuln04(id);
}
```

[![](https://storage.tttang.com/media/attachment/2022/08/30/ecb91bc7-1f17-4692-a1a6-dfe04776ee58.png)](https://storage.tttang.com/media/attachment/2022/08/30/ecb91bc7-1f17-4692-a1a6-dfe04776ee58.png)

[![](https://storage.tttang.com/media/attachment/2022/08/30/8b38e22c-8e3a-4c80-9159-ea0f98e0e2fb.png)](https://storage.tttang.com/media/attachment/2022/08/30/8b38e22c-8e3a-4c80-9159-ea0f98e0e2fb.png)

​ 正确用法为使用 foreach，而不是将 #替换为 $

```
id in<foreach collection="ids" item="item" open="("separatosr="," close=")">#{ids} </foreach>
```

#### [3.3 使用 order by 语句](#toc_33order-by)

​ 和 JDBC 同理，使用 #{} 方式传参会导致 order by 语句失效，所以使用 order by 语句的时候还是需要做好过滤

[三. Mybatis-plus 框架下的 sql 注入](#toc_mybatis-plussql)
---------------------------------------------------

​ 与 SpringDataJpa 类似，mybatis-plus 提供了相关的 funciton 进行 sql 的操作，例如 like("name","tks")——>name like '%tks%'，同时也很贴心的考虑到了 SQL 注入问题，对绝大部分场景进行了预编译处理。但是类似动态表名、orderby 这种需要拼接的场景在实际开发中还是需要额外的注意。

[1. 条件构造器 Wrapper](#toc_1wrapper)
---------------------------------

​ 条件构造器 Wrapper 可以用于复杂的数据库操作：大于、小于、模糊查询等等。

[![](https://storage.tttang.com/media/attachment/2022/08/30/c4b6465e-94a8-4fe4-9884-c58aa4ad56b9.png)](https://storage.tttang.com/media/attachment/2022/08/30/c4b6465e-94a8-4fe4-9884-c58aa4ad56b9.png)

​ 比较常用的是 QueryWrapper 和 UpdateWrapper：

*   Wrapper ： 条件构造抽象类，最顶端父类，抽象类中提供 4 个方法
*   AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件
*   AbstractLambdaWrapper ： Lambda 语法使用 Wrapper 统一处理解析 lambda 获取 column。
*   LambdaQueryWrapper ：用于 Lambda 语法使用的查询 Wrapper
*   LambdaUpdateWrapper ： Lambda 更新封装 Wrapper
*   QueryWrapper ： Entity 对象封装操作类，不是用 lambda 语法
*   UpdateWrapper ： Update 条件封装，用于 Entity 对象更新操作

### [1.1 基础使用](#toc_11)

配置基础类

```
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;

@Data
@TableName("tutorials")
//tutorials
public class Tutorial {

    private Integer Id;
    private String Title;
    private String Author;

}
```

配置 Mapper

```
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import org.apache.ibatis.annotations.Mapper;
import org.joychou.dao.Tutorial;

@Mapper
public interface TutorialMapper extends BaseMapper<Tutorial> {

}
```

调用相关的 api 进行操作

```
@RequestMapping("selectauthor")
public Tutorial mybatisselect(String author) {
    QueryWrapper<Tutorial> wrapper = new QueryWrapper<>();
    wrapper.eq("author",author);
    Tutorial tutorial = tutorialMapper.selectOne(wrapper);
    return tutorial;
}
```

### [1.2mybatis-puls 预编译](#toc_12mybatis-puls)

传统的 mybaits 框架对于 in 范围查询和 like 模糊查询需要做额外的处理：

like 模糊查询需要在 mapperxml 配置中用 sql 的内置函数进行拼接，拼接后再采用 #预编译的方式进行查询；

in 范围查询的话需要在进行同条件多值查询的时候，可以使用 MyBatis 自带的循环指令 foreach 来解决 SQL 语句动态拼接的问题；

mybatis-puls 已经考虑到 sql 注入的影响，相关 wrapper 的 function 已进行了相关的预编译处理。例如 mybatis 常见的 like 和 in 注入场景，均进行了预编译处理，例如如下例子：  
like 模糊查询

```
@RequestMapping("/like")
public List<Tutorial> mybatislike(String author) {
    QueryWrapper<Tutorial> wrapper = new QueryWrapper<>();
    wrapper.select("*").like("author",author);
    List<Tutorial> tutorials = tutorialMapper.selectList(wrapper);
    return tutorials;
}
```

打印相关的查询 log，可以看到相关查询已使用? 进行预编译处理：

[![](https://storage.tttang.com/media/attachment/2022/08/30/1203b36f-b2d7-451c-aa3a-539915bc4694.png)](https://storage.tttang.com/media/attachment/2022/08/30/1203b36f-b2d7-451c-aa3a-539915bc4694.png)

​ in 范围查询

```
@RequestMapping("/in")
public List<Tutorial> mybatisin(String author1,String author2) {
    QueryWrapper<Tutorial> wrapper = new QueryWrapper<>();
    wrapper.select("*").in("author",author1,author2);
    List<Tutorial> tutorials = tutorialMapper.selectList(wrapper);
    return tutorials;
}
```

打印相关的查询 log，可以看到相关查询已使用? 进行预编译处理：

[![](https://storage.tttang.com/media/attachment/2022/08/30/0bef8b83-bc8b-4ff1-bfa7-615074ccd71d.png)](https://storage.tttang.com/media/attachment/2022/08/30/0bef8b83-bc8b-4ff1-bfa7-615074ccd71d.png)

[2. 常见注入场景](#toc_2)
-------------------

### [1. 条件构造器常见注入场景](#toc_1)

#### [apply](#toc_apply)

```
apply(String applySql, Object... params)
apply(boolean condition, String applySql, Object... params)
```

*   拼接 sql
*   注: 该方法可用于数据库**函数** 动态入参的`params`对应前面`applySql`内部的`{index}`部分. 这样是不会有 sql 注入风险的, 反之会有!
*   示例：

​ apply() 直接拼接 sql 语句存在 sql 注入

```
@RequestMapping("/applyvuln")
public Tutorial mybatisapplyvuln(String author,String title) {
    QueryWrapper<Tutorial> wrapper = new QueryWrapper<>();
    wrapper.eq("author",author).apply("title="+title);
    Tutorial tutorial = tutorialMapper.selectOne(wrapper);
    return tutorial;
}
```

[![](https://storage.tttang.com/media/attachment/2022/08/30/3761f9e0-5076-485d-9183-73a823fd9f7d.png)](https://storage.tttang.com/media/attachment/2022/08/30/3761f9e0-5076-485d-9183-73a823fd9f7d.png)

​ 使用 {index}params 进行预编译处理, 不存在 sql 注入

```
@RequestMapping("/applysec")
public Tutorial mybatisapplysec(String author,String title) {
    QueryWrapper<Tutorial> wrapper = new QueryWrapper<>();
    wrapper.eq("author",author).apply("title={0}",title);
    Tutorial tutorial = tutorialMapper.selectOne(wrapper);
    return tutorial;
}
```

[![](https://storage.tttang.com/media/attachment/2022/08/30/15303ff3-8154-4b77-acb5-3534850c040e.png)](https://storage.tttang.com/media/attachment/2022/08/30/15303ff3-8154-4b77-acb5-3534850c040e.png)

#### [last](#toc_last)

```
last(String lastSql)
last(boolean condition, String lastSql)
```

*   无视优化规则直接拼接到 sql 的最后
    
*   注：只能调用一次, 多次调用以最后一次为准 ，若相关内容用户可控，则存在 sql 注入风险
    
*   示例：
    

```
@RequestMapping("/lastvuln")
public List<Tutorial> mybatislastvuln(String column) {
    QueryWrapper<Tutorial> wrapper = new QueryWrapper<>();
    wrapper.last("order by " + column);
    List<Tutorial> list = tutorialMapper.selectList(wrapper);
    return list;
}
```

#### [exists/notExists](#toc_existsnotexists)

```
exists(String existsSql)
exists(boolean condition, String existsSql)
```

```
notExists(String notExistsSql)
notExists(boolean condition, String notExistsSql)
```

*   拼接 EXISTX / NOT EXISTS (sql 语句)
    
*   注：若 existsSql 或 notExistsSql 中有关内容用户可控，则存在 sql 注入风险
    
*   示例：
    

```
@RequestMapping("/existsvuln")
public List<Tutorial> mybatisexistsvuln(String title) {
    QueryWrapper<Tutorial> wrapper = new QueryWrapper<>();
    wrapper.exists("select title from tutorials where title = " + title);
    List<Tutorial> list = tutorialMapper.selectList(wrapper);
    return list;
}
```

#### [having](#toc_having)

```
having(String sqlHaving, Object... params)
having(boolean condition, String sqlHaving, Object... params)
```

*   HAVING (sql 语句), 用于 Having 查询，一般用配合 groupby 在对分组统计函数进行过滤的场景中
*   注：与 apply 一样，动态入参的 params 对应前面 applySql 内部的 {index} 部分，可以进行预编译防止 SQL 注入问题。
*   示例：

```
@RequestMapping("/havingvuln")
public List<Tutorial> mybatishavingvuln(String id) {
    QueryWrapper<Tutorial> wrapper = new QueryWrapper<>();
    wrapper.select().groupBy("author").having("id > " +id);
    List<Tutorial> list = tutorialMapper.selectList(wrapper);
    return list;
}
```

#### [order by](#toc_order-by)

*   orderBy

```
orderBy(boolean condition, boolean isAsc, R... columns)
```

*   orderByAsc

```
orderByAsc(R... columns)
orderByAsc(boolean condition, R... columns)
```

*   orderByDesc

```
orderByDesc(R... columns)
orderByDesc(boolean condition, R... columns)
```

*   排序：ORDER BY 字段, (ASC/DESC)
*   注：Order by 排序时不能进行预编译处理, 故相关内容用户可控的话会存在 sql 注入风险。
*   示例：

```
@RequestMapping("/orderbyvuln")
public List<Tutorial> mybatishorderbyvuln(String column) {
    QueryWrapper<Tutorial> wrapper = new QueryWrapper<>();
    wrapper.select().orderBy(true, true, column);
    List<Tutorial> list = tutorialMapper.selectList(wrapper);
    return list;
}

@RequestMapping("/orderbyAscvuln")
public List<Tutorial> mybatishorderbyAscvuln(String column) {
    QueryWrapper<Tutorial> wrapper = new QueryWrapper<>();
    wrapper.select().orderByAsc(column);
    List<Tutorial> list = tutorialMapper.selectList(wrapper);
    return list;
}

@RequestMapping("/orderbyDescvuln")
public List<Tutorial> mybatishorderbyDescvuln(String column) {
    QueryWrapper<Tutorial> wrapper = new QueryWrapper<>();
    wrapper.select().orderByDesc(column);
    List<Tutorial> list = tutorialMapper.selectList(wrapper);
    return list;
}
```

#### [group By](#toc_group-by)

```
groupBy(R... columns)
groupBy(boolean condition, R... columns)
```

*   分组：GROUP BY 字段, ... 主要用于用于结合聚合函数，根据一个或多个列对结果集进行分组
*   示例：

```
@RequestMapping("/gropbycvuln")
public List<Tutorial> mybatishsgropbycvuln(String column) {
    QueryWrapper<Tutorial> wrapper = new QueryWrapper<>();
    wrapper.select().groupBy(column);
    List<Tutorial> list = tutorialMapper.selectList(wrapper);
    return list;
}
```

#### [insql/notinsql](#toc_insqlnotinsql)

```
inSql(R column, String inValue)
inSql(boolean condition, R column, String inValue)
```

```
notInSql(R column, String inValue)
notInSql(boolean condition, R column, String inValue)
```

*   字段 IN / NOT IN (sql 语句)
*   column 字段、inValue 字段可控的情况下存在注入风险。
*   示例：

```
@RequestMapping("/insqlcvuln")
public List<Tutorial> mybatisinsqlvuln(String column,String id) {
    QueryWrapper<Tutorial> wrapper = new QueryWrapper<>();
    wrapper.select().inSql(column,"select id from tutorials where id >" + id);
    List<Tutorial> list = tutorialMapper.selectList(wrapper);
    return list;
}
```

### [2. 使用 Wrapper 自定义 SQL（特殊的预编译场景）](#toc_2-wrapper-sql)

​ Wrapper 提供了自定义 SQL 场景，与传统的 mybatis 一样使用 $ 进行注解，但实际上 ew 已经做了预编译处理。同样的也支持注解 & xml 配置。

注：需要 mybatis-plus 版本 >= 3.0.7 param 参数名要么叫 ew, 要么加上注解 @Param(Constants.WRAPPER) 使用 ${ew.customSqlSegment} 不支持 Wrapper 内的 entity 生成 where 语句

示例：

#### [1. 注解模式](#toc_3)

*   配置 mapper

```
import com.baomidou.mybatisplus.core.conditions.Wrapper;
import com.baomidou.mybatisplus.core.toolkit.Constants;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Select;
import org.joychou.dao.Person;

import java.util.List;

@Mapper
public interface PersonMapper {

    @Select("select * from persons ${ew.customSqlSegment}")
    List<Person> selectPerson(@Param(Constants.WRAPPER) Wrapper wrapper);

}
```

*   ​ 配置 controller

```
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import org.joychou.dao.Person;
import org.joychou.dao.Tutorial;
import org.joychou.mapper.PersonMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/sqlimybatis_plus")
public class Mybatis_Plus_SQLI_2 {

    @Autowired
    PersonMapper personMapper;

    //orderby  R... columns 可控，存在SQL注入风险
    @RequestMapping("/selectperson")
    public List<Person> selectPerson(String column){
        QueryWrapper<Object> wrapper = new QueryWrapper<>();
        wrapper.orderByAsc(column);
        return personMapper.selectPerson(wrapper);
    }

    //like 自动进行预编译，不存在SQL注入风险
    @RequestMapping("/selectpersonlike")
    public List<Person> selectPersonlike(String name) {
        QueryWrapper<Object> wrapper = new QueryWrapper<>();
        wrapper.like("name", name);
        return personMapper.selectPerson(wrapper);
    }

}
```

​ Wrapper 自定义模式下 like、in 等会自动进行预编译，但若存在 last、orderby 等未进行预编译方法，若相应数据用户可控仍会存在 SQL 注入风险，风险 API 仍为 2.1 中常见注入场景。

[![](https://storage.tttang.com/media/attachment/2022/08/30/594737b7-64a7-4ba1-8ce8-e2ceffe4ed31.png)](https://storage.tttang.com/media/attachment/2022/08/30/594737b7-64a7-4ba1-8ce8-e2ceffe4ed31.png)

[![](https://storage.tttang.com/media/attachment/2022/08/30/c0d99114-1512-49cd-a44c-042202335310.png)](https://storage.tttang.com/media/attachment/2022/08/30/c0d99114-1512-49cd-a44c-042202335310.png)

#### [2.XML 模式](#toc_2xml)

*   配置 mapper

```
import com.baomidou.mybatisplus.core.conditions.Wrapper;
import com.baomidou.mybatisplus.core.toolkit.Constants;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Select;
import org.joychou.dao.Person;

import java.util.List;

@Mapper
public interface PersonMapper {

    @Select("select * from persons ${ew.customSqlSegment}")
    List<Person> selectPerson(@Param(Constants.WRAPPER) Wrapper wrapper);

    List<Person> selectPersonXML1(Wrapper ew);

    List<Person> selectPersonXML2(Wrapper ew);

    List<Person> selectPersonXMLOrdeyBy(Wrapper ew);

}
```

*   配置 XXXXMapper.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="org.joychou.mapper.UserMapper">

    <resultMap type="org.joychou.dao.Person" id="Person">
        <id column="id" property="id" javaType="java.lang.Integer" jdbcType="NUMERIC"/>
        <id column="name" property="name" javaType="java.lang.String" jdbcType="VARCHAR"/>
        <id column="address" property="address" javaType="java.lang.String" jdbcType="VARCHAR"/>
        <id column="city" property="city" javaType="java.lang.String" jdbcType="VARCHAR"/>
    </resultMap>

    <select id="selectPersonXML1"  resultMap="Person">
        select * from persons where ${ew.customSqlSegment}
    </select>

    <select id="selectPersonXML2"  resultMap="Person">
        select * from persons
        <where>
            ${ew.SqlSegment}
        </where>
    </select>

    <select id="selectPersonXMLOrdeyBy"  resultMap="Person">
        select * from persons ${ew.SqlSegment}
    </select>

</mapper>
```

*   配置 controller

```
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import org.joychou.dao.Person;
import org.joychou.dao.Tutorial;
import org.joychou.mapper.PersonMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/sqlimybatis_plus")
public class Mybatis_Plus_SQLI_2 {

    @Autowired
    PersonMapper personMapper;

    @RequestMapping("/selectperson")
    public List<Person> selectPerson(String column){
        QueryWrapper<Object> wrapper = new QueryWrapper<>();
        wrapper.orderByAsc(column);
        return personMapper.selectPerson(wrapper);
    }

    @RequestMapping("/selectperson1")
    public List<Person> selectPersonXML1(String name) {
        QueryWrapper<Object> wrapper = new QueryWrapper<>();
        wrapper.eq("name", name);
        return personMapper.selectPerson(wrapper);
    }

    @RequestMapping("/selectperson2")
    public List<Person> selectPersonXML2(String name) {
        QueryWrapper<Object> wrapper = new QueryWrapper<>();
        wrapper.eq("name", name);
        return personMapper.selectPerson(wrapper);
    }

    @RequestMapping("/selectperson3")
    public List<Person> selectPersonXMLOrderBy(String column) {
        QueryWrapper<Object> wrapper = new QueryWrapper<>();
        wrapper.orderByAsc(column);
        return personMapper.selectPerson(wrapper);
    }

}
```

​ 以上 selectPersonXML1、selectPersonXML2 均实现相同功能，SQL 注入问题与注解模式相同。

[![](https://storage.tttang.com/media/attachment/2022/08/30/fe61b5f1-b9f5-4919-a5e0-a5f84ca02a34.png)](https://storage.tttang.com/media/attachment/2022/08/30/fe61b5f1-b9f5-4919-a5e0-a5f84ca02a34.png)  
[![](https://storage.tttang.com/media/attachment/2022/08/30/b22d2fac-51c5-4fcd-958f-0c4161c3fa91.png)](https://storage.tttang.com/media/attachment/2022/08/30/b22d2fac-51c5-4fcd-958f-0c4161c3fa91.png)

### [3. 分页插件](#toc_4)

*   配置分页插件

```
import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MybatisPlusConfig {

    /**
     * 注册插件
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {

        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        // 添加分页插件
        PaginationInnerInterceptor pageInterceptor = new PaginationInnerInterceptor();
        // 设置请求的页面大于最大页后操作，true调回到首页，false继续请求。默认false
        pageInterceptor.setOverflow(false);
        // 单页分页条数限制，默认无限制
        pageInterceptor.setMaxLimit(500L);
        // 设置数据库类型
        pageInterceptor.setDbType(DbType.MYSQL);

        interceptor.addInnerInterceptor(pageInterceptor);
        return interceptor;
    }

}
```

*   配置 controller

```
@RequestMapping("/selectpage")
public List<Person> mybatispluspage(Long page,Long size,String order){

    QueryWrapper<Person> qw = new QueryWrapper<>();
    Page<Person> personPage = new Page<>(page,size);
    personPage.addOrder(OrderItem.asc(order));
    IPage<Person> iPage = personMapper.selectPage(personPage, qw);
    List<Person> persons = iPage.getRecords();
    return persons;
}
```

​ 若直接使用 addOrder() 未进行过滤，则存在 SQL 注入漏洞。

[![](https://storage.tttang.com/media/attachment/2022/08/30/2432a547-62d3-4132-9076-20ecdb7a90ee.png)](https://storage.tttang.com/media/attachment/2022/08/30/2432a547-62d3-4132-9076-20ecdb7a90ee.png)

#### [2.pagehelper](#toc_2pagehelper)

因为 Order by 排序时不能进行预编译处理，所以在使用插件时需要额外注意如下 function，同样会存在 SQL 注入风险：

*   **com.github.pagehelper.Page**
*   主要是 setOrderBy(java.lang.String) 方法
*   **com.github.pagehelper.page.PageMethod**
*   主要是 startPage(int,int,java.lang.String) 方法
*   **com.github.pagehelper.PageHelper**
*   主要是 startPage(int,int,java.lang.String) 方法

[四. Hibernate 框架下的 SQL 注入](#toc_hibernatesql)
---------------------------------------------

​ Hibernate 是一个开放源代码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，使得 Java 程序员可以随心所欲的使用对象编程思维来操纵数据库。

Hibernate 可以使用 hql 来执行 SQL 语句，也可以直接执行 SQL 语句，无论是哪种方式都有可能导致 SQL 注入

### [HQL](#toc_hql)

hql 语句：

```
String hql = "from People where username = '" + username + "' and password = '" + password + "'";
```

这种拼接方式存在 SQL 注入

正确使用以下几种 HQL 参数绑定的方式可以有效避免注入的产生：

#### [1. 命名参数（named parameter）](#toc_1named-parameter)

```
Query<User> query = session.createQuery("from users name = ?1", User.class);
String parameter = "g1ts";
Query<User> query = session.createQuery("from users name = :name", User.class);
query.setParameter("name", parameter);
```

#### [2. 位置参数（Positional parameter）](#toc_2positional-parameter)

```
String parameter = "g1ts";
Query<User> query = session.createQuery("from users name = ?1", User.class);
query.setParameter(1, parameter);
```

#### [3. 命名参数列表（named parameter list）](#toc_3named-parameter-list)

```
List<String> names = Arrays.asList("g1ts", "g2ts");
Query<User> query = session.createQuery("from users where name in (:names)", User.class);
query.setParameter("names", names);
```

#### [4. 类实例（JavaBean）](#toc_4javabean)

```
user1.setName("g1ts");
Query<User> query = session.createQuery("from users where name =:name", User.class);
query.setProperties(user1);
```

#### [5.HQL 拼接方法](#toc_5hql)

​ 这种方式是最常用，而且容易忽视且容易被注入的，通常做法就是对参数的特殊字符进行过滤，推荐大家使用 Spring 工具包的 StringEscapeUtils.escapeSql() 方法对参数进行过滤：

```
import org.apache.commons.lang.StringEscapeUtils;
public static void main(String[] args) {
  String str = StringEscapeUtils.escapeSql("'");
  System.out.println(str);
}
```

### [SQL](#toc_sql)

Hibernate 支持使用原生 SQL 语句执行，所以其风险和 JDBC 是一致的，直接使用拼接的方法时会导致 SQL 注入

语句如下：

```
Query<People> query = session.createNativeQuery("select * from user where username = '" + username + "' and password = '" + password + "'");
```

正确写法：

```
String parameter = "g1ts";
Query<User> query = session.createNativeQuery("select * from user where name = :name");
query.setParameter("name",parameter);
```

注：此文为总结多位师傅文章，包括不限于以下文章：  
[https://www.sec-in.com/article/1073](https://www.sec-in.com/article/1073)  
[https://www.cnblogs.com/klslb/p/7146889.html](https://www.cnblogs.com/klslb/p/7146889.html)  
.......