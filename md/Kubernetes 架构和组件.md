> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/HeXogdjWrj3eF48r45VIzg)

        kubernetes 也称为 K8s，是一个开源系统，用于自动部署、扩展和管理容器化应用程序。

1.POD 定义：

    > Pod 基本上是容器之上的抽象层。

    > 每个 pod 都有自己的 IP 地址和内部 IP。

    > 一个 pod 可以使用他们的 ip 与另一个 pod 通信。

    > Pod 是短暂的，这意味着如果容器或应用程序崩溃，Pod 将死亡，将使用新的 IP 地址创建一个新的 Pod。

2. 容器定义：

    > 简单来说，容器就是镜像的运行环境。

    > 当我们在本地机器上拉取图像并启动它时，容器内的应用程序将启动并创建一个容器环境。

    > “如果它正在运行，它就是一个容器。

![](https://mmbiz.qpic.cn/mmbiz_png/aPmkR80bcV32wLHwk4UrD8Lj6QoiaqeIQA0VsxHx868QqeBRFs54XQvGWufibmT0mytK6deBJV9N4lKw59Iic059w/640?wx_fmt=png)

                由 worker 节点和 master 节点组成的 Kubernetes 架构

Kubernetes 中的主进程：

![](https://mmbiz.qpic.cn/mmbiz_png/aPmkR80bcV32wLHwk4UrD8Lj6QoiaqeIQ7dKytaNRrZY0tfxhrq9LGN9VTtHlOhAyPvVSS9PnvibnnM0Gdj8f3EQ/640?wx_fmt=png)

*   Kubernetes master 定义为 Kubernetes master 节点是可以指挥和安排一组工作节点的节点。
    
*   有 4 个进程在主节点上运行。他们也控制工作节点和 Kubernetes 集群。
    

```
apiserver
调度器
控制器
etcd
```

api 服务器：

*   主节点中的第一个进程是 apiserver。
    
*   它充当 Kubernetes 集群的入口点。
    
*   作为用户，当您在 kubernetes 集群中部署应用程序时，我们通过客户端或 kubelet 与 Apiserver 交互。
    
*   Apiserver 是一个集群网关，用于获取集群的初始请求或更新。
    

调度器：

*   在节点上调度 pod 的进程是 scheduler。
    
*   它只是决定在哪个节点上安排新的 pod。
    
*   一旦 apiserver 验证了拥有新 pod 的请求，它会将其处理给调度程序，以便在其中一个工作节点上启动 pod。
    
*   Kublet 从调度器获取请求并将 Pod 调度到节点上。
    

控制器管理器：

*   控制器管理器检测集群的状态。
    
*   如果 pod 在任何节点上死亡，我们需要尽快重新调度这些 pod 以执行它与调度程序交互的此活动，会发生什么情况。
    

Etcd：

*   Etcd 存储 Kubernetes 的关键数据。
    
*   通过分布式进程，它还在分布式机器 / 服务器上的所有集群中维护数据存储的副本。
    
*   它将集群状态存储在键 / 值对中。
    
*   etcd 是集群大脑
    
*   如果一个 pod 死亡，一个新的 pod 加入，所有这些值都存储在 etcd 中。
    

工作节点：

*   它是物理服务器或虚拟服务器。
    
*   工作节点是 Kubernetes 集群的一部分，实际上在它们上面执行容器和应用程序。
    
*   每个节点都有多个 Pod 和容器在其上运行。
    
*   每个节点上必须安装 3 个进程。
    
*   这 3 个进程负责调度和管理这些 pod。
    
*   节点是执行实际工作的实际集群服务器，这就是它们被称为 “工作节点” 的原因。
    

![](https://mmbiz.qpic.cn/mmbiz_png/aPmkR80bcV32wLHwk4UrD8Lj6QoiaqeIQXlWqLsaIib9yuIlprTnN8JJ0fdZrQ2ZTHgsd15TvvTxnMyrpgU9GPnw/640?wx_fmt=png)

工作节点有 3 个进程，它们是

*   容器运行时
    
*   kubelet
    
*   kubeproxy
    

容器运行时

*   " 它在每个节点上运行的第一个进程是容器运行时。
    
*   容器运行时是一个执行容器的进程。
    

kubelet

*   在容器下调度 pod 的过程称为 kubelet
    
*   kubelet 与容器和节点交互
    
*   kubelet 启动带有容器的 pod
    

服务

*   pod 和应用程序之间的通信方式是通过 service object 进行的。
    
*   服务对象具有将附加到 pod 的带有 DNS 名称的静态 IP 地址。
    
*   服务对象捕获请求并将其转发到 pod 。
    
*   即使 pod 死掉了服务，它的 IP 地址也会出现。
    
*   这里的服务对象是负载均衡器。
    

有两种服务

*   对外服务
    
*   内部服务
    

对外服务

如果应用程序需要通过 bowser 访问，我们需要外部服务。

例子：

*   外部服务打开来自外部源的通信。
    
*   外部服务的 URl 看起来像示例：https://xxx:8080
    
*   此 URL 适用于测试环境。
    
*   这里 xxx 是节点的 ip，8080 是应用程序的端口号。
    

入口：

如果我们需要最终用户访问应用程序，它应该采用以下形式

        这里以 https://niuniu.com 为例，https 是由域名 “niuniu” 提供的安全协议。为此，我们在 kubernetes 中有一个名为 “INGRESS” 的组件。请求首先进入入口，然后请求将被转发到服务。

对外服务：

        如果我们需要为公共请求打开数据库，我们需要创建一个称为外部服务的服务。

配置图：

*   它是应用程序的外部配置。
    
*   configmap 包含应用程序的配置。
    
*   configmap 包含数据库的 URL。我们只需将它连接到一个 pod。pod 获取 configmap 中存在的数据。
    
*   如果我们更改服务名称或更改端点，我们将只调整 configmap。
    
*   外部配置的 pod 也可以是数据库，如果在应用部署过程中用户名和密码发生变化怎么办。
    
*   在配置映射中有用户名和密码是不安全的，尽管它是一个外部服务。
    
*   为了解决这个问题，我们有一个名为 “SECRETS” 的组件。
    

secrets:

*   它以 base64 编码格式存储凭据和证书等机密数据，但这并不安全。为此，我们使用 kuberenetes 中的第三方服务来处理机密。
    
*   我们只是将 secret 连接到 pod，以便 pod 可以从 secret 中获取信息。
    
*   我们可以使用环境变量或属性 life 将配置映射和 sectets 的数据使用到我们的应用程序 pod 中。
    

Volumes :

*   当我们重新启动 pod 时，数据会发生什么变化？.pod 内的数据或日志将消失。如果我们需要长期保存数据，我们使用卷。
    
*   kuberenetes 不管理数据持久性。k8 管理员负责数据的复制和可用性。
    
*   卷是附加到服务器节点的硬盘驱动器或运行 pod 的本地计算机的物理存储。它可以是 Kubernetes 集群之外的远程存储，如云存储。
    
*   我们可以将存储视为可以插入 Kubernetes 集群的外部硬盘驱动器。
    

![](https://mmbiz.qpic.cn/mmbiz_png/aPmkR80bcV32wLHwk4UrD8Lj6QoiaqeIQcrmjIQYOzMoribz7NHM5OV8q3IZ48cLuBcuviaRS4zwjiaZ7d6NMNfQAg/640?wx_fmt=png)

部署对象：

*   在部署中，我们可以指定我们需要的 pod 副本数。
    
*   我们可以根据需要放大和缩小 pod
    
*   实际上，我们使用的是部署而不是 pod '
    
*   pod 是容器之上的一层。
    
*   部署是 pod 之上的抽象。
    
*   如果应用程序 pod 的副本之一死亡，服务会将请求转发给另一个，并且最终用户仍然可以访问应用程序。
    
*   这在应用程序 pod 的情况下是正确的。
    
*   数据库吊舱死机的情况如何？
    
*   在这种情况下，我们无法访问该应用程序。
    
*   为什么部署对象无法复制数据库？
    
*   这是因为数据库有状态。这意味着如果我们克隆了数据库的副本，那么这些副本都需要共享数据存储。
    
*   在这里，我们需要一些进程来管理哪些 pod 从存储读取和写入存储，以避免数据不一致。这个机制是通过 statefulset 处理的。
    

状态集：

*   它们适用于有状态的应用程序和数据库，如 mysql。
    
*   任何数据库应用程序都必须使用 statefulsets 而不是 Deployment 对象创建。
    
*   有状态集就像部署对象一样，它们负责扩展和复制 pod 以及处理数据库一致性。
    
*   通常，数据库托管在 kuberenetes 集群之外。
    

守护程序集：

*   当我们添加或删除节点时，我们需要调整副本数，通过部署我们无法确保 pod 是均匀分布的。
    
*   但是使用 Daemon 设置它会根据节点数自动计算所需的副本数。
    
*   守护程序集仅为每个节点部署 1 个副本或 1 个 pod。
    
*   当我们向集群添加一个节点时，守护进程集会添加一个 pod 副本。
    
*   我们不需要定义副本数。