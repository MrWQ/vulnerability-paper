> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/vMo3ac-tIYLmOuUAbZ5r_Q)

![图片](https://mmbiz.qpic.cn/mmbiz_gif/96Koibz2dODv058icFziakGc3QJbCoicHZavCia2A6Kmf6Q0B68IwVE66fqiaPXl56QneZ1ZdTGA0o5Ln3oLBMhZJp2Q/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

点击上方“蓝字”，关注更多精彩

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavCRa1mmlZwXADCmOcPAMGBuaVA25wsVKKWUQpC7Xs8icRtnt2l1tJ3qg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**起因**

以前一直以为只有我一个人用frp来做内网的socks5代理，后来不知道为啥越来越多的人也用frp来做内网socks5了。在上次的攻防演练中发现了其他攻击队上传的一个frpc.ini打开发现里面frpc和frps没有做验证。所以在想能不能写一个工具去批量验证frps有没有密码，以及爆破frps的token。

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavMh9NyJa1SmP1x7gib3JNRf4icp0wSotYJ12RqIxecRFBq4QaZNHlvQDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODv058icFziakGc3QJbCoicHZavJZHLicqpdT6JYveyfibwDDR86nc7zj2f88CibuAHZVEdUgfUyspGeBkcQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

frpc请求分析
========

**环境：**  

frpc:192.168.153.154  
frps:192.168.153.135

在不使用token的情况下。直接用wireshark抓取frpc和frps的连接数据包，前三个数据包就是经典的TCP三次握手。从第四个包到第六个包可以看出来frpc和frps应该是用的一个私有协议的认证。主要的数据位于第六个数据包中，从数据包的长度就可以看出来！

![图片](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODvhZxySRflTvsvMPUEqpJHHTvqgibTicw2Phm3llNslNs3cKCpsZuRHAlX7spiaibZnTiaQEhW9rWzWlyA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/96Koibz2dODvhZxySRflTvsvMPUEqpJHHzg3TxnBuwFJtCVzbVVuk0TOGWtZteOHJOhJLzAW86bKqcSCt21jvibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

为了查看，我把主要内容复制到下面了。可以看见，frpc会向frps传递frpc的版本以及系统架构时间戳和key等信息。

```
{"version":"0.37.0","hostname":"","os":"windows","arch":"amd64","user":"","privilege_key":"3900738c9c817bab438548f48a6d2823","timestamp":1629082109,"run_id":"","metas":null,"pool_count":1}
```

尝试模拟frpc
========

直接使用简单暴力的办法把四到六组数据包中的tcp payload拿出来用用socket发送就行了。垃圾代码如下

```
`import socket``import binascii``host="192.168.200.132"``port=7000``s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)``s.connect((host,port))``hex1="000100010000000100000000"``hex2="0000000000000001000000c5"``hex3="6f00000000000000bc7b2276657273696f6e223a22302e33372e30222c22686f73746e616d65223a22222c226f73223a2277696e646f7773222c2261726368223a22616d643634222c2275736572223a22222c2270726976696c6567655f6b6579223a223339303037333863396338313762616234333835343866343861366432383233222c2274696d657374616d70223a313632393038323130392c2272756e5f6964223a22222c226d65746173223a6e756c6c2c22706f6f6c5f636f756e74223a317d"``str=binascii.unhexlify(hex1)``s.send(str)``str=binascii.unhexlify(hex2)``s.send(str)``str=binascii.unhexlify(hex3)``s.send(str)`
```

从frps可以看出来连接成功了。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

frps返回分析
========

第七个数据包返回了一个ACK的数据包，暂时不知道是干啥用的。从第八到第十个数据包长度来看主要信息应该在第十组数据包中。数据包如下。返回的数据中主要包括了frps的版本等信息。第八和第九个数据包中返回的tcp payload 长度为12，第十组长度为88

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

```
{"version":"0.37.0","run_id":"7bd1c9e7f0c561f2","server_udp_port":0,"error":""}
```

使用recv接收收三次数据包即可

```
`s.recv(12)``s.recv(12)``resp=s.recv(88)`
```

返回结果如下。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

我们再把frps设置token来试试。可见recv的长度不够，加到200就行了。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

好了，所以扫描未授权直接判断error是否为空就行了！

frps弱口令
=======

通过whireshark分别抓取设置token和没设置token的数据包，并未发现两个数据包有什么不同。猜测privilege_key应该就是token了。但是发现每次抓取的包的privilege_key都不一样，privilege_key应该是token和时间戳timestamp进行了某种运算得出来的，这就得看frp的源码了。

打开github搜索auth或者login，定位到frp/pkg/auth/token.go的77行，可见判断了PrivilegeKey是否与util.GetAuthKey函数处理token和Timestamp之后的值相等。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

定位到util.GetAuthKey函数，可见是util.GetAuthKey的返回值是token和Timestamp拼接之后的md5。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

所以爆破的思路就是密码和时间戳拼接然后计算md5，将计算出来的md5当作PrivilegeKey，然后发送到服务器进行认证！

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

END

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

**看完记得点赞，关注哟，爱您！**

  

**请严格遵守网络安全法相关条例！此分享主要用于学习，切勿走上违法犯罪的不归路，一切后果自付！**

  

  

关注此公众号，回复"Gamma"关键字免费领取一套网络安全视频以及相关书籍，公众号内还有收集的常用工具！

  

**在看你就赞赞我！**

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

扫码关注我们

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

扫码领hacker资料，常用工具，以及各种福利

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

转载是一种动力 分享是一种美德