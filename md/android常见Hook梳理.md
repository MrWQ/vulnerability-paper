> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/64so1IAJnA3oDlVRWyrQ7Q)

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/m7tZOvC2fza9CllN6tG7YO64On4RL8H6HicHALYZFgSiaTE6ch5AXwDuvEnaPH8hXqwiceTicia6V9IOzeicM95GZIKg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

背景

Android进行逆向安全破解或安全测试中，Hook技术是android安全人员都需具备的技术。它可以用于绕过系统限制、修改别人发布的代码、动态化、调用隐藏API、插件化、组件化、自动化测试、沙箱等等非常规的功能。下面就对这些hook技术的适用范围和优缺点进行梳理总结。

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/m7tZOvC2fza9CllN6tG7YO64On4RL8H6HicHALYZFgSiaTE6ch5AXwDuvEnaPH8hXqwiceTicia6V9IOzeicM95GZIKg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

Android进程的结构

**Android系统是基于Linux系统，Android进程本质就是一个Linux进程。**通过掌握Android进程的基本结构，有利于在进程中，不同区域采用不同的hook技术去解决。

![图片](https://mmbiz.qpic.cn/mmbiz_png/haqlQiars3wrSquUuY68RH5sjyTx6FM9gkrmAxj40maGaobhLJLcGoAWRhsbgllvwoJa4ia8yicKEuibriazpKd0vYQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

**基于上图android结构进行解析**

1.最外面是一个linux进程，主要是动态链接了一堆动态链接库so（ELF文件）。

2.Linux进程中主要运行ART/Davlik虚拟机，虚拟机包含Classloader、对象管理（内存管理）、线程调度等。虚拟机主要是为JAVA提供运行时环境。

3.如果app中还包含navtive代码，native代码会和虚拟机一起在Linux进程中运行，两者是平行的关系。

4.虚拟机中，包含JAVA FrameWork和应用JAVA代码两部分。

5.Android进程和其他进程交换数据，依赖于linux内核提供进程通信接口（驱动）。例如：Binder通信、Socket通信等等

hook原理就是去修改Android进程中的这些组件，达到某预期目的的过程。

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/m7tZOvC2fza9CllN6tG7YO64On4RL8H6HicHALYZFgSiaTE6ch5AXwDuvEnaPH8hXqwiceTicia6V9IOzeicM95GZIKg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

反射和动态代理HOOK

**它只在java层，只能通过替换对象达到目的，适用范围较小。但是，****调用反射和动态代理并不存在适配问题，实现起来较简单**。

它主要应用于java层的java Application和java Framwork。反射和动态代理是虚拟机提供的标准编程接口，可靠性较高。通过反射API可以帮助我们们访问到private属性并修改，动态代理可以直接从Interface中动态的构造出代理对象，并去监控这个对象。

常见的用法是，用动态代理构造出一个代理对象，然后用反射API去替换进程中的对象，从而达到hook的目的。如：对Java Framework API的修改常用这种方法，修改ActivityThread、修当前进程的系统调用等。

  

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/m7tZOvC2fza9CllN6tG7YO64On4RL8H6HicHALYZFgSiaTE6ch5AXwDuvEnaPH8hXqwiceTicia6V9IOzeicM95GZIKg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

JNI的Hook

**这种技术它稳定性较高，但是它****只能hook Java和Native之间的native接口函数。**

在android中，java和native的代码之间的调用，是通过JNI接口调用的，所有JNI接口的函数指针都会被保存在虚拟机的一张表中。因此，java和native之间调用可以通过修改函数指针完成。

  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

classLoader的 Hook

  

java代码的执行都是靠虚拟机的类加载器ClassLoader去加载，ClassLoader默认的双亲委派机制保证了ClassLoader总是从父类优先去加载java class。所以一类hook方案就是通过修改ClassLoader加载java class的Path路径达到目的。常见的应用场景有一些热修复技术。

**这种实现稳定性较高，但是它****需提前编译好修改后的class去替换。**

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

GOT表的hook

**这种got在ELF文件也就是so的入口函数都可以被hook，稳定性高，但是，它要求****替换后的函数签名要保持一致，只能hook so入口，无法hook so内部代码逻辑，且so的调用出现内联调用时（不查表直接跳函数地址）无法hook。**

Android进程（linux进程）加载动态链接库的时候，都是通过dlopen()函数去把so读入到当前进程中的一个内存区域中。当调用so代码时，直接跳转到so的内存区域去执行。so对外提供的函数表及函数地址也都在这块内存中。所以，一个hook方法是，修改这块函数地址，从而达到hook的目的。

例如native层的IO重定向，就可以通过这个技术hook libc的open read write等函数实现。

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

Inline hook

  

因为GOT的 hook有一定的局限性，有些应用场景需要hook so内部函数。这就要用到inline hook技术。

基本原理是在目标函数执行区域中插入Jump指令，使得cpu跳转到我们的hook函数（shellcode）中。如果我们的hook函数和原目标函数的签名不一致，还需额外保存寄存器信息，跳转回原函数时恢复寄存器信息。

inline hook原理虽简单，但是实现起来需要处理的细节很多，因为是直接去改so，所以和指令平台强相关，armv7，armv8，arm64，x86, Thumb指令集都需要去针对性的实现。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

Xposed的HOOK

  

**xposed的hook，它在java层所有的class都可以修改，Activity等都可以进行hook。但是，****ART/Dalvik每次Android系统发布大版本都会被大改，导致每个Android版本都要去适配配。稳定性变差。**

xposed的hook技术的原理就是去修改ART/Dalvik虚拟机，虚拟机为java提供运行时环境，所有的java method都保存在虚拟机一张Map维护，每个Java Method都有个是否是JNI函数的标志位，如果是JNI函数则去查找对应的native函数。所以，一个hook方案是通过把要hook的函数修改为JNI函数，然后实现一个对应的native函数从而达到hook。

  

  

  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

Frida的Hook

  

frida-java采用常见的Dalvik Hook方案，将待hook的java函数修改为native函数，当调用该函数时，会执行自定义的native函数。但是和其他hook框架不同的是，使用frida时，我们hook的代码是js实现的，所以有一个基于js代码生成native函数过程。

Frida-so通过地址进行hook。

有导出：函数名可以在导出表找到 通过导出表的数据结构 用函数名称进行函数的定位。  
无导出：函数名在导出表找不到。这里需要根据函数特征 比如字符串等 手动搜索关键字符串定位函数地址。

  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

  

参考借鉴文章

https://zhuanlan.zhihu.com/p/109157321

 ![](http://mmbiz.qpic.cn/mmbiz_png/haqlQiars3wrIJ0a6Vfic8AnrKAUMuscw7NI0MZJHvddaGYdjArhsDvESBdpiaPlicyXTD5ZNpNicJo9JWHGZAkxOJQ/0?wx_fmt=png) ** 编码安全 ** 专注于编程安全技术的分享。 27篇原创内容   公众号

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

点个在看你最好看

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)