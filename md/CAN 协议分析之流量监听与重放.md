> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/wUGsyqTyXjq4mVbReiNLEw)

本篇文章将主要为大家介绍车联网中重要的组成部分之一的 CAN 总线的协议结构，以及在没有硬件支撑的情况下如何对其进行仿真状态下的流量嗅探与重放方法的学习与研究。  

**0****1**

**CAN‍‍‍‍**

  

  

  

CAN 是控制器局域网络 (Controller Area Network, CAN) 的简称，是 ISO 国际标准化的串行通信协议。简单的来说，CAN 总线就是一种传输数据的线，主要用于在不同的 ECU 之间传输数据。

**信号表示**

而 CAN 总线由 CAN_H 和 CAN_L 两根线组成，它应用在有很多的信息共享与高可靠性的环境中。这使得汽车制造商选择 CAN 而不是使用复杂的直接信号线连接到车辆网络中的每个 ECU。  

其次在 CAN 总线中，由 CAN_H 和 CAN_L 两根线上的电位差来表示 CAN 信号，而电位差分为显性电平和隐性电平两种逻辑状态：

1. 显性电平为逻辑 0

2. 隐性电平为逻辑 1。

在 ISO11898 标准（125kbps \~ 1Mbps）中 CAN 信号的表示为下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQkpHJwxyjlEdr2flq62AUF3nJnGUAdzmRhYZj3ia5V6JicaEeOPystnETfDzIU5aqpRVsv6S59ibabg/640?wx_fmt=png)

**传****输过程**

发送过程：

CAN 控制器将 CPU 传来的信号转换为逻辑电平（即逻辑 0 - 显性电平或者逻辑 1 - 隐性电平）。CAN 发射器接收逻辑电平之后，再将其转换为差分电平输出到 CAN 总线上。

接收过程：

CAN 接收器将 CAN_H 和 CAN_L 线上传来的差分电平转换为逻辑电平输出到 CAN 控制器，CAN 控制器再把该逻辑电平转化为相应的信号发送到 CPU 上。

**帧结构**

CAN 通信的报文传输过程中有：数据帧、远程帧、错误帧、过载帧和帧间隔五种帧类型。

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQkpHJwxyjlEdr2flq62AUFLevlhIhHbzBeTiayLhoPojhIW7U6X1T4opic0XP38KmKXn0bwHBerExw/640?wx_fmt=png)

而其中标准的数据帧格式主要为四个部分，即：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQkpHJwxyjlEdr2flq62AUFbwoAKBVW4xLt3qxgKJiaTUCCWHne4o9fav74gesiaibdicOOCo8RFqFVZQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQkpHJwxyjlEdr2flq62AUFbibJHtgYMMtkPVWhGrJstKXYyxRsG1mZiaN3M3kdZCic5nzuC7FtmrJxg/640?wx_fmt=png)

1. 起始帧 (Start of Frame-SOF)：1bit，显性信号，表示数据帧的开始

2. 仲裁段 (Arbitration     Field)：包括两部分: 标识符位(Identifier field-ID) 和远程发送请求位

3. 控制段 (Control     Field):6bits，拓展标识位 (1bit)，保留位 (1bit)，数据长度编码位 (4bit)

4. 数据段 (Data     Field)：发送数据的内容，最多 8 个字节

5. 循环校验位 (CRC     Field)：循环校验序列和界定符

6. 确认段 (ACK     Field): 确认位和界定符

7. 帧结束 (End of     Fram)：7bit, 隐性信号，表示帧结束

**02****‍**

**CAN 流量监听与重放‍‍‍‍‍‍**

  

**ICSim 汽车仪表盘仿真**

首先需要使用 ICSim 工具来模拟汽车仪表盘的使用。

```
> sudo apt-get install libsdl2-dev libsdl2-image-dev can-utils  
> sudo apt-get install aptitude 
> git clone https://github.com/zombieCraig/ICSim.git
> cd ICSim
> make
> ./setup_vcan.sh 
> ./icsim vcan0    #启动仪表盘模拟器
> ./controls vcan0  #启动控制器
```

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQkpHJwxyjlEdr2flq62AUFf6oztia8TAy1w77m5oISsVlhFVYfLmnzTdsF2WBSSxA7oHqTDqqbd6g/640?wx_fmt=png)

操作方法如下：  

**![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQkpHJwxyjlEdr2flq62AUFZ7JOxSN1nZgrdHicu0xQwpKy1VGMgSc4Xr22orF2ibIibmzRpAw77sAyg/640?wx_fmt=png)**

**can-utils** 

> 项目地址：https://github.com/linux-can/can-utils

通过 can-utils 工具进行对 can 流量的监听与重放，可以使用源码安装或直接使用 apt-get 进行安装。

**candump** 

显示、过滤和记录 CAN 原始数据到文件（未解码的数据）。

通过 candump 对指定网络接口进行流量的监听，将会保存日志文件到当前目录中，在通过 ctrl+c 停止后可进行查看相应的流量数据。

保存的格式为：（时间戳） 网络接口 ID# 数据

```
> candump -l vcan0
> cat candump-2022-12-28_105004.log|more
```

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQkpHJwxyjlEdr2flq62AUFcBoDoymaichIP2SLcVOjpcsrCuRcVxB2HbwTCC1o0a3gCCDpaod6oIQ/640?wx_fmt=png)

**cansniffer**

根据仲裁 ID 进行分组显示数据，其次可以通过交互进行内容过滤。

```
> cansniffer -c vcan0
```

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQkpHJwxyjlEdr2flq62AUFJIZRjKpe3LA3ic6RDPfHqCrzCEnXTaUYexhqoJmXNibFYaibF4WXMDcjA/640?wx_fmt=png)

输入 - 000000 关闭所有数据包的显示，再输入 + ID 显示指定 ID 的数据包，如：  

```
-000000
+234
[return]
```

**canplayer**

canplayer 可以用来播放 can 帧，用于重放 candump 记录的流量内容。

```
> canplayer -I <*.log>
```

**cansend**

cansend 用于将 CAN 帧发送到一个特定的 CAN 接口。

```
> cansend  vcan0 <ID>#<DATA>
```

**SavvyCAN**

> 项目地址：https://github.com/collin80/SavvyCAN

SavvyCAN 是一个基于多个 QT 平台的 C++ 程序，主要用于 CAN 数据的逆向分析和捕获。作为同样是免费的开源工具来说，相对于前面的 can-utils 命令行的操作方式，SavvyCAN 提供了更适合初学者使用的 GUI 图形化界面，可以用于更轻松的浏览、过滤 ID 数据包等。

直接下载编译好的 appimage，便可以直接运行程序。

```
> wget https://github.com/collin80/SavvyCAN/releases/download/V208/SavvyCAN-x86_64.AppImage
> chmod 755 SavvyCAN-305dafd-x86_64.AppImage
> ./SavvyCAN-305dafd-x86_64.AppImage
```

但是由于 QTSerialBus 默认被禁用导致无法与 ICSim 配合使用，因此需要下载 QT5 环境手动编译安装 SavvyCAN。

```
> wget https://download.qt.io/archive/qt/5.14/5.14.2/qt-opensource-linux-x64-5.14.2.run
> chmod a+x ./qt-opensource-linux-x64-5.14.2.run
> ./qt-opensource-linux-x64-5.14.2.run
```

随后注册账户进行登录，并勾选上 qt5 进行安装。

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQkpHJwxyjlEdr2flq62AUFU4ZhcMAWMOzuGBwtk8tGBBHdTGoExyfUkSc3hKPjTjsFnaWqaicyjfw/640?wx_fmt=png)

在对 SavvyCAN 工具进行编译。

```
> sudo apt install qtdeclarative5-dev qttools5-dev g++  
> git clone https://github.com/collin80/SavvyCAN  
> cd SavvyCAN/
> ~/Qt5.14.2/5.14.2/gcc_64/bin/qmake CONFIG+=debug 
> make     
> ./SavvyCAN
```

### 流量监听

在 `Connection`->`Open Connection Window`->`Add New Device Connection` 中选择 `QT SerialBus Devices`，将 SerialBus Devices 选择为 `socketcan`，将 Port 选择为虚拟端口 `vcan0`：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQkpHJwxyjlEdr2flq62AUFDBQJBaaVHIuyEOyaqereraksIuxdOfNWeqewxW4yiaHqPXg9uoeBlSg/640?wx_fmt=png)

随后就可以在 Savvy CAN 中看到捕捉到的数据。

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQkpHJwxyjlEdr2flq62AUFP0FXrPeiboLXvz9hibgt6kAD1Bjg4RLsGo4iaib73eJoibaY0icTfuiaqQMYQ/640?wx_fmt=png)

### 流量重放

在 Savvy CAN 中的 `Send Frames` 里选择 `Playback`，便可以从文件加载数据或直接从捕获的数据加载数据等功能。

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQkpHJwxyjlEdr2flq62AUF8V91b9P3MGaHCIF04JqL21qhodAyqRvBwD5LqsTLCoPsricgTmLhdNw/640?wx_fmt=png)

对于 CAN 协议上的流量监听与重放的方法本篇以 can-utils 与 SavvyCAN 两种较为常用的工具为例进行讲解，到这里就算是结束了，实际上对于 CAN 协议进行流量嗅探的方法远不止于此，还可以使用如 wireshark、Kayak 等工具方便我们研究，在后续的文章中将会进行更深入的分析学习。