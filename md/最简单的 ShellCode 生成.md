> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/px3PgV_fJTiopGo2Wi0gwg)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8G5iaAarGAfJaXhhA5PUADmv8truwvTFHrGOvjJObRL7uuF2YorOTAEqMbbtHsicHuZUgAP2D7ves4g/640?wx_fmt=jpeg)

本文为看雪论坛优秀文章  

看雪论坛作者 ID：wx_墨雪妖莲

**ShellCode 初级版：**  

#### 什么是 ShellCode？  

shellcode 实际上是一段可以独立执行的代码，常指一段二进制数据，这段二进制数据独立存在，不像常规 PE 数据那样加载运行。它没有导入表导出表之类的结构，这使得 shellcode 极为灵活，同时也加大了它的编写难度。一段健壮的 shellcode 应具备很好的兼容性。因此，要编写出一个完整的 ShellCode 需要以下几个重要的技术要点：

#### **1、GetPC（用于准确定位 ShellCode 所定义的数据）**

#### 在 x86 中即为获取当前代码执行的 EIP（也就是程序执行到了哪一行代码）。 

目前 GetPC 技术一共有以下几种：

##### （1）CALL 方式

利用

```
E8 00000000 #CALL xxxx 58          #POP EAX

```

获取当前 EIP 的值。在这里，CALL 的作用等同于将下一条指令的地址压入栈后，在 jmp 到函数地址上。利用这个特性，我们可以结合 pop 将压入的地址进行弹出，从而获取到当前 EIP。  

但是虽然这种方法直观简便，但是注意很多程序在读取你所编写 ShellCode 时是自带 00 截断的，说的形象点，就像读取字符串的长度 strlen 一样，遇到 00 就会返回前面的字符串长度，后面的字符就不计数了。因此很有可能在读取 Shell Code 时会因为 00 截断导致后面的 ShellCode 无法正常加载并运行。

##### （2）FSTEVV 方式

这个方式主要是因为 x86：当一个进程正在使用 FPU（浮点单元）执行浮点运算时，这些寄存器需要有操作系统在上下文切换时保存。

重点关注这个结构体中的 fpu_instruction_pointer：

```
struct FpuSaveState
{
uint32 control_word;    // 控制码
uint32 status_word;        // 状态码
uint32 tag_word;        // 标志位
uint32 fpu_instruction_pointer;        // *指向上条FPU指令*
uint16 fpu_instruction_selector;   
uint16 fpu_opcode;
uint32 fpu_operand_pointer;
uint16 fpu_operand_selector;
uint16 reserved;
}

```

利用这个内容，我们可以得到上一条 FPU 指令所在的位置。大致情况如下：通过汇编指令 FNSTENV（将 FPU 的状态值保存在内存中），在进行 pop 就可以得到当前 EIP 的值了：

```
D9 EE           #FLDZD9 74 24 F4  #FNSTENV[ESP-0CH]5B             #POP EBX

```

#### **2、模拟导入表，获取函数地址**

作为一段可以独立运行的代码，那必然没有线程的 dll 和函数可以提供给你直接调用。因此，在这里，我们就要用到 Windows 的强大设计：PEB（进程环境块），可能讲到这里，有些人不是对齐特别的了解，在这里我从网上扣了 2 张神图提供给大家方便学习：

![](https://mmbiz.qpic.cn/mmbiz_png/3zMVo4c6cMUib0Z06gVgdNpwjmObeSULa6uibmgyN93gsyMr0dHorJic6dgDVZhEk4icibqaPWMibfYmZGiazNx7oeCLg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/3zMVo4c6cMUib0Z06gVgdNpwjmObeSULadJp9h0HibTCeUfVcvCmQP1bicKCxha6Jqbq8OqtQteyZaDj57V961O1A/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/3zMVo4c6cMUib0Z06gVgdNpwjmObeSULaPNbVNHjkVvGGX1kT003sUaiab66lrXVQ9T0dwhGShnwlmCWu4ia0lT9g/640?wx_fmt=png)

大致代码原理如下：

```
xor eax,eaxmov eax,fs:[0x30]        #获取PEB地址mov eax,[eax+0xC]        #获取PEB_LDR_DATA的结构体指针mov esi,[eax+0x1C]        #通过PEB_LDR_DATA获取到结构体成员：模块链表的头部地址mov eax,[esi]            #获取第一个加载的模块信息（根据环境的不同而不同）mov eax,[eax]            #获取第二个加载的模块信息（根据环境的不同而不同），我这里是kernel32.dllmov eax,[eax+0x8]         #获取kernel32.dll的模块基址mov kernelBase,eax        将基址保存到定义的变量进行接收

```

获取到了指定的模块基址后，我们就可以通过其来获取我们想要的函数地址了，在这里，需要对 PE 结构有一个基本的了解。

怎么获取函数地址呢？若是能够使用函数的话，当然可以直接使用 GetProcAddress 进行获取，但现在我们写的是 ShellCode，必然不可能通过这种方法进行获取，这里我们就要用到 PE 结构中的导出表了：（在这里我就不用汇编表示了，我用 C 的结构体进行表示更加明了）

```
// 获取DOS头
IMAGE_DOS_HEADER* DosHeader = (IMAGE_DOS_HEADER*)kernelBase;
// 获取NT头
IMAGE_NT_HEADERS* NtHeader = (IMAGE_NT_HEADERS*)(DosHeader->e_lfanew + kernelBase);
// 获取扩展头
IMAGE_OPTIONAL_HEADER OPHeader = NtHeader->OptionalHeader;
// 获取导出表
IMAGE_EXPORT_DIRECTORY* ExportList= (IMAGE_EXPORT_DIRECTORY*)(OPHeader.DataDirectory[0].VirtualAddress + kernelBase);
// 获取函数地址表
DWORD* FuncAddList = (DWORD*)(ExportList->AddressOfFunctions+kernelBase);
// 获取函数名称表
DWORD* NameAddList = (DWORD*)(ExportList->AddressOfNames+kernelBase);
// 获取函数序号表
SHORT* OriList = (SHORT*)(ExportList->AddressOfNameOrdinals + kernelBase);

```

获取到了导出表后，就可以通过遍历导出表中的名称表，序号表，以及函数地址表就可以进行获取函数地址了（这里我找的是 GetProcAddress）：

```
// 循环遍历，获取LoadLibrary函数地址以及GetProceAddress地址
for (int i = 0; i < ExportList->NumberOfNames; i++)
    {
if (g_strcmp((char*)(NameAddList[i] + kernelBase), g_GetProcAddress) == TRUE)
        {
            My_GetProcAddress = (MyGetProcAddress)((FuncAddList[OriList[i]]+kernelBase));
        }
    }

```

当然这里的 g_strcmp 函数和 GetProcAddress 的字符串也需要自己进行定义：

注：字符串之所以这样定义，并定义在函数内，是因为 ShellCode 加载的位置不确定，如果直接定义字符串或者全局变量，很有可能会导致数据的不可靠性。而这样定义，在汇编层就会单个字节的进行局部变量的赋值。

```
char g_GetProcAddress[] = { 'G','e','t','P','r','o','c','A','d','d','r','e','s','s',0 };

```

```
inline BOOL g_strcmp(char* str1, char* str2)
{
// 判断对比字符的长度，防止访问越界
int length = 0;
for (length;; length++)
    {
if (str1[length] == 0 || str2[length] == 0)
break;
    }
// 进行对比
for (int i = 0;i<length; i++)
    {
if (str1[i] != str2[i])
return FALSE;
else if (str1[i] == str2[i] && str2[i + 1] == 0&&str1[i+1]==0)
return TRUE;
    }
};

```

做到了以上代码，我们就可以通过 kernel32.dll 找到 GetProcAddress 和 LoadLibrary 的函数地址，进行后续的操作。

例：通过获取到的 GetProcAddress 地址和 LoadLibrary 的函数地址，我们就可以直接调用它去获取其他的函数地址。

比如实现一个弹框：MessageBoxA(在 user32.dll 中)

```
// 定义函数指针
typedef HMODULE(WINAPI* MyLoadLibrary)(_In_ LPCSTR lpFileName);
typedef FARPROC(WINAPI* MyGetProcAddress)(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
typedef int(WINAPI* MyMessageBox)(_In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType);
// 通过遍历导出表进行获取函数地址（这里我就不详细写了，具体情况就是上面的代码修改一下）
HMODULE hModule = NULL;
hModule=My_LoadLibrary(g_user32);
My_MessageBox=(MyMessageBox)My_GetProcAddress(hModule, g_MessageBox);
My_MessageBox(0, 0, 0, 0);

```

#### **3、生成 ShellCode**

#### 上述写的代码是用 C 语言结合嵌入汇编进行编写的，现在我们要做的就是将程序进行生成（Release 版本我用的是），然后用 x32dbg 进行调试，找到程序 main 函数的起点和终点，进行二进制代码复制，这段代码就是我们的 ShellCode：

操作如下：选中代码，右键二进制 -> 编辑 -> 复制数据 -> 选中 C 样式 ShellCode 字符串 -> 复制即可

![](https://mmbiz.qpic.cn/mmbiz_png/3zMVo4c6cMUib0Z06gVgdNpwjmObeSULaJh9ftdVibhcTXe7G6XZ6a6YRPQGqxafyKpibkA7v98BFIFQ01lJaAuIQ/640?wx_fmt=png)

#### **4、调试生成的 ShellCode**

对于 Shell Code 的调试，我们可以直接运用以下代码（这里的原理我就不多说了，就是将 arr 的首地址当成代码进行执行）：

不过要注意的是：#pragma comment(linker, "/section:.data,RWE") 要加上，不然你的数据区就是不可执行的，自然就不会运行你编写的 ShellCode 了。

```
#include<Windows.h>
#include<iostream>
// 使数据段可读可写可执行
#pragma comment(linker, "/section:.data,RWE")
// 生成的ShellCode
char arr[] = { "\x55\x8B\xEC\x81\xEC\x2C\x01\x00\x00\x53\x33\xC0\xC7\x45\xD8\x4C\x6F\x61\x64\x56\x57"\
"\xC7\x45\xDC\x4C\x69\x62\x72\xC7\x45\xE0\x61\x72\x79\x41\x88\x45\xE4\xC7\x45\xC8\x47"\
"\x65\x74\x50\xC7\x45\xCC\x72\x6F\x63\x41\xC7\x45\xD0\x64\x64\x72\x65\x66\xC7\x45\xD4"\
"\x73\x73\x88\x45\xD6\xC7\x45\xF4\x75\x73\x65\x72\xC7\x45\xF8\x33\x32\x2E\x64\x66\xC7"\
"\x45\xFC\x6C\x6C\x88\x45\xFE\xC7\x45\xE8\x4D\x65\x73\x73\xC7\x45\xEC\x61\x67\x65\x42"\
"\xC7\x45\xF0\x6F\x78\x41\x00\x33\xC0\x64\xA1\x30\x00\x00\x00\x8B\x40\x0C\x8B\x70\x1C"\
"\x8B\x06\x8B\x00\x8B\x40\x08\x89\x45\xC4\x8B\x5D\xC4\x8D\xBD\xD4\xFE\xFF\xFF\x6A\x38"\
"\x59\x8D\x73\x18\x03\x73\x3C\xF3\xA5\x8B\x85\x34\xFF\xFF\xFF\x33\xFF\x33\xF6\x8B\x4C"\
"\x18\x1C\x8B\x54\x18\x20\x03\xCB\x89\x4D\xBC\x03\xD3\x8B\x4C\x18\x24\x8B\x44\x18\x18"\
"\x03\xCB\x89\x55\xB4\x89\x4D\xC0\x89\x45\xB8\x85\xC0\x74\x2E\x8D\x45\xC8\x50\x8B\x04"\
"\xB2\x03\xC3\x50\xE8\x40\x00\x00\x00\x59\x59\x83\xF8\x01\x75\x0F\x8B\x45\xC0\x8B\x4D"\
"\xBC\x0F\xBF\x04\x70\x8B\x3C\x81\x03\xFB\x8B\x55\xB4\x46\x3B\x75\xB8\x72\xD2\x8D\x45"\
"\xD8\x50\x53\xFF\xD7\x8D\x4D\xF4\x51\xFF\xD0\x8D\x4D\xE8\x51\x50\xFF\xD7\x33\xC9\x51"\
"\x51\x51\x51\xFF\xD0\x5F\x5E\x5B\xC9\xC3\x55\x8B\xEC\x53\x8B\x5D\x0C\x33\xD2\x56\x8B"\
"\x75\x08\x57\x8B\xFA\x38\x16\x74\x11\x8B\xCB\x8B\xC6\x2B\xCE\x38\x14\x01\x74\x06\x47"\
"\x40\x38\x10\x75\xF5\x85\xFF\x7E\x30\x8B\xC6\x2B\xC3\x89\x45\x08\x8D\x0C\x1A\x8A\x04"\
"\x08\x3A\x01\x75\x1D\x80\x7C\x1A\x01\x00\x75\x07\x80\x7C\x32\x01\x00\x74\x0A\x42\x3B"\
"\xD7\x7D\x0C\x8B\x45\x08\xEB\xDE\x33\xC0\x40\xEB\x02\x33\xC0\x5F\x5E\x5B\x5D\xC3" };
int main()
{
    _asm {
        lea eax,arr
        push eax
        jmp eax
    }
}

```

运行效果如下：（当然你也可以添加弹框的参数，用上述的 char 数组进行添加），或者自己写一些有趣的小玩意。

![](https://mmbiz.qpic.cn/mmbiz_png/3zMVo4c6cMUib0Z06gVgdNpwjmObeSULaN6qJicHMZByExhXGI1icld2w6ibtmELjhYzawZTxv8rrVFPsnyV83744Q/640?wx_fmt=png)

end

  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HIUyx5My20Ou0SxHOu78ibp27yKKDDE4CicnibJzoAreQ9TtX7zG7tfGH8QcylEEOSVGPv5nXHmB1SQ/640?wx_fmt=png)

  

**看雪 ID：wx_墨雪妖莲**

https://bbs.pediy.com/user-home-916882.htm

  * 本文由看雪论坛 wx_墨雪妖莲 原创，转载请注明来自看雪社区。

[![](https://mmbiz.qpic.cn/mmbiz_jpg/b5wZciafGVmkaLwgsWgGNozTJLmUDKpCxXl7Ks2icTRfvuaWO8XSn3NpxjzibAiaXFRs1evXibCLAA010O9BW1N3bkw/640?wx_fmt=jpeg)](https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458384556&idx=3&sn=e8ea619b79119926ee20636c8896fd30&scene=21#wechat_redirect)

《安卓高级研修班》2021 年秋季班火热招生中！

**#** **往期推荐**

*   [对安卓反调试和校验检测的一些实践与结论](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458387262&idx=1&sn=cebaea52889ccbc361791e6887eae01c&chksm=b18f33b486f8baa27234d50cf334ed82e5c0d309e99191a814117259640b1cece9c3eb44d158&scene=21#wechat_redirect)
    
*   [Bingo.png 图片逆向分析](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458387168&idx=2&sn=b7ff8510c4c080fd149b76e6da7a0817&chksm=b18f326a86f8bb7c839d73eb1c0b52a0fa2d0131813181efa7a2f79314798a525a0648eac9e5&scene=21#wechat_redirect)
    
*   [Go 语言逆向初探](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458387116&idx=1&sn=c668daea30bc9dce8d79d316e93993e4&chksm=b18f322686f8bb30e81b746446f08dcd381a588b5c0c6b842007cc822a875bd5ed14c2d74d6a&scene=21#wechat_redirect)
    
*   [AndroidNativeEmu 和 unidbg 对抗 ollvm 的字符串混淆](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458387084&idx=1&sn=11b65ecf03fbdababd8e16cb63381d29&chksm=b18f320686f8bb1038590723551478822d17d2d341262bbdb5a8b8ae764a925ec4bf3ad74573&scene=21#wechat_redirect)
    
*   [强网杯赛题解析 | unicorn_like_a_pro](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458387028&idx=1&sn=871e93d6cc7610a13b7303f50d343934&chksm=b18f32de86f8bbc8ecbb8772bc68b670b9872313cfeeb8aa5666bb9a7805df613818818369a1&scene=21#wechat_redirect)  
    

  

  

![](https://mmbiz.qpic.cn/mmbiz_jpg/Uia4617poZXP96fGaMPXib13V1bJ52yHq9ycD9Zv3WhiaRb2rKV6wghrNa4VyFR2wibBVNfZt3M5IuUiauQGHvxhQrA/640?wx_fmt=jpeg)

公众号 ID：ikanxue  

官方微博：看雪安全

商务合作：wsc@kanxue.com

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8EbEJaHl4j4oA4ejnuzPAicdP7bNEwt8Ew5l2fRJxWETW07MNo7TW5xnw60R9WSwicicxtkCEFicpAlQg/640?wx_fmt=gif)

**球分享**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8EbEJaHl4j4oA4ejnuzPAicdP7bNEwt8Ew5l2fRJxWETW07MNo7TW5xnw60R9WSwicicxtkCEFicpAlQg/640?wx_fmt=gif)

**球点赞**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8EbEJaHl4j4oA4ejnuzPAicdP7bNEwt8Ew5l2fRJxWETW07MNo7TW5xnw60R9WSwicicxtkCEFicpAlQg/640?wx_fmt=gif)

**球在看**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8EbEJaHl4j4oA4ejnuzPAicd7icG69uHMQX9DaOnSPpTgamYf9cLw1XbJLEGr5Eic62BdV6TRKCjWVSQ/640?wx_fmt=gif)

点击 “阅读原文”，了解更多！