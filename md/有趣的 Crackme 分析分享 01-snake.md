> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzI4MDQ5MjY1Mg==&mid=2247504200&idx=2&sn=5019364790b9713198973d0464c306cf&chksm=ebb53e4bdcc2b75d493785082933abf7624952bfbedaad922cb79662ff36ea5c37822b6a8cca&scene=21&sessionid=1662135887&key=78fb1eae9cadd3bd166648c4b87221952cd41fda2219f2c7c7ef0ea3386ab7e1524a9da2069a5f42050fcf0b1ffb081b73ab2fbfdee185188aaa2b823545d34f534b611756eac5c43bf9e702aaf41b89b5a8f9830aad7dcbb9e70e9285811d6f218c85ff92f2785d172d443a863209a3f010f310a420142df9eae5960de44299&ascene=15&uin=MzgxODQ4MjMz&devicetype=Windows%20Server%202016%20x64&version=63070517&lang=zh_CN&session_us=gh_f64291c6fcef&exportkey=AxJb3zF48MJoTR01wyWVyZc=&acctmode=0&pass_ticket=s4FD/u3ZgLu00QW/dOU%20GLkouXqDdmayP5ppccSENtfKmw%20Vrjvsp3GML1eE07xg&wx_header=0&fontgear=2#wechat_redirect)

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3Uibs8wicKVvNazj0IibytzkMDJBmNm3VefIXPPia74oCvTOuIHXic5jq32odKU8iauGFK9eSz6QsHAPA00fA/640?wx_fmt=png)

前言
--

曾经试图挑战 160 个 cm 练习，但是很快又放弃了，这次重新归来，由于很多 cm 很重复没啥意思，所以就挑着有趣的或者有价值的来论坛发帖跟大家分享分享（当然，也会有其他来源的 cm）

对于其他的 cm 分析，有兴趣的童鞋可以去我的博客上逛逛

本文的 cm 来自新 160 个 crackme 练习中的第 60 个，以静态分析为主，动态分析可以看 b 站 up 主的分析视频

信息收集
----

### 运行情况：

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqpjREFojHwuZPmLFibgGZJdd3Wf3DlG6EI7hzzMsbkWdCm3fLkjwZSlkw/640?wx_fmt=png)

### 查壳与脱壳：

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqp7ubkqcViacDjibPDWO51uBCbRFgpB2ibgk5ictltINkXP5xgYUytje0WWw/640?wx_fmt=png)

调试分析
----

### Check 按钮事件

老样子，IDA 打开，找到 Check 按钮的事件分支：

首先是获取 Name 和 Serial，为空会提示

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqppnQ9Rib3xFY6HVOZStSDVwicTDRjmjgH6zibQNicDDsGjgO7q1EB3z6MKQ/640?wx_fmt=png)

然后一个 call 验证 Serial 合法性，不行就弹窗提示

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqphhianhqAycWjibsHawXKhuVoaxeibZKDLXt9IiavXCOLJzaiaa4eKx65ZMQ/640?wx_fmt=png)

这个 call 的内容如下：判断内容要由数字和大写字母组成

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqpAEbCrr2fSY1J4PXUWQibFGLCpxc97XW6c5ibc6y8vVuU4oR6R0hkEkPg/640?wx_fmt=png)

再往下就是三个 call 和弹窗提示验证是否成功了：

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqpkn7cwUeYkFcXGTK2PH1H2cMtNTAaYTtsylwuNujvNvpl7zJiaMqw9eA/640?wx_fmt=png)

### 验证过程 -- 第 1 个 Call

验证过程主要是 3 个 call

首先是第一个 call：

内容较少，简单来说就是填充数组

填充 16 个 FF，然后填充 16*16 个 00，然后再填充 16 个 FF

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqpNdGEekDK9Zuic2AlMeL0x2yEViaW89TmFFxtah6sMMAXDCQHMWib6dhiag/640?wx_fmt=png)

### 验证过程 -- 第 2 个 Call

第 2 个 Call 内容多点

首先是对输入的 Name 进行处理，累加每一个字符，得到一个累加值，保存到 dl

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqpt1q3REv6crch7ia0lytxic82p3vux4xbC6yfBF4vUkic3NnTCGJFavRMQ/640?wx_fmt=png)

接下来生成 CC，通过累加值 dl 和取出来的字节进行异或，得到数组索引，该位置是 0 就往该位置填充 CC，计数 CC 的数量

累加值异或字节，然后用过的累加值再减去字节值，来使得 CC 随机分布，但最终取决于输入的 Name

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqphKHECmLyP4FcJfIicaJqYaHjao52aYsWyht67QJF8zibJRJ4X1bXh73Q/640?wx_fmt=png)

再往下就是填充 DD，总共填充一个，接着用刚刚填充 CC 的位置计算方法进行

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqpRB34zzXnia3JVvrXhibjc0UtP3yz7Qd1l9q1FObP2fSWCQempwxh0x1Q/640?wx_fmt=png)

再往后就是填充 99：

直接用计算到最后的 dl 作为索引进行，如果是 00，就填充为 99，否则就往前挪一格再次判断，最后保存 99 的地址

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqpkhOT5xPpqfgk14Ggrhg9vPaA22ib7Lc51zvy9Qgm8Pz3UhZxWd6Gq0A/640?wx_fmt=png)

使用字符串 selph 生成一个地图看看：

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqpHUGibxvye8oQbmFABH1hmeNnG09A9nZKm0lA9Eh4Tq3w7gwPbvIZm6w/640?wx_fmt=png)

### 验证过程 -- 第 3 个 Call

到这里已经很明显的感觉到了，16*16 的地图，生成了很多 CC，然后有一个 DD，一个 99，再加上程序名 snake，这就是一个贪吃蛇啊

第一个 call 开辟空间，第二个 call 布置场地，第三个 call 理所应当就是开始游戏了！

首先获取当前位置和序列号，通过序列号的输入来进行移动

首先是判断输入是否是数字，是数字则直接进行移动，这里的移动是通过加减数组的索引进行的

判断方式是这样进行的：取数字的后两位：

*   00：向下一格
    
*   01：向上一格
    
*   10：向左一格
    
*   11：向右一格
    

如果数字不只是后两位有值，则执行完用前两位再次走一遍判断，比如 9，就是 1001，就是上左移动一格，如果输入的是大写字母的话，也是类似的，具体可见反汇编这一段的计算过程

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqpYQd0RzsKXvTNZR2iblnUyboAq1VFp1uM7jWOmDibTtrK0YBwdlfaiclQQ/640?wx_fmt=png)

计算完移动方向之后，该进行移动判断了：

如果下一个位置是 0，或者 CC，都跳转去执行，如果是 99 则返回 0 失败，如果是 DD 且没吃完 CC，也返回 0 失败，如果是 CC 吃完了，就是返回 1 成功

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqpOMjicblHnf74QqgvzgkiaiaVuicyB2busjUGrzRRDcSCJicRWEfIWcmuIXQ/640?wx_fmt=png)

首先看如果下一个位置是 00 怎么处理：

调用一个 call，就是走格子用的，然后判断是否有高 2 位，有的话再按高 2 位走一遍，没有的话，获取下一个字符进入下一个循环

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqpBVibpYxzpVSdYSyicKmPxBTvUy4hsy6SiazdrDdaG5bicGS5bLKQweythQ/640?wx_fmt=png)

接下来看看这个走格子的 call：

首先是获取当前格子的新位置，起始位置，把新位置写入 99，把当前位置写入 00

然后 edi+4 进行判断，edi 里装的是个数组，数组成员是当前蛇的身子的位置，当长度大于 1 的时候，edi+4 就是第二个位置，有值的时候，把刚刚写入 0 的位置作为新位置，把身子的位置作为当前位置，再次进行相同的操作

视觉效果就是，身子跟着头一起移动了

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqpiaDk1ZLibpYcZbLVCXUXvWXO3h98gTJTlujz0uOJGe21yZm8U6V3cSRQ/640?wx_fmt=png)

回到刚刚的循环里，如果移动遇到了 CC 则再次执行这个移动的函数，同时给 count 计数 - 1，这个 count 变量保存的是当前场上 CC 的数量

然后把这个函数清零的位置变成 99，也就是让蛇身子最后一个位置本来清零了，结果又填充回 99，同时把新的位置加入到身子数组里

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqp9icY9vbAficGL3Wm6UicAvMjz6Ed9jgkRQllhC0oBQcDVG8rOuKT2iaUjA/640?wx_fmt=png)

到这里，整个程序的逻辑分析完整了，就是贪吃蛇，吃完所有 CC 走到 DD 即可验证通过

### 注册机

注册码生成算法：

```
#include <iostream>#include <setjmp.h>using namespace std;uint8_t areas[18][16] = {0};uint8_t countCC = 0;uint8_t snake[10][2] = {0};uint8_t pos[10][2] = { 0 };void GenerateAreas(string str) {    // 场地生成    memset(&areas[0], 0xFF, 0x10);    memset(&areas[1], 0, 0x100);    memset(&areas[17], 0xFF, 0x10);    // 填充CC    uint8_t* areasBegin = (uint8_t*)&areas[1];    uint8_t sum = 0;    uint8_t tmp = 0;    for (auto var : str) sum += var;    for (auto var : str) {        tmp = var ^ sum;        sum -= tmp;        *(areasBegin + tmp) = 0xCC;        // 保存坐标        pos[countCC][0] = tmp / 16;        pos[countCC][1] = tmp % 16;        countCC++;    }    // 填充DD    sum ^= tmp;    for (; *(areasBegin + (tmp -= sum)) == 0xCC; sum--);    *(areasBegin + tmp) = 0xDD;    pos[countCC][0] = tmp / 16;    pos[countCC][1] = tmp % 16;;    // 填充99    tmp = sum;    for (; *(areasBegin + tmp) == 0xCC || *(areasBegin + tmp) == 0xDD; tmp--);    *(areasBegin + tmp) = 0x99;    snake[0][0] = tmp / 16;    snake[0][1] = tmp % 16;    countCC++;}int main(){    GenerateAreas("selph");    // 生成注册码：长度短的情况下，不用考虑自己咬到自己    uint8_t x = snake[0][0];    uint8_t y = snake[0][1];    for (int i = 0; i<countCC; i++) {        uint8_t xCC = pos[i][0];        uint8_t yCC = pos[i][1];        if (yCC - y >= 0) for (int i = 0; i < yCC - y; i++)cout << "3";        else for (int i = 0; i < y - yCC; i++)cout << "2";        if (xCC - x >= 0) for (int i = 0; i < xCC - x; i++)cout << "0";        else for (int i = 0; i < x - xCC; i++)cout << "1";        x = xCC;        y = yCC;    }}
```

效果：

```
selph33333333333333311222222200000031111333111111222200000000000
```

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3UibtzELYfgcBa1aVxibLxFFQqpZ14ZNvVJ3scFCt0110ZcNBFdnTQausU2xplQDicrkfhGIl3iakWyuwLg/640?wx_fmt=png)

总结
--

有趣的验证方式，通过输入的用户名生成贪吃蛇地图，通过密码来进行移动，吃完豆子 CC，走到终点 DD 算验证通过，很有趣的一次逆向体验

该内容转载自网络，更多内容请点击 “阅读原文”

![](https://mmbiz.qpic.cn/mmbiz_png/8H1dCzib3Uibs8wicKVvNazj0IibytzkMDJB7Fib9vPahRVb96WsjciabeVaXSu25HOQyBFKqFrtG4c7kQAOBhD9GQLQ/640?wx_fmt=png)