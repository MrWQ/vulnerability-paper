> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MjM5Njg5ODU2NA==&mid=2257500406&idx=1&sn=c39c6d7c26a31b9c97899410c81f31cf&scene=21#wechat_redirect)

前言
==

Android 系统上抓包 HTTPS 是不是越来越难了？高版本无法添加 CA 证书，抓包软件依赖太多，VPN 模式、或 HOOK 程序时，会被 APP 检测到。对抗成本愈加增高。有什么万能的工具吗？

是的，eCapture for Android[1] 来了。以后在 Android 上抓 HTTPS 通讯包，再也不用安装 CA 证书了，再也不用下载一堆 python 依赖环境了，再也不用重打包 ssl 类库了，再也不用改一堆手机参数了，一键启用，简单明了。

eCapture 简介
===========

eCapture 是一款无需 CA 证书即可抓获 HTTPS 明文的软件。支持 pcapng 格式，支持 Wireshark 直接查看。基于 eBPF 技术，仅需 root 权限，即可一键抓包。eCapture 中文名旁观者，即 当局者迷，旁观者清。![](https://mmbiz.qpic.cn/mmbiz_png/IjnZ9ic9bGHsZh69nmys4sfu7uiczoQsKTkCzh2njUuGlqtaNXCALtozjibot3T9CKodjNqUSfsOD5r2uHcvo7BJA/640?wx_fmt=png)

2022 年年初上海疫情期间，笔者开始编写并开源 [2]，至今已经半年，GitHub 上已经 `4200`个星星。

[eCapture 是基于 eBPF 技术实现的抓包软件](http://mp.weixin.qq.com/s?__biz=MzUyMDM0OTY5NA==&mid=2247483843&idx=1&sn=fd17a5037e0941b415e53f6b0eda74d2&chksm=f9eaf352ce9d7a4482d07a750cec0340f975b5260ac78cfe3ced4b3340539a779b43ff69262d&scene=21#wechat_redirect)，依赖系统内核是否支持 eBPF。目前支持在操作系统上，支持了 X86_64\ARM64 的 Linux kernel 4.18 以上内核，支持了 ARM64 Android(Linux) kernel 5.4 以上版本。最新版是在 2022 年 9 月 9 日发布的 v0.4.3 版本。

![](https://mmbiz.qpic.cn/mmbiz_png/IjnZ9ic9bGHsZh69nmys4sfu7uiczoQsKTddia4XjYibdPmbd6g8rXDoJpvxoVvpZcL8IQicz2PVAcnzTVerhicMBgVw/640?wx_fmt=png)

演示视频
====

下载后，一条命令启动，干净利索。`./ecapture tls -w ecapture.pcapng`

先看演示视频，演示环境为 Ubuntu 21.04、Android 5.4 （Pixel 6）。

以下视频来源于榫卯江湖 [视频详情](javascript:;)

模块功能
----

eCapture 支持 tls、bash、mysqld、postgres 等模块的信息提取与捕获。本文仅讨论`tls`这个 HTTPS/TLS 明文捕获模块。

加密通讯明文捕获 --tls 模块
-----------------

`tls`模块在加密通讯类库上，支持了 openssl、gnutls、nspr/nss、boringssl 等类库。但在 Android 上，pcapng 模式只支持 boringssl，文本模式则都支持。

如何使用 eCapture
=============

环境依赖
----

1.  操作系统 Linux kernel 4.18 以上，Android kernel 5.4 以上。
    
2.  支持 BPF，可选支持 BTF（eCapture 版本不同）
    
3.  root 权限
    

版本选择
----

BPF CO-RE[3] 特性为 BTF 通用的格式，用于做跨内核版本兼容。有的 Android 手机是没开启 BTF。可以查看系统配置确认，`CONFIG_DEBUG_INFO_BTF=y`为开启；`CONFIG_DEBUG_INFO_BTF=n`为关闭；其他为不支持 BPF，无法使用 eCapture。

```
cfc4n@vm-server:~$# cat /boot/config-`uname -r` | grep CONFIG_DEBUG_INFO_BTF
CONFIG_DEBUG_INFO_BTF=y
```

Android 系统上，config 是 gzip 压缩的，且配置文件目录也变了。可使用`zcat /proc/config.gz`命令代替。

eCapture 默认发行了支持 CO-RE 的 ELF 程序。Android 版会发行一个 5.4 内核不支持 BTF（即没有 CO-RE）的版本。下载后，可以通过`./ecapture -v`确认。非 CO-RE 版本的 version 信息中包含编译时的内核版本。

```
# no CO-RE
eCapture version:	linux_aarch64:0.4.2-20220906-fb34467:5.4.0-104-generic
# CO-RE
eCapture version:	linux_aarch64:0.4.2-20220906-fb34467:[CORE]
```

若版本不符合自己需求，可以自行编译，步骤见文末。

全局参数介绍
------

全局参数重点看如下几个

```
root@vm-server:/home/cfc4n/# ecapture -h
      --hex[=false]  print byte strings as hex encoded strings
  -l, --log-file=""  -l save the packets to file
  -p, --pid=0   if pid is 0 then we target all pids
  -u, --uid=0   if uid is 0 then we target all users
```

1.  `--hex` 用于 stdout 输出场景，展示结果的十六进制，用于查看非 ASCII 字符，在内容加密、编码的场景特别有必要。
    
2.  `-l, --log-file=`  保存结果的文件路径。
    
3.  `-p, --pid=0` 捕获的目标进程，默认为 0，则捕获所有进程。
    
4.  `-u, --uid=0` 捕获的目标用户，默认为 0，则捕获所有用户，对 Android 来说，是很需要的参数。
    

模块参数
----

```
root@vm-server:/home/cfc4n/project/ssldump# bin/ecapture tls -h
OPTIONS:
      --curl=""  curl or wget file path, use to dectet openssl.so path, default:/usr/bin/curl
      --firefox="" firefox file path, default: /usr/lib/firefox/firefox.
      --gnutls="" libgnutls.so file path, will automatically find it from curl default.
      --gobin="" path to binary built with Go toolchain.
  -h, --help[=false] help for tls
  -i, --if (TC Classifier) Interface name on which the probe will be attached.
      --libssl="" libssl.so file path, will automatically find it from curl default.
      --nspr=""  libnspr44.so file path, will automatically find it from curl default.
      --port=443 port number to capture, default:443.
      --pthread="" libpthread.so file path, use to hook connect to capture socket FD.will automatically find it from curl.
      --wget=""  wget file path, default: /usr/bin/wget.
  -w, --write="" write the  raw packets to file as pcapng format.
```

#### -i 参数

`-i`参数为网卡的名字，Linux 上默认为`eth0`，Android 上默认为`wlan0`，你可以用这个参数自行指定。

输出模式
----

输出格式支持两种格式，文本跟 pcapng 文件。有三个参数，

1.  默认，全局参数，输出文本结果到 stdout
    
2.  `-l` 全局参数，保存文本结果的文件路径
    
3.  `-w` 仅 tls 模块参数，保存 pcapng 结果的文件路径
    

类库路径
----

Linux 上支持多种类库，不同类库的路径也不一样。

<table><thead><tr><th>类库</th><th>参数路径</th><th>默认值</th></tr></thead><tbody><tr><td>openssl/boringssl</td><td>--libssl</td><td>Linux 自动查找，Android 为 / apex/com.android.conscrypt/lib64/libssl.so</td></tr><tr><td>gnutls</td><td>--gnutls</td><td>Linux 自动查找，Android pcapng 模式暂未支持</td></tr><tr><td>nspr/nss</td><td>--nspr</td><td>Linux 自动查找，Android pcapng 模式暂未支持</td></tr></tbody></table>

### 文本模式

`-l` 或者不加 `-w` 参数将启用该模式。

支持 openssl、boringssl、gnutls、nspr/nss 等多种 TLS 加密类库。支持 DTLS、TLS1.0 至 TLS1.3 等所有版本的加密协议。支持`-p`、`-u`等所有全局过滤参数。

### pcapng 模式

`-w` 参数启用该模式，并用`-i`选择网卡名，Linux 系统默认为`eth0`,Android 系统默认为`wlan0`，

仅支持 openssl、boringssl 两个类库的数据捕获。暂不支持 TLS 1.3 协议。

![](https://mmbiz.qpic.cn/mmbiz_jpg/IjnZ9ic9bGHsZh69nmys4sfu7uiczoQsKT07ll5sfqP6vnZoIgAkBlR5UibAZQZrRuWB4lopNdCvDQ9O0VjVjDxnA/640?wx_fmt=jpeg)

### 类库与参数支持

在 Linux 系统上，大部分类库与参数都是可以支持的。但在 Android 系统上，因为内核与 ARM 架构的原因，支持的参数上，有一定的差异。

#### 不同模式的参数支持

`-p`、`-u`两个全局参数，支持文本模式，不支持 pcapng 模式。这是因为 pcapng 模式是使用 eBPF TC 技术实现。![](https://mmbiz.qpic.cn/mmbiz_png/IjnZ9ic9bGHsZh69nmys4sfu7uiczoQsKTErHiccJDhwKRkVtiaV9qSugZx5SMVPOTzPyRzRG7uT24JHvibbCnC0yzA/640?wx_fmt=png)

<table><thead><tr><th>模式</th><th>-p</th><th>-u</th><th>--libssl<br></th><th>--port<br></th></tr></thead><tbody><tr><td>文本</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>pcapng</td><td>❌</td><td>❌</td><td>✅</td><td>✅</td></tr></tbody></table>

#### 不同模式的类库以协议支持

<table><thead><tr><th>模式</th><th>openssl（类库）</th><th>boringssl（类库）</th><th>TLS 1.0/1.1/1.2（协议）</th><th>TLS 1.3（协议）</th></tr></thead><tbody><tr><td>文本</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>pcapng</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr></tbody></table>

pcapng 模式暂时不支持 TLS 1.3，TLS 1.3 密钥捕获功能 [4] 已经开发完成，只是遇到一些 BUG，还在解决中。笔者不是 openssl 的专家，对 TLS 协议也不太熟。需要补充这两块的知识，解决起来成本比较高，也欢迎对这块擅长的朋友一起来解决。

与 tcpdump 联合使用
--------------

eCapture 基于 eBPF TC，实现了流量捕获，并保存到 pcapng 文件中。基于 eBPF Uprobe 实现了 TLS Master Secret 的捕获。并基于 Wireshark 的 Decryption Secrets Block (DSB)[5] 标准，实现了 gopacket 的 DSB 功能 [6]，合并网络包与密钥，保存到 pcapng 中。

eCapture 在网络包捕获上，没有 tcpdump 强大，不支持丰富的参数。你可以用 eCapture 捕获 master secrets，用 tcpdump 捕获网络包，然后使用 wiresahrk 自定义设置密钥文件，配合使用。

#### 网络包捕获

tcpdump 的常规用法，不再赘述。

#### 密钥捕获

同时启用 ecapture ，模式可以选文本或者 pcapng，都会保存 TLS 的 master secrets 密钥数据到 ecapture_masterkey.log 中。

#### 网络包查看

用 Wireshark 打开网络包文件，设置这个 master key 文件，之后就可以看到 TLS 解密后的明文了。

配置路径：`Wireshark` --> `Preferences` --> `Protocols` --> `TLS` --> `(Pre)-Master-Secret log filename`![](https://mmbiz.qpic.cn/mmbiz_jpg/IjnZ9ic9bGHsZh69nmys4sfu7uiczoQsKTicLKPQUzBiaNMibEcCzyC9SIK7WzT7hWiaYHZCbYAdhdXNajFgUdicunUrw/640?wx_fmt=jpeg)

参数
--

### 指定路径

#### 默认路径

在 Android 上，Google 使用了 boring ssl 类库，也就是 C++ 语言在`libssl`基础上的包装。默认情况下，会使用`/apex/com.android.conscrypt/lib64/libssl.so`路径。

#### APP 的类库确认

你可以使用`lsof -p {APP PID}|grep libssl`来确认。若不是默认路径，则可以使用`--libssl`参数来指定。

高级用法
====

如果你需要查看的 APP 是自定义 SSL 类库，那么你可以自助修改 eCapture 来实现。

### 自定义函数名与 offset

首先，需要确定 HOOK 函数的函数名或者符号表地址。

#### 没有源码

如果你没有目标类库的源码，可以通过 IDA 等软件静态分析、动态调试，确定 SSL Write 的地址 offset。在配置填写在`user/module/probe_openssl.go`文件中，对应的 probe 配置部分。

```
{    Section:          "uprobe/SSL_write",    EbpfFuncName:     "probe_entry_SSL_write",    AttachToFuncName: "SSL_write",    UprobeOffset:       0xFFFF00, // TODO    BinaryPath:       binaryPath,},
```

### offset 自动计算

如果你有源码，则可以自行阅读源码确定函数名或者符号表的地址。对于结构体的成员属性读取，则可以通过`offsetof`宏来自动计算。通过偏移量的方式，读取内容。

```
//  g++ -I include/ -I src/ ./src/offset.c -o off#include <stdio.h>#include <stddef.h>#include <ssl/internal.h>#include <openssl/base.h>#include <openssl/crypto.h>#define SSL_STRUCT_OFFSETS               \    X(ssl_st, session)              \    X(ssl_st, s3)              \    X(ssl_session_st, secret)        \    X(ssl_session_st, secret_length)  \    X(bssl::SSL3_STATE, client_random) \    X(bssl::SSL_HANDSHAKE, new_session) \    X(bssl::SSL_HANDSHAKE, early_session) \    X(bssl::SSL3_STATE, hs) \    X(bssl::SSL3_STATE, established_session) \    X(bssl::SSL_HANDSHAKE, expected_client_finished_)    struct offset_test{    /* data */    int t1;    bssl::UniquePtr<SSL_SESSION> session;};int main() {    printf("typedef struct ssl_offsets { // DEF \n");#define X(struct_name, field_name) \    printf("   int " #struct_name "_" #field_name "; // DEF\n");    SSL_STRUCT_OFFSETS#undef X    printf("} ssl_offsets; // DEF\n\n");    printf("/* %s */\nssl_offsets openssl_offset_%d = { \n",           OPENSSL_VERSION_TEXT, OPENSSL_VERSION_NUMBER);#define X(struct_name, field_name)                         \    printf("  ." #struct_name "_" #field_name " = %ld,\n", \           offsetof(struct struct_name, field_name));     SSL_STRUCT_OFFSETS#undef X    printf("};\n");    return 0;}
```

![](https://mmbiz.qpic.cn/mmbiz_jpg/IjnZ9ic9bGHsZh69nmys4sfu7uiczoQsKTRNicicHn24jcbIJBML8jdzqFbMsBOObtoNtxIrIItjrxu4JGV1KBib5wQ/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/mmbiz_jpg/IjnZ9ic9bGHsZh69nmys4sfu7uiczoQsKTdiafia652vTKMzPGCCLxVZnRT6Sogr8kP1MlsRA8F1GBjDU7UlEUTACQ/640?wx_fmt=jpeg)

### 参数提取

对于参数，你需要确认被 HOOK 函数的参数类型，以便确认读取方式，可以参考`kern/openssl_kern.c`内的`SSL_write`函数实现。

编译
--

### ARM Linux 编译

公有云厂商大部分都提供了 ARM64 CPU 服务器，笔者选择了腾讯云的。在`广州六区`中，名字叫`标准型SR1`(SR1 即 ARM 64CPU)，最低配的`SR1.MEDIUM2` 2 核 2G 即满足编译环境。可以按照`按量计费`方式购买，随时释放，比较划算。

操作系统选择`ubuntu 20.04 arm64`。

```
ubuntu@VM-0-5-ubuntu:~$sudo apt-get update
ubuntu@VM-0-5-ubuntu:~$sudo apt-get install --yes wget git golang build-essential pkgconf libelf-dev llvm-12 clang-12  linux-tools-generic linux-tools-common
ubuntu@VM-0-5-ubuntu:~$wget https://golang.google.cn/dl/go1.18.linux-arm64.tar.gz
ubuntu@VM-0-5-ubuntu:~$sudo rm -rf /usr/local/go && sudo tar -C /usr/local -xzf go1.18.linux-arm64.tar.gz
ubuntu@VM-0-5-ubuntu:~$for tool in "clang" "llc" "llvm-strip"
do
sudo rm -f /usr/bin/$tool
sudo ln -s /usr/bin/$tool-12 /usr/bin/$tool
done
ubuntu@VM-0-5-ubuntu:~$export GOPROXY=https://goproxy.cn
ubuntu@VM-0-5-ubuntu:~$export PATH=$PATH:/usr/local/go/bin
```

### 编译方法

1.  `ANDROID=1 make` 命令编译支持 core 版本的二进制程序。
    
2.  `ANDROID=1 make nocore`命令编译仅支持当前内核版本的二进制程序。
    

### 当 Wireshark 遇到 eBPF

![](https://mmbiz.qpic.cn/mmbiz_jpg/IjnZ9ic9bGHsZh69nmys4sfu7uiczoQsKTW3jPXCdy5P89KI8M9XicXrs9icSWQEKLIn24FQttib3nTrVNJFALPqoQA/640?wx_fmt=jpeg)  +    ![](https://mmbiz.qpic.cn/mmbiz_png/IjnZ9ic9bGHsZh69nmys4sfu7uiczoQsKT1ibXibsO7VeklIWTVcjCmVWTL6qiczRJcynCEQcLaZFXvia346eew3KEow/640?wx_fmt=png)  =  ![](https://mmbiz.qpic.cn/mmbiz_png/IjnZ9ic9bGHsZh69nmys4sfu7uiczoQsKTxrhclDRnlgDxLOGL0e5LqacjOZUu6dY7E0nVyic2ejKozVvuB6DbBTA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_jpg/IjnZ9ic9bGHsZh69nmys4sfu7uiczoQsKT1mFdvzlPHhTu8bvW3IGXGj92WSXMYze3lDZLNdKaic9PKhYhJBwrf3g/640?wx_fmt=jpeg)

贡献者
===

感谢 chriskaliX 、chenhengqi、vincentmli、huzai9527、yihong0618、sfx(4ft35t) 等朋友的贡献。感谢 tiann Weishu 在 Android 这个需求上的推动。![](https://mmbiz.qpic.cn/mmbiz_png/IjnZ9ic9bGHsZh69nmys4sfu7uiczoQsKTuAtiavpTIm8YHxKHNtR4UWvjZKSJayPPF4iccBUlOVB0OrPrwXKJ7dmw/640?wx_fmt=png)

招聘
==

美团信息安全部，某项目组 Leader 直招，没有中间商赚差价。北京上海两地任选，面向 RASP、HIDS 产品，JVM、Linux 内核入侵检测等安全研发职位

1.  JAVA 资深研发工程师
    
2.  golang 高级工程师
    
3.  更多职位见 https://www.cnxct.com/jobs/[7]
    

### 参考资料

[1]

eCapture for Android: _https://ecapture.cc_

[2]

笔者开始编写并开源: _https://www.cnxct.com/what-is-ecapture/_

[3]

CO-RE: _https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html_

[4]

TLS 1.3 密钥捕获功能: _https://github.com/ehids/ecapture/pull/143_

[5]

Decryption Secrets Block (DSB): _https://github.com/pcapng/pcapng/pull/54_

[6]

gopacket 的 DSB 功能: _https://github.com/google/gopacket/pull/1042_

[7]

https://www.cnxct.com/jobs/: _https://www.cnxct.com/jobs/?f=wxg_