> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/A8BD7Trgi97HGiDqL1p8Pw)

### 0x01基本概念

RMI的全称是Rmote Method Invocation,即远程方法调用，具体怎么实现呢？远程服务器提供具体的类和方法，本地会通过**某种方式**获得远程类的一个代理，然后通过这个代理调用远程对象的方法，方法的参数是通过序列化与反序列化的方式传递的，所以，**1.** 只要服务端的对象提供了一个方法，这个方法接收的是一个Object类型的参数，**2.** 且远程服务器的classpath中存在可利用pop链，那么我们就可以通过在客户端调用这个方法，并传递一个精心构造的对象的方式来攻击rmi服务。

### 0x02 实现机制

上面说了本地会通过某种方式获得远程对象的代理，那么具体是怎么的实现机制呢？RMI模式中除了有Client与Server,还借助了一个Registry(注册中心)。

|Server|Registry|Client| |:-:|:-:|:-:| |提供具体的远程对象|一个注册表，存放着远程对象的位置（ip、端口、标识符）|远程对象的使用者|

其中Server与Registry可以在同一服务器上实现，也可以布置在不同服务器上，现在一个完整的RMI流程可以大概描述为：

1.  Registry先启动，并监听一个端口，一般为1099
    
2.  Server向Registry注册远程对象
    
3.  Client从Registry获得远程对象的代理（这个代理知道远程对象的在网络中的具体位置：ip、端口、标识符），然后Client通过这个代理调用远程方法，Server也是有一个代理的，Server端的代理会收到Client端的调用的方法、参数等，然后代理执行对应方法，并将结果通过网络返回给Client。
    

两图胜千言：

整体流程：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

ps: 图中的stub就是客户端代理，skeleton就是服务端代理，老外起的这英文名字我实在是理解不了～  

远程方法调用的通信模式：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

> 不知道有没有人和我一样想过为什么需要这个注册表？

### 0x03 代码实现

我们已经知道了大体的流程了，那么用代码如何实现上述流程呢?我们自己动手创建一个项目吧，项目结构如下：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

1.首先创建一个接口Hello:  

```


1.  `package model;`
    
2.    
    
3.  `import java.rmi.Remote;`
    
4.  `import java.rmi.RemoteException;`
    
5.    
    
6.  `public interface Hello extends Remote {`
    
7.   `public String welcome(String name) throws RemoteException;`
    
8.  `}`
    


```

2.基于这个接口实现一个类Helloimpl：

```


1.  `package model.impl;`
    
2.    
    
3.  `import model.Hello;`
    
4.    
    
5.  `import java.rmi.RemoteException;`
    
6.  `import java.rmi.server.UnicastRemoteObject;`
    
7.    
    
8.  `public class Helloimpl extends UnicastRemoteObject implements Hello {`
    
9.   `public Helloimpl() throws RemoteException {`
    
10.   `}`
    
11.    
    
12.   `@Override`
    
13.   `public String welcome(String name) throws RemoteException {`
    
14.   `return "Hello, "+name;`
    
15.   `}`
    
16.  `}`
    


```

3.创建服务端，服务端创建了一个注册表，并注册了客户端需要的对象

```


1.  `package server;`
    
2.    
    
3.  `import model.Hello;`
    
4.  `import model.impl.Helloimpl;`
    
5.  `import java.rmi.RemoteException;`
    
6.  `import java.rmi.registry.LocateRegistry;`
    
7.  `import java.rmi.registry.Registry;`
    
8.    
    
9.  `public class Server {`
    
10.   `public static void main(String[] args) throws RemoteException{`
    
11.   `// 创建对象`
    
12.   `Hello hello = new Helloimpl();`
    
13.   `// 创建注册表`
    
14.   `Registry registry = LocateRegistry.createRegistry(1099);`
    
15.   `// 绑定对象到注册表，并给他取名为hello`
    
16.   `registry.rebind("hello", hello);`
    
17.   `}`
    
18.  `}`
    


```

4.客户端调用远程对象

```


1.  `package client;`
    
2.  `import model.Hello;`
    
3.  `import java.rmi.NotBoundException;`
    
4.  `import java.rmi.RemoteException;`
    
5.  `import java.rmi.registry.LocateRegistry;`
    
6.  `import java.rmi.registry.Registry;`
    
7.    
    
8.  `public class Client {`
    
9.   `public static void main(String[] args) throws RemoteException, NotBoundException {`
    
10.   `// 获取到注册表的代理`
    
11.   `Registry registry = LocateRegistry.getRegistry("localhost", 1099);`
    
12.   `// 利用注册表的代理去查询远程注册表中名为hello的对象`
    
13.   `Hello hello = (Hello) registry.lookup("hello");`
    
14.   `// 调用远程方法`
    
15.   `System.out.println(hello.welcome("axin"));`
    
16.   `}`
    
17.  `}`
    


```

先启动服务端，在启动客户端，客户端成功执行远程方法并获得返回的数据：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

在写代码的时候有几点需要注意：  

1.  接口需要集成Remote接口，且方法需要抛出RemoteException错误
    
2.  接口的实现类需要继承UnicastRemoteObject，同样的方法需要抛出RemoteException错误
    
3.  如果远程方法需要传参，需要保证参数是可序列化的，我这里传参只是传了字符串，字符串是可序列化的，如果传参是自定义的对象，那么这个对象需要实现Serilizable接口
    

注意一点，由于我这里服务端与客户端都是在一台机器上实现的，所以看起来比较简单，如果服务端与客户端不在同一主机，需要保证调用的远程对象实现的那个接口在客户端与服务端都存在！

### 0x04 其他

到这里就差不多了，暂时满足我们后续学习rmi反序列化漏洞的需要，如果好奇rmi底层代码实现，可以再去读一下jdk的源码，这样会加深你对rmi的理解～

放一篇从源码层面解析rmi实现的文章：https://xz.aliyun.com/t/2223

看文章的同时，最好结合着实践

  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

  

长按识别二维码，了解更多关于我的故事

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)