> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/dlbpoZxMN8WZw7HDBJe78w)

> 原文链接：https://forum.butian.net/share/3710

0x01 前言
=======

本文主要内容：

> 1、windows uac 机制的流程及原理
> 
> 2、windows uac 逻辑代码逆向调试分析
> 
> 3、windows bypassuac 构造原理以及实践
> 
> 4、常见 uacme 里面 bypass 方法及检测方式

之前分析一个黑产样本里面内置了一堆 Bypasss UAC 提权的操作，分析完之后测试发现一些杀软这个行为检测不到，于是准备从 windows uac 机制底层详细分析下 Bypass UAC 提权的原理和产生的行为有哪些，以及如何针对这种 Bypass UAC 提权行为产生的特征进行关联从而落下来一个检测思路；

0x02 UAC 流程
===========

一、判断流程
------

UAC 的流程，微软有说明文档，用文字和图大致说了 UAC 的提权过程中的一些影响因素，我们可以先简单了解下：

参考：`https://learn.microsoft.com/zh-cn/windows/security/application-security/application-control/user-account-control/how-it-works`

运行一个可执行文件之前，调用 CreatePrcess 之前的相关判断流程图如下：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhhJkVuHh2QHrWVk6TxoWQOPyZ4aaRemblpG5z9lcxp0oWhN3lEUqsgg/640?wx_fmt=png&from=appmsg)

这里面有几个判断点：

### 1、第一个判断点：ActiveX 是否安装

简单查了下 ActiveX 这个东西是一个 windows 下的用户交互组件，之前基本都是和 IE 联动是实现一些功能，但是这个东西现在的电脑上基本都没有了，具体分界可以大致参考，微软弃用 ie，转 Microsoft Edge 的时候；引入 Microsoft Edge 之后 windows 在默认情况下不再内置 ActiveX；所以这里我们默认都是 no 就行；

### 2、第二个判断点：检查 UAC 滑块设置

cmd 运行 msconfig，工具里面有个更改 AC 设置，这里就是这个 UAC 滑块，如下图，我们可以看到其分为四个档次；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhZIUibLWbo3zOwyawtJCz7iajBpnPF5CPonpUUfkAbvEuEB69CUlkHCkA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhsfkzwlwA1LicA4beOib2lMHRrj6UBbmJwSJiaHVRv0nLGtHeuibQiaRiaqrw/640?wx_fmt=png&from=appmsg)

对于四个级别的定义：

```
始终通知 将：
当程序尝试安装软件或对计算机进行更改时，通知你。
更改 Windows 设置时通知你。
冻结其他任务，直到你做出响应。
如果你经常安装新软件或访问不熟悉的网站，建议这样做。
  
  
仅当程序尝试对我的计算机进行更改时，才会通知我 ：
当程序尝试安装软件或对计算机进行更改时，通知你。
对 Windows 设置进行更改时，不会通知你。
冻结其他任务，直到你做出响应。
如果你不经常安装应用或访问不熟悉的网站，建议这样做。
  
  
仅当程序尝试对我的计算机进行更改时通知我 (不调暗我的桌面) 会：
当程序尝试安装软件或对计算机进行更改时，通知你。
对 Windows 设置进行更改时，不会通知你。
在响应之前，不会冻结其他任务。
不建议这样做。仅当需要很长时间来调暗计算机上的桌面时，才选择此选项。
  
  
从不通知 (禁用 UAC 提示) 将：
当程序尝试安装软件或更改计算机时，不会通知你。
对 Windows 设置进行更改时，不会通知你。
在响应之前，不会冻结其他任务。
出于安全考虑，不建议这样做。



```

我理解其实就是分了三个档，对应图上就是高中低，中等级占了两个，有点区别，选择中高的时候，系统会打开安全桌面，选择中低的时候不会；

如下图是选择中里面的第一个偏高模式的时候，系统打开安全桌面：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh8ghvNSJQJ81RsoQzZPm2VZsicZIKHemOBqh9O0rzHREEQQ1sibLiaLZxQ/640?wx_fmt=png&from=appmsg)

如下是选择中里面的第二个偏低模式的时候，系统关闭安全桌面：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhzVE7l8dfPAQnbiaMRM007Q3dkebvibQEdLzdPGSI6omdgE8znO7Y4Z2Q/640?wx_fmt=png&from=appmsg)

从流程中可以看到，低就会直接创建；中的话会去校验一些东西，比如可执行文件的签名、过文件清单、注册表等，就是类似白名单的东西，只不过这个表现形式不一样，如果符合白名单就要可以直接创建，不符合就去下一个判断节点；高就是不会直接创建，都会来到下一个节点判断安全桌面开没；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhHVKInIgUYrZXRIPNwkQSXSMJ9iaNY0zvqGeSv0yWH1NNTqNM1gtbkxw/640?wx_fmt=png&from=appmsg)

### 3、第三个判断点：安全桌面

这个安全桌面本身就会受 UAC 滑片影响，除非是特定的修改；直观的用户体验就是，uac 弹窗时背景是否时灰色的，灰色就是开始，白色就是没开；

如下图，左边时开了，右边时没开：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhY5y7CalsiaFaQ7cRMHaKlS8iaGxGicr4rdygCSbH05YILr6tHHHq2oVUQ/640?wx_fmt=png&from=appmsg)

到这我们就了解这个 uac 的工作机制了，但是不清楚具体过程是怎么个调用实现的，接着我们来看下这个调用过程；

二、UAC 进程逆向分析
------------

调试环境：windows10 19045

笔者之前学习 fakePPID 技术的时候，接触过一点 uac 提权的知识，通过 fakePPID 技术我们可以实现父进程伪造；并且 uac 就是利用的这一过程，手动设置被提权运行的进程的父进程；

我们不妨想想，平常我们右击已管理员运行某个程序的时候，最后运行完他的父进程都是 explorer.exe，他的父进程真的是 explorer.exe 吗；

如下图，通过 process explorer，我们可以看到 explorer.exe 进程使隶属于 g0 用户，并且没什么特殊权限，显然不是 system 权限；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhwjwvPYiaA4ywIibSIILLyRS4oHSHLu2ScnGwRXOkQMXcuv64lI7vRTCQ/640?wx_fmt=png&from=appmsg)

然后我们再看下通过右击运行的进程的权限，如下图，我们可以看到相关其相关特权权限已经变成 system 的了：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh4pP7GjBR0FAuqcDawCM4q84MibkatPBqwdYRXGYhRll0MUrss6RckBg/640?wx_fmt=png&from=appmsg)

一个不是 system 权限，没有对应权限令牌 token 的进程，凭什么可以创建一个 system 权限的进程呢，这显然和 windows 安全权限管控相悖；所以，当我们以管理员权限运行的时候，这里真正创建对应的应用程序的进程不是 explorer.exe，当时学习的时候了解到的是 consent.exe 这个进程做的；

真的是这个进程做的吗，所以这次我们深入的来剖析下；

这里我们可以先看下现象，sysmon 全开，手动右击以管理员身份运行任意可执行文件，查看日志；

如下图（去除模块加载、注册表操作后）：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhicEibCq2V4Iqsl0Q5mUdA6Sdx7qLC0ibgLQqYg3GTxqDx2J7PgWD8AV4A/640?wx_fmt=png&from=appmsg)

按时间顺序我们简单看下；

第一条如下图，就是我们熟悉的 consent.exe 进程的创建，这里我们注意看其父进程；可以看到父进程是一个通过 svchost 启动，在 netsvcs 组的，一个叫 Appinfo 的服务；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhkzDnukmc50yn8M1GRUcAricIIY573RCltYEu937jgku9KiaCtnYw7T1A/640?wx_fmt=png&from=appmsg)

然后就是 consent.exe 结束：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhULWpH2ZeGrBuofPaRIJ5VqZ8B303jLFpLacCF0Y4H9FPKF2Y2MbTiaA/640?wx_fmt=png&from=appmsg)

最后应用程序被创建，可以看到父进程换成成 explorer.exe；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh1Bxwj7iciakbA1QdoeWhY0qs6PZh3yiaK6qpX8nr2XicibZBCnvRnj4gvZA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhic6GwsibEZdHXt2slUpSehC6tQ7l1aaAQnDBsBd7f7pB3cYfAymQJFNg/640?wx_fmt=png&from=appmsg)

接着往下，

### 搞清楚两个问题：

第一个问题，谁去创建要提权的进程；

第二个问题，如何去创建要提权的进程；

其实就是流程图中这两部分在哪完成的，如下图

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhEiaNsNYo1zuTgAgjgVAaCJlcz6TwHBTJd4wBnUicwyXxiaUQ74dXCCgcQ/640?wx_fmt=png&from=appmsg)

#### 1、谁去创建要提权的进程

这里我们直接使用 windbg 调试 explorer.exe，不管怎么说，右击管理员运行这个过程，肯定是先走的 replorer.exe 的逻辑，所以在 explorer.exe！`kernelbase!CreateProcessW/A`下个断，以管理员权限运行应用程序（当前 uac 等级是中等偏上）：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh5E0f5m1zMjbPFKtZ3un2yt38vL1nhPcrzYiamYDy3eYvxrHx7HxG7EA/640?wx_fmt=png&from=appmsg)

直接运行成功，没有断点，说明不是 explorer.exe 里面调用 CreateProcess 来创建被提权的进程；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhp9tKiaiaPlawflibLACkUezlzpQxOOod6dtw7ZaxsSVPmsYwD1icicibsGtA/640?wx_fmt=png&from=appmsg)

普通双击运行，断下来了，此时堆栈如下图，这里我们需要往回找，根据栈回溯，肯定有相关判断逻辑，类似判断这个操作是正常运行，还是要提权运行的，也就是 createprocess 之前是从哪来的；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhkHdB6EokctWbogY6tTogltBThPldlZq4CG8vKqgfliaUkhk0zdRHg9g/640?wx_fmt=png&from=appmsg)

可以看到，最近的是来自一个`windows_storeage!CinvokeCreateProcessVerb::CallCreateProcess`;

使用 ida 简单看下 windows.storage.dll 这个函数：

应该是从这来的：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhBA0EG3n4FDTiat5QezF8KbaB9tWZtkmQ1pe8kh22B6dnibsibgdy8BMkg/640?wx_fmt=png&from=appmsg)

看下伪代码逻辑，可以看到调用这个 createprocessw 之前，是有个判断的，通过 SHTestTokenMembership 判断之前检查进程的令牌是否是域中管理员组里成员的 (这个是 uac 的一个判断条件，用户在管理员组，提升权限的时候，会起 uac)，所以这里我们回到 windbg，在这个函数下断点；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhvhsD49WIe1ic9DZmQiar8Xags1RjvZKpdgeia3nuVNI3OOrCBMCLibtMLw/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh0VgacmyyxKBI7icCwm9rC5QMyZxgqdXGXyCKVBYI1IXbxS55PnoYpxw/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhdsprZe2SvlrvawlibVPbaKS5B8MQ9QsTnm80xGXkOHPT8KqhzyE3XGg/640?wx_fmt=png&from=appmsg)

explorer.exe 里面下断点：`windows_storage!cinvokecreateprocessverb::callcreateprocess`

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhmoEsTjiaicws6s2qD5nCgqjNpM3zDFzWmV0IxOTeib1Dx00wdOXgs3sKw/640?wx_fmt=png&from=appmsg)

再以管理员权限运行，这次果然断下来了

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh7rbl9jrzr7hI8UStRmT87TWOzlvrISzn34vLmRLwW1uiaWXtz1kPt3A/640?wx_fmt=png&from=appmsg)

堆栈和上面一致，

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhUncDia2z42s4Zm4ib77dB7DubibSqOaS3nn9AJgibYHLjOPHNrNG61djPA/640?wx_fmt=png&from=appmsg)

进入调试跟踪分析，我们来看下，这个在要 uac 提权的情况下，这个函数如何走向：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhZkwr4bzv8XbN1fiadKX96o7uj3PdoVLibPqt3GcWLKS2srokLXlJso1w/640?wx_fmt=png&from=appmsg)

调试发现，提权运行最后都会来到如下函数 AicLaunchAdminProcess，顾名思义启动管理进程；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhgH8HweEqy80nbPwYfqlGWoBSnMicQYdXqmwBibPWdXPtZYv3DLmJl4UA/640?wx_fmt=png&from=appmsg)

这个函数里面，调用了 rpc 函数`AicpCreateBindingHandle`，这里有一个 uuid，我们可以大致判断，这里可能是尝试通过这个 uuid 和 com 组件进行通信,`201ef99a-7fa0-444c-9399-19ba84f12a1a`;

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhTd6QiaSSnBQCicSciceBvx1RCdpiaMbCERB7B9WUvC8J3e4pE4AlKmSghg/640?wx_fmt=png&from=appmsg)

通过 rpcview，我们看到这个请求的 uuid 对应的接口是来自 svchost 的 Appinfo 服务，就是上面我们找到的那个服务

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhzW6rXGR2Q22ow047OQuAxVCic08tOUDlqSyWGbTrfNIjAKicJB4eDaMQ/640?wx_fmt=png&from=appmsg)

#### 2、如何去创建要提权的进程；

Appinfo 这个服务，通过查注册表服务项路径，找到对应的 dll 文件

`计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Appinfo`

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhrg1Z5HdhfTUSaNWOeKG8r6IKnRwgpUO8pth3ssJx3lmxtgMQLZ9Dow/640?wx_fmt=png&from=appmsg)

接着我们跟进 appinfo.dll 分析，先找到 LaunchAdminProcess 相关接口，如下图，应该就是我们上面提到的 AicLaunchAdminProcess 对应，处理使用

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhZWNRpB40kcPgZb3GdKjl1XpJLx92gWg790goxuM1ZGmU1GqdlqpqUg/640?wx_fmt=png&from=appmsg)

我们详细来分析这个函数，如下第一个判断点，传入的参数 r8，对应的文件名是否传入：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhibibys2agXT7eOQLpzYgyKkbia3WCc1PfC3k2jOicwtXAfHVyfOce7nyKQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhXiazcZVYKbQgtOguQdM4T8Am98quqlFkicTzdgA8vOKF2me4bUDib1piag/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhsXBZicGp5mrwLubycRJiaBN3ibRWqqLIPeE2VqoyD1mqnD3fiaCpyR4sKA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhzVkAXia81eUJuFOQCEUhicelIsxw1WptwgkS9nHqEiajJDPLgruxGafYg/640?wx_fmt=png&from=appmsg)

这里我们动态跟（windbg attach svchost 启的 appinfo 服务，然后右键以管理员权限运行位于桌面上的 010Editor），可以看到 r8 传入的参数就是要打开的可执行文件名称,(`c:\Users\g0\Desktop\010Editor\010Editor.exe`)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhicRDD1YZnNkibibsF1C1HDVKwr8OkmRm3PAsW0FS2yeUWlpPWpAlbLTAQ/640?wx_fmt=png&from=appmsg)

然后在如下位置调用 CheckElevationEnabled 判断是否启用了 uac，这个 CheckElevationEnabled 并非微软公开记录的导出函数，当返回 0 表示 uac 是开启的；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhgP0ceQSNxQRicEXCdrNbSpZI9AMHCV1bYk75Sd6k4CdtQDkykltu0nA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhMWDQoJwZIo7cmVOd09nyk2uAf4I9x19hzGUROFKDEujy0gbWUGn4wg/640?wx_fmt=png&from=appmsg)

然后拿到父进程 explorer.exe 的句柄：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhxibtibylBqCu1uUjzdFCVYnRnxqjqP1tU1w3IMiczhdognhO2BiawF2xNQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh5S10Wa1Lb1kN9WMLD9ibjpagIkV97bdgm0MyVQmbTM86rKbWVLdJFOw/640?wx_fmt=png&from=appmsg)

这里拿到后没有做其他操作，其实就是判断下父进程还活着，别 rpc 过来了，父进程 g 了，那这边就没必要继续处理了；

然后调用了一个有意思的函数`**RpcImpersonateClient**`，msdn 对其的描述如下，意思是模拟 rpc 的客户段操作，这里其实就是模拟 explorer.exe 操作；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh8oficJ5mVmXNzxW1uI5f8xSIHqANWADiarCgib1cicpFN5YCvBrXQn22rg/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhaoet0V2eJ69Caiay3hs5Kb79kzNXyQTGUicUehmiaOHFt0NQfE1y5Glfw/640?wx_fmt=png&from=appmsg)

然后通过尝试 NtOpenThreadToken、NtDuplicateToken 复制线程令牌；（[handle]-2|0x0xFFFFFFFFFFFFFFFE 指当前线程句柄）当前线程就是模拟的 rpc 客户端即 explorer.exe ，所以这里的令牌 token 是低权限的令牌；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhqxkdZkpw1I4xibfHBKIUawlWlefWZvfJiaGMliatShd248LUa9yQC1y0Q/640?wx_fmt=png&from=appmsg)

并通过 NtQueryInformationToken 检查是否具备管理员权限：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhBy4diaAqDqfqTKmsdjF9z0Plbhicqf7iatP8wUbgJT7b57YOqxDQ2oclw/640?wx_fmt=png&from=appmsg)

接着，打开要执行的文件句柄；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhPPz8LXlSiaN9FUyuzuTibjEvNfCquFpzRV9pMe6AoRcsKVsY3WKl2zRA/640?wx_fmt=png&from=appmsg)

成功打开，就会传入文件名，调用 CheckElevation 函数检查对应的路径执行文件，是否需要提升权限来运行；这里的 CheckElevation 是从 kernel32 里面导出来的，但是微软公开资料并没有对这个函数及参数进行解释；我从如下微软的求助链接，拿到了一个参考，链接里面提到可以通过这个函数来检查一个路径文件是否需要管理员权限执行，返回 0，则说明需要提权，反之不需要（详细的检查原理可以逆向分析 kernel32 的 checkElevation 看，这里我们暂时先不看了）；

`https://learn.microsoft.com/en-us/answers/questions/1184440/is-there-a-way-to-determine-if-a-program-needs-to`

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhCjfHDOnKGLWq21jrnplrLYesZYnzkHKQac6MT5NWK5NMHbmC6OTQLg/640?wx_fmt=png&from=appmsg)

判断逻辑的位置：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhIZqvhNA3xf7ibEGBLQNEziadwaWQPrV1C8XOal3vuHPb5XmUDwkmPgSA/640?wx_fmt=png&from=appmsg)

我们这里调试的时候就是右键通过管理员权限运行的 pe，所以这里返回了 0，流程来到需要提权；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh1wdSgMBCtk5OP4WNl7VvqP61pksmtMRqMgg4PEDI2EDRADl7EnzNdg/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhib2h8dJNOH75CNialH0Ptg8ZLZ8NGnES3DgW8m9VY9KGmicr5uOSKe2pQ/640?wx_fmt=png&from=appmsg)

然后对该路径进行转换，转化成长路径，这里主要是兼容一些版本中的短路径（比如路径中存在 `~`这种）

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qheia6Nt8nedKtbo6UC8hg8Qu9aoCJbqLgfrFkmfHsEWJfQA4yxNw1gFA/640?wx_fmt=png&from=appmsg)  
接着使用 kernelbase 里面导出的`RtlDosPathNameToRelativeNtPathName_U_WithStatus`、`RtlReleaseRelativeName`尝试转化为 nt 文件系统形式名称, 转化后的文件名如下：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhkGxcjpstV2dtw1nlRP6W6nPnLZXJOghqyDWr2Qwd0m9icDkHX8OUJhg/640?wx_fmt=png&from=appmsg)

然后来到如下位置：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhETHN5rdb7icbwl7hZHhmLVvCicqiaM2xIPlpNo1PefWt6W4slX2qrTibsQ/640?wx_fmt=png&from=appmsg)

获取到`g_Dirs`，将要打开文件路径同 g_Dirs 里面的路径循环对比，开头是否相同：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh24pJ9pnGXfYReO3WNvR43DkMCtNQbfVGDLcluRlyC0GuCnWCzfw8CA/640?wx_fmt=png&from=appmsg)

可以看到循环次数 ebx 是和 3 比较，所以这个 g_Dirs 里面因该是有三个路径, 通过动态调试，我们拿到这三个路径：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhxXS6URgS6YsVcS45UvBBVZu0Fy78vD85gAxOiaBofMyAoTu4G4J0p7A/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhBrN8h82WyHmmFzHqcls4MSwMLias0uT4ZkKXqGQR0RfewvkjaD2iaGnw/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhyWqRuDbZgfs59b2x8koxYg51iaqIGWVKrXSAcausGHzRUzTg2lyLVaQ/640?wx_fmt=png&from=appmsg)

这里三个都没匹配上；

判断逻辑如下，如果 ebx 为 1，也就是第二个路径（`\??\c:\\windows\`）匹配上了才往左走，不然都是往右走：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhOpiaYdF09tNjSwmvY3Nt0f4HO3vicQNuzVUcNA2NpgLRTLmTibiaX9SkDg/640?wx_fmt=png&from=appmsg)

这里我们的路径显然不在上述路径，所有接下来的逻辑是往右走，但是往下分析之前我们简单看下左边的逻辑，

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhzfdCveP6dx7sccHrrcVrxbOjzcICsx7DIbqHJjQgvghiaYfauH3qq5g/640?wx_fmt=png&from=appmsg)

如下图，可以看到左边的逻辑是：又出现一个`g_ExcludeWinDir`的路径 list，循环匹配，

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh9qRBBRChad1vOgmRJtNA4qumHWBibgGqDkzliapUA1KTMlTaqOHQL18w/640?wx_fmt=png&from=appmsg)

然后更具结果不同，又去其他路径 list 匹配（`g_IncludedWinDir`、`g_IncludedXmtExe`等），根据匹配的不同，会给 r15d 这个寄存器置入一些值，比如，如果匹配 `g_IncludedWinDir`列表里面的路径，那么就把 0x6000 置入 r15d，（这里其实是在做一些标记，r15d 后续是会用来做判断的）;

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhENibncWlAuPO27l6byXond3LRlkxEeqvurdk9u8c9ZXpfFfgxicNaDKw/640?wx_fmt=png&from=appmsg)

然后我们会到右边逻辑，如下图，如果`g_Dirs`里面的路径都没匹配上，就会渠道`3aba`appinfo 的偏移位置：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhfEgrd3Xow69HiaXq1HvYfz7UeYbww4LM2d0IbOUich8AticWiaicKb7FFPg/640?wx_fmt=png&from=appmsg)

appinfo 的`3ad2`偏移位置，释放路径存储的空间；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhp40DA5ZmB7WiaASooKaialf7icDlgq0tj8Xb9bWKUj0aibTBK5ghtjRlhQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhPv690uo7PV4bRCgQcawqJYW9kvzgKibCMl1C2FicHia00ARTjUqy004bQ/640?wx_fmt=png&from=appmsg)

appinfo 的`3ad2`偏移逻辑，拿到原路径名传入`appinfo!AiIsEXESafeToAutoApprove`函数

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhobLlmYcxQ09pEPy9mECOJ3icibpNvbCdArIDtbM4xOYwZGC2yS7D2Ehg/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhePyDzrtMSffqxbgibvxxAfQ1LIxc2OIibXGx7otPYKgpL6NJlT3SgGEA/640?wx_fmt=png&from=appmsg)

AilsEXESafeToAutoApprove，首先通过注册表`Software\Microsoft\Windows\CurrentVersion\Policies\`判断当前是否开启了受限的自动审批`EnableRestrictedAutoApprove`

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhs1v979IaibyapzL3nUOJN0VQvL1KA5sic2UpVUHzXfltDeGRN8WyS7Zw/640?wx_fmt=png&from=appmsg)

然后对 r15 存在一个判断，判断第 21 位是否为 1，为 1 就运行下面逻辑（这个标志不出意外因该是路径判断那里给的，后续我们会使用符能够匹配对应路径的 pe 文件，然后详细看下路径匹配那边的规则）：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhQ6eZDL7ia08WY6DJLqtqE7y6icGLSqUYOY0J9C8mg0uf6ibDzAPYMYJ9Q/640?wx_fmt=png&from=appmsg)

通过文件路径获取文件内容，通过读取映射后的文件内容里面是否配置了，autoElevate = T（这个是可执行程序 manifest 里面的一个标记，带这个标记说明需要自动提权，运行就需要提权；）；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhe450RzMrxYBsM6ZG8uzqQD6ib8woeNIzVsoQSziaYiahicgpgEdTicbiaYOA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhpibgYgicwM8aiaOIB3gBDJpBdbVDfEOLUBLs54QJGiaQtN0oMjjjGNKpmQ/640?wx_fmt=png&from=appmsg)

如果没有这个标记，就进入下面的白名单匹配：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhl0Lwqx7ZLnibX0xMkOxiaC96aeh9AhzkBM5y3Wy65SocIwGaOdZicBNBQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhAiciciacCpBM9061N0ND0GtJrZh8sH6898kyQFOYElSjr61Dw48fzQiaXA/640?wx_fmt=png&from=appmsg)

`g_lpAutoApproveEXEList` 白名单列表：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhYGuH4sCYR7wwIWqK1P5g16ulw0OmCb64vecicX8hbW5GbicNILb3ZQZA/640?wx_fmt=png&from=appmsg)

AipIsValidAutoApprovalEXE 校验，获取签名信息，以及匹配

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhibjVTFnkUwsEZ2g3SfkXYpPJSVflGyX1q0jyPotWNtjpGetibu6Ks6CA/640?wx_fmt=png&from=appmsg)

WTGetSignatureInfo 是校验签名的；下面的 AipMathchesOriginalFileName 是通过文件信息里面的 OriginalFilename 和当前名称对比，判断名称是否更改过，如下图：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhubVNThXlfoX3ib38WowymaGVvoXnSszgzSP7aBTNgGQjzlQlk5pY5aQ/640?wx_fmt=png&from=appmsg)

取的字段如下：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhiav60qpAfzhIiaFJ2icIuQ7WaeT2Vw34yV76F2GVCe2HJ8wWliatCYdCrg/640?wx_fmt=png&from=appmsg)

所以在 AilsEXESafeToAutoApprove 这个检查 exe 是否能够被允许自动提升权限的的函数中，只要上面提到的两个条件只要满足一个即可：

1、要么是 manifest 文件里面带自动提权标记提权

2、要么是校验通过的白名单

接着 AilsEXESafeToAutoApprove 下来就是一些特殊判断，比如 mmc.exe 运行有一些特殊的操作；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhBxXvpOP92wo6t96cBozu3nfkmFKe6KrZ8gia2h7BrlVjYrvh3JV3DhA/640?wx_fmt=png&from=appmsg)

显然，本次我们运行的可执行文件是不满足上面要求的，调试函数返回如下, r15 没有改变；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhvKk9ZibVA19L6VaibVk7nFMcibKRmLIpXUFUE3VTsaGibCPUlEDol20E5Q/640?wx_fmt=png&from=appmsg)

回到`RAiLaunchAdminPorcess`函数之后，对 r15d 进行判断逻辑：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhjCO8KBaW2Aff83ibvjEW4gVor7ucye79rYFLW1QoxwDFYYm3McKzNmA/640?wx_fmt=png&from=appmsg)

这里我们的 r15 各个位置都是 0，所以最后是走没匹配上的逻辑，就是左边的逻辑，左边逻辑好像是在做一个缓存校验，看看缓存列表里面是否有，具体我们就不看了，这里是没有匹配上：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhllqjhGXR7KsyPxHvkeQbYwsxeaoxhpqpeOiab5S9PqQHxQHyyxbBroQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhp5M39y7yIKia1qjFMoD1GSQL8abbenKYp7qkAguuMKfVibtiaib9MCCDLw/640?wx_fmt=png&from=appmsg)

接着读取注册表`\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System`获取`ValidateAdminCodeSignatures`值，判断本地是否开启管理员权限运行的代码必须做签名校验

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhKMuywm65CmOgLztnoO7FmN55zyoa8oPdk8qMjKV4j0xSMCmj30mOqA/640?wx_fmt=png&from=appmsg)

这里默认时没有开启的，即键值为 0；

然后来到如下函数 AiLaunchConsentUI，即启动 consent 的 ui 处：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhFm18xUiaicyLt6z8cSUiaMTcqNYx1q4ibCicXs8KM9jeic0ZXFqIGksT7vYQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh8dDExbbGd4aNJeRPDqKfPvnh2eM2c60bpY3ib0V7cRxU34HygAicgxbA/640?wx_fmt=png&from=appmsg)

跟进 AiLaunchConsentUI，关于 consent 起来的过程

这个函数先获取了一个一份 svchost 自己的高权限 token：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhcy3zocBPfZLpth5icYuia3Ll9DODTbgianKxsdFQPCibIpAaic9X52N2lXA/640?wx_fmt=png&from=appmsg)

然后通过 AilaunchProcess 起 consent.exe ，并传入刚刚高权限 token

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhyjicuib6xdQCUxUl3VeLa7yMYC46RufP98MibyOkwco1KmoL1RJsewXIQ/640?wx_fmt=png&from=appmsg)

跟进 AilaunchProcess 函数：

通过调用 CreateProcessAsUserW 函数，起的 consent.exe 进程

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhdoFEpEkjFPfwr60sUmPRLTQv4TCJK0Fx9YkP11jemGicLxj8g7Ax9bQ/640?wx_fmt=png&from=appmsg)

这里有一个细节，我们看这个 lpCommandLine 参数，也就是 consent.exe 进程的参数；

如下图这个参数是从 a6 来的，也就是形参的第六个参数：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhSCgcsYfJFWys9mC1GaRbXkFI7rEUia7vwZ0xjBzu7iaicF0YQBd19TJgw/640?wx_fmt=png&from=appmsg)

回到 AilaunchProcess 调用的时候的第六个参数：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhEjfSt8UvhNdiaaoXYDkHJVt7sAtYh3FOANhTfm8iaSicusdWficia9ybiccQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhTLP19icAYeKVIxIZxqRetAHsDOpPpmIib4PGb9B0eyoVR7jbtwV6qNxg/640?wx_fmt=png&from=appmsg)

可以看到，带了三个参数，第一个参数是 appinfo 服务的进程 PID，第二个第三个参数是一个类似结构体的地址，

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhO8M5x9xKX5y9H2ROIXyGnh8AsakEJFKJlQE8tLcMEgVbb3ySKApzpA/640?wx_fmt=png&from=appmsg)

这也是为什么我们当时看 sysmon 日志的时候，看到 consent.exe 是带参数的，如下，8248 是 appinfo 服务的进程 pid，第二、三个参数是 appinfo 进程里面的一个结构体地址相关内容；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh2OQJlT4hlibUacSxVtWHb6Q0MvheBeD42J8qcqPFmQQ87oQeS0AUy0g/640?wx_fmt=png&from=appmsg)

这里为什么要这么做呢？

1、那个结构体里面都是些什么，至少说 appinfo 想要给 consent 传递这个内容

2、对 consent.exe 对参数处理逻辑分析

我们先看下结构体里面是什么：通过 ida 代码往回找，笔者找了下没找到明显直观的答案

这里调试下：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh5YZfDwxfAMBmCplGprhZ269f3HIKlS47EBVg4j41CAzOsMgft12fMA/640?wx_fmt=png&from=appmsg)

如下图是结构体的内容，最直观的就是 0x28 偏移是我们要打开的进程的绝对路径，

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhdVBfDtwS1EKTTaBQn4edsQJtpicumDWoARvHapnlic3qnJadleKNgiafQ/640?wx_fmt=png&from=appmsg)

对应的 comsent.exe 界面上面也有这个信息，所以相关信息应该都是从这个结构体里面获取的：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhUTCBicIcA2TVia0ATH45h3UKAWXU1icPomQ0KUc1lia2icTO6b9vWcLQHEQ/640?wx_fmt=png&from=appmsg)

这里我们就不在多次一举分析 consend.exe 了；

这里还有一个细节，通过调用 AiLaunchConsentUI—>AilaunchProcess —>CreateProcessAsUserW 函数，起 consent.exe 进程的时候，createflag 参数是带 0004 的，如下图：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhc4mZ4FPSf7II5sWaha5E2ZFXy7UqRUeic3A0Lycmiamia7j90KAlGWMjA/640?wx_fmt=png&from=appmsg)

也就是这里创建的时候，是以挂起状态创建的 consent.exe，然后如下图，AiLaunchProcess 里面接着调用 AipVerifyConsent 函数，对挂起的 consent.exe 操作，看名字这个函数应该是校验 consent 的，防止被篡改劫持；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhWyyzTa9BbQC1BdLDe15YeEUrFqllicTkvts8JMdfS4o6FSyIw8RMmFw/640?wx_fmt=png&from=appmsg)

获取挂起的 consent 相关位置内容（AipVerifyConsent ），比较校验；（这里的校验好像不怎么严格，发行信息是微软）

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhWyyzTa9BbQC1BdLDe15YeEUrFqllicTkvts8JMdfS4o6FSyIw8RMmFw/640?wx_fmt=png&from=appmsg)

校验通过，后续调用 ResumeThread 激活挂起的进程，等待 consent 返回，用户给的结果，一个 ExitCode

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhJWNjbtmk5YmMKDAkt8d0e7JQ2m8NeLoHjKqd4TnN5v0y8vb40ZgcicQ/640?wx_fmt=png&from=appmsg)

用户选是，返回的值是 exitcode 就是：0，（注意这里下面图标错了，对应的是 edi，也是 0）

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhvPpU93F7jMvMpCBVpjianBTPYSEk1ic2Uibfen7Smmvs1icNcYqYOZXxAg/640?wx_fmt=png&from=appmsg)

这里笔者也测试了下，用户选否，返回的 exitcode 是：`0x4c7` （1223）；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhcW98TJ8ibV1BrSE491KcULXZ0ZGE0TaiaV1BGl4WDWnFkljAssTBRGVA/640?wx_fmt=png&from=appmsg)

然后结束 consent：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh67Trtiambl1KDhzNE5qWVibRdKJ0ox4uYNJQ6f1T4YwUYmuz5C3l9F2Q/640?wx_fmt=png&from=appmsg)

回到 RAiLaunchAdminProcess，判断 AiLaunchConsentUI 返回结果，同意提权就借助 AiLaunchProcess 使用带特殊权限令牌起待提权进程：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhbEqXFul75zibhVM1lT4pTQk6OIMCbnojRlmiabQNYJJ4yGRbibhYf8iaqw/640?wx_fmt=png&from=appmsg)

到这整个流程差不多就结束了；；

#### 简单判断逻辑总结

通过分析出来的逻辑，这里大致能够推断其实 对 pe 是否可以不弹窗提权，主要取决于三方面：

1、和 pe 文件本身路径相关

上面分析的过程中，提到的内置的几个路径列表，当前可执行文件是否匹配，以及具体匹配哪个会影响最后的判断逻辑；

2、和`appinfo!AiIsEXESafeToAutoApprove`函数相关；

这个函数里面判断当前可执行文件是否符合两个条件之一：

*   条件一：g_lpAutoApproveEXEList 成员里面的可执行文件，并且签名校验通过
    
*   条件二：manifest 里面是否存在 autoelavate 为 true 的 pe 文件
    

3、和注册表的设置的一些键值相关

`\\HKEY\_LOCAL\_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\`的`EnableRestrictedAutoApprove`  
判断当前是否开启了受限的自动审批  
`\\HKEY\_LOCAL\_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System`的`ValidateAdminCodeSignatures`  
判断本地是否开启管理员权限运行的代码必须做签名校验  

这里里面我们对路径的判断其实没了解具体的匹配逻辑，所以这里我们需要找一个合适的测试 pe 文件；

在指定路径（system32 、systemWOW64）下面的两种程序，一是经过校验的白名单程序，二是 manifest 里面存在 autoElevate 为 true 的程序；

不着急这里我们先测试下已有的逻辑；

### 测试下分析出来的已有逻辑是否正确：

#### 找一个白名单程序看下

找到到一个位于`g_lpAutoApproveEXEList`中的白名单 pe 文件，如：pkgmgr.exe 是在上面我们提到的白名单里面的;

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhOicm74mPXVMTxwPxx2WicMUcKmLP1bTkwEibstcIHicb4fbbdSyctf4Nyw/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhORNaiaAe8SPKFPLfSMx9O1u6xWgefTEuicAaiaTKC6jJ9kJ7twZWUaCEA/640?wx_fmt=png&from=appmsg)

可以看到右下角是有一个小标，说明这个可执行文件要高权限运行，这里我们直接双击，并没有产生弹窗直接运行成功了；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhBmbVJYtxbGKg6GgS6aw6sTIUhKygH1gBiaZjDj8bCj0R7viaTodfjIkQ/640?wx_fmt=png&from=appmsg)

控制变量法，我们尝试将其路径做膝盖，看看结果

如下，将其移出 system32 文件夹，再次双击运行测试，此时 uac 验证弹窗了，说明这里是上面那个我们还没弄清楚的路径匹配生效了，所以这里我们分析具体的路径匹配规则的时候，可以尝试调试分析下，位于`c:\\windows\\system32\\PkgMgr.exe`的文件，看下这里的路径匹配逻辑，正好也能看看，windows 本身自带 uac 自动审批的逻辑是什么（内置的 uac 绕过方式），

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhTa4QAN8sQdtq7dtLSqNCSkLArYPX8yQnootAibWfQcGeUWXibPAX2C7w/640?wx_fmt=png&from=appmsg)

#### 分析路径匹配逻辑

这次调试`c:\\windows\\system32\\PkgMgr.exe`我们的断点直接打到如下图路径匹配的位置 (appinfo!0x3987 的位置)：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh2XRdWfYQPoibFy24iaoZ93fibajQDoa2y60tjWtPUBtLaibBEIdo7uftkA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhRs5IVKH3S049TicW6IrPp3LUKc52DicdZC3pibVqxcWFcibicicVico8Sc1Bg/640?wx_fmt=png&from=appmsg)

此时路径是匹配上了 `g_Dirs`里面的第二个路径（`c:\windows\`），此时 ebx 为 1；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhssUE5d2Yp2XFIs8kmpIzkplE8XSYk74IuibRZY7DUSCawCu71z02W4g/640?wx_fmt=png&from=appmsg)

ebx 为 1，进入左边逻辑，开始匹配`g_ExcludeWinDir`里面的路径：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhPjSs6rxfPIQia1o0x7EQ09gFm0EOpe1zCQsq5BBYIHhHmtsSS1lKxibw/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhebX0cXqQepJPia3rAGTM6GpKTJQAmlFAMibHLCE95cWLtdd6ia1AlDrqA/640?wx_fmt=png&from=appmsg)

根据判断条件，这里我们大致知道，是要匹配前 0x20 个路径：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhN9YLiaEvFhzicaEEicKqveaTU6DLHelL8cF7Z52GyWjYNt1EjFdRQ4o5g/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhI4ym71DEGVRQfYAqhyUuMfuvtWtgbPFtds6fkyGnzn8bnEbnXurMag/640?wx_fmt=png&from=appmsg)

这些路径大致如下：

```
\\??\\C:\\Windows\\Debug  
\\??\\C:\\Windows\\PCHealth  
\\??\\C:\\Windows\\Registration  
\\??\\C:\\Windows\\System32\\com  
\\??\\C:\\Windows\\System32\\FxsTmp  
\\??\\C:\\Windows\\System32\\Microsoft  
\\??\\C:\\Windows\\System32\\Spool  
\\??\\C:\\Windows\\System32\\Tasks  
\\??\\C:\\Windows\\SysWow64\\com  
\\??\\C:\\Windows\\SysWow64\\FxsTmp  
\\??\\C:\\Windows\\SysWow64\\Microsoft  
.  
.


```

此时我们运行的 pe 文件路径没有能够匹配的，然后来到下面的匹配点，匹配`g_IncludeWindDir`列表，这里注意，进入下面匹配之前，将 r15d 置值 0x2000h；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh6sXKiaWbLZNUW3P9U1wopBtib9LOrmyibeejRK6xMAr3ORuXmSZknD5Ow/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh8Y1v9QicKUUpqsI1hOFGXYo2RMGovKs1HGbMYAXln7ricMcAYrbUj18g/640?wx_fmt=png&from=appmsg)

匹配 5 个路径：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh3nhPhIYafWuOP8SiaRRkhHYnApqmnbSlCtlHsDzrZHlsrBqRU4ib7eKg/640?wx_fmt=png&from=appmsg)

5 个路径如下：

```
\\??\\C:\\Windows\\System32  
\\??\\C:\\Windows\\ehome  
\\??\\C:\\Windows\\ImmersiveContriolPanel  
\\??\\C:\\Windows\\Adam  
\\??\\C:\\Windows\\SyswOW64


```

这次第一个路径就匹配上了，将 0x6000 置入 r15d;

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhDM3H0iaDIEliaO5hj8iatga3yKFVDg4VqRHpZ7PUibzcrOISOp12WC2ibvw/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhpa7vSLyY48VFlojLdicjtKRRj6PEfGlhfFp38O06mtRHcjCNVDjqFRw/640?wx_fmt=png&from=appmsg)

然后，再匹配`g_IncludedXmtExe`这个列表，匹配两个路径，这个两个路径是两个 exe 文件，一个是 windows 操作系统中涉及系统部署的 sysprep.exe 一个 IIS 管理器 InetMgr.exe;

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhQv2O6CbH1rSmF4YZb3CO1e2epSGXpV1dxSWeQCJ3n0g99I7NutCSfg/640?wx_fmt=png&from=appmsg)

```
\\??\\C:\\Windows\\System32\\Sysprep\\sysprep.exe  
\\??\\C:\\Windows\\System32\\inetsrv\\InetMgr.exe  


```

没匹配上之后，开始在`g_IncludedSysDir`匹配

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhibicYLylpqGhx8ubE4YvgE5TmxeqMWRguUIBHEsibqUkeHPnDrNBsXfTA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhQI2K9yicuqWMH0LWv9THBljq4F7lDrFDZCpu94yTriavCT9ia4OMQ96ew/640?wx_fmt=png&from=appmsg)

对应的匹配的两个路径是：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhpCias9HvM6yZcTHlBPISEktibVHibwmfcV6ltibxwCjibIA11qZxdPgPPyg/640?wx_fmt=png&from=appmsg)

```
\\??\\C:\\Windows\\System32  
\\??\\C:\\Windows\\SyswOW64


```

匹配上第一个路径之后，获取匹配路径之后的内容，这里我们测试使用的是`\??\c:\Windows\System32\pkgMgr.exe`, 所以去除前面的路径，就只剩一个 PE 文件名，然后尝试找`\(0x5c)`， 其实就是找到是 system32 下 pe 文件，还是其下还有目录；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh9ubMSt6vnVqLpdWK2traFTMY0AqSffDleApcQPEtYLgJViblEMJcvYA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhdz1AhRZVaMPibR2eLEu7eCqqQromhIjs8ibehcicsiaoicrWlkgk4fUv3iaw/640?wx_fmt=png&from=appmsg)

如果是直接 system32 下的路径，就把 r15d 里面第 21 位置值 1（这个标记非常重要，上文我们分析下面的校验函数 AilsEXESafeToAutoApprove 的时候，会校验 r15 的第 21 位，校验的就是这个值）；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhQ2icCm1Yz5Gicibszzu5c2yjcC4LEpiaQJOIFZWakfXCUTLKLuHLjvPNDg/640?wx_fmt=png&from=appmsg)

此时我们看下 r15，如下图，值位`0x20600`

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhOLUzWicaYMNBnkGE86ickccIWHodO34SnUJlKWWC4tpG7GYASQ8SMo4Q/640?wx_fmt=png&from=appmsg)

接着下面就是 AiIsEXESafeToAutoApprove 了, 这里我们可以看到是把 r15d 作为第四个参数传入了：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhwPfW1MgGcOF9dAoNMj1Zmxx4vKFbH2tZ4IPb0D6coJcSyYNz6DhiaPw/640?wx_fmt=png&from=appmsg)

和上面我们分析 AiIsEXESafeToAutoApprove 就对上了，里面会判断第 21 位是否为 1，为 1，才会进行 manifest 内容以及后续的白名单匹配；

那么什么时候第 21 位才为 1 呢？在匹配到`system32 和 sysWow64`路径下的 pe 文件的时候才置 1；

所以这里我们对路径的检查和把控也分析出来了；这也是把 Pkgmgr.exe 丢到桌面，运行的时候 uac 就弹窗了；

另外不妨也总结回顾下这里的路径匹配：

其实就是搞了个黑名单 + 白名单的匹配方式，黑名单是:`g_ExcludeWinDir`, 白名单是：`g_IncludedXmtExe`+`g_IncludedSysDir`，先过黑名单，然后过白名单；

为了验证我们这一想法，我们再测试几个案例：

#### system32 下找一个带自动提权标记的进程：

找一个 manifest 的里面的存在 autoElevate 为 true 的

如：msconfig.exe

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhmM3qjD3Picd3km4cpRyicNoJuEEiapWw1ibyzg2fibZkibn9fdTfr7vGbfzw/640?wx_fmt=png&from=appmsg)

使用微软的签名校验工具 sigcheck 查看 manifest 内容，存在自动提权的标志；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhJU6mvA350LQf0hReU5YV6gbExHGgicibPENpiaaPLic3497km7S6LC5qfQ/640?wx_fmt=png&from=appmsg)

因为这个程序图标下面也有一个小盾（这个盾是否存在其实就是上图中的 manifest 里面的 requestedExecutionLevel 决定的），说明需要高权限执行，这里直接运行运行测试就行，或者你右击管理员权限运行也行，一回事，测试结果是没有 uac 弹窗：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhxq6vKNic5IJicriaibUhaXzcKJLua4BkySlykicibWcesC2yica3uxkoic8qWA/640?wx_fmt=png&from=appmsg)

同样这里我们也把文件放到随意路径双击运行测试，结果是还是会弹出 uac 校验：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhTpIulJRRlzLx3oQYIBJE0naxvbCJL7icTsvICOib3SoXGzXTicwVdr2Zg/640?wx_fmt=png&from=appmsg)

#### 最后我们找一个 system32 下，但是既不是白名单，也没有自动提权标记的可执行程序测下

这里我们找到一个 netsh.exe 可执行程序：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhBKoheYHz2Aa6GGmShNZJ4XMcSyFeIH8u7Gr9hbInpSjYxYZDqqhszg/640?wx_fmt=png&from=appmsg)

查看 manifest 不存在自动提权标记：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhBC90v2mKGuBFYiaA0bhcynjlHtHrqR8gUfZ9EmPX9ACus9K9gXjzd1A/640?wx_fmt=png&from=appmsg)

并且该程序也不在白名单里面；此时我们右键以管理员运行（注意这里不能双击，因为这个可执行文件对权限没有要求）；

测试效果：需要 uac 验证；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhjKgUSPb1BhibnrXibaRWeenglalHmIPBpiaRp59pIfCibR8VMx4VjNHyog/640?wx_fmt=png&from=appmsg)

通过这几个测试，说明我们逆向分析出来的 uac 逻辑基本没有问题；sysWow64 路径和 system32 测试下来一样的效果；

0x03 UAC 提权
===========

说起 UAC 提权，那必不可少的搬出 UACME 这个项目：`https://github.com/hfiref0x/UACME`

这个项目几乎是记录了目前所有公开的 bypass UAC 技术的方法；

目前来看，能够绕过 uac 弹窗验证的可执行文件，需要满足的特点是（注册表相关自动审批打开，admincode 要前面关校验，）：

*   在指定路径（system32 、systemWOW64）下面的两种程序，一是经过校验的白名单程序，二是 manifest 里面存在 autoElevate 为 true 的程序；
    

学习完该项目之后会发现 bypass 的思路大致就那么几条：

一、Bypass 思路
-----------

项目中的主要的思路大致可以分为以下的几大类：

### 1、dll 劫持 UAC 白名单进程

通过利用 IFileOperation 往高权限目录（system32\syswow）写 dll 文件，dllHijack 劫持 windows 内置的能够不弹窗自提权的 exe，从而实现提权；

如：uacme23，利用 pkgmgr.exe 白名单 bypassuac

实现原理细节、落地代码、测试效果以及检测方式可以参考：

ga0weI'blog-BypassUAC - 白名单_PkgMgr_DLL 劫持

### 2、篡改 pe 执行逻辑通过注册表

通过修改低权限注册表，使某些 windows 内置的能够不弹窗自提权的 exe 的逻辑被篡改，从而实现提权；

如：uacme33，利用 fodhelper.exe 会获取 HKCU 注册表内容，修改特定路径`shell\open\command`执行 pe 文件来 bypassuac；

实现原理细节、落地代码、测试效果以及检测方式可以参考：

ga0weI'blog-BypassUAC_fodhelper 进程 Registry-Shell_Open_Command 提权

### 3、通过高权限 com 组件任意代码、命令执行的接口提权

通过利用某些 com 组件的某些接口方法存在类似任意命令执行的接口实现提权，然后利用 com 组件的校验缺陷（和 IFileOpearion 提权操作一样，IFileOperation 本身也是一个 com 组件），从而实现提权；

如：uacme41，利用一个叫`CMSTPLUA`的 com 组件，其存在一个名为 ICMLuaUtil 的接口，这个接口提供了一个名为 ShellExec 的方法可以实现任意进程执行；

实现原理细节、落地代码、测试效果以及检测方式可以参考：

BypssUAC_com 组件 CMSTPLUA_ICMLuaUtil 接口提权

二、调用 com 组件本身也需要权限
------------------

如果我们使用自己的进程直接调用 com 组件，IFileOperation、CMSTPLUA 这种，那么其实调用 com 组件的时候，就会弹窗 uac 了，windows 这里 rpc 调用 com 接口是存在校验的，微软自己的可信程序调用的时候，就不需要弹窗提权;

当一个 com 组件调用发生的时候，微软是如何辨认对应的调用者是否是其受信的调用者的呢，有人分析发现，这个对调用进程判断的逻辑存在几个点：

*   PEB 下面的_RTL_USER_PROCESS_PARAMETERS 里面的 ImagePathName;
    
*   PEB 下面的_LDR_DATA_TABLE_ENTRY 里面的 FullDllName 和 BaseDllName；
    

所以这里只需要修改下自己进程的 peb 里以上三个变量就行；

0x04 一个待解决的疑问
=============

uac 流程分析下来，其实笔者在没有具体去看 uacme 这个项目的时候，就在想，直接可信目录下，写个样本，然后修改 manifest，满足自动提权，这样 uac 岂不是直接就被绕过了，于是这里笔者做了一个测试：

使用 visualstudio 随便生成一个 exe，配置的时候，生成清单打开，把运行权限调高，并且可避 uac：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhccMSIKpfC2RR5L1iahrqoYRKdhaxBf0Rr26Iff4hDVml0Yb4WH1YyzA/640?wx_fmt=png&from=appmsg)

通过 mt.exe 修改 exe 的 manifest 文件

获取当前的 manifest 文件

```
mt.exe -inputresource:Create\_thing.exe;#1 -out:current.manifest  


```

修改 current.manifest 文件，加上自动提权的标记

```
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>  
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" manifestVersion="1.0">  
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">  
    <security>  
      <requestedPrivileges>  
        <requestedExecutionLevel level="requireAdministrator" uiAccess="false"></requestedExecutionLevel>  
      </requestedPrivileges>  
    </security>  
  </trustInfo>  
<asmv3:application>  
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">  
        <dpiAware>true</dpiAware>  
        <autoElevate>true</autoElevate>  
    </asmv3:windowsSettings>  
</asmv3:application>  
</assembly>


```

修改完，再写回 exe：

mt.exe -manifest current.manifest -outputresource:Create_thing.exe;#1

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhnBYK7t1vXjRn6InCWv875zAjNHB3vicIav4bRoRen9xhYt0dEnwIjtg/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhs5gbw1MjwrPwPL2eVVORSWa3NKWiajHq6KYcs1tbT4Q1qHy8sn5wW0g/640?wx_fmt=png&from=appmsg)

使用 sigcheck 检查下修改是否成功，如下图可以看到修改成功了：

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhs5gbw1MjwrPwPL2eVVORSWa3NKWiajHq6KYcs1tbT4Q1qHy8sn5wW0g/640?wx_fmt=png&from=appmsg)

我们把这个 exe 丢到指定目录：system32 下（这里只是测试效果，实际情况可以结合 IFileOperation 来做文件移动），看下能否提权，如下图，失败了；

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qhiaKibAyh7zsPzxia8iaM26fGq477udV2TsSCwnsxaSXicxzZLmGNw0eklKA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/mmbiz_png/XicduVvI3nG0IYakV1z7m9BTPHCIdp0qh3libNm2Ob0qHpN1bN7vZy2ygCSpGZvrINF7ZHNGibwsHCxQrvhTjphtA/640?wx_fmt=png&from=appmsg)

奇怪，这里并没有直接提权成功，出现了弹窗；

难道我们分析的 uac 流程有问题？于是这里我回溯回去，调试了下，发现上面的校验都过了，应该是没问题的才对；

嗯，反复分析，笔者推断是 consent.exe 里面出问题了，后续待分析调试，暂时没找到问题在哪；

0x05 检测及思考
==========

检测思路，拿 sysmon 日志举例，这几篇 blog 中对几个常见场景给出了一些检测建议：检测方法

攻击者一般在渗透过程中什么阶段会需要使用到 uacbypass 呢？

1、边界突破钓鱼的时候，如果我们肯定希望自己的样本是高权限执行的，那么对于一般样本用户双击运行样本，样本本身如果要高权限，就会触发 uac 弹窗，从而被钓鱼的用户就会产生警觉；所以此时需要 bypassuac 提权弹窗；

2、权限维持的时候，如果我们现在一个样本已经以一个低权限在受害机器上运行了，那么我们如何做到权限维持呢，一般来说都是写计划任务和服务等方法实现权限维持，这些实现的时候都是需要管理员权限的；

3、对抗 av 的时候，比如有些黑灰产上来就是关防火墙和干掉 av，这里写操作至少也要管理员权限；

0x06 总结
=======

笔者分析学习 windows 的 uac 机制，前前后后加上 bypass 也学习了一个半月，这一套学习下来感觉还是收获颇丰的，虽然这个东西以及很多技术四五年前就有了，但是其实你会发现只有你自己亲自去调试分析这里面的细节逻辑的时候，你才能体会到后面的绕过技术为什么要那么做，而且还有一个意外的收获就是通过对 uac 机制的逆向分析，感觉也锻炼了逆向分析能力，笔者之前逆向分析大多数都是一些攻击者写的样本和一些破解类的东西，怎么说呢，攻击者技术参差不齐使用的百编程语言也各部相同，分析的时候就是大杂烩（这里面一堆干扰因素，什么编译器、编程语言、优化结构等等东西，如果你去过分关注细节你会发现你就会被绕进去）；但是这次分析 windows uac 的时候发现，每个动作和步骤都是有他的原因，也反向的学习到了一些安全编程；

还有就是你会发现，虽然技术四五年前就有，但是很多现在还是可以使用的，甚至在 win11 里面也可以使用；那么你觉得使微软不想修吗？这个问题智者见智，仁者见仁；了解细节，然后去推敲问什么他不修，这也是个非常有意思的事情；当然有些因素绕回来了，就是业务和安全之间对一个问题的不同看法了；

笔者才疏学浅，文笔轻浮，如有笔误，请各位师傅不吝赐教；

参考：

https://3gstudent.github.io/%E9%80%9A%E8%BF%87COM%E7%BB%84%E4%BB%B6IFileOperation%E8%B6%8A%E6%9D%83%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6

https://www.youtube.com/watch?v=TkC19ukBBxk

https://www.youtube.com/watch?v=6LUo-Crd9pc