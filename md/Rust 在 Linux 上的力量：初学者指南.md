> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Fl1YBLYjwwTvtmsHK868ow)

Rust 正迅速成为系统编程的首选语言，原因不难理解。其独特的安全性、速度和并发性组合使其非常适合 Linux 开发。

如果你是 Rust 或 Linux 的新手，不要担心——这篇文章将介绍一些实用的方法，你可以使用 Rust 来增强你的 Linux 体验。

为什么 Rust 是 Linux 开发的完美选择

在深入探讨 Linux 上使用 Rust 可以做什么之前，让我们先谈谈为什么 Rust 是一个很棒的选择：

*   内存安全：Rust 的所有权模型可以同时捕获内存错误，防止像空指针解引用和缓冲区溢出这样的错误。
    
*   高性能：Rust 的性能与 C 和 C++ 相当，使其成为系统级编程的理想选择。
    
*   并发：Rust 的并发模型可以编写安全的多线程代码，而不必担心数据竞争。
    
*   健壮的工具：Rust 拥有丰富的生态系统和优秀的工具，比如 Cargo 等。
    

1. 创建高效的系统工具

Linux 用户通常需要小型、高效的工具来管理文件、监视系统性能和自动执行任务。Rust 的安全性和性能使其成为构建这些实用程序的绝佳选择。

下面是一个用 Rust 编写的简单文件复制实用程序，该工具将一个文件的内容复制到另一个文件，演示了 Rust 的简单语法和强大的标准库。

```
use std::env;
use std::fs;
use std::io::Result;

fn main() -> Result<()> {
    let args: Vec<String> = env::args().collect();
    if args.len() != 3 {
        eprintln!("Usage: {} <source> <destination>", args[0]);
        return Ok(());
    }

    fs::copy(&args[1], &args[2])?;
    Ok(())
}


```

用法 

```
$ cargo run source.txt destination.txt


```

该命令将 source.txt 复制到 destination.txt。

2. 构建高性能网络工具

网络是 Rust 擅长的另一个领域。无论你是在构建 web 服务器、代理还是任何与网络相关的工具，Rust 的性能和安全保证都是无可挑剔的。

使用 hyper crate，可以在 Rust 中创建一个简单的 HTTP 服务器。在下面这个例子中，监听端口 3000，并以 “Hello, Rust!” 响应任何请求。

```
use hyper::service::{make_service_fn, service_fn};
use hyper::{Body, Request, Response, Server};
use std::convert::Infallible;

async fn handle_request(_req: Request<Body>) -> Result<Response<Body>, Infallible> {
    Ok(Response::new(Body::from("Hello, Rust!")))
}
#[tokio::main]
async fn main() {
    let make_svc = make_service_fn(|_conn| {
        async { Ok::<_, Infallible>(service_fn(handle_request)) }
    });
    let addr = ([127, 0, 0, 1], 3000).into();
    let server = Server::bind(&addr).serve(make_svc);
    if let Err(e) = server.await {
        eprintln!("Server error: {}", e);
    }
}


```

用法 

```
$ cargo run
Server running on http://127.0.0.1:3000


```

在浏览器中访问 http://127.0.0.1:3000，可以看到 “Hello, Rust!”。

3. 开发自动化脚本工具

Rust 可以在许多任务中取代传统的脚本语言，提供编译语言的性能和安全性。

下面是一个通过读取 /proc/stat 来监视 CPU 使用情况的脚本。它演示了 Rust 强大的标准库和文件 I/O 功能。

```
use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

fn main() {
    if let Ok(lines) = read_lines("/proc/stat") {
        lines.for_each(|line| {
            if let Ok(cpu_line) = line {
                if cpu_line.starts_with("cpu ") {
                    let parts: Vec<&str> = cpu_line.split_whitespace().collect();
                    let user: u64 = parts[1].parse().unwrap();
                    let nice: u64 = parts[2].parse().unwrap();
                    let system: u64 = parts[3].parse().unwrap();
                    let idle: u64 = parts[4].parse().unwrap();
                    println!(
                        "CPU Usage: User={} Nice={} System={} Idle={}",
                        user, nice, system, idle
                    );
                }
            }
        });
    }
}

fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}


```

用法 

```
$ cargo run
CPU Usage: User=600 Nice=10 System=300 Idle=2000


```

实际的输出将根据系统的状态而变化。

Rust 的独特特性使其成为 Linux 开发的绝佳选择。无论是在编写系统实用程序、网络工具、自动化脚本还是跨平台应用程序，Rust 都能提供所需的性能、安全性和并发性。