> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzI2NDQyNzg1OA==&mid=2247491694&idx=1&sn=f9d15af93fc8e5b048a93ad23be86766&chksm=eaae6053ddd9e9457e65ecf3d66ff309beb89c782a9e6c717a46a0151dd3fb777df72a0a28d6&scene=21#wechat_redirect)

![图片](https://mmbiz.qpic.cn/mmbiz_svg/iaRlzG8zy7Bs0ONz1j1MClOtxWDsVazPXaGOicFBQ8cJ34tgbuOzbTiciaacx1Y96yYtrWuwdCFybUHG39RZEEwGLuKichcF892at/640?wx_fmt=svg)

**目录**

**认证 Authentication**

1. 认证主体

    (1) Service Account

    (2) 普通用户

          1)K8s 中内置的用户

    (3)Anonymous

    (4)K8s 中的 Group

          1)K8s 中内置的组

2.HTTPS 证书认证

3.HTTP Bear Token 认证

**授权 Authorization**

1.RBAC 授权

    (1)Role 和 ClusterRole

          1)Role 示例

          2)ClusterRole 示例

          3)Role 和 ClusterRole 的 rules 可配置参数

    (2)RoleBinding 和 ClusterRoleBinding

          1)RoleBinding 示例

          2)ClusterRoleBinding 示例

2.Node 授权

**准入控制 Admission Control**

1.NodeRestriction 准入控制器

2.Service Account 准入控制器

3.Token 准入控制器

![图片](https://mmbiz.qpic.cn/mmbiz_svg/iaRlzG8zy7Bs0ONz1j1MClOtxWDsVazPXY655IPFVXxW4MwxIuOktV9ZWwUC9pk3YKEpThufETCAq05ib8xUXlFwQVLfK7zP5s/640?wx_fmt=svg)

    我们在请求 API Server 的时候，会经历哪些步骤呢？总得来说，有如下步骤：

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEgwBwrfvop6FfAp3tP0amRJotLnJSwO8O4y9xlhFaofrLnY5ZcibzDU1A/640?wx_fmt=png)

 **·** 认证 (Authentication) 是识别用户的过程，这个过程需要知道用户到底是谁；

**·** 而授权 (Authorization) 是识别已认证用户访问权限的过程，这个过程判断用户是否具有某些权限;

 **·** 准入控制 (Admission Control) 是最后的关卡，它会在请求通过认证和鉴权之后、对象被持久化之前拦截到达 API 服务器的请求，其通过一组控制逻辑对对象的操作进行验证和变更等操作。

**一.**

**认证 Authentication**

![图片](https://mmbiz.qpic.cn/mmbiz_svg/iaRlzG8zy7Bs0ONz1j1MClOtxWDsVazPXe45zBRo5dybMdS1ficTDVKCeX70oibZdrb2kic2zLZzogv4VB6ibic5haPCQvexLev3lS/640?wx_fmt=svg)

在认证方面，K8s 提供了如下的认证方式：

**HTTPS 证书认证：**

    基于 CA 根证书签名的双向数字认证方式，比如 k8s 运维人员通过 kubectl 访问 API Server 或 node 节点上的 kubelet 进程与 API Server 进程交互都是使用的证书认证；kubectl 默认的配置文件保存路径为~/.kube/config，而 kubelet 默认的配置文件保存路径为 /etc/kubernetes/kubelet.conf。

**HTTP Bear Token 认证：**

    通过一个 Bear Token 识别合法用户，比如 pod 与 API Server 交互这种认证方式，pod 以 Service Account 的身份去运行，一个 Service Account 对应着一个 Secret，而 Secret 中保存着 Bear Token，pod 中 Bear Token 默认的保存路径为 /var/run/secrets/kubernetes.io/serviceaccount/token，是 jwt 格式的字符串。

**OpenID Connect Token 第三方认证：**

    通过第三方 OIDC 协议进行认证。

**Webhook Token 认证：**通过外部 Webhook 服务进行认证。

**Authentication Proxy 认证：**通过认证代理进程序行认证。

    在身份认证阶段，最重要的就是辨别用户的身份了，API Server 需要从请求中获取有关于用户身份的信息。通常用户身份信息可以通过 User 或 Group 来定义，但是 K8s 中并没有相关的定义，所以无法通过 API Server 对 User 或 Group 进行管理。K8s 认为 User、Group 这类信息由外部系统来管理，自己并不负责管理和设计，这样做的好处在于可以避免重复定义用户模型，更方便第三方用户权限平台进行对接。

  **当向 API Server 发送请求时，认证插件将以下属性与请求者相关联：**

**用户名：**标识最终用户的字符串，在证书中也就是 subject 字段所对应的 CN。

**组：**一组将用户和常规用户组相关联的字符串，在证书中也就是 subject 字段所对应的 O。自 Kubernetes 1.4 开始，客户端证书还可以通过证书的 organization 字段标明用户的组成员信息。 要包含用户的多个组成员信息，可以在证书中包含多个 organization 字段。

**UID：**标识最终用户的字符串，比用户名更加一致且唯一。

**额外字段：**包含其他有用认证信息的字符串列表的映射。

所有的值对身份认证系统都是不透明的，并只有在由 authorizer 授权者解释时才具有重要意义。您可以一次性启用多种身份验证方式。通常使用至少两种认证方式。

当启用了多个认证模块时，第一个认证模块成功认证后将不会进行第二个模块的认证。**API Server** 不会保证认证的顺序。

与其他身份验证协议（**LDAP、SAML、Kerberos、x509 方案等**）的集成可以使用身份验证代理或身份验证 **webhook** 来实现。

**1**

**认证主体**  

K8s 集群中包含两类用户：

 **·** 一类是由 K8s 管理的 **Service Account**；

 **·** 另一类是普通用户。

    为什么 **K8s** 中会有 **Service Account** 和普通用户这两种形式呢？因为与 **API Server** 服务交互实际上有两种类型东西，一种是真实的人类用户，另一类就是程序。因此，真实的人类用户对应的就是普通用户账号，而程序对应的就是 **Service Account** 了。

    API Server 请求被绑定到 **Service Account** 或普通用户上，或者作为匿名请求对待。这意味着集群内部或外部的每个进程，无论是在服务器上输入 **kubectl** 的用户、节点上的 kubelet 或 web 控制面板的成员，都必须在向 **API Server** 发出请求时进行身份验证，否则被视为匿名用户。

**1**

**Service Account**  

 **Service Account** 是由 K8s API 管理的帐户，它不是给 K8s 集群的用户（系统管理员、运维人员、租户用户等）使用的，而是给运行在 Pod 里的进程用的，它为 Pod 里的进程提供了必要的身份证明。Service Account 都绑定到了特定的 namespace，并由 API Server 自动创建或者通过 API 调用手动创建。一个 Pod 必须要以某一个 Service Account 的身份去运行，一个 Service Account 对应着一个 Secret，一个 Secret 保存着一个 Token 和公钥文件，从而允许 pod 与 API Server 之间的调用。Secret 从属于 Service Account 资源对象，属于 Service Account 的一部分，在一个 Service Account 对象里面可以包括多个不同的 Secret 对象，分别用于不同目的的认证活动。

    我们进入 pod 中，查找 **/var/run/secrets/kubernetes.io/serviceaccount** 下的 **token** 文件，即可看到该 pod 对应服务账户的 Token，该 Token 是 jwt 格式的字符串，如图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEgV8iblz2cITM7p7RMicUApSJEwQ7AQf6r3FApEnVmewPkAqbwlrveanXg/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEgm8vt9Zq4PmX9ObqCmNlIO0zujWic4Nt62jdGYbic7AulwsHXtzxabDmA/640?wx_fmt=png)

**那么，这个 Token 是怎么生成的呢？**

    该 Token 是动态生成的，是由 **kube-controller-manager** 进程调用 API Server 的私钥（**/etc/kubernetes/manifests/kube-controller-manager.yaml** 配置文件 **--service-account-private-key-file** 参数指定的文件）签名生成的一个 JWT 格式的 Token。API Server 接收到客户端发来的 Token 后，会再次用私钥（**/etc/kubernetes/manifests/kube-controller-manager.yaml** 配置文件 **--service-account-private-key-file** 参数指定的文件）对该 Token 进行校验。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEglEsUsZmIzkcZpP6iaS195Aw3PUkiaT7YicEiaoprtEXXswy76NPib0H99icw/640?wx_fmt=png)

    我们查看所有的 **ServiceAccount**，发现在每个命名空间下都存在一个名为 **default** 的默认 **ServiceAccount** 对象。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEgWd5zZF8wxTWdmOibmPLSbiafZITn72pRyia1PMEN4KRxy4Mu9MJLOEuNQ/640?wx_fmt=png)

    在这个 **Service Account** 里面有一个名为 **Secrets** 的可以作为 **Volume** 被挂载到 Pod 里的 Secret，Pod 启动时，这个 Secrets 会自动被挂载到 Pod 的指定目录下，用来协助完成 Pod 中的进程访问 **API Server** 时的身份鉴权。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEgic1jXbcQDLsDZjuCUarLe6nfzCuu2Rmqibf1lia02KDn4PrdKib6Sibdia0w/640?wx_fmt=png)

    一个 **Service Account** 可以包含多个 secret，名为 secrets 的 secret 用于访问 API Server 的 secret，也被称为 **ServiceAccountSecret**；名为 **imagePullSecrets 的 secret** 用于下载容器镜像时的认证，但是由于镜像库通常运行在 **Insecure** 模式下，所以这个 secret 为空；用户还可以自定义其他的 secret。

    如果一个 Pod 在定义时没有指定 **spec.serviceAccountName** 属性，则系统会自动将其赋值为 **default**，即大家都使用同一个命名空间中的默认 **Service Account**。如果某个 Pod 需要使用非 **default 的 Service Account**，则需要在定义时指定 **spec.serviceAccountName** **为 "** **服务账户名 "**。

Service Account 的正常工作离不开以下准入控制器：

*   Service Account 准入控制器
    
*   Token 准入控制器
    

    关于准入控制器，我们会后文章最后进行讲解。

 **注意：**由于 **Service Account** 的 **token** 存储在 **secret** 中，所以具有对这些 secret 的读取权限的任何用户都可以作为 **Service Account** 进行身份验证。授予 **Service Account** 权限和读取 **secret** 功能时要谨慎。

**2**

**普通用户**  

    普通用户就是个人用户，比如某个研发人员或外部应用的账号。但是 K8s 并没有相应的资源对象或者 API 来支持常规的个人用户。拥有 K8s 集群的 CA 证书签名的有效证书，个人用户就可以访问 K8s 集群了。在这种情况下，证书中的 subject 会被 API Server 服务解析成一个用户。比如，证书中的 subject 的内容为：**O=yunwei,CN=lisi****。**其中 **CN(Common Name)lisi** 会被解析为用户，而 **O(Organization Name)yunwei** 会被解析为用户所在的组。

**K8s 中内置的用户**

K8s 内置了一组系统级别的用户，以 “system：” 开头，如下：

 **· system:kube-controller-manager：**绑定了名为 system:kube-controller-manager 的 ClusterRole，允许访问控制器管理器组件所需要的资源。

**· system:kube-scheduler：**绑定了名为 system:kube-scheduler 的 ClusterRole，允许访问 scheduler 组件所需要的资源。

 **· system:kube-proxy：**绑定了名为 system:node-proxier 的 ClusterRole，允许访问 kube-proxy 组件所需要的资源。

 **· system:anonymous：**绑定了名为 kubeadm:bootstrap-signer-clusterinfo 的 Role，当一个请求没有携带任何的认证信息时，它会自动获得该用户名。

执行如下命令然后查看 Users 列即可查看 K8s 默认创建的 User。

```
kubectl get clusterrolebinding -A -o wide
kubectl get rolebinding -A -o wide
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEgpNXzHkJdicVibxhKQqtnao9ibgOBUwQsNibm9DsTH2UWlwT6nM1kGdppvQ/640?wx_fmt=png)

**3**

**Anonymous**  

    当一个请求没有携带任何的认证信息时，它会自动获得用户名：**system:anonymous** 和用户组 **system:unauthenticated**，我们可以配置分配特定的权限给这种匿名用户，适用于想要公开一些不敏感的资源等场景。

**4**

**K8s 中的 Group**  

    同外部用户一样，**Group** 也是一种外部的概念，在 X509 客户端证书认证的方式中，**Group** 名字就是证书的组织名 **O（Orgnization）**。

**K8s 中内置的组**

    K8s 内置了一组系统级别的组，以 “system：” 开头，如下：

 **· system:authenticated：**认证成功后的用户自动加入的一个组，用于快捷引用所有正常通过认证的用户账号，该组包含在所有已验证用户的组列表中。绑定了名为 system:discovery 的 ClusterRole。

 **· system:unauthenticated：**未能通过任何一个授权插件检验的账号，即未通过认证测 试的用户所属的组 。绑定了名为 system:public-info-viewer 的 ClusterRole。

 **· system:serviceaccounts：**当前集群上的所有 Service Account 对象。绑定了名为 system:service-account-issuer-discovery 的 ClusterRole。

**· system:serviceaccounts:**<namespace＞：特定命名空间内的所有 service account="" 对象。<=""span="">

 **· system:masters：**绑定了名为 cluster-admin 的 ClusterRole。

**· system:nodes：**绑定了名为 system:certificates.k8s.io:certificatesigningrequests:selfnodeclient 的 ClusterRole。

 **· system:monitoring：**绑定了名为 system:monitoring 的 ClusterRole。

 **·system:bootstrappers:**kubeadm:default-node-token

    执行如下命令然后查看 **Groups** 列即可查看 K8s 默认创建的 **Group**。

```
kubectl get clusterrolebinding -A -o wide
kubectl get rolebinding -A -o wide
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEgSuib17NyhPsDkoAuzQCDl5cHUsdiaPRcUSHibzHCdaib82Lt0FmCCQtJMw/640?wx_fmt=png)

**2**

**HTTPS 证书认证**  

    K8s 需要 **PKI（public key infrastructure**，公钥基础设施）证书来基于 TLS 的安全的认证。如果是使用 **kubeadm** 来初始化的集群，则 **kubeadm** 会帮助你自动生成集群所需要的各类证书。**kubeadm** 会将证书放置在 **/etc/kubernetes/pki** 目录下，而包含管理员证书的配置文件 **admin.conf** 会放置到 **/etc/kubernetes** 目录下。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEgPOZbBDc3McnVKRYvicwxyIwDpoRZxBXHj6RyVERUhGGoKkVJT1cq5Rg/640?wx_fmt=png)

    k8s 使用 x509 证书中 **CN(Common Name)** 以及 **O(Organization)** 字段对应 k8s 中的 **user** 和 **group**，将 **Authentication** 和 **RBAC Authorization** 结合到了一起，巧妙地将 **Control Plane** 中的各个核心 **User 和 Group**、与操作权限（**ClusterRole**）进行了集群绑定（**ClusterRoleBinding**）。

**3**

**HTTP Bear Token 认证**

    这种认证采用的数据结构是由 **JWT Token** 类型的，一般的形式是在 **HTTP Authroziation** 头部添加 **Bear Token**，每个 **Bearer Token** 都对应一个用户名。客户端发起 API 调用请求时，**API Server** 就能识别用户身份了。比如 pod 所对应的 **Service Account** 采用的就是这种形式，**Token** 采用的是 **RS256** 非对称加密算法进行加密。

```
#使用Bear Token进行认证
kubectl --insecure-skip-tls-verify -s https://172.16.200.70:6443  --token="xxxx" get cs

#使用Bear Token进行认证
curl --header "Authorization: Token" -X GET https://172.16.200.70:6443/api -k
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEg6ycQrxJFNNtYKRRjf0Q36dghCWiazEEjQ4D8Wq9GzSF7LJ0FrsS2tGA/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEgrFTeK6UQxmBHNpszS1IpMZN5XB3ruAKicswRmiajoasKV5gmNicrLaczg/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_svg/iaRlzG8zy7Bs0ONz1j1MClOtxWDsVazPXB5VAHqVjhRdI4R3SL9WFp9h0m19q3Ujt4O66d5xJ6PjyAQEKWMqaibu03ibnTcyL1c/640?wx_fmt=svg)

**二**

**授权 Authorization**

![图片](https://mmbiz.qpic.cn/mmbiz_svg/iaRlzG8zy7Bs0ONz1j1MClOtxWDsVazPXe45zBRo5dybMdS1ficTDVKCeX70oibZdrb2kic2zLZzogv4VB6ibic5haPCQvexLev3lS/640?wx_fmt=svg)

    当用户认证通过后，下一步就是授权操作了。**API Server** 服务目前支持以下几种授权策略：

 **·** **AlwaysDeny：**表示拒绝所有请求，一般用于测试。

 **· AlwaysAllow：**允许接收所有请求。如果集群不需要授权流程，则可以采用该策略。但是为了安全，千万不要采用该策略！

 **·ABAC(Attribute-Based Access Control)：**基于属性的访问控制。表示使用用户配置的授权规则对用户请求进行匹配和控制，它是 K8s 1.6 之前的默认策略，现在已经被 RBAC 代替。

 **· RBAC(Role-Based Access Control)：**基于角色的访问控制，它是目前 K8s 默认的授权策略。如果 RBAC 仍然不满足某些特定需求，则用户还可以自行编写授权逻辑并通过 Webhook 方式注册为 Kubernetes 的授权服务，以实现更加复杂的授权规则。

 **· Node：**是一种特殊授权模式，用于对 kubelet 发出的请求进行访问控制。

Webhook：通过调用外部 REST 服务对用户进行授权。

    通过 API Server 的配置文件 **/etc/kubernetes/manifests/kube-apiserver.yaml** 的参数 **--authorization-mode** 可配置多种授权策略，用逗号分隔即可。在通常情况下，我们会设置授权策略为 **Node,RBAC**，如图所示。**API Server** 在收到请求后，会读取该请求中的数据，生成一个访问策略对象，然后 **API Server** 会将这个访问策略对象和配置的授权模式逐条进行匹配，第一个被满足或拒绝的授权策略决定了该请求的授权结果，如果匹配的结果是禁止访问，则 **API Server** 会终止 API 调用流程，并返回客户端的错误调用码。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEgIgXENLAWVmDbC3icD7FJicNciauwl1CTMgib9C92b5fiaH8h5X7qGqngibuQ/640?wx_fmt=png)

**1**

**RBAC 授权**  

基于角色（Role）的访问控制（RBAC）是一种基于组织中用户的角色来调节控制对计算机或网络资源的访问的方法。RBAC 鉴权机制使用 rbac.authorization.k8s.io API 组来驱动鉴权决定， 允许你通过 K8s API 动态配置策略。RBAC 在 K8s 1.8 版本时升级为 GA 稳定版本，并作为 kubeadm 安装方式下的默认授权选项。

RBAC 具有如下优势：

*   对集群中的资源和非资源权限均有完整的覆盖。
    
*   RBAC 的权限配置通过几个 API 对象即可完成，同其他 API 对象一样，可以用 kubectl 或 API 进行操作。
    
*   可以在运行时进行调整，无须重新启动 API Server。
    

在 RBAC 授权中，有如下概念：

**subject 主体**

 **·** User

 **·** Group

 **·** ServiceAccount

**角色**

 **·** Role：授予特定命名空间的访问权限

 **·** ClusterRole：授予集群的访问权限

**角色绑定**

 **·** RoleBinding：将特定命名空间的角色绑定到 subject 主体

 **·** ClusterRoleBinding：将集群角色绑定到 subject 主体

**资源**：也就是 K8s 中的各种资源对象，如 pod、service、secret 等。

最后就是将主体与角色进行绑定，以获得特定的权限，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEgthduv0LbTExVRcqRqPibnMv2ZclQRuh8NP0L8fZOMrT63Mw4AbSKdRw/640?wx_fmt=png)

    在 RBAC 管理体系中，K8s 引入了 4 个资源对象：**Role、ClusterRole、RoleBinding** 和 **ClusterRoleBinding**。同其他 API 资源对象一样，用户可以使用 kubectl 或者 API 调用等方式操作这些资源对象。

**1**

**Role 和 ClusterRole**

    Role 或 ClusterRole 中包含一组代表相关权限的规则，这些规则设置的权限都是许可形式的，不可以设置拒绝形式的规则。Role 设置的权限将会局限于命名空间范围内，在你创建 Role 时，你必须指定该 Role 所属的名字空间。如果需要在集群级别设置权限，就需要使用 ClusterRole 了。

**Role 示例**

以下是一个 Role 的 yaml 定义：

```
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: test
  name: test-role
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch", "delete"]
```

    上述定义的 Role 的 name 是 **test-role**，这个 Role 的权限是可以对所有 **apiGroups** 下面的资源名为 **“pods****”** 的资源进行 get、list、watch 和 delete 的操作。但是需要注意的是限定在 test 的命名空间范围内。

Role 资源对象主要通过 **rules** 字段来描述它的功能，rules 字段是 rule 的列表，每个 rule 是一组作用于不同 **apiGroup** 资源上的一组操作的集合，每一个 rule 包含如下几个关键字段：

 **· apiGroups：**api 组，比如当我们使用 **kubectl api-resources** 来查询集群所支持的 api 资源时，会发现如 **“apps/v1”** 这样的 vesion，它的结构是 **apiVersion: $GROUP_NAME/$VERSION**，所以，这里的 api 组就是 apps。

 **· resouces：**和 Role 绑定的资源名称，如 node、pod、secret 等资源对象。

 **· verbs：**和 Role 绑定的动作，比如 get、list、watch、delete、update、create、patch 等。

**ClusterRole 示例**

    从命名上来看，ClusterRole 的处理范围要比 Role 大，因为 Role 的范围是 namespace，而 ClusterRole 的范围是 Cluster。

**ClusterRole 主要适用以下场景：**

 **·** 对集群范围内资源的授权，例如 Node。

 **·** 对非资源型的授权，例如 healthz。

 **·** 对包含全部 namespace 资源的授权，例如 pods（用于 kubectl get pods -A 这样的操作授权）。

 **·** 对某个命名空间中多种权限的一次性授权。

**下面是一个 ClusterRole 的 yaml 定义：**

```
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-ClusterRole
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list", "watch"]
```

    上述 **ClusterRole** 定义的是一个 name 为 **test-ClusterRole**，拥有对所有 **apiGroup** 下的资源类型为 **secrets** 的资源进行 get、list、watch 的操作，并且他没有限定 **namespace**。

 **Role 和 ClusterRole 的 rules 可配置参数**

**apiGroups**

```
"","apps", "autoscaling", "batch"
```

**resources**

```
"services", "endpoints", "pods","secrets","configmaps","crontabs","deployments","jobs","nodes","rolebindings","clusterroles","daemonsets","replicasets","statefulsets","horizontalpodautoscalers","replicationcontrollers","cronjobs"
```

**verbs**

```
"get", "list", "watch", "create", "update", "patch", "delete", "exec"
```

**2**

**RoleBinding 和**

**ClusterRoleBinding**  

    角色绑定（Role Binding）是将角色中定义的权限赋予一个或者一组用户。 它包含若干主体（用户、组或服务账户）的列表和对这些主体所获得的角色的引用。 RoleBinding 在指定的名字空间中执行授权，而 ClusterRoleBinding 在集群范围执行授权。

**RoleBinding 示例**

    一个 RoleBinding 可以引用同一命名空间中的任何 Role，也可以引用 ClusterRole 并将该 ClusterRole 绑定到 RoleBinding 所在的名字空间。

    下面这个 RoleBingding 的例子是将上面我们定义的 test-role 与用户 test 进行绑定，作用的命名空间为 test。

```
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: test-rolebinding
  namespace: test
  labels:
    roleBinding: test-rolebinding
  annotation:
subjects:
- kind: User
  name: test
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: test-role
  apiGroup: rbac.authorization.k8s.io
```

**RoleBinding** 有两个比较重要的根节点，一个是 **subjects**，描述了需要绑定的主体，有 user、group 和 service account；另一个是 **roleRef**，描述了要绑定的 Role。

**RoleBinding** 本身会被 **namespace** 所影响，用于某个 namespace 内的授权，如果它与 Role 进行绑定，就需要保持一致的 namespace；

**RoleBinding** 除了能够和 Role 绑定，也能和 **ClusterRole** 绑定，这个操作的含义是：对目标主体在其所在的命名空间授予在 ClusterRole 中定义的权限。如下将集群角色 **test-ClusterRole** 与用户 test 进行绑定，虽然 test-ClusterRole 是一个集群角色，但因为 RoleBinding 的作用范围为命名空间 test，所以用户 test 只能读取命名空间 test 中的 secret 资源对象，而不能读取其他命名空间中的 secret 资源对象。

```
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: rolebinding-with-clusterole
  namespace: test
subjects:
- kind: User
  name: test
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: test-ClusterRole
  apiGroup: rbac.authorization.k8s.io
```

**ClusterRoleBinding 示例**

**ClusterRoleBinding** 用于进行集群级别或者对所有命名空间都生效的授权。下面的例子允许 test 组的用户读取任意命名空间中的 secret 资源对象：

```
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: test-ClusterRoleBinding
subjects:
- kind: Group
  name: test
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: test-ClusterRole
  apiGroup: rbac.authorization.k8s.io
```

在集群角色绑定（**ClusterRoleBinding**）中引用的角色只能是集群级别的角色（**ClusterRole**），而不能是命名空间级别的 Role。

一旦通过创建 **RoleBinding** 或 **ClusterRoleBinding** 与某个 Role 或 ClusterRole 完成了绑定，用户就无法修改与之绑定的 Role 或 ClusterRole 了。只有删除了 RoleBinding 或 ClusterRoleBinding，才能修改 Role 或 ClusterRole。**Kubernetes** 限制 **roleRef** 字段中的内容不可更改，主要有以下两个原因。

 **·** 从逻辑上来说，与一个新的 Role 进行绑定实际上是一次全新的授权操作。通过删除或重建的方式更改绑定的 Role，可以确保给主体授予新角色的权限（而不是在不验证所有现有主体的情况下去修改 roleRef）。

 **·** 使 roleRef 不变，可以授予某个用户对现有绑定对象（Bindingobject）的更新（update）权限，以便其管理授权主体（subject），同时禁止更改角色中的权限设置。

**2**

**Node 授权**  

    Node 授权策略用于对 kubelet 发出的请求进行访问控制，与用户的应用授权无关，属于 K8s 自身安全的增强功能。简单来说，就是限制每个 Node 只访问它自身运行的 Pod 及相关的 Service、Endpoints 等信息；也只能受限于修改自身 Node 的一些信息，比如 Label；也不能操作其他 Node 上的资源。而之前用 RBAC 这种通用权限模型其实并不能满足 Node 这种特殊的安全要求，所以将其剥离出来定义为新的 Node 授权策略。Node 授权可以与 NodeRestriction 准入控制插件相结合使用来进行 Node 隔离。

**Node 授权器允许 kubelet 执行的 API 操作包括：**

**读取：**

 **· services**

 **· endpoints**

 **· nodes**

 **· pods**

 **·** 与绑定到 **kubelet** 节点的 Pod 相关的 **Secret**、**ConfigMap**、**PersistentVolumeClaim** 和持久卷

**写入：**

 **·** Node 和 Node 状态（启用 **NodeRestriction** 准入插件限制 kubelet 仅修改当前的 Node）

 **·** Pod 和 Pod 状态（启用 **NodeRestriction** 准入插件限制 kubelet 仅修改与当前绑定的 pod）

 **·** 事件

**身份认证与鉴权相关的操作：**

 **·** 对于基于 TLS 的启动引导过程时使用的 **certificationsigningrequests API** 的读 / 写权限

 **·** 为委派的身份验证 / 鉴权检查创建 **TokenReview** 和 **SubjectAccessReview** 的能力

**在 K8s 1.6 中**，使用 RBAC 授权模式时，**system:node** 群集角色（role）自动绑定到该 **system:nodes** 组。

**在 K8s 1.7 中**，由于 Node 授权器实现了相同的目的，因此不再支持 **system:nodes** 组与 **system:node** 角色的自动绑定，从而有利于对 secret 和 configmap 访问的附加限制。

**在 K8s 1.8 中**，将不会创建 binding。

使用 RBAC 时，将继续创建 system:node 集群角色，以便兼容使用 deployment 将其他 users 或 groups 绑定到集群角色的方法。

**三**

**准入控制 Admission Control**

![图片](https://mmbiz.qpic.cn/mmbiz_svg/iaRlzG8zy7Bs0ONz1j1MClOtxWDsVazPXe45zBRo5dybMdS1ficTDVKCeX70oibZdrb2kic2zLZzogv4VB6ibic5haPCQvexLev3lS/640?wx_fmt=svg)

客户端的请求通过认证 **Authentication** 和授权 **Authorization** 后，会进入到准入控制 **AdmissionControl** 关卡。准入控制可以执行验证 Validating 和变更 Mutating 等操作。准入控制器限制创建、删除、修改对象的请求，也可以阻止自定义动作，但是准入控制器不会也不能阻止 get、watch、list 对象的请求。

准入控制过程分为两个阶段。**第一阶段**，运行变更准入控制器。**第二阶段**，运行验证准入控制器。 某些准入控制器既可以是变更准入控制器又可以是验证准入控制器。如果两个阶段之一的任何一个控制器拒绝了某请求，则整个请求将立即被拒绝，并向最终用户返回错误。最后，除了对对象进行变更外，准入控制器还可能有其它的作用，比如将相关资源作为请求处理的一部分进行变更。 增加配额用量就是一个典型的示例，说明了这样做的必要性。 此类用法都需要相应的回收或回调过程，因为任一准入控制器都无法确定某个请求能否通过所有其它准入控制器。

**那么可能很多人会问了，为什么需要准入控制呢？**  

原因在于 K8s 的若干重要功能 (如创建、删除等高危操作) 都要求启用一个准入控制器，以便正确地支持该特性。 因此，没有正确配置准入控制器的 K8s API 服务器是不完整的，它无法支持你所期望的所有特性。

**那么如何启用一个准入控制器呢？**  

在 K8s 1.9 及之前的版本中使用的参数是 --**admission-control**，其中的内容是顺序相关的；在 Kubernetes1.10 及之后的版本中使用的参数是 **--enable-admission-plugins**，该参数标志接受一个准入控制插件列表（以逗号分隔的）， 这些准入控制插件会在集群修改对象之前被调用，发送给 **API Server** 的任何请求都需要通过列表中每个准入控制器的检查，检查与准入控制器的顺序无关。

**如下，下面的参数标准启用 NodeRestriction、NamespaceLifecycle 和 LimitRanger 准入控制插件：**

```
- --enable-admission-plugins=NodeRestriction,NamespaceLifecycle,LimitRanger
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEgQKopU57iaMIvHDJle64ReTv3Ptng12icwYTlhhJ7ic9KOaF4YiciciaJz0MQ/640?wx_fmt=png)

    如果想关闭准入控制器的话，可以使用 **disable-admission-plugins** 参数标志，该参数会将传入的（以逗号分隔的） 准入控制插件列表禁用，即使是默认启用的插件也会被禁用。

**如下，下面的参数标准禁用 PodNodeSelector 和 AlwaysDeny 准入控制插件。**

```
--disable-admission-plugins=PodNodeSelector,AlwaysDeny ...
```

除了静态编译的 **Admission** 插件，也可以通过 **Webhook** 方式对接外部的 **AdmissionWebhook** 服务，实现与 **Admission** 插件一样的功能。但 Webhook 方式更加灵活，能够在 **API Server** 运行时修改和配置动态更新控制策略。

    不过，相对于 **Admission Control** 插件来说，使用 **Admission Webhook** 要复杂得多，除了需要开发一个 **Admission Webhook Server** 实现 HTTP 回调的逻辑，还需要创建一个对应的 **ValidatingWebhookConfiguration** 资源对象配置文件，如果 Admission Webhook 需要与 API Server 进行认证，则还需要创建对应的 **AdmissionConfiguration** 配置文件。

**1**

**NodeRestriction 准入控制器**  

    该准入控制器插件限制了 **kubelet** 可以修改的 Node 和 Pod 对象。 为了受到这个准入控制器的限制，kubelet 必须使用在 **system:nodes** 组中的凭证， 并使用 **system:node:** 形式的用户名。 这样，kubelet 只可修改自己的 Node API 对象，只能修改绑定到自身节点的 Pod 对象。

并且该准入控制器插件不允许 kubelet 更新或删除 Node API 对象的污点。

NodeRestriction 准入控制器插件可防止 kubelet 删除其 Node API 对象， 并对前缀为 **kubernetes.io/** 或 **k8s.io/** 的标签的修改对 kubelet 作如下限制：

 **·** 禁止 kubelet 添加、删除或更新前缀为 **node-restriction.kubernetes.io/** 的标签。 这类前缀的标签时保留给管理员的，用以为 Node 对象设置标签以隔离工作负载，而不允许 kubelet 修改带有该前缀的标签。

 **·** 允许 kubelet 添加、删除、更新以下标签：

**kubernetes.io/hostname  
**

**kubernetes.io/arch**

**kubernetes.io/os**

**beta.kubernetes.io/instance-type**

**node.kubernetes.io/instance-type**

**failure-domain.beta.kubernetes.io/region** （已弃用）

**failure-domain.beta.kubernetes.io/zone** （已弃用）

**topology.kubernetes.io/region**

**topology.kubernetes.io/zone**

**kubelet.kubernetes.io/** 为前缀的标签

**node.kubernetes.io/** 为前缀的标签

    以 **kubernetes.io** 或 **k8s.io** 为前缀的所有其他标签都限制 kubelet 使用，并且将来可能会被 **NodeRestriction** 准入插件允许或禁止。将来的版本可能会增加其他限制，以确保 kubelet 具有正常运行所需的最小权限集。

**2**

**Service Account 准入控制器**  

 **Service Account** 准入控制器实现了 ServiceAccount 的自动化，如果你打算使用 **K8s** 的 ServiceAccount 对象，强烈推荐为 **K8s** 项目启用此准入控制器。

    Service Account 准入控制器的工作相对简单，它会监听 Service Account 和 Namespace 这两种资源对象的事件，如果在一个 Namespace 中没有默认的 Service Account，那么它会为该 Namespace 创建一个默认的 ServiceAccount 对象，这就是在每个 Namespace 下都有一个名为 default 的 Service Account 的原因。

 **针对 Pod 新增或修改的请求，Service Account 准入控制器会验证 Pod 里的 Service Account 是否合法，并做出如下控制操作：**

 **·** 如果 Pod 的 **spec.ServiceAccount** 没有被设置，则 **Service Account** 准入控制器将为其添加名称为 default 的 **ServiceAccout**。

 **·** 如果 Pod 的 **spec.ServiceAccount** 指定了不存在的 Service Account，则该 Pod 操作会被拒绝。

**·** 如果服务账号的 **automountServiceAccountToken** 字段或 Pod 的 **automountServiceAccountToken** 字段都未显式设置为 false：

     · 准入控制器变更新来的 Pod，添加一个包含 API 访问令牌的额外卷。  

    · 准入控制器将 **volumeMount** 添加到 Pod 中的每个容器， 忽略已为 /var/run/secrets/kubernetes.io/serviceaccount 路径定义的卷挂载的所有容器。 对于 **Linux** 容器，此卷挂载在 /var/run/secrets/kubernetes.io/serviceaccount； 在 **Windows** 节点上，此卷挂载在等价的路径上。

 **·**  如果新来 Pod 的规约已包含任何 **imagePullSecrets**，则准入控制器添加 **imagePullSecrets**， 并从 **ServiceAccount** 进行复制。

    在 K8s 1.6 版本以后，我们可以禁止自动创建 **ServiceAccount** 对应的 Secret 了，在 ServiceAccount 的 yaml 文件中增加 **automountServiceAccountToken：false** 属性即可，同时可以在某个 Pod 的 yaml 文件中增加此属性，以实现同样的效果。

**3**

**Token 准入控制器**  

    Token 准入控制器作为 kube-controller-manager 的一部分运行，以异步的形式工作。

 **其职责包括：**

 **·** 监测 **ServiceAccount** 的删除并删除所有相应的服务账号令牌 Secret。

 **·** 监测服务账号令牌 Secret 的添加，保证相应的 ServiceAccount 存在。如果发现在新建的 Service Account 里没有对应的 Secret，则会用私钥文件（--service-account-private-key-file 参数标志指定的文件，默认为 /etc/kubernetes/pki/sa.key）签名生成一个 Token，并用该 Token、API Server 的 CA 证书 (/etc/kubernetes/pki/ca.crt) 等信息生成一个 secret 对象，然后放入刚才的 Service Account 中。而 /etc/kubernetes/pki/sa.pub 公钥文件用于 API Server 在身份认证过程中校验 Token。

![图片](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEgpvhEm0miaWlH43VlTib9LvCmTjbKLSEgvD70e8clc1WKOoZHvhxmIiaUA/640?wx_fmt=png)

 **·** 监测服务账号令牌 Secret 的删除，如有需要，从相应的 ServiceAccount 中删除 Secret，确保与对应的 Service Account 的关联关系正确。

    非常感谢您读到现在，由于作者的水平有限，编写时间仓促，文章中难免会出现一些错误或者描述不准确的地方，恳请各位师傅们批评指正。

    如果你想一起学习内网渗透、域渗透、云安全、红队攻防的话，可以加入下面的知识星球一起学习交流。

![](https://mmbiz.qpic.cn/mmbiz_png/rSyd2cclv2d5tYts8CvtzzbSgXUicfWEgSwlNaQZvO2REopERnBxu3AhzbDNBwpWhYdoib6pbZWPGUhjH7ofeLaQ/640?wx_fmt=png)

参考：  

用户认证：

https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authentication/

使用 RBAC 鉴权：

https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/#core-component-roles

使用 Node 鉴权：

https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/node/

kubernetes 集群安全机制：

https://zhuanlan.zhihu.com/p/468010077

Kubernetes 集群权限管理 RBAC：

https://blog.csdn.net/qq_34556414/article/details/112909522

Kubernetes 中的用户与身份认证授权：

https://www.kancloud.cn/chriswenwu/g_k8s/1006520

- END -