> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/z9393SFKBjCJhwyzWRMiYg)

       在我刚刚入行时，看见师傅各种 shellcode 乱飞，看着这些二进制代码，又看看墙上黑客帝国的尼奥海报，内心逐渐向往起来。shellcode 使用比较灵活，在免杀和漏洞利用中经常被大家使用到。那么我们是如何去是实现一个 shellcode 的提取、加载呢，msf 的 shellcode 又是如何实现的呢？  

![图片](https://mmbiz.qpic.cn/mmbiz_png/LibDfs7GHe8v6tFB8M7JJ98XuCZPXnPYhPES8icJIowK3JvgfSnlrVE9Q1sFANbRTMJ0BRTXDwibMHQEG2K2Xn46g/640?wx_fmt=png)

**0x01 shellcode 基础**
---------------------

shellcode 为 16 进制的机器码，下面我们通过一段打开计算器 Calc.exe 的简单的代码来进一步了解一下什么是 shellcode。

```
#include "stdafx.h"          
#include                    
int main(int argc, char* argv[])          
{          
  WinExec("calc",1);          
  return 0;          
}

```

一句特别简单的代码，调用 Windows API WinExec 打开计算器，接着我们在 OD 动态调试看看。

![图片](https://mmbiz.qpic.cn/mmbiz_png/LibDfs7GHe8v6tFB8M7JJ98XuCZPXnPYhETUianicqTPRYCzK5OUqxIdyecGJmqpjnZxJia8ibutWpWHChibS9hQPfbQ/640?wx_fmt=png)

```
push 0x1 ;在x86下，通过压栈来传参，将1压栈，WinExec("calc",1)里的参数1          
push OpenCalc.00406030 ;将存放calc字符串的地址压栈，也是传参          
call dword ptr ds:[<&KERNEL32.WinExec>] ;调用KERNEL32下的WinExec

```

**引出问题**

我们将这三句话下划线标注部分的机器码，用 C 语言的方式表达就是 "\x6A\x01\x68\x30\x60\x40\x00\xFF\x15\x00\x50\x40\x00"，也就是我常见的 shellcode 字符串。如果我们把这串加载在内存，能不能成功运行起来，恐怕是不行的，因为我们不能保证每一个程序的 0x406030 地址上都存放了 calc 字符串，也不能保证导入表中 0x405000 就是 WinExec 地址。

**0x02 编写一个简单的 shellcode** 

那么问题很多的小明就会问，如果我们直接传 calc 字符串，写死的 WinExec 地址，是不是能在当前环境下的主机上运行？那我们就来试试，试试就试试。

**首先构造一个 calc 字符串**

```
xor  ecx, ecx              ; 把ecx置零          
push ecx                   ; 置零后压栈，充当字符串结尾的\x00          
push 0x636c6163            ; clac（calc小端）          
mov  eax, esp              ; 再把指向calc\x00的栈顶指针保存到eax

```

**获取 Kernel32 WinExec 地址** 

有两种方法获取地址，一是通过动态调试，二是通过 GetProcAddress.

方法一：

![图片](https://mmbiz.qpic.cn/mmbiz_png/LibDfs7GHe8v6tFB8M7JJ98XuCZPXnPYhpjcfJWZPJPaUOE33qicAgjnERQNtgYGwSRg2dOWCoDsiafCcdZcznpvw/640?wx_fmt=png)

选中或右键再数据窗口跟随，即可获取 WinExec 地址。

![图片](https://mmbiz.qpic.cn/mmbiz_png/LibDfs7GHe8v6tFB8M7JJ98XuCZPXnPYhhJuOp3MRcdVHxudy4hDkJZAAqERGwwun5Z2cYvLPMzdWb5VtcNoUhg/640?wx_fmt=png)

方法二：

```
#include "stdafx.h"
#include <windows.h>
typedef int (__cdecl *MYPROC)(LPTSTR);
int main() {
  HINSTANCE Kernel32Addr;
  MYPROC WinExecAddr;
  Kernel32Addr = GetModuleHandle("kernel32.dll");
  printf("KERNEL32 address in memory: 0x%08p\n", Kernel32Addr);
  WinExecAddr = (MYPROC)GetProcAddress(Kernel32Addr, "WinExec");
  printf("WinExec address in memory is: 0x%08p\n", WinExecAddr );
  getchar();  
  return 0;
}

```

![图片](https://mmbiz.qpic.cn/mmbiz_png/LibDfs7GHe8v6tFB8M7JJ98XuCZPXnPYhLuvicabplzD8oa4Q6n03zGIw2vocnAvUFzFZjiaSnWzADPcxA4HrTicVg/640?wx_fmt=png)

**构造完整的汇编代码**

```
section .data
section .bss
section .text
  global _start
_start:
  xor  ecx, ecx              ; 把ecx置零
  push ecx                   ; 置零后压栈，充当字符串结尾的\x00
  push 0x636c6163            ; clac（calc小端）
  mov  eax, esp              ; 再把指向calc\x00的栈顶指针保存到eax
  inc  ecx              ; ecx 置1
  push ecx              ; 压栈传第二个参数1
  push eax              ; 压栈，eax指向的是calc\x00
  mov  ebx, 0x7c86250d  ; 把WinExec地址保存到evx
  call ebx              ; 执行WinExec

```

将上面文件保存为 xxx.asm，如果 windows 没有编译环境，可以直接用 kali 进行编译，命令如下

```
nasm -f elf32 -o xxx.o xxx.asm
ld -m elf_i386 -o xxx xxx.o

```

然后通过 objdump -d xxx 读取文件，并将其通过 C 格式打印出来，命令如下 

```
objdump -M intel -d xxx | grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'

```

这样就顺利拿到了我们的 shellcode  

![图片](https://mmbiz.qpic.cn/mmbiz_png/LibDfs7GHe8v6tFB8M7JJ98XuCZPXnPYhosZicIAS6MVwusy1kwgygGutbjw2XFqtMS6HpgUjsWOwATL1YntYtcQ/640?wx_fmt=png)

### **加载 shellcode**  

```
#include "stdafx.h"
#include <windows.h>
unsigned char shellcode[] = 
"\x31\xc9\x51\x68\x63\x61\x6c\x63\x89\xe0\x41\x51\x50\xbb\x0d\x25\x86\x7c\xff\xd3\x59";
int main(int argc, char* argv[])
{
  //将shellcode保存到内存中进行加载
  void* exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
  memcpy(exec, shellcode, sizeof shellcode);
  ((void(*)())exec)();
  return 0;
}

```

编译后运行。  

![图片](https://mmbiz.qpic.cn/mmbiz_png/LibDfs7GHe8v6tFB8M7JJ98XuCZPXnPYhwxxClHibPf3vhX72rjibwDyRPs4z7sMPcja7L1jSsLp8LIWh7ZmhaU3w/640?wx_fmt=png)

成功弹出计算器，证实了小明的猜想是可行的。那么问题很多的小明又问了，这种写死的地址只能自己操自己，那有什么用呢？不妨我们来看下 msf 的 shellcode 是如何实现在不同机器上实现功能的。

**0x03 解析 msf 的 shellcode**  
-----------------------------

我们从逆向的角度去解析 msf 的 shellcode，首先我们先通过一条 msfvenom 命令输出与上文实现相同功能的 shellcode。

```
msfvenom -p windows/exec cmd=calc.exe -f c

```

编译我们的加载器，对其进行逆向分析。

```
#include "stdafx.h"
#include <windows.h>
// msf shellcode 
unsigned char shellcode[] = 
"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
"\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52"
"\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"
"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b"
"\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03"
"\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b"
"\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"
"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb"
"\x8d\x5d\x6a\x01\x8d\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f"
"\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5"
"\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a"
"\x00\x53\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";
int main(int argc, char* argv[])
{
  void* exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
  memcpy(exec, shellcode, sizeof shellcode);
  ((void(*)())exec)();
  return 0;
}

```

作者使用 OD 调试报错，而改用 windbg 进行动态调试。

0x401000 为 main 函数（代码段初始地址），是我们加载代码，通过 virtualAlloc 申请内存空间，并把内存地址放在了 eax 里面，为 0x003A0000，通过 memcpy，将存放在. data 段的 shellcode 变量存放在 0x003A0000 上，然后 call。

![图片](https://mmbiz.qpic.cn/mmbiz_png/LibDfs7GHe8v6tFB8M7JJ98XuCZPXnPYhW9mAicu29JJHrXmQTqKjLsbclbwqFaCAoRbZ2JiaJGSfDb4hFlXAChXw/640?wx_fmt=png)

我们跟进去看下，发现已经 shellcode 已经复制进了内存，我们的 shellcode 就能够正常运行起来了，我把每一步汇编的作用都注释了起来。

![图片](https://mmbiz.qpic.cn/mmbiz_png/LibDfs7GHe8v6tFB8M7JJ98XuCZPXnPYhJE5Dy4SnsAhXEHNOzGwWpdibKsdQicdx2k1VibjKC1RaYd9jtfXTB4UcQ/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/LibDfs7GHe8v6tFB8M7JJ98XuCZPXnPYhbF2hQFKV2wy5Gf36KbCibCaBhRh5EBYvueCPWIodC0PUB0KWJH3KKSw/640?wx_fmt=png)

大致的流程我们可以分解成：

1. 通过硬编码偏移 0x82 获得 shellcode 末尾的字符串 “calc.exe”，然后入栈参数 1 以及 calc.exe，还有 winexec API hash 876F8B31

2. 循环遍历 PEB 表获取模块基址

3. 解析 PE 文件，无导出表则跳过，继续 2

4. 解析导出表，导出表数量为 0 则跳过，继续 2

5. 根据导出名称表遍历导出名称来计算 hash，并找到对应的函数，也就是 WinExec

6. 若找不到该函数，则通过链表找到下一个模块信息，继续 2

7. 找到 winExec，执行该函数

里面比较有意思的是使用了一个 API hash 来查找函数地址，这种技术叫 SFHA(Stephen Fewer’s Hash AI)，相关技术在 17 年的 DEFCON 时有专题讲解。

**0x04 总结**
-----------

书山有路勤为径，学海无涯苦作舟，还得是要多多调试下代码，才能深化理解。