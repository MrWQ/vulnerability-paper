> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/a8A0g7-S0FiMuRa3YOg89Q)

本文主要介绍 Android 内核利用入门，分析经典漏洞 CVE-2015-3636 [0] ，主要介绍 ret2dir 利用思路。

**漏洞分析**  

CVE-2015-3636 是一个 Linux 内核中的 UAF 漏洞，最初由 fuzz 工具 Trinity 发现，可利用此漏洞在安卓设备上提升权限，主要影响 Android 4.4～5.1 的设备，对应 Linux 上游内核版本 3.4～4.1 [1]。

当`socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP)`创建 socket 之后，使用`connect`系统调用将会触发`inet_dgram_connect`函数处理用户请求：

```
int inet_dgram_connect(struct socket *sock, struct sockaddr *uaddr,
               int addr_len, int flags)
{
    struct sock *sk = sock->sk;


    if (addr_len < sizeof(uaddr->sa_family))
        return -EINVAL;
    if (uaddr->sa_family == AF_UNSPEC)
        return sk->sk_prot->disconnect(sk, flags);


    if (!inet_sk(sk)->inet_num && inet_autobind(sk))
        return -EAGAIN;
    return sk->sk_prot->connect(sk, uaddr, addr_len);
}
EXPORT_SYMBOL(inet_dgram_connect);

```

上述代码中，如果`uaddr->sa_family == AF_UNSPEC`，则调用`sk->sk_prot->disconnect`断开连接。对于 ping 的 ICMP 协议，disconnect 函数指针为`udp_disconnect`函数：

```
int udp_disconnect(struct sock *sk, int flags)
{
    struct inet_sock *inet = inet_sk(sk);
    /*
     *  1003.1g - break association.
     */


    sk->sk_state = TCP_CLOSE;
    inet->inet_daddr = 0;
    inet->inet_dport = 0;
    sock_rps_reset_rxhash(sk);
    sk->sk_bound_dev_if = 0;
    if (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))
        inet_reset_saddr(sk);


    if (!(sk->sk_userlocks & SOCK_BINDPORT_LOCK)) {
        sk->sk_prot->unhash(sk);
        inet->inet_sport = 0;
    }
    sk_dst_reset(sk);
    return 0;
}

```

在上述代码中，如果`sk->sk_userlocks & SOCK_BINDPORT_LOCK`为 0，则调用`sk->sk_prot->unhash(sk)`，对于 ping 的 ICMP 协议，unhash 函数指针为`ping_unhash`：

```
void ping_unhash(struct sock *sk)
{
    struct inet_sock *isk = inet_sk(sk);
    pr_debug("ping_unhash(isk=%p,isk->num=%u)\n", isk, isk->inet_num);
    if (sk_hashed(sk)) {
        write_lock_bh(&ping_table.lock);
        hlist_nulls_del(&sk->sk_nulls_node);
        sock_put(sk);
        isk->inet_num = 0;
        isk->inet_sport = 0;
        sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
        write_unlock_bh(&ping_table.lock);
    }
}
EXPORT_SYMBOL_GPL(ping_unhash);

```

如`ping_unhash`代码所示，当参数`sk`，也就是 ICMP 的套接字被哈希时，会进入 if 判断，调用`hlist_nulls_del`。而`hlist_nulls_del`函数会将`n->ppriv`的值变为`LIST_POSION2`：

```
static inline void hlist_nulls_del(struct hlist_nulls_node *n)
{
    __hlist_nulls_del(n);
    n->pprev = LIST_POISON2;
}

```

`LIST_POISON2`为宏定义的常量，在 32 位与 64 位都是 0x200200。所以可以简单的理解为：`hlist_nulls_del`函数将 ppriv 的值写为 0x200200，而且这个地址是我们可以从用户态映射的地址。

在第一次调用 connect 整体逻辑看起来都没问题，但在第二次调用 connect 时就出现了问题。在之前`hlist_nulls_del`函数删除掉套接字对象后，它仍然保持散列的状态，因为它是否处于散列状态取决于`sk->sk`节点，这个节点在第一次连接期间不会改变。所以会再次进入 if 判断调用`hlist_nulls_del`函数。而这一次执行 `*ppriv = next` 时将会导致内核崩溃，因为此时 ppriv 值为 0x200200，如果这个地址没有被映射，那么就会出现严重的页错误导致内核崩溃。

在`ping_unhash`函数中，每次进入 if 分支，`sock_put`都会将对象的引用计数减一。另外，它还会检查引用计数是否为 0，如果为 0，sock 对象将会被释放，而在第二次进入`ping_unhash`的 if 分支时，使用的就是被释放后的 sock 对象，因此是一个典型的 UAF 漏洞。`sock_put`函数逻辑如下：

```
static inline void sock_put(struct sock *sk)
{
    if (atomic_dec_and_test(&sk->sk_refcnt))
        sk_free(sk);
}

```

**利用思路**  

通过漏洞分析，得知可以使用两次`connect`来触发内核崩溃，因此可得如下 PoC：

```
int sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);
struct sockaddr addr = { 
    .sa_family = AF_INET 
};
int ret = connect(sockfd, &addr, sizeof(addr));
struct sockaddr _addr = { 
    .sa_family = AF_UNSPEC 
};
ret = connect(sockfd, &_addr, sizeof(_addr));
ret = connect(sockfd, &_addr, sizeof(_addr));

```

上述代码中，首先使用了`AF_INET`使 sock 对象在内核中进行 hash，否则无法访问对象。在安卓设备上，普通用户可以创建 PING 套接字，而在 PC 则没有权限创建，因此这个 PoC 只适用于安卓设备，并且此 PoC 代码只能达到拒绝服务的攻击效果，我们能做的不止于此。

在关闭一个套接字时，可以使用`close`系统调用。在 ICMP 协议中，最终会调用`inet_release`函数来执行关闭操作：

```
int inet_release(struct socket *sock)
{
    struct sock *sk = sock->sk;


    if (sk) {
        long timeout;


        sock_rps_reset_flow(sk);
        ip_mc_drop_socket(sk);
        timeout = 0;
        if (sock_flag(sk, SOCK_LINGER) &&
            !(current->flags & PF_EXITING))
            timeout = sk->sk_lingertime;
        sock->sk = NULL;
        sk->sk_prot->close(sk, timeout);
    }
    return 0;
}

```

在上述代码中，实际上最后会调用`sk->sk_prot->close`函数来关闭 sock 对象。这个 close 函数指针正好在`sock->sk`中，因此，如果我们在 close 之前，将此 sock 对象覆盖，那么就能够控制`sk->sk_prot->close`，如果内核中没有应用 PAN [2] 保护机制，那么就可以通过此函数指针控制 PC 寄存器。实际上在此漏洞公布时，市面上还没有任何 Android 设备采用这种保护机制。

综合以上结论，需要处理两个关键的问题：

1.  如何在 Android 内核大量的内存申请过程中，准确的申请到之前释放过的对象位置？
    
2.  如何在 close 之前伪造 sock 对象进而控制 PC 指针？
    

针对于第一个问题的描述，PING sock 对象使用的是`kmem_cache_create`[3] 创建的 SLAB 缓存对象，对象大小为 576，这种对象不会在分配常规的内存时进行分配。也就是说，sock 对象与一般大小的 SLAB 是相互隔离的，没办法直接通过堆喷的方式去占用已释放的对象。另外由于内核多线程的影响，内核中的多个任务产生的内存申请，可能会导致没办法及时占用到之前释放过的内存。不同的内核版本 PING sock 大小是不相同的，为了找到一种适用于所有安卓设备的通用解决方案，那么就不应该依赖于这些设备的 PING sock 的大小。因此，这里提出了使用 physmap [4] , ret2dir [5] 的利用方法。

具体原理：physmap 是内核空间中的一大块内存 [6] ，将用户空间的内存直接映射到内核空间，以提升系统性能。用户可以通过在用户态空间大量 mmap，其中大部分数据将会直接出现在内核空间。那么就可以通过 physmap 来覆盖释放的 sock 对象。

在利用过程中存在一个问题，如何得知已经覆盖到了 physmap 的位置？答案是在喷射过程中，除了一些关键的字节用于保证内核不发生崩溃，在其他的位置可以填充一些我们自己的标识内容，然后可以调用 `ioctl(sockfd, SIOCGSTAMPNS, (struct timespec*))` 来读取这些标识内容。这一操作将会调用`sock_get_timestampns`函数：

```
int sock_get_timestampns(struct sock *sk, struct timespec __user *userstamp)
{
    struct timespec ts;
    if (!sock_flag(sk, SOCK_TIMESTAMP))
        sock_enable_timestamp(sk, SOCK_TIMESTAMP);
    ts = ktime_to_timespec(sk->sk_stamp);
    if (ts.tv_sec == -1)
        return -ENOENT;
    if (ts.tv_sec == 0) {
        sk->sk_stamp = ktime_get_real();
        ts = ktime_to_timespec(sk->sk_stamp);
    }
    return copy_to_user(userstamp, &ts, sizeof(ts)) ? -EFAULT : 0;
}
EXPORT_SYMBOL(sock_get_timestampns);

```

如上述代码所示，此函数最终调用`copy_to_user`读取出了`sk`的`sk_stamp`，因此可以通过这种方式泄露出固定偏移位置的内容，然后与之前填写的标识内容相比较，就可以得知覆盖是否完成。当得知覆盖完成时，就可以调用`sk->sk_prot->close`函数指针，以此控制 PC 指针。

控制了 PC 寄存器之后，下一步就是将 thread_info 结构的`addr_limit`成员改写为 0。addr_limit 是用于限制一个线程虚拟地址访问范围的字段，它表示一个线程可以访问的地址空间的上界。改写 addr_limit 的目的是为了能够在内核空间中实现任意读写 [7] 。

对于没有启用 PXN [8] 保护机制的设备，可以直接在 physmap 放置一段 shellcode 来改写 addr_limit 的值。而对于启用了 PXN 保护机制的设备，内核空间不再能直接执行用户空间代码，类似于 x86 架构的 SMEP，则需要进行 ROP 修改 addr_limit 来实现任意地址读写。为了更稳定的利用效果，可以选择 JOP 来替代 ROP，最主要的原因是 ROP 需要从内核 stack pivot 到用户态空间，这时会破坏 SP 指针，由于 SP 指针在整个利用过程中非常重要，因此随意更改 SP 指针不是一个明智的选择。在构造 JOP 时有两个重要的目标：

1.  从内核中泄露 SP 值，通过 SP 来获取当前 task 的结构体。可以通过如下 gadget 完成：
    
    ```
    str x1, [x0, 0x14]
    ldr x1, [x2, 0x10]
    blr x1
    
    ```
    
    在第一段汇编指令中，x0 寄存器为用户空间地址，那么就可以将 x1 寄存器的值写入到用户空间，即泄露了内核空间的地址，可以用于泄露内核 SP 值以及当前 task 地址。
    
    在第二段与第三段汇编指令，如果 x2 寄存器为用户空间地址，则可以通过 x2 寄存器从内核空间返回到用户空间。
    
    对于 64 位 Android 设备，x29 寄存器通常存储 SP 值，因此可以通过如下 gadget 完成泄露：
    
    ```
    mov x0, sp # 32bit
    mov x0, x29 # 64bit
    
    ```
    
2.  重写当前 task 结构体的 addr_limit，从而完成任意地址读写。有两种方式可以完成：
    

*   直接重写：
    
    ```
    mov x1, 0
    str x1, [addr_limit]
    
    ```
    
*   间接重写：
    
    ```
    mov x1, [user_space_address]
    str x1, [addr_limit]
    
    
    或者使用下面的gadget重复两次写入：
    str w1, [addr_limit]
    
    ```
    

**参考**  

[0] https://www.blackhat.com/docs/us-15/materials/us-15-Xu-Ah-Universal-Android-Rooting-Is-Back-wp.pdf

[1] https://en.wikipedia.org/wiki/Android_version_history

[2] https://hack-big.tech/2021/10/07/PXN 与 PAN 机制攻防 /

[3] https://www.unix.com/man-page/linux/9/KMEM_CACHE_CREATE/

[4] https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-kemerlis.pdf

[5] https://www.jianshu.com/p/3c662b6163a7

[6] https://www.kernel.org/doc/html/v5.8/x86/x86_64/mm.html

[7] https://cloudfuzz.github.io/android-kernel-exploitation/chapters/exploitation.html#primitive

[8] https://developer.arm.com/documentation/107565/0101/Memory-protection/Significance-of-XN-and-PXN-bits