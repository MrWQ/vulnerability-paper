> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/fhUAqM1hIC-xm5Pl8-qt6w)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8EYaibg8K5vn9b1ABb77ofz89KswU54BMToIYj2w8cK1W7UocEExG28WOxLWVgZ47tOiaU98jphrM2g/640?wx_fmt=jpeg)  

本文为看雪论坛优秀文章

看雪论坛作者 ID：顾忧

DLL 注入是指向运行中的其它进程强制插入特定的 DLL 文件。从技术细节来说，DLL 注入命令其它进程自行调用 LoadLibrary()API，加载用户指定的 DLL 文件。DLL 注入与一般 DLL 加载的区别在于，加载的目标进程是其自身或其他进程。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8T3wjVdc94x6uvARJHsEP0E9EVgbeZUsiaXrVPtibN8o26PfPI49sibhylw/640?wx_fmt=jpeg)

从上图可以看到，test.dll 已被强制插入进程 (本来 notepad 并不会加载 test.dll)。加载到某一进程中的 test.dll 与已经加载到某一进程中的 dll 一样，拥有访问 notepad.exe 进程内存的权限。

```
DLL被加载到进程后会自动运行DLLMain()函数，用户可以把想执行的代码放到DLLMain()函数，
每当加载DLL时，添加的代码就会得到执行。利用这种特性可以修复程序Bug以及添加新功能
```

```
DllMain 函数是DLL模块的默认 入口点。当Windows加载DLL模块时调用这一函数。
系统首先调用全局对象的 构造函数，然后调用 全局函数DLLMain。
DLLMain 函数不仅在将DLL链接加载到进程时被调用，在DLL模块与进程分离时（以及其它时候）也被调用。
 
BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
　switch (ul_reason_for_call)
　{
　　case DLL_PROCESS_ATTACH:
      //添加想要执行的代码
      //当dll被进程加载时DLLMain被调用
　　　//printf(" process attach of dll");
　　　break;
　　case DLL_THREAD_ATTACH:
      //添加想要执行的代码
      //当有线程被创建时，DLLMain被调用
　　　printf(" thread attach of dll");
　　　break;
　　case DLL_THREAD_DETACH:
      //添加想要执行的代码
      //当有线程结束时，DLLMain被调用
　　　printf(" thread detach of dll");
　　　break;
　　case DLL_PROCESS_DETACH:
      //添加想要执行的代码
      //当dll被进程卸载时，DLLMain被调用
　　　printf(" process detach of dll");
　　　break;
　}
　return TRUE;
}
```

```
1.LoadLibraryA 和 LoadLibraryW 不同字符表示
之前一直没有成功，没有使用L,但是使用了LoadLibraryW，导致加载dll失败，
如果不使用L，请用LoadLibraryA
 
2.注册的时候注意DLL完整路径，除非被注入程序和dll在同一个文件夹
InjectDll.exe 3480 D:\test\myhack.dll
```

使用 LoadLibrary()API 加载某个 DLL 时，该 DLL 中的 DLLMain() 函数会被调用执行。DLL 注入的工作原理就是从外部促使目标进程调用 LoadLibrary()API, 所以会强制调用执行 DLL 的 DLLMain 函数。并且被注入的 DLL 拥有目标进程内存的访问权限，用户可以随意操作。

```
//myhack.cpp
#include "windows.h"
#include "tchar.h"
 
#pragma comment(lib, "urlmon.lib")
 
#define DEF_URL       (L"http://www.naver.com/index.html")
#define DEF_FILE_NAME   (L"index.html")
 
HMODULE g_hMod = NULL;
 
DWORD WINAPI ThreadProc(LPVOID lParam)
{
    TCHAR szPath[_MAX_PATH] = {0,};
 
    if( !GetModuleFileName( g_hMod, szPath, MAX_PATH ) )
        return FALSE;
     
    TCHAR *p = _tcsrchr( szPath, '\\' );
    if( !p )
        return FALSE;
    //下载指定网站的index.html文件
    _tcscpy_s(p+1, _MAX_PATH, DEF_FILE_NAME);
 
    URLDownloadToFile(NULL, DEF_URL, szPath, 0, NULL); 
 
    return 0;
}
 
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    HANDLE hThread = NULL;
 
    g_hMod = (HMODULE)hinstDLL;
 
    switch( fdwReason )
    {
    case DLL_PROCESS_ATTACH :  //加载时
        OutputDebugString(L"<myhack.dll> Injection!!!"); //输出调试字符串
        hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); //创建线程
        CloseHandle(hThread);
        break;
    }
 
    return TRUE;
}
```

#### 1、创建远程线程 (CreatRemoteThread)

#### 2、使用注册表 (AppInit_DLLs 值)

#### 3、消息钩取（SetWindowsHookEx()API）

```
//InjectDLL.cpp
#include "windows.h"
#include "tchar.h"
 
BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) 
{
    TOKEN_PRIVILEGES tp;
    HANDLE hToken;
    LUID luid;
 
    if( !OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
                          &hToken) )
    {
        _tprintf(L"OpenProcessToken error: %u\n", GetLastError());
        return FALSE;
    }
 
    if( !LookupPrivilegeValue(NULL,           // lookup privilege on local system
                              lpszPrivilege,  // privilege to lookup 
                              &luid) )        // receives LUID of privilege
    {
        _tprintf(L"LookupPrivilegeValue error: %u\n", GetLastError() ); 
        return FALSE; 
    }
 
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    if( bEnablePrivilege )
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tp.Privileges[0].Attributes = 0;
 
    // Enable the privilege or disable all privileges.
    if( !AdjustTokenPrivileges(hToken, 
                               FALSE, 
                               &tp, 
                               sizeof(TOKEN_PRIVILEGES), 
                               (PTOKEN_PRIVILEGES) NULL, 
                               (PDWORD) NULL) )
    { 
        _tprintf(L"AdjustTokenPrivileges error: %u\n", GetLastError() ); 
        return FALSE; 
    } 
 
    if( GetLastError() == ERROR_NOT_ALL_ASSIGNED )
    {
        _tprintf(L"The token does not have the specified privilege. \n");
        return FALSE;
    } 
 
    return TRUE;
}
 
BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath)
{
    HANDLE hProcess = NULL, hThread = NULL;
    HMODULE hMod = NULL;
    LPVOID pRemoteBuf = NULL;
    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR);
    LPTHREAD_START_ROUTINE pThreadProc;
 
    // #1. 使用 dwPID 获取目标进程(notepad.exe)句柄（PROCESS_ALL_ACCESS权限），然后就可以用 hProcess 控制进程.
    if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )
    {
        _tprintf(L"OpenProcess(%d) failed!!! [%d]\n", dwPID, GetLastError());
        return FALSE;
    }
 
    // #2. 在目标进程(notepad.exe) 内存中分配 szDllName 大小的内存，返回 pRemoteBuf 作为该缓冲区的地址.
    pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE);
 
    // #3. 将 myhack.dll 路径写入刚刚分配的缓冲区.
    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL);
 
    // #4. 获取 LoadLibraryW() API 地址，kernel32.dll在每个进程中的加载地址相同（这个特性就是我们要利用的）.
    hMod = GetModuleHandle(L"kernel32.dll");
    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, "LoadLibraryW");
     
    // #5. 在 notepad.exe 中运行线程
    hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL); //CreateRemoteThread()驱使进程调用LoadLibrary()，进而加载指定的DLL文件
    WaitForSingleObject(hThread, INFINITE);   
 
    CloseHandle(hThread);
    CloseHandle(hProcess);
 
    return TRUE;
}
 
int _tmain(int argc, TCHAR *argv[])
{
    if( argc != 3)
    {
        _tprintf(L"USAGE : %s <pid> <dll_path>\n", argv[0]);
        return 1;
    }
 
    // change privilege
    if( !SetPrivilege(SE_DEBUG_NAME, TRUE) )
        return 1;
 
    // inject dll
    if( InjectDll((DWORD)_tstol(argv[1]), argv[2]) )
        _tprintf(L"InjectDll(\"%s\") success!!!\n", argv[2]);
    else
        _tprintf(L"InjectDll(\"%s\") failed!!!\n", argv[2]);
 
    return 0;
}
```

#### **3.1、效果示例**

运行 process explorer（或者火绒剑，任务管理器）获取 notepad.exe 进程的 pid。

可以看见 process explorer.exe 的 pid 为 2788。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TuzN3sCDqu0ByfGjXAQ6selK4p4MEeYxdR2mL8h9GMEX1KTALdVJdFw/640?wx_fmt=png)

运行 InjectDll.exe 将 myhack.dll 注入到 notepad.exe 进程当中。可以看到 dll 文件已经被注入到里面。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TVYI4S7KlGe44DqaIGnVh77N9nbH0H3NRhElaOL9L3bx4YgnDia1DXVA/640?wx_fmt=png)

要想在 process explorer 中看见注入的 dll 文件，需要依次选择 view->Lower Pane view->DLLS 选项。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TkAiaFHa55VbXBlckuWsnDX1bT8102xldZSNVFKqwtbvUjhic2fBMhicgw/640?wx_fmt=png)

进行注入时需要注意：

```
//获取目标的进程句柄
hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)
```

同时可以看见文件内已经多了一个 html 文件，此文件是 dll 中所指定的文件。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TIjNuQAWH25DMkb5Yvp9gGLhcLUBRTyTe8A41Sl6eNePqOmAU8rFaag/640?wx_fmt=png)

#### **3.2、分析示例源码**

在 DLLMmain()函数中可以看到，这个 dll 被加载 (DLL_PROCESS_ATTACH) 时, 先输出一个字符串（"<myhack.dll> Injection!!!"），然后再创建线程调用函数（ThreadProc）。在 ThreadProc 函数中通过调用 URLDownloadToFile 来下载指定网站的 index.html 文件。前面提到过，向进程注入 dll 后会调用 dll 的 DLLMain 函数。所以当 dll 文件注入到 exe 进程后，会调用 URLDownloadToFile 下载文件。

```
pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE);
```

main 函数的主要功能时检查输入程序的参数，然后调用 InjectDLL 函数。InjectDLL 函数是用来进行 dll 注入的核心，其作用是使目标进程自行调用 LoadLibrary 这个 api。

```
提示：
VirtualAllocEx()函数的返回值为分配所得缓冲区的地址。
该地址不是程序自身进程(Inject.exe)的内存地址，
而是hProcess句柄所指目标进程（notepad.exe）的内存地址。
```

下面来详细分析一下 injectDll 函数。

调用 OpenProcess 这个 API，借助程序运行时以参数形势传递过来的 dwPID 值，获取 exe 进程的句柄（PROCESS_ALL_ACCESS）。得到 PROCESS_ALL_ACCESS 之后，就可以用获取的句柄控制对应进程。

```
WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL);
  
 //调用API
 //Windows操作系统提供了调试API，借助其可以访问其它进程的内存空间。
 //例如：VirtualAllocEx()、 WriteProcessMemory等
```

需要把即将加载的 dll 文件的路径通知目标进程。因为任何内存空间都无法进行写入操作，所以先使用 VirtualAllocEx() API 在目标进程的内存空间中分配一块缓冲区，且指定的缓冲区大小为 dll 文件路径字符串的长度。

```
//在windows中，kernel32.dll在每个进程中的加载地址是相同的。
hMod = GetModuleHandle(L"kernel32.dll");
pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, "LoadLibraryW");
```

```
hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL);
```

使用 WriteProcessMemory 将 DLL 路径字符串（xxx\xxx\xxx.dll）写入到分配所得缓冲区地址。WriteProcessMemory 所写的内存空间也是 hProcess 句柄所指的目标进程的内存空间。

```
HANDLE CreateRemoteThread(
  // 进程句柄
  hProcess,                          
  //  线程安全描述字，指向SECURITY_ATTRIBUTES结构的指针
  LPSECURITY_ATTRIBUTES lpThreadAttributes, 
  SIZE_T dwStackSize,                       //  线程栈大小，以字节表示
  LPTHREAD_START_ROUTINE lpStartAddress,    // 指向在远程进程中执行的函数地址
  LPVOID lpParameter,                       // 传入参数
  DWORD dwCreationFlags,                    // 创建线程的其它标志
  LPDWORD lpThreadId                        // 线程身份标志，如果为NULL,则不返回
);
 
 
HANDLE CreateThread(
  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
  SIZE_T                  dwStackSize,
  LPTHREAD_START_ROUTINE  lpStartAddress,
  __drv_aliasesMem LPVOID lpParameter,
  DWORD                   dwCreationFlags,
  LPDWORD                 lpThreadId
);
```

调用 LoadLibrary 前需要先获取其地址。LoadLibraryW() 是 LoadLibrary() 的 Unicode 字符串版本。

我们的目标明明是获取加载到 notepad.exe 进程的 kernel32.dll 的 LoadLibraryW 的起始地址，但代码却用来获取加载到 InjectDll.exe 进程的 kernel32.dll 的 LoadLibraryW 的起始地址。如果加载到 notepad.exe 进程中的 kernel32.dl 的地址与加载到 InjectDll.exe 进程中的 kernel32.dll 的地址相同，那么上面的代码就不会有什么问题。但是如果 kernell32.d 在每个进程中加载的地址都不同，那么上面的代码就错了，执行时会发生引用错误。

根据 Os 类型、语言、版本不同，kerne32.dll 加载的地址也不网。并且 Vista /7 中应用了新的 ASLR 功能，每次启动时。系统 DLL 加载的地址都会改 0。但是在系统运行期间它都会被映射（ Mapping ）到号进程的相同地址。

Windows 作系统中， DLL 首次进入内存称为 “加载”( Loading )，以后其他进程需要使用相网 DLL 时不必再次加载，只要将加载过的 DLL 代码与资源映射一下即可，这种映射技术有利于提高肉存的使用效率。

像上面这样， OS 核心 DUL 会被加载到自身固有的地址， DLL 注人利用的就是 Windows Os 这一特性（该特性也可能会被恶意使用，成为 Windows 安全漏洞）。导人 InjectDll.exe 进程中 LoadlibraryW 地址与导人 notepad.exe 进程中的 LoadLibraryWO 地址是相同的。

```
//调用 CreateRemoteThread 创建远程线程所需要的过程函数的标准形式为
DWORD WINAPI ThreadProc(
  _In_ LPVOID lpParameter
);
 
//Win32编程加载DLL的API为：
HMODULE WINAPI LoadLibrary(
  _In_ LPCTSTR lpFileName
);
```

在目标进程中运行远程线程，pThreadProc 是 exe 进程内存中 LoadlibraryW 的地址，pRemoteBuf 是 exe 进程内存中 dll 字符串的地址。

```
提示：
FreeLibrary卸载dll的方法只适用于CreateRemoteThread注入
```

CreateRemoteThread 用来在目标进程中执行其创建的线程，其函数原型如下：

除第一个参数 hProcess 外，其他参数与 CreateThread (）函数完全一样。 hProcess 参数是要执行线程的目标进程（或称 “远程进程”、“宿主进程”）的句柄。 IpStartAddress 与 IpParameter 参数分别给出线程函数地址与线程参数地址。需要注意的是，这 2 个地址都应该在目标进程虚拟内存空间中（这样目标进程才能认识它们）。

```
#include "windows.h"
#include "tlhelp32.h"
#include "tchar.h"
 
#define DEF_PROC_NAME  (L"notepad.exe")
#define DEF_DLL_NAME   (L"myhack.dll")
 
DWORD FindProcessID(LPCTSTR szProcessName)
{
    DWORD dwPID = 0xFFFFFFFF;
    HANDLE hSnapShot = INVALID_HANDLE_VALUE;
    PROCESSENTRY32 pe;
 
    // Get the snapshot of the system
    pe.dwSize = sizeof( PROCESSENTRY32 );
    hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL );
 
    // find process
    Process32First(hSnapShot, &pe);
    do
    {
        if(!_tcsicmp(szProcessName, (LPCTSTR)pe.szExeFile))
        {
            dwPID = pe.th32ProcessID;
            break;
        }
    }
    while(Process32Next(hSnapShot, &pe));
 
    CloseHandle(hSnapShot);
 
    return dwPID;
}
 
BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) 
{
    TOKEN_PRIVILEGES tp;
    HANDLE hToken;
    LUID luid;
 
    if( !OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
                          &hToken) )
    {
        _tprintf(L"OpenProcessToken error: %u\n", GetLastError());
        return FALSE;
    }
 
    if( !LookupPrivilegeValue(NULL,           // lookup privilege on local system
                              lpszPrivilege,  // privilege to lookup 
                              &luid) )        // receives LUID of privilege
    {
        _tprintf(L"LookupPrivilegeValue error: %u\n", GetLastError() ); 
        return FALSE; 
    }
 
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    if( bEnablePrivilege )
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tp.Privileges[0].Attributes = 0;
 
    // Enable the privilege or disable all privileges.
    if( !AdjustTokenPrivileges(hToken, 
                               FALSE, 
                               &tp, 
                               sizeof(TOKEN_PRIVILEGES), 
                               (PTOKEN_PRIVILEGES) NULL, 
                               (PDWORD) NULL) )
    { 
        _tprintf(L"AdjustTokenPrivileges error: %u\n", GetLastError() ); 
        return FALSE; 
    } 
 
    if( GetLastError() == ERROR_NOT_ALL_ASSIGNED )
    {
        _tprintf(L"The token does not have the specified privilege. \n");
        return FALSE;
    } 
 
    return TRUE;
}
 
BOOL EjectDll(DWORD dwPID, LPCTSTR szDllName)
{
    BOOL bMore = FALSE, bFound = FALSE;
    HANDLE hSnapshot, hProcess, hThread;
    HMODULE hModule = NULL;
    MODULEENTRY32 me = { sizeof(me) };
    LPTHREAD_START_ROUTINE pThreadProc;
 
    // dwPID = notepad 进程 ID
    // 使用 TH32CS_SNAPMODULE 参数，获取加载到 notepad 进程的 DLL名称
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);
 
    bMore = Module32First(hSnapshot, &me);
    for( ; bMore ; bMore = Module32Next(hSnapshot, &me) )
    {
        if( !_tcsicmp((LPCTSTR)me.szModule, szDllName) || 
            !_tcsicmp((LPCTSTR)me.szExePath, szDllName) ) 
        {
            bFound = TRUE;
            break;
        }
    }
 
    if( !bFound )
    {
        CloseHandle(hSnapshot);
        return FALSE;
    }
 
    if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) ) //使用进程ID来获取目标进程的进程句柄
    {
        _tprintf(L"OpenProcess(%d) failed!!! [%d]\n", dwPID, GetLastError());
        return FALSE;
    }
    
    //获取加载到EjectDll.exe进程的kernel32.FreeLibrary地址（这个地址在所有进程中是一样的）
    hModule = GetModuleHandle(L"kernel32.dll");
    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, "FreeLibrary");
     
    //在目标进程中运行线程，pThreadProc是FreeLibrary地址，me.modBaseAddr是要卸载的DLL的加载地址
    hThread = CreateRemoteThread(hProcess, NULL, 0, 
                                 pThreadProc, me.modBaseAddr, 
                                 0, NULL);
    WaitForSingleObject(hThread, INFINITE);   
 
    CloseHandle(hThread);
    CloseHandle(hProcess);
    CloseHandle(hSnapshot);
 
    return TRUE;
}
 
int _tmain(int argc, TCHAR* argv[])
{
    DWORD dwPID = 0xFFFFFFFF;
  
    // find process
    dwPID = FindProcessID(DEF_PROC_NAME);
    if( dwPID == 0xFFFFFFFF )
    {
        _tprintf(L"There is no <%s> process!\n", DEF_PROC_NAME);
        return 1;
    }
 
    _tprintf(L"PID of \"%s\" is %d\n", DEF_PROC_NAME, dwPID);
 
    // change privilege
    if( !SetPrivilege(SE_DEBUG_NAME, TRUE) )
        return 1;
 
    // eject dll
    if( EjectDll(dwPID, DEF_DLL_NAME) )
        _tprintf(L"EjectDll(%d, \"%s\") success!!!\n", dwPID, DEF_DLL_NAME);
    else
        _tprintf(L"EjectDll(%d, \"%s\") failed!!!\n", dwPID, DEF_DLL_NAME);
 
    return 0;
}
```

查看 ThreadProc 与 LoadLibrary。两函数都有一个 4 字节的参数，并返回一个 4 字节的值。也就是说，二者形态结构完全一样灵感即源于此。调用 CreateRemoteThread 时，只要将 LoadLibrary 函数的地址传递给第四个参数 IpStartAddress ，把要注人的 DLL 的路径字符串地址传递给第五个参数 IpParameter 即可（必须是目标进程的虚拟内存空间中的地址）。由于前面已经做好了一切准备，现在调用该函数使目标进程加载指定的 DLL 文件就行了。  

CreateRemoteThread （函数最主要的功能就是驱使目标进程调用 LoadLibrary 函数，进而加载指定的 DLL 文件。  

```
hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);
//使用 Create Toolhelp32Snapshot0 API 可以获取加载到进程的模块（ DLL ）信息。
//将获取的 hSnapshot 句柄传递给Module32First(Module32NextO函数后，
//即可设置与MODULEENTRY32结构体相关的模块信息.
```

```
hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)
//使用pid获取目标进程的进程句柄
```

DLL 卸载（DLL Ejection）：将强制插入进程的 DLL 弹出的技术。

原理：驱使目标进程调用 FreeLibrary() API。

```
hModule = GetModuleHandle(L"kernel32.dll");
 pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, "FreeLibrary");
 //若要驱使 notepad 进程自己调用 FreeLibrary API ，需要先得到 FreeLibrary的地址。
 //然而代码获取的不是加载到 notepad.exe 进程中的Kernel32!FreeLibrary 地址，
// 而是加载到 EjectDl . exei 程中的Kernel32! FreeLibrary 地址。
```

先注入 dll 到目标进程

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TvmUxjeJibLleiaORoIaiac6zcCHDXjRibtWx3YULZhZicC5bkCmUs1Pfrew/640?wx_fmt=png)

注入成功后，卸载 dll

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TaVLj81E37EQbEbJyjqJSPXPu4W08W6eLFLfZtCRQooOLAzQujudniaw/640?wx_fmt=png)

分析一下 EjectDll.exe

```
hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, me.modBaseAddr, 0, NULL);
//pThreadProc 参数是 FreeLibrary API 的地址,
//me.modBaseAddr 参数是要卸载的 DLL 的加载地址。
//将线程函数指定为 FreeLibrary 函数，并把 DLL 加载地址传递给线程参数，
//就在目称世中成功调用了 FreeLibraryO ) API 。
```

获取进程中加载的 DLL 信息。

```
// myhack2.cpp
 
#include "windows.h"
#include "tchar.h"
 
#define DEF_CMD  L"c:\\Program Files\\Internet Explorer\\iexplore.exe" 
#define DEF_ADDR L"http://www.naver.com"
#define DEF_DST_PROC L"notepad.exe"
 
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    TCHAR szCmd[MAX_PATH]  = {0,};
    TCHAR szPath[MAX_PATH] = {0,};
    TCHAR *p = NULL;
    STARTUPINFO si = {0,};
    PROCESS_INFORMATION pi = {0,};
 
    si.cb = sizeof(STARTUPINFO);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;
 
    switch( fdwReason )
    {
    case DLL_PROCESS_ATTACH : 
        if( !GetModuleFileName( NULL, szPath, MAX_PATH ) )
            break;
    
        if( !(p = _tcsrchr(szPath, '\\')) )
            break;
 
        if( _tcsicmp(p+1, DEF_DST_PROC) )
            break;
 
        wsprintf(szCmd, L"%s %s", DEF_CMD, DEF_ADDR);
        if( !CreateProcess(NULL, (LPTSTR)(LPCTSTR)szCmd, 
                            NULL, NULL, FALSE, 
                            NORMAL_PRIORITY_CLASS, 
                            NULL, NULL, &si, &pi) )
            break;
 
        if( pi.hProcess != NULL )
            CloseHandle(pi.hProcess);
 
        break;
    }
    
    return TRUE;
}
```

获取目标进程的句柄。

```
HHOOK SetWindowsHookEx(
 
　　int idHook, // 钩子的类型，即它处理的消息类型
 
　　HOOKPROC lpfn, //钩子子程的地址指针。如果dwThreadId参数为0
 
　　// 或是一个由别的进程创建的线程的标识，
 
　　// lpfn必须指向DLL中的钩子子程。
 
　　// 除此以外，lpfn可以指向当前进程的一段钩子子程代码。
 
　　//钩子函数的入口地址，当钩子钩到任何消息后便调用这个函数。
 
　　HINSTANCE hMod, 
    //应用程序实例的句柄。标识包含lpfn所指的子程的DLL。
 
　　// 如果dwThreadId 标识当前进程创建的一个线程，
 
　　// 而且子程代码位于当前进程，hMod必须为NULL。
 
　　// 可以很简单的设定其为本应用程序的实例句柄。
 
　　DWORD dwThreadId //与安装的钩子子程相关联的线程的标识符。
 
　　// 如果为0，钩子子程与所有的线程关联，即为全局钩子。
 
　　);
```

获取 FreeLibrary API 地址

```
//HookMain.exe
 
#include "stdio.h"
#include "conio.h"
#include "windows.h"
 
#define DEF_DLL_NAME        "KeyHook.dll"
#define DEF_HOOKSTART       "HookStart"
#define DEF_HOOKSTOP        "HookStop"
 
typedef void (*PFN_HOOKSTART)();
typedef void (*PFN_HOOKSTOP)();
 
void main()
{
    HMODULE         hDll = NULL;
    PFN_HOOKSTART   HookStart = NULL;
    PFN_HOOKSTOP    HookStop = NULL;
    char            ch = 0;
 
    // 加载KeyHook.dll
    hDll = LoadLibraryA(DEF_DLL_NAME);
    if( hDll == NULL )
    {
        printf("LoadLibrary(%s) failed!!! [%d]", DEF_DLL_NAME, GetLastError());
        return;
    }
 
    // 获取导出函数地址
    HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);
    HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);
 
    // 开始
    HookStart();
 
    // “q”退出
    printf("press 'q' to quit!\n");
    while( _getch() != 'q' )    ;
 
    // 结束
    HookStop();
     
    // 卸载 KeyHook.dll 
    FreeLibrary(hDll);
}
```

在目标进程中运行线程

```
// KeyHook.dll
 
#include "stdio.h"
#include "windows.h"
 
#define DEF_PROCESS_NAME       "notepad.exe"
 
HINSTANCE g_hInstance = NULL;
HHOOK g_hHook = NULL;
HWND g_hWnd = NULL;
 
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)
{
    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:
            g_hInstance = hinstDLL;
            break;
 
        case DLL_PROCESS_DETACH:
            break; 
    }
 
    return TRUE;
}
 
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    char szPath[MAX_PATH] = {0,};
    char *p = NULL;
 
    if( nCode >= 0 )
    {
        // bit 31 : 0 => press, 1 => release
        if( !(lParam & 0x80000000) ) //释放键盘按键时
        {
            GetModuleFileNameA(NULL, szPath, MAX_PATH);
            p = strrchr(szPath, '\\');
 
            // 比较当前进程名称，如果是 notepad.exe 则消息不会传给应用程序
            if( !_stricmp(p + 1, DEF_PROCESS_NAME) )
                return 1;
        }
    }
 
    //反之，调用 CallNextHookEx() 消息传给应用程序
    return CallNextHookEx(g_hHook, nCode, wParam, lParam);
}
 
#ifdef __cplusplus
extern "C" {
#endif
    __declspec(dllexport) void HookStart()
{
        g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);
    }
 
    __declspec(dllexport) void HookStop()
{
        if( g_hHook )
        {
            UnhookWindowsHookEx(g_hHook);
            g_hHook = NULL;
        }
    }
#ifdef __cplusplus
}
#endif
```

```
1、逐行跟踪调试
2、检索相关API
3、搜索相关字符串
```

计算机 \ HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8Tn5gwcLeDX6LHiaoqWOupKWC5JnOhQibV9wYgKaorwEVcRpW8W5pJWnXw/640?wx_fmt=png)

填入 dll 文件路径

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TBibc1AAWHEtGjzd9DZw0DhEjvJpUbof92sbqviaJB63gkCI4AIGia8yCA/640?wx_fmt=png)

修改 LoadAppInit_DLLs

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TyvHD3KiaZShtgYYQ89GZxTPJ02szQ0LARLsUwMGTr7LrLrFGyiazIIoA/640?wx_fmt=png)

重启系统使修改生效，使用火绒剑，process explorer 查看是否注入成功。可以看见已经被注注入成功了。并且是注入了所有加载了 user32.dll 的进程。但是由于此 dll 的目标是 notepad.exe 进程，所以只要当运行这个 exe 之后才会有所动作。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TYLokx78jbxic9BG3AiaJg8KsxxwhjTTmXltmibQlv9LxOO3sf9vdyneXA/640?wx_fmt=jpeg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TiaFkYLNqgVDqIYQW050shsLgEJLf79O4s5XP1a7KmWKpaIibEVmfvZEA/640?wx_fmt=png)

myhack2.dll 的源码比较简单。主要目的为加载进程为 notepad.exe 的程序，然后隐藏并连接指定网站。

```
1、OD运行notepad.exe
2、开启Break on new module(中断于新模块)选项
3、运行HookMain.exe
4、进行键盘输入，触发键盘消息事件
5、dll被注入
6、OD中设置钩子进程（KeyboardProc）断点
```

```
六





SetWindowsHooKEX（）
```

钩子过程（hook procedure）是系统调用的回调函数。

安装钩子时，钩子过程需要在 DLL 内部，该 DLL 的示例句柄（instance handle）即 hMod。

线程 ID 如果为 0，则钩子为 “全局钩子”。

用 SetWindowsHookEx() 设置好钩子后，在某个进程中生成指定消息时，操作系统会将相关 DLL 文件强制注入相应进程。

```
HHOOK SetWindowsHookEx(
　　int idHook, // 钩子的类型，即它处理的消息类型
　　HOOKPROC lpfn, //钩子子程的地址指针。如果dwThreadId参数为0
　　// 或是一个由别的进程创建的线程的标识，
　　// lpfn必须指向DLL中的钩子子程。
　　// 除此以外，lpfn可以指向当前进程的一段钩子子程代码。
　　//钩子函数的入口地址，当钩子钩到任何消息后便调用这个函数。
　　HINSTANCE hMod, 
    //应用程序实例的句柄。标识包含lpfn所指的子程的DLL。
　　// 如果dwThreadId 标识当前进程创建的一个线程，
　　// 而且子程代码位于当前进程，hMod必须为NULL。
　　// 可以很简单的设定其为本应用程序的实例句柄。
　　DWORD dwThreadId //与安装的钩子子程相关联的线程的标识符。
　　// 如果为0，钩子子程与所有的线程关联，即为全局钩子。
　　);
```

#### **6.1、效果示意**

首先运行 HookMain.exe

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TjwxTDb78CGlXsBibEwEbicBexCdbPAkm22icwdrxTcSnRMZFDib2HfKA4Q/640?wx_fmt=png)

再运行 notepad.exe，之后再使用查看，发现 dll 文件已经被注入。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TBEBHZhjGmyrboGXj11kdlatp0hWeum0P9ZUat8RM7P8gkuxU8ia1AqA/640?wx_fmt=png)

输入 q，拆除钩子。拆除后，dll 文件消失，可以正常输入。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TB87ptYlWVnicRBJbia6JZDSrjw8Yz1TnKYDxEtv9tn1GZQVbsvsqb0dQ/640?wx_fmt=png)

#### **6.2、分析源码**

HookMain.exe 主要过程为：首先加载 KeyHook.dll 文件，然后调用 HookStart() 函数开始钩取，用户输入 "q" 时，调用 HookStop() 函数终止钩取。

```
//HookMain.exe
#include "stdio.h"
#include "conio.h"
#include "windows.h"
#define DEF_DLL_NAME        "KeyHook.dll"
#define DEF_HOOKSTART       "HookStart"
#define DEF_HOOKSTOP        "HookStop"
typedef void (*PFN_HOOKSTART)();
typedef void (*PFN_HOOKSTOP)();
void main()
{
    HMODULE         hDll = NULL;
    PFN_HOOKSTART   HookStart = NULL;
    PFN_HOOKSTOP    HookStop = NULL;
    char            ch = 0;
    // 加载KeyHook.dll
    hDll = LoadLibraryA(DEF_DLL_NAME);
    if( hDll == NULL )
    {
        printf("LoadLibrary(%s) failed!!! [%d]", DEF_DLL_NAME, GetLastError());
        return;
    }
    // 获取导出函数地址
    HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);
    HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);
    // 开始
    HookStart();
    // “q”退出
    printf("press 'q' to quit!\n");
    while( _getch() != 'q' )    ;
    // 结束
    HookStop();
    // 卸载 KeyHook.dll 
    FreeLibrary(hDll);
}
```

KeyHook.dll 在调用 HookStart() 时，SetWindowsHookEx() 函数就会将 KeyboardProc() 添加到键盘钩链。

安装好键盘 “钩子” 后，无论哪个进程，只要发生键盘输人事件， OS 就会强制将 KeyHook . dl 人相应进程。加载了 KeyHook.dll 的进程中，发生键盘事件时会首先调用执行 KeyHookKeyboardProc 。  

KeyboardProc 函数中发生键盘输入事件时，就会比较当前进程的名称与 “notepad.exe” 字符串，若相同，则返回 1，终止 KeyboardProc（）函数，这意味着截获且删除消息。这样，键盘消息就不会传递到 notepad.exe 程序的消息队列。 安装好键盘 “钩子” 后，无论哪个进程，只要发生键盘输人事件， OS 就会强制将 KeyHook . dl 人相应进程。加载了 KcyHook . dll 的进程中，发生键盘事件时会首先调用执行 KeyHfookKeyboardProc 。  

KeyboardProd 函数中发生键盘输人事件时，就会比较当前进程的名称与 “notepad . exe” 字符串，若相同，则返网 1，终止 KcyboardProc （函数，这意味着截获且删除消息。这样，键盘消息就环会传透到 notapadexe 程序的消息队列。notepad.exe 未能接收到任何键盘消息，故无法输出。  

除此之外（即当前进程名称非 “notepad . exe” 时），执行 return CallNextHookEx ( g_hHook , nCode , wParam, lParam)，消息会被传递到另一个应用程序或钩链的另一个 “钩子” 函数。  

```
// KeyHook.dll
#include "stdio.h"
#include "windows.h"
#define DEF_PROCESS_NAME       "notepad.exe"
HINSTANCE g_hInstance = NULL;
HHOOK g_hHook = NULL;
HWND g_hWnd = NULL;
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)
{
    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:
            g_hInstance = hinstDLL;
            break;
        case DLL_PROCESS_DETACH:
            break; 
    }
    return TRUE;
}
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    char szPath[MAX_PATH] = {0,};
    char *p = NULL;
    if( nCode >= 0 )
    {
        // bit 31 : 0 => press, 1 => release
        if( !(lParam & 0x80000000) ) //释放键盘按键时
        {
            GetModuleFileNameA(NULL, szPath, MAX_PATH);
            p = strrchr(szPath, '\\');
            // 比较当前进程名称，如果是 notepad.exe 则消息不会传给应用程序
            if( !_stricmp(p + 1, DEF_PROCESS_NAME) )
                return 1;
        }
    }
    //反之，调用 CallNextHookEx() 消息传给应用程序
    return CallNextHookEx(g_hHook, nCode, wParam, lParam);
}
#ifdef __cplusplus
extern "C" {
#endif
    __declspec(dllexport) void HookStart()
{
        g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);
    }
    __declspec(dllexport) void HookStop()
{
        if( g_hHook )
        {
            UnhookWindowsHookEx(g_hHook);
            g_hHook = NULL;
        }
    }
#ifdef __cplusplus
}
#endif
```

#### **6.3、调试方法**

先调试 HookMain().exe，OD 打开该程序。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TSO86icibI3gqmDN3vxiaJxSaHibZofjxjA8bGMVjNcoJaRjFNGvmyHcicFA/640?wx_fmt=png)

查找核心代码

```
1、逐行跟踪调试
2、检索相关API
3、搜索相关字符串
```

由于之前打开过此程序，所以直接搜索 "press'q'to quit!\n"。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TYibQmCvuPyOfMibRhFeyPiaGqgBN4fSybo4qu5eLWoWuL7COnZPaaBR1w/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8T19iaaibicxeia7mIgY9ib3Plnia6JYkhkBibxhsdeBd0XeHMwUhAW9dXAvIDA/640?wx_fmt=png)

点击后跳转到该位置，在 401000 地址处下断点。然后运行到此处。

先在 401006 地址处调用 LoadLibrary, 然后由 40104B 地址处的 CALL 指令调用 KeyHook.HookStart() 函数。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8Te4I7mhxkJVGMHq0mRF1lIcK3Ug4xhduIphtajrJ4K3n5FYufticQDqg/640?wx_fmt=png)

F7 跟踪进入。

图中的代码是被加载到 HookMain.exe 进程中的 KeyHook.dll 的 HookStart() 函数。

在 100010EF 地址处可以看到 CALL SetWindowsHookExW() 指令，其上方 10010E8 与 100010ED 地址处的 2 条 PUSH 指令用于把 SetWindowsHookExW() API 的第 1、2 两个参数压入栈。  

Set WindowsHookExW() API 的第一个参数（ idHook）值为 WH_KEYBOARD(2)，第二个参数 ( Ipfn ）值为 10001020，该值即是钩子过程的地址。后面调试 KeyHook . dlI 时再仔细看该地址。HookMain.exe 的 main() 函数（401000）的其余代码接收到用户输人的 “ q ” 命令后终止钩取。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TwBoYiaz0WNA4XzZu7WG8IxA8h0IlN0fKKicxH6RcVyVkicyjG75EHU7UA/640?wx_fmt=png)

调试 KeyHook.dll

使用 OD 打开 notepad.exe,F9 运行

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TIfEngMM834LZ9ThhH0ibxicmtOJRMZQGbk6M4YKLEVNQAkerUEvX2F3Q/640?wx_fmt=png)

在 OD 中设置如下的选项

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8Tps4vQbDjGvmzZfzoJNYcwQHENH5JxrXFsK5v50UMSd2eeicxKMB0sGQ/640?wx_fmt=png)

运行 HookMain.exe

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TKYVicOibuDzbvib8QWgGrqticTgFjKUyapTo0e53CYzabRWwSAXwabzVgg/640?wx_fmt=png)

随后在 notepad 中随意输入一个字母，此时 dll 被加载到 10000000 处

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TBOOD64uiaSnmIH7pzEygcQCrdBAXOzJI6qEAceKicJeDqYg71LJndNLA/640?wx_fmt=png)

根据系统环境不同，有时不会先显示 KeyHook.dll，而是先加載其他 DLL 库。

此时按（F9）运行键，直到 KeyHook.dll 加载完成。  

有些系统无法正常运行该功能，此时使用 OllyDbg2.0 即可保证运行顺畅。

点击 dll 跳转到 KeyHook.dll 的 EP 地址处。并且由于之前在调试 HookMain.exe 时候已经知道钩子的地址是 10001020，所以直接在此处下断点。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TGVnYVGrbwzPapEWVwmqYEibxmibZibGlt7iclNZ9HlqqEOIkL1Ntf0bTUQ/640?wx_fmt=png)

下好断点好，再重新运行一下程序。然后在记事本当中尝试输入数据，记事本无接收数据的意向，并且 OD 已经跳转到断点处。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8TokWWU0cxgqeiaVS8Pd6tO8iaWiabibTicjhUlKUb1cqdIWBC4OkpTqfHfqA/640?wx_fmt=png)

```
1、OD运行notepad.exe
2、开启Break on new module(中断于新模块)选项
3、运行HookMain.exe
4、进行键盘输入，触发键盘消息事件
5、dll被注入
6、OD中设置钩子进程（KeyboardProc）断点
```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8Fz4lU5jRTibIbrXKXTr0s8T8MSdpztz8sML6ribRI2GKkESMEPBOg9sgvZuJjNwf7LFLz1hFouMjFw/640?wx_fmt=jpeg)

  

**看雪 ID：顾忧**

https://bbs.kanxue.com/user-home-890008.htm

* 本文由看雪论坛 顾忧 原创，转载请注明来自看雪社区

[![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FJVH3PGSiaY563SLhIPrI0tKsReH9ARfAoZb9ibj7MGPKOXiceialNsOGKPTYRKxcFMlibNjcdZml6dmw/640?wx_fmt=jpeg)](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458493150&idx=3&sn=0a4ba5f62fe6fc295c3d4569edb34516&chksm=b18e905486f91942323e5185759dd19a811000d1248844b1bafb0deef364d6b8408a64fa97ec&scene=21#wechat_redirect)

**#** **往期推荐**

1.[CVE-2022-21882 提权漏洞学习笔记](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458471430&idx=1&sn=6a47d0c5c8f3f6204548e80977ecd059&chksm=b18e7c8c86f9f59a88d9b8e83c8297e0ef65034a73436998ab835531baadaa51f3d630793b95&scene=21#wechat_redirect)  

2.[wibu 证书 - 初探](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458471429&idx=1&sn=a85188de9b9697fd1b9e708bb8bb1fdb&chksm=b18e7c8f86f9f59933d6cbf0040ed796f06e37b23f17f1ae842eb22257de02338e1a8d751f6b&scene=21#wechat_redirect)

3.[win10 1909 逆向之 APIC 中断和实验](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458471421&idx=2&sn=e83cf7220dc1c4c06a2efc78593e30cc&chksm=b18e7b7786f9f2614ecce34e23be7f71a3d3516766aabda8f25ae41c81ef359a2c245503cf86&scene=21#wechat_redirect)

4.[EMET 下 EAF 机制分析以及模拟实现](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458468723&idx=2&sn=5a830d04185d80e1b6cfa639dc6c6c15&chksm=b18e71f986f9f8ef5b3c2fec51f69751e63a5d6bdbadf43b49728ba05606fc4ac63fda378c92&scene=21#wechat_redirect)

5.[sql 注入学习分享](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458468108&idx=1&sn=42c8ec155e13e3882cf4aeb60cdbb982&chksm=b18e0f8686f98690c9792298abb04dd243862ff8effd545dc668c7b1c682aaacf9797d899e97&scene=21#wechat_redirect)

6.[V8 Array.prototype.concat 函数出现过的 issues 和他们的 POC 们](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458468074&idx=2&sn=06eb27c1649bd4e3a3e43a46a9500add&chksm=b18e0e6086f9877644ba0de33658232f99213d1b1b074342260031cb529c1b7ad1b89b2e0204&scene=21#wechat_redirect)

  

![](https://mmbiz.qpic.cn/mmbiz_jpg/Uia4617poZXP96fGaMPXib13V1bJ52yHq9ycD9Zv3WhiaRb2rKV6wghrNa4VyFR2wibBVNfZt3M5IuUiauQGHvxhQrA/640?wx_fmt=jpeg)

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8EbEJaHl4j4oA4ejnuzPAicdP7bNEwt8Ew5l2fRJxWETW07MNo7TW5xnw60R9WSwicicxtkCEFicpAlQg/640?wx_fmt=gif)

**球分享**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8EbEJaHl4j4oA4ejnuzPAicdP7bNEwt8Ew5l2fRJxWETW07MNo7TW5xnw60R9WSwicicxtkCEFicpAlQg/640?wx_fmt=gif)

**球点赞**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8EbEJaHl4j4oA4ejnuzPAicdP7bNEwt8Ew5l2fRJxWETW07MNo7TW5xnw60R9WSwicicxtkCEFicpAlQg/640?wx_fmt=gif)

**球在看**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8EbEJaHl4j4oA4ejnuzPAicd7icG69uHMQX9DaOnSPpTgamYf9cLw1XbJLEGr5Eic62BdV6TRKCjWVSQ/640?wx_fmt=gif)

点击 “阅读原文”，了解更多！