> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/s5qn7L5ON5rc7buqTZ9m1w)

扫码领资料

获黑客教程

免费 & 进群

![](https://mmbiz.qpic.cn/mmbiz_png/CBJYPapLzSFJNibV2baHRo8G34MZhFD1sjTz4LHLiaKG9208VTU6pdTIEpC9jlW6UVfhIb9rHorCvvMsdiaya4T6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaaJcib7FH02wTKvoHALAMw4fchVnBLMw4kTQ7B9oUy0RGfiacu34QEZgDpfia0sVmWrHcDZCV1Na5wDQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

这篇文章介绍了作者去年提出的一种新方法，用于阻止 EDR DLLs 加载到新生成的进程中。经过几个月的努力，作者成功地实现了这个想法，并在今年的 x33fcon 和 Troopers 会议上展示了这个主题，并发布了 PoC。本文将介绍该技术的背景和描述。  

Endpoint Detection and Response (EDR) 系统如何检测恶意活动或软件。EDR 系统可以从用户空间（用户进程运行的位置）或内核空间（操作系统层级）进行检测。用户空间的典型分析 / 检测包括静态和动态分析、用户空间钩子和堆栈跟踪分析。静态分析可以用于文件签名（例如任何杀毒软件使用的方式）或检查元数据（如证书及其有效性）。动态分析可以包括对可执行文件的主动调试，或将其放入类似沙箱的环境中以查看其在运行时的行为。堆栈跟踪分析可以显示进程是否从未备份的内存区域执行特定的 Windows API（私有提交内存部分中的动态代码，非常可疑）。来自内核空间的检测通常利用 Kerne Callback 和 ETW Threat Intelligence（ETWti）。

EDR（终端威胁检测和响应）使用签名驱动程序在内核空间中操作，并拦截特定的 Kernel Callback 来拦截进程和线程的执行，以执行自己的代码来检查是否存在恶意代码。使用  
PsSetCreateProcessNotifyRoutine() 来拦截新进程的创建并检查其要执行的内容，同时也  
可以使用 PsSetCreateThreadNotifyRoutine() 来拦截新线程的创建并检查其入口点是否存在  
恶意代码。该技术需要在内核中运行，因此任何错误都可能导致系统崩溃。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEavwUj62Ope0iaher7SmkTOrfRribatdNibHDL2hog1hc9NrHSKSEr6IpTAaaiaiaJEnIGicrJYumMwvKw/640?wx_fmt=png)

ETWti 是由 Microsoft 提供的一个接口，驱动程序可以订阅以接收特殊的 ETW 事件。这些事件专门用于检测恶意活动，包括进程创建、内存分配、线程创建等。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEavwUj62Ope0iaher7SmkTOf7zeDZXjf1hpfzXa1o2uAjZbNwpNUYc8whp2GFPXPmjhjJbRZoFldA/640?wx_fmt=png)

对于这篇博文来说，我们主要讨论用户空间钩子检测技术。至少根据我以前的经验，几乎所有的 EDR 都用到了相关的检测技术。

用户空间 hook 了什么呢？  
在进行用户空间进程的实时分析时，EDR 供应商和大多数 AV 供应商会加载自己的动态链接库（DLL）到操作系统上运行的进程中。加载 DLL 后，它会对选择的 Windows API 的内存区域进行修补，以放置一个钩子，这基本上是一个 JMP 指令，转到它们自己的 DLL 内存区域。这些钩子检测技术是 EDR 中最常用的检测技术之一。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEavwUj62Ope0iaher7SmkTOyWPpIkAicPP4qS1vBbQfRzlyAB8TmbdQ9lYFgIVtCc7UtVtfu7hL88Q/640?wx_fmt=png)

在这种攻击中，恶意软件可以拦截进程的运行时 Windows API 调用，并检查其输入参数以了解它在运行时要做什么。这样，恶意软件可以执行 shellcode 以执行任意代码。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEavwUj62Ope0iaher7SmkTOSgRwnoQ4R4CUxSAagBsiaib8IyK8hjNjG6mPXEonDp8W9wIib5a81ibjTw/640?wx_fmt=png)

下面来讲解一种恶意软件的攻击技术。首先，恶意软件使用 OpenProcess 获取远程进程的句柄，然后使用 VirtualAllocEx 在远程进程中分配内存。接着，使用 WriteProcessMemory 将 Shellcode 写入到新分配的内存区域中。最后，使用 CreateRemoteThread 在远程进程中创建一个新线程来执行 Shellcode。为了避免基于签名的检测，可能会在运行时对 Shellcode 进行加密和解密，然后再使用 WriteProcessMemory 写入到远程进程中。CreateRemoteThread 会调用 ntdll.dll 中的 NtCreateThreadEx 函数，这是从用户空间调用的最后一个函数。由于 ntdll.dll 函数是从用户空间调用的最后一个函数，因此许多供应商倾向于钩住这个特定 DLL 中的函数。

某个 NtCreateThreadEx 的定义看起来如下：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEavwUj62Ope0iaher7SmkTOMvtTPeWaqS2UDNAgjOnleqTVt5Iuic9ia2ibIq0IgSUpxoibZxtm7ZJLXw/640?wx_fmt=png)

当恶意软件想要在新线程中启动 Shellcode 时，EDR 可以检查 NtCreateThreadEx 的输入参数，特别是 startAddress 输入指针。当恶意软件想要在新线程中启动 Shellcode 时，startAddress 通常指向已解密的纯文本 Shellcode，例如 C2 植入程序。现在，EDR 可以在 startAddress 内存区域上应用 Yara 规则（内存扫描）以查找任何已知的恶意 C2 植入程序，如 CobaltStrike、Sliver、Covenant 等。如果规则匹配，则可以确认存在恶意软件并杀死进程。

现有的用户空间钩子逃避技术  
包括 Unhooking、使用直接 Syscalls、使用硬件断点和修补 DLL 入口点。这些技术可以绕过用户空间钩子检测，因此需要使用其他技术来检测和防止恶意软件的运行。

Unhooking  
在这种方法中，从任何位置 (Disk, KnownDlls) 获取 ntdll.dll 的新副本，并用跳转到 EDR DLL 的 EDR 修补的内存区域替换。这将有效地绕过钩子，因为不再发生跳转，也不再进行输入参数分析。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEavwUj62Ope0iaher7SmkTOj2foibnIsQN87UHJuWzAjAGwAStHCDjicZAjvR1ZTe9kROL4MfviaX6sw/640?wx_fmt=png)

直接 syscall（系统调用）  
这种方法可以通过在当前进程内存中检索或重新构建 ntdll.dll 函数并直接执行它们来实现。这种方法可以绕过 ntdll.dll 内存位置中的钩子。文本提到了几个检索技术的 Proof of Concept，包括从内存中重建 ntdll.dll 函数 (HellsGate, RecycledGate,*-Gate)、从磁盘获取新的 ntdll.dll 副本并将函数内容放入内存 (GetSyscallStub, e.G. C DInvoke) 以及在恶意软件可执行文件中嵌入部分或全部 Syscall Stubs(Syswhispers 1,2,3)。

此外，文本还提到了使用硬件断点来规避用户空间钩子的方法，其中 TamperingSyscalls 是第一个使用硬件断点的 PoC。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEavwUj62Ope0iaher7SmkTONdZicMs3Jy1YP4qbw5oUPFUZBfjxOkqFFr426plR91mDKRL3ia9HQoRw/640?wx_fmt=png)

通过在 ntdll.dll 函数中设置硬件断点来拦截执行，隐藏特定函数的输入参数并备份原始值，然后恢复输入参数并继续执行以避免 EDR 检测。

在这第一个原始 poc 执行过程中，利用者通过单步执行程序，找到了 Syscall 指令被调用的位置。在调用 Syscall 之前，利用者需要将原始输入参数恢复到堆栈中，以确保函数能够按预期工作。

通过在 DLL 入口点处进行修补  
2020 年里的博文中提出该技术以及工具 SharpBlock ：  
1. 利用 DEBUG_ONLY_THIS_PROCESS 标志创建一个新进程，并将父进程作为调试器来拦截特定事件的执行，并在恢复执行之前执行代码。  
2. 作为调试器，父进程等待 LOAD_DLL_DEBUG_EVENT 事件，这些事件在 DLL 被加载到进程中但在执行 DLL 中的内容之前出现。  
3. 父进程检查正在加载的 DLL。如果是 EDR DLL，则会使用 0x3c - return 来修补其 Entrypoint，以便该 DLL 在之后不会再放置钩子，而是直接返回并退出。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEavwUj62Ope0iaher7SmkTO0ibfrBa6fUGvzwET1163pibGDo8Jlg6h2obEkRqwHPDDiboTIpicWibAYNQ/640?wx_fmt=png)

有效地实现，不会再有 dll 和钩子放置在新进程中了。  
某种新型实现的想法  
在阅读完如下博文后我有了新型实现的想法：  
https://waawaa.github.io/es/amsi_bypass-hooking-NtCreateSection/  
该技术可以通过在涉及将 DLL 加载到进程并将其映射到内存的过程中自己放置钩子到 API 函数来防止 DLL 被加载到进程中。它可以用于例如在调用 assembly::load() 之前防止 amsi.dll 加载到当前进程，从而导致 AMSIs 绕过。

钩取了函数 NtCreateSection，当目标 DLL 的内存段要创建时，可以拦截这个过程并返回 NTSTATUS 失败。如果 NtCreateSection 失败，内存映射也无法完成，最终导致 DLL 根本无法加载。但是这种方法只能应用于当前进程中尚未加载的 DLL。

EDR DLLs 的问题  
EDRs 可以像国际象棋游戏中的白方一样行动。它们可以在接收到新进程的 Kernel Callback 后，直接将自己的 DLL 加载到进程内存中。在良好的实现中（有些供应商不这样做），DLL 将在 ntdll.dll 之后立即加载。它将被加载到基本上任何用户空间进程中（除非您可能会发现一些例外）。

由于这些 DLL 已经在我们自己的进程中加载了，因此我们不能挂钩 NtCreateSection 来防止它们的加载。

可以解答吗？  
但是如果我们创建一个新的挂起进程，只加载 ntdll.dll：

```
tProcPath = newWideCString(r"C:\windows\system32\windowspowershell\v1.0\powershell.exe")

status = CreateProcess(
    NULL,
    cast[LPWSTR](tProcPath),
    ps,
    ts, 
    FALSE,
    CREATE_SUSPENDED or CREATE_NEW_CONSOLE or EXTENDED_STARTUPINFO_PRESENT,
    NULL,
    r"C:\Windows\system32\",
    addr si.StartupInfo,
    addr pi)

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEavwUj62Ope0iaher7SmkTOZVGxQETeicBpout5IGCTRBrOqvPSfzVgKIrEsLYVRDQXjXNScgibxIXQ/640?wx_fmt=png)

  
我的想法是在已经加载了 ntdll.dll 的进程中，通过将自定义的 Shellcode 写入进程中，来设置一个钩子（hook）以阻止特定 DLL 的加载。步骤如下：

1.  创建一个挂起的进程。
    
2.  为自定义 Shellcode 分配内存并将其写入该区域。
    
3.  远程在 NtCreateSection 上放置一个钩子，跳转到我们的 Shellcode。
    
4.  恢复进程。
    
5.  我们控制 DLL 加载
    

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEavwUj62Ope0iaher7SmkTOfQ24tmlicic4k9ULACPOxANIV8VwSDkyuFXcI6VV5YCGia8zNH6SwrmOQ/640?wx_fmt=png)

听起来简单？当然，至少在实际实施时对我而言并不简单。

**在实现中的挑战**  
**PIC 代码**  
我们不得不编写自定义 Shellcode。在编写 Shellcode 时，需要使用 PIC-Code 以确保代码可以在不同环境中正常工作。  
· 所有东西都应该存在于编译后的可执行文件的 .text 段中。这是一个动态（位置无关）的部分，我们可以提取它来获得 PIC-Code。  
· 我们不能再使用任何全局变量（它们不会被放置在 .text 段中）- 因此，我们必须找到交换不同函数之间信息的替代方法。  
· 所有被调用的 Windows API 都需要动态解析。  
·mainCRTStartup 程序需要被替换为我们的入口点以进行正确的执行。  
· 特定了这个 PoC（Proof of Concept，概念验证）的局限性：只能使用 ntdll.dll 函数，因为当钩子被触发时，进程甚至还没有完全初始化。此时不能加载其他 DLL，否则会导致进程崩溃。我也提到了另一种可能的解决方案是等待进程初始化完成后再应用逻辑，但我自己没有实现。

· 编写 PIC-Code 时可能无法使用的一些常用函数，如 charcmp，StrStrIA，strlen，memcpy 等。作者提到他手动编写了这些函数的逻辑，或者使用了 GitHub Copilot 来自动生成代码。

· 在调试 PIC 代码时遇到的困难，因为只能使用 ntdll.dll 函数。作者最终编写了一个自定义的日志记录函数，以便在需要排除故障时提供一些信息。  
原始的 NtcreateSection 值  
通过 hooking NtCreateSection 函数来创建进程中的 Section。当新进程被恢复时，原始值不再存在于其进程内存中。但是为了能够创建其他 DLL 或对象句柄的 Section，需要在某个时候恢复原始值。最后注意这是一个 Syscall Stub，可以使用现有的直接 Syscall 检索和执行技术，如 TartarusGate 或 GetSyscallStub，但仅使用 ntdll.dll 函数。  
讨论了一个初始的 PoC（Proof of Concept）方案，使用了一个在主机进程中的 egghunter，其中在 Shellcode 中放置了一个 egg。在放置钩子之前，原始的主机进程可以检索原始的 NtCreateSection 值，并将 egg 替换为该原始值，以便 Shellcode 本身可以在运行时恢复原始值。其中使用的技术术语包括：PoC（概念证明）、egghunter（寻找 egg）、Shellcode（外壳代码）、NtCreateSection（创建新进程的函数）。

```
void originalBytes() { // used to store the original bytes of the function we are hooking. This function can be used in PIC to exchange information between functions, as global variables cannot be used. Thanks @Mr-Un1k0d3r for the hint.
    asm(".byte 0xDE, 0xAD, 0xBE, 0xEF, 0x13, 0x37, 0xDE, 0xAD, 0xBE, 0xEF, 0x13, 0x37, 0xDE, 0xAD, 0xBE, 0xEF, 0x13, 0x37, 0xDE, 0xAD, 0xBE, 0xEF, 0x13, 0x37 ");
}

```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEavwUj62Ope0iaher7SmkTOd6fkf5Y2wI4RX2PVV8mSU87cC6N3YdibCaIicf6CcHdhElnTBze02uSw/640?wx_fmt=png)

堆栈对齐？  
在 Github 上已有的 PIC-Code 实现，比如 Handlekatz 和博客文章。这些实现中都包含一个小的嵌入式 ASM-Stub，用于实现特定的功能。

```
extern entryFunction
global alignstack

segment .text

alignstack:
    push rdi                    ; 备份 rdi 因为我们将使用其作为主要的寄存器
    mov rdi, rsp                ; 保存栈指针到rdi
    and rsp, byte -0x10         ; 将栈指针调整到16字节的边界上
    sub rsp, byte +0x20         ; 为我们的c函数分配一些空间
    call entryFunction          ; 调用c函数
    mov rsp, rdi                ; 重置栈指针
    pop rdi                     ; 重置rdi寄存器
    ret                         ; 跳转到我们离开的地方

```

编写 Shellcode 时需要注意将栈指针调整到 16 字节的边界上，然而，在实现中不能使用这种技术，因为它会修改栈，导致 NtCreateSection 函数的输入参数被破坏。因此，在编写 Shellcode 时需要直接跳转到入口点函数，而不是修改栈。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/CBJYPapLzSEavwUj62Ope0iaher7SmkTO3Vo4u0IH3AibhGZG8sqbrYLETkHR1KialaWEsNglKTaiaMGoVBHHArWkA/640?wx_fmt=png)

在调用 NtCreateSection 函数时不需要对栈进行对齐的情况。在这种情况下，NtCreateSection 函数已经自动完成了栈对齐，因此不需要再次进行对齐操作。

**选择正确的 NTSTATUS 返回值**  
不同的进程 / 软件不同地处理对 NtCreateSection 的调用，并且根据返回的 NTSTATUS 调用行为不同。一些进程 / 软件可能会忽略返回值，其他进程 / 软件将尝试无限重复调用等等。我尝试防止 amsi.dll 加载到新生成的 Powershell 进程中，当返回 NTSTATUS 0 时，Powershell 会崩溃，这是因为 Windows OS 和 / 或 Microsoft 认为 Section 已经成功创建，因此继续正常执行而不处理结果崩溃。但是，当传递像 0xC0000054-STATUS_FILE_LOCK_CONFLICT 这样的错误时，此错误将被正确处理，并且 amsi.dll 不会被加载，但是 Powershell 仍将启动。

然而，在使用不同的可执行文件或 EDR DLL 时，可能会出现 GUI 错误消息的情况。只要没有人按下 “确定” 按钮，程序就不会继续执行。作者个人的经验是，对于阻止 EDR DLL，最好仍然返回 NTSTATUS 成功值，但如果遇到问题，可以尝试调整该值。

**概念证明 - Ruy Lopez**  
该恶意软件的技术方法可以欺骗 EDR（终端检测和响应）系统，使其无法检测到恶意软件的存在。EDR 通常被视为在象棋游戏中扮演白方的角色，但是使用这种方法，恶意软件可以像白方一样行动，并在 EDR DLL 加载之前进入远程进程并防止其加载。我将此称为 “Ruy Lopez”，这是一种起始技术，来自于国际象棋中白方的开局策略。

一个已经发布的概念证明（Proof of Concept）执行后将在挂起模式下生成一个新的 PowerShell，将 Shellcode 写入该挂起的进程中，并放置钩子，然后恢复它。但由于它只是一个概念证明，它只会有效地阻止 / 防止 amsi.dll 被加载，从而导致 AMSI 绕过。如果您想阻止 EDR DLL，您必须修改 HookForward 代码来实现，这对于学习目的来说，自己动手做总是很好的。

我在测试中发现，我的技术可以成功地检测和防止大多数 EDR 厂商的恶意软件，但在某些特殊情况下，可能需要根据不同的厂商进行修改或调整。在其中一个测试中，有一个厂商注入 DLL 而不是以常规方式加载它，这种情况下作者的技术无法阻止。在另一个测试中，作者发现其中一个厂商的五个不同的 DLL 中有一个会导致进程崩溃，但幸运的是，这个 DLL 并不是放置钩子的那个。最后，作者提供了一个可以找到这个技术的 PoC 链接：

*   https://github.com/S3cur3Th1sSh1t/Ruy-Lopez
    

**OPSec 安全吗？**  
注入和钩取是一些恶意软件使用的技术，它们允许恶意软件在系统内部运行并执行其操作。然而，这些技术也会留下易于发现的痕迹，称为指标或 IoCs。如果蓝队或猎人 / 分析师审查涉及的进程，就很容易发现这些指标并发现是否发生了恶意活动。作者提到，尽管存在这些指标，但目前还没有自动化的检测机制能够预警或防止这种技术。作者建议 EDR 供应商可以集成检查，如果一个挂起的进程被恢复，并且在那个时候某些 ntdll.dll 函数被钩取，则杀死该进程。

**OPSec 改进**  
这第一个 PoC 使用了 Win32 API 来进行注入和放置 hook（钩子），但在 Troopers 演讲后已经改为直接使用 Syscalls（系统调用）。

在发布版本中需要具有 RWX 权限（可读、可写、可执行），因为 Shellcode 需要进行一些自我修改。但这并非必需，相对容易调整，我在代码中加了一些注释，以便有兴趣的人进行修改。通过修改程序，也可以使用 RX 权限（可读、可执行）。

讨论了两种方法来避免 Shellcode 被检测和拦截。第一种方法是使用哈希算法来代替明文 DLL 名称，以避免基于签名的检测。第二种方法是使用硬件断点来代替钩子，以避免基于 IoC 的检测。

**提到了几个潜在的使用方式：**

1.  绕过 Device Guard / 信任检查：通过阻止 wldp.dll 文件的加载来实现。
    
2.  阻止自定义的 AMSI Provider DLLs 的加载。
    
3.  使用 ThreadlessInject 方式的注入 / 执行 Shellcode，这里的 Shellcode 会在任何 DLL 加载时自动执行，也会在进程初始化时至少执行一次。这种方法不需要执行原语或者像 ThreadlessInject 那样放置钩子，而是可以直接解密嵌入的 Shellcode 并执行它。
    

**链接 & 资源**

*   Hellsgate https://github.com/am0nsec/HellsGate
    
*   RecycledGate https://github.com/thefLink/RecycledGate
    
*   DInvoke https://github.com/TheWover/DInvoke
    
*   Syswhispers https://github.com/jthuraisamy/SysWhispers
    
*   Syswhispers2 https://github.com/jthuraisamy/SysWhispers2
    
*   Syswhispers3 https://github.com/klezVirus/SysWhispers3
    
*   TamperingSyscalls https://github.com/rad9800/TamperingSyscalls
    
*   SharpBlock Blog post https://ethicalchaos.dev/2020/06/14/lets-create-an-edr-and-bypass-it-part-2/
    
*   Chess White player idea https://bruteratel.com/release/2022/08/18/Release-Scandinavian-Defense/
    
*   HandleKatz https://github.com/codewhitesec/HandleKatz  
    From:https://s3cur3th1ssh1t.github.io/Cat_Mouse_or_Chess/
    

```
原文地址：https://xz.aliyun.com/t/12678

```

声明：⽂中所涉及的技术、思路和⼯具仅供以安全为⽬的的学习交流使⽤，任何⼈不得将其⽤于⾮法⽤途以及盈利等⽬的，否则后果⾃⾏承担。**所有渗透都需获取授权**！

@

**学习更多渗透技能！体验靶场实战练习**

```
（hack视频资料及工具）


```

（部分展示）

往期推荐

[

给第一次做渗透项目的新手总结的一些感悟



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247567614&idx=1&sn=d2574a0e08aa40af7905e29d2dc87e84&chksm=ebeb81d3dc9c08c5cf67ba30beca4fb3c4eb43fe70fd3731edeb670c0c1423af3a8984c9de53&scene=21#wechat_redirect)

[

「登陆页面」常见的几种渗透思路与总结！



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247552705&idx=1&sn=5921efbffcfd42b3e8d578d8f9295c60&chksm=ebea47ecdc9dcefa2c202ac765a199999ef595bc0ea9dd27fc2d5da1b92f21452a17c5c16188&scene=21#wechat_redirect)

[

突破口！入职安服后的经验之谈



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247495613&idx=1&sn=2fcfb9e0f1d47e24b634f1586ffebe8c&chksm=ebeaa690dc9d2f8638afc42a0f02a0e752a9f6d2a7bb6a3334fdb2c04dfad39914e1e913328d&scene=21#wechat_redirect)

[

红队渗透下的入口权限快速获取



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247550034&idx=1&sn=654ea58293a45c3ed5db6d4d32c9a57a&chksm=ebea4d7fdc9dc4690c21119fe028c655f6cd5f976c54c79af736064c19a47fcd99f6ff846a72&scene=21#wechat_redirect)

[

攻防演练｜红队手段之将蓝队逼到关站！



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247541662&idx=1&sn=343a8d7764dde2121f6b0373aa4dbd28&chksm=ebea6ab3dc9de3a5ad1f7eadd96bd2d42375d7f4c40bd8c4ea4b4dc000415097a0e3fe0fbd38&scene=21#wechat_redirect)

[

CNVD 之 5000w 通用产品的收集 (fofa)



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247543436&idx=1&sn=c0a7481697648512e9f314594b10f304&chksm=ebea63a1dc9deab7b3b07e7f692f2d83cff78a3fcc64dbfa91ec03b88eb1a4940589298ed5fd&scene=21#wechat_redirect)

[

自动化挖掘 cnvd 证书脚本



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247558287&idx=1&sn=5ed10ac4f4d34db64b722f228e3da1f5&chksm=ebebada2dc9c24b4ea13c98034bb5981ea991691c5b730ff4f83f11dadc487b941cb7a1ce7ac&scene=21#wechat_redirect)

[

Xray 捡洞中的高频漏洞



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247543338&idx=1&sn=5e9785e8832acd77232cfe45944285f6&chksm=ebea6307dc9dea11f1862284f24607ce970c4e24bbafc16d6d249bedd283a4c3cf68fc41d8e2&scene=21#wechat_redirect)

[

实战｜通过供应链一举拿下目标后台权限



](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247543100&idx=1&sn=2d4abc345b450d41b802b419c9b2a797&chksm=ebea6011dc9de907ebc4eca7b6541df614c03a810a4263278a885700d3b06525019a4bf69577&scene=21#wechat_redirect)

[实战｜一次真实的域渗透拿下域控（内网渗透）](https://mp.weixin.qq.com/s?__biz=MzI4NTcxMjQ1MA==&mid=2247542735&idx=1&sn=1d47080088a36f8a5cafdc50ae718b0b&chksm=ebea6ee2dc9de7f461437399cec4079875f7c988eeb63eef0dc8dd77c9ed20ab33396b44218f&scene=21#wechat_redirect)

看到这里了，点个 “赞”、“再看” 吧