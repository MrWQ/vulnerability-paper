> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/CD2dhot98NaL-m8kia_q0Q)

前言
==

逛 github 的时候看到了一个项目`ShellGhost`，介绍了一种内存规避技术，可以让 shellcode 在进程从开始到结束都始终是不可见的。讲的还是挺邪乎的，不过我盲猜是利用异常获取 CPU 控制权去动态修改 shellcode 的内容，这就下载学习一下是怎么实现的。

shellcode 的预处理
==============

项目提供了一个 python 脚本 `ShellGhost_mapping.py` 来对 shellcode 进行处理，主要是使用`ndisasm`对 shellcode 进行反汇编，然后分别获取到每一条指令的相对偏移以及长度，保存在一个数组中。

代码如下：

![](https://mmbiz.qpic.cn/mmbiz_png/ibpscEmmu0YTPv1IWVibj0FxhjbrUmllJHXJibuhiaKKSmcH7njdAR3FxyauicnyrpJC7k0zwPgEZZUzrWLvFWtPk3g/640?wx_fmt=png)

处理之后的结果示例如下：

![](https://mmbiz.qpic.cn/mmbiz_png/ibpscEmmu0YTPv1IWVibj0FxhjbrUmllJHRmfMbr52xzLfK2E26BmjtZWcb8icrqkWmtWLzDscDWyrCg48zNAvLWw/640?wx_fmt=png)

RVA 保存的就是指令的相对偏移，quota 保存的就是当前的指令长度。记住这个表的结构，它会贯穿后续 shellcode 执行全过程。

最后是输出每条指令被 RC4 加密之后的结果，注意是每条指令单独加密，而不是所有指令一起加密。将加密后的 shellcode，密钥，指令长度，以及上述的表写入到 c 文件中。

![](https://mmbiz.qpic.cn/mmbiz_png/ibpscEmmu0YTPv1IWVibj0FxhjbrUmllJHElW9avEJSia7FYHTn0icDjE4Yd4xrhsUBSwNXCzB78cVnp2nuNuXo99g/640?wx_fmt=png)好了，数据准备工作到此为止，接下来开始分析执行过程。

初始化过程
=====

首先看一下 main 函数：

![](https://mmbiz.qpic.cn/mmbiz_png/ibpscEmmu0YTPv1IWVibj0FxhjbrUmllJHC8cicBhGyq9OzPoeanuCmhVllp8UGxFxL0WcIMbXIl1C5vV4qVDPQQA/640?wx_fmt=png)

首先，申请的内存并不是可执行的，然后将这块内存都修改为 0xcc 软中断；

另外比较怪异的一点是启动的新线程的的起始地址是. text 节的末尾全是 \x00 的地方。

`ResolveEndofTextSegment`会返回`.text`末尾全是`\x00`的起始地址，详细代码如下：

![](https://mmbiz.qpic.cn/mmbiz_png/ibpscEmmu0YTPv1IWVibj0FxhjbrUmllJHrdMdySfKJ6ARW0EsDtFdianA6EyRSItC1OUlYDmfVjVviaql8N6JDhiag/640?wx_fmt=png)

为什么要这么做呢？作者在注释里也解释了，靠近`entry_point`位置的代码或者地址其实是被杀毒软件重点关注的，其实在引擎中很多特征码的定位都是以`entry_point` 作为起始地址的。

最后注册了一个向量化异常处理函数`InterceptShellcodeException` ，这个处理函数是 shellcode 可以执行的关键。

shellcode 的执行
=============

`InterceptShellcodeException` 异常处理函数是 shellcode 可以正常执行的关键，可以看到在上面创建的线程的起始地址也不是 shellcode，接下来怎么控制 EIP 指向 shellcode 呢？其实精髓就是在这个异常处理函数。

首先要知道的是`.text`节末尾全是`\x00`, 反汇编结果如下图所示，在这里创建线程一定会触发异常,`rax`一定不会是一个可写的地址，想一想是为什么？

![](https://mmbiz.qpic.cn/mmbiz_png/ibpscEmmu0YTPv1IWVibj0FxhjbrUmllJHMtss9wP68PdwJhAWw5UCibmxnEPiapdw98XzlibRRWSXhoJSwnliaVhkow/640?wx_fmt=png)

因为看代码：

```
hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)ResolveEndofTextSegment(), 0, 0, 0);

```

RAX 此时应该保存的刚好是 `ResolveEndofTextSegment()`的返回值，text 节显然是不可写的。这里处理的还是比较精妙的，需要仔细的琢磨一下。接下来执行流程就进入了异常处理函数：

![](https://mmbiz.qpic.cn/mmbiz_png/ibpscEmmu0YTPv1IWVibj0FxhjbrUmllJHm56weFLvW2NAYmtNa79d5oLNeZxclmgibdSueRDM13yiaRDmqF5WjWZw/640?wx_fmt=png)

首先判断异常是不是在自己需要处理的地址范围内，然后判断如果异常发生的地方在. text 的默认，就将执行流 (eip) 修改到堆上，但是当前的堆上有两个问题：

1.  1. 是只可读写，不可执行的
    
2.  2. 全是 0xcc
    

继续阅读代码，看是怎么处理的：

![](https://mmbiz.qpic.cn/mmbiz_png/ibpscEmmu0YTPv1IWVibj0FxhjbrUmllJH3qOyLOmFwLUZ66KaAavm93e61qmiaGJ1VXhP5GgteVuCSiaCicv8Zka1w/640?wx_fmt=png)

首先是调用 `ResolveInstructionByRva` 修改当前的指令为解密后的指令，此函数如下：

```
// Edits current breakpoint to be the next instruction to decrypt
NTSTATUS ResolveInstructionByRva(PVOID pointer) //修改当前指令
{
    DWORD64 rva = ResolveBufferFeature(pointer, INSTRUCTION_OPCODES_RVA); // 获取当前地址的rva
    for (DWORD i = 0; i < instruction[ResolveBufferFeature(pointer, INSTRUCTION_OPCODES_NUMBER)].quota; i++)
    {
        *(BYTE*)((BYTE*)pointer + i) = *(BYTE*)((BYTE*)sh + rva + i);
    }

    return STATUS_SUCCESS;

}

```

其中`ResolveBufferFeature`就会利用之前存储的`instruction`找到当前指令的 RVA 和 quota，然后进行修改。

然后对内存的这一条指令进行解密，解密结束之后修改内存的权限为可执行，然后继续执行这一条指令。

当执行下一条指令时，由于内容是`0xCC`, 所以会再次触发异常，继续走上面的异常函数处理逻辑，达到了单条指令依次执行的目的。

当在执行下一条指令的时候会顺便把上一条指令给抹掉，防止在内存中保留有可见的 shellcode。

![](https://mmbiz.qpic.cn/mmbiz_png/ibpscEmmu0YTPv1IWVibj0FxhjbrUmllJHwFnxufBIG9hpYhZVt8yPtgO0x3DRWOQBqXGUib6GcL7q4JOm35b30BQ/640?wx_fmt=png)

相信已经讲解的够清楚，为了保险起见，还是来画个图更形象的说明一下。

![](https://mmbiz.qpic.cn/mmbiz_png/ibpscEmmu0YTPv1IWVibj0FxhjbrUmllJHBgaKGSh2rKH4WV8jbrLWj8rB8l72mqC3BbCibDQwibhaOXdwfdP9jTCA/640?wx_fmt=png)

总结
==

如此执行 shellcode 具备隐藏内存，反调试等优点，但是唯一的问题就是执行效率太低了。我虽然没有想到有什么实际的用途，但是作者的代码写的非常的工整，也可以给我们写其他的内存规避提供一些实现思路。

**最后欢迎加入知识星球进行深度交流~**

![](https://mmbiz.qpic.cn/mmbiz_png/ibpscEmmu0YTPv1IWVibj0FxhjbrUmllJHUfvJc5L9XQPsQ394d3xIEfUVNkmP955gWH1at319D2g4RhnfP18l6g/640?wx_fmt=png)

**咨询微信**  

![](https://mmbiz.qpic.cn/mmbiz_jpg/ibpscEmmu0YTZKfBmdLCPUQ6KFM8iahGJHXUnfQicSmBGib1XIsurj6dWaytDDzPKNutyPrKibHTfP2yS88N2mOEywQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)