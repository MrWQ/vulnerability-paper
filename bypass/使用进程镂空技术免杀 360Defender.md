> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/pyALO84x82aPb10AqV1eKA)

点击上方 [蓝字]，关注我们

**建议大家把公众号 “Z2O 安全攻防” 设为星标，否则可能就看不到啦！**因为公众号现在只对常读和星标的公众号才能展示大图推送。操作方法：点击右上角的【...】，然后点击【设为星标】即可。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuao3T9EnGbUIqxgDhEVicCV8NbH4FiaZ3YIbpXNEr6qFicGkAelnQHKGHsVlfapMGgO3DHA68iaiac0n4Q/640?wx_fmt=png)

免责声明
====

本文仅用于技术讨论与学习，利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，文章作者及本公众号不为此承担任何责任。

文章正文
====

使用进程镂空技术免杀 360Defender
======================

进程镂空
----

> 进程镂空（Process Hollowing）又称傀儡进程，其原理是利用 windows 提供的 API 运行指定程序，然后修改其内存数据，将目标进程 “掏空” 替换成恶意的木马程序以达到隐蔽和免杀的目的，我使用 python3 实现了这项技术并写了一个免杀工具：风暴免杀（ _https://github.com/StormEyePro/StormBypassAV  ）_。
> 
> 这项技术已经不算新鲜，当我们将目标进程替换为恶意进程后，windows defender 通过行为检测依然可以发现这是木马进程进行查杀，但当我们将目标进程设定为 winlogon.exe 这个特殊进程，Defender 并不会直接进行查杀拦截，仅仅只是提示管理员有恶意病毒木马需要重启。

测试效果
----

### VT

非常不错的免杀率

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuYY8F0bYCia8LdDyZyvtI4RfEc9xQstBInlDLdS7eLHkNMsYH2icic8pZwHMzdQia4bfMiaZ0rAEBSadUg/640?wx_fmt=png)image-20230501143816011

### defender

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuYY8F0bYCia8LdDyZyvtI4RfMO9DuRCbq5cDGZxD2JCZUDzGBv2Iwgnh7GnTOrstTibOT2jZygjXfjw/640?wx_fmt=png)image-20230501114236799

### 360

很容易绕过，不截图了

杀毒原理
----

常见杀软的查杀原理可以概况如下：

### 扫描技术

通过对文件特征、内存进行扫描，可以检测恶意软件的静态特征，于是出现了**文件静态特征**、**内存静态特征**的查杀技术。

### 监控技术

通过 hook 技术可以实现对任意程序的监控，可以监视木马程序的行为，监控关键 API 调用等，于是出现了主动防御、沙箱等查杀技术。

免杀原理
----

### 一、加密 shellcode 和 shellcode 加载器

针对杀软的查杀原理可以很容易理解免杀的原理，首先是针对静态特征的查杀，如果一个木马程序一生成就被杀软查杀，那么肯定是静态特征查杀，绕过静态特征的方式有很多，使用 Python 开发的好处就是可以利用 eval 函数来加密所有的 python 代码。

1. 一个木马程序通常可以看出 shellcode 和 shellcode 加载器 2 部分，shellcode 的编写非常困难，我们一般通过 cs/msf 生成，shellcode 加载器可以使用很多种编程语言来实现。

> shellcode 和 shellcode 加载器：通常木马文件可以看成 shellcode 和 shellcode 加载器这 2 部分，shellcode 是执行命令的核心，它是一段机器指令（汇编指令），机器指令是计算机 CPU 可以直接识别和执行的指令，因此使用 shellcode 可以让恶意代码拥有很好的通用性。shellcode 加载器的作用是将 shellcode 写入内存然后运行，实现这个目的的方式也有很多，风暴免杀 ( _https://github.com/StormEyePro/StormBypassAV_) 实现了动态申请内存、UUID、IPV4、进程注入、进程镂空等加载器。

2. 传统的免杀工具只是将 shellcode 进行各种加密，规避 shellcode 的静态特征，但现在杀软将 shellcode 加载器的这些代码也做了静态特征，所以会被查杀。风暴免杀工具使用 python3 开发，核心免杀思路是利用 python 的 eval 函数将字符串当做代码执行，所以可以将 shellcode 和 shellcode 加载器都进行加密，结合 base64 和随机位移这样简单的加密手段，就可以做到隐藏静态特征的作用，eval 也是 python 中常用的内置函数，想要将它和正常业务区分开也不是一件容易的事情。

风暴免杀 最终生成的木马脚本是这样的：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuYY8F0bYCia8LdDyZyvtI4RfEEnXx0MvDFfoPgN1yPJ47IHe7vbRILb8ju2txAuQ8z6W5uE4FHyovg/640?wx_fmt=png)image-20230504174832022

3. 除了对 shellcode 和 shellcode 加载器进行加密，风暴免杀还实现了 shellcode 分离免杀，将 shellcode 和加载器分离以达到免杀的目的，这种做法也是非常简单而高效。

### 二、隐匿

风暴免杀实现了进程注入和进程镂空技术以达到隐匿和免杀的效果，进程注入是利用 windows API 在目标进程中申请一块内存，然后将 shellcode 直接注入其中并创建线程运行，恶意的 shellcode 直接运行在目标程序内，结合运行后删除自身 / 从网络加载 shellcode 等方式，具备非常好的隐匿效果，目前测试只能稳定注入到 explorer.exe 进程中。而进程镂空技术结合镂空 winlogon.exe，达到了意想不到的效果，可以稳定上线 windows defender。

#### 1、进程注入

进程注入技术主要通过下面几个 Windows 提供的 API 来实现：

```
OpenProcess
VirtualAllocEx
WriteProcessMemory
CreateRemoteThread


```

#### OpenProcess

打开一个现有的本地进程对象，获得该对象的句柄：通过 OpenProcess 我们可以获得目标进程的句柄。

```
HANDLE OpenProcess(
    [in] DWORD dwDesiredAccess,        #要获取的访问权限
    [in] BOOL  bInheritHandle,        
    [in] DWORD dwProcessId         #目标进程的ID
); 


```

#### VirtualAllocEx

在指定进程的虚拟地址空间中保留、提交或更改内存区域的状态：通过 VirtualAllocEx 我们可以在目标进程中申请一块内存空间。

```
LPVOID VirtualAllocEx(
  [in]           HANDLE hProcess,      #OpenProcess获得的句柄
  [in, optional] LPVOID lpAddress,      
  [in]           SIZE_T dwSize,       #要分配的内存大小，需要设置为shellcode的大小
  [in]           DWORD  flAllocationType,
  [in]           DWORD  flProtect      #要分配的内存权限：0x40代表读/写/执行
);


```

#### WriteProcessMemory

将数据写入指定进程中的内存区域：通过 WriteProcessMemory 我们可以在申请的内存空间中写入指定的数据（shellcode）

```
BOOL WriteProcessMemory(
  [in]  HANDLE  hProcess,          #OpenProcess获得的句柄
  [in]  LPVOID  lpBaseAddress,         #VirtualAllocEx申请的地址指针
  [in]  LPCVOID lpBuffer,          #要写入的内容，可以传入shellcode
  [in]  SIZE_T  nSize,           #目标大小，shellcode的大小
  [out] SIZE_T  *lpNumberOfBytesWritten
);


```

#### CreateRemoteThread

创建在另一个进程的虚拟地址空间中运行的线程：通过 CreateRemoteThread 我们可以在目标进中创建一个线程来运行 shellcode

```
HANDLE CreateRemoteThread(
  [in]  HANDLE                 hProcess,       #OpenProcess获得的句柄
  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,     
  [in]  SIZE_T                 dwStackSize,
  [in]  LPTHREAD_START_ROUTINE lpStartAddress,      #VirtualAllocEx申请的地址指针
  [in]  LPVOID                 lpParameter,
  [in]  DWORD                  dwCreationFlags,
  [out] LPDWORD                lpThreadId       
);


```

#### 2. 进程镂空

进程镂空的运行流程如下：

以挂起状态运行指定程序 -> 获取目标程序的上下文 -> 获取目标基地址 -> 如果目标基址和 shellcode.exe 的基址一样通过 NtUnmapViewOfSection 卸载 -> 在目标进程的 “shellcode 基址” 处申请一块内存 -> 向申请的内存写入 shellcode.exe 的头 -> 修改目标进程的 sections 地址 -> 修改目标进程的 EntryPoint 入口 -> 修改目标上下文 -> 恢复运行状态

它使用了一下 windows API 来实现这些功能：

```
CreateProcessA
GetThreadContext
ReadProcessMemory
NtUnmapViewOfSection
VirtualAllocEx
WriteProcessMemory
SetThreadContext
ResumeThread


```

#### CreateProcessA

创建新进程及其主线程。新进程在调用进程的安全上下文中运行：使用 CreateProcessA 我们可以运行指定的程序

```
BOOL CreateProcessA(
  [in, optional]      LPCSTR                lpApplicationName,  
  [in, out, optional] LPSTR                 lpCommandLine,       #要执行的命令行，此处设置为我们的目标程序
  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,     
  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,
  [in]                BOOL                  bInheritHandles,
  [in]                DWORD                 dwCreationFlags,      #控制优先级类和进程的创建的标志，设置为0x00000004可以让目标处于挂起状态创建
  [in, optional]      LPVOID                lpEnvironment,
  [in, optional]      LPCSTR                lpCurrentDirectory,
  [in]                LPSTARTUPINFOA        lpStartupInfo,          #指向 STARTUPINFO 或 STARTUPINFOEX 结构的指针。
  [out]               LPPROCESS_INFORMATION lpProcessInformation     #指向 PROCESS_INFORMATION 结构的指针，该结构接收有关新进程的标识信息process_info
);


```

#### GetThreadContext

检索指定线程的上下文：使用 GetThreadContext 可以获得目标基址等信息

```
BOOL GetThreadContext(
  [in]      HANDLE    hThread,                #通过CreateProcessA获取的进程句柄
  [in, out] LPCONTEXT lpContext                   #指向 CONTEXT 结构的指针， 此结构的 ContextFlags 成员的值指定检索线程上下文的哪些部分
);


```

#### ReadProcessMemory

读取进程数据：使用 ReadProcessMemory 可以获取目标的基址

```
BOOL ReadProcessMemory(
  [in]  HANDLE  hProcess,                #通过CreateProcessA获取的进程句柄
  [in]  LPCVOID lpBaseAddress,               #指向要从中读取的指定进程中基址的指针，通过GetThreadContext获得
  [out] LPVOID  lpBuffer,                #用来接收内容的指针，
  [in]  SIZE_T  nSize,                 #要读取的大小
  [out] SIZE_T  *lpNumberOfBytesRead           
);


```

NtUnmapViewOfSection

从指定进程的虚拟地址空间中取消映射包含 BaseAddress 的节的整个视图：使用 NtUnmapViewOfSection 可以清空目标进程原来的 section 等，我们的程序主要使用 WriteProcessMemory 来修改这些信息。

```
NTSYSAPI NTSTATUS ZwUnmapViewOfSection(
  [in]           HANDLE ProcessHandle,
  [in, optional] PVOID  BaseAddress
);


```

#### VirtualAllocEx

在指定进程的虚拟地址空间中保留、提交或更改内存区域的状态：通过 VirtualAllocEx 我们可以在目标进程中申请一块内存空间。

```
LPVOID VirtualAllocEx(
  [in]           HANDLE hProcess,      #通过CreateProcessA获取的进程句柄
  [in, optional] LPVOID lpAddress,      #指定要分配的页面区域的所需起始地址的指针，设置为shellcode.exe的基址
  [in]           SIZE_T dwSize,       #要分配的内存大小
  [in]           DWORD  flAllocationType,     #内存分配类型，MEM_COMMIT | MEM_RESERVE代表保留和提交页面
  [in]           DWORD  flProtect      #要分配的内存权限：0x40代表读/写/执行
);


```

#### WriteProcessMemory

将数据写入指定进程中的内存区域：通过 WriteProcessMemory 我们可以在申请的内存空间中写入指定的数据

```
BOOL WriteProcessMemory(
  [in]  HANDLE  hProcess,          #通过CreateProcessA获取的进程句柄
  [in]  LPVOID  lpBaseAddress,          #要写入数据的地址，调用了3次WriteProcessMemory：1.向VirtualAllocEx写入shellcode.exe的头。2.修改目标的section（已经初始化的数据，资源和重定位信息等数据被按照属性分类放在不同的section）和EntryPoint（代码开始执行的地方）
  [in]  LPCVOID lpBuffer,          #要写入的内容，可以传入shellcode
  [in]  SIZE_T  nSize,           #目标大小，shellcode的大小
  [out] SIZE_T  *lpNumberOfBytesWritten
);


```

#### SetThreadContext

设置指定线程的上下文：设置为 GetThreadContext 拿到的上下文地址

```
BOOL SetThreadContext(
  [in] HANDLE        hThread,        #通过CreateProcessA获取的进程句柄
  [in] const CONTEXT *lpContext        #GetThreadContext获取的线程上下文地址
);


```

#### ResumeThread

恢复线程的执行。

```
DWORD ResumeThread(
  [in] HANDLE hThread          #通过CreateProcessA获取的进程句柄
);


```

免杀测试
----

国内的杀毒软件比较好绕，使用风暴免杀的各个模块都可以轻松绕过 360、火绒等杀软，这里主要测试一下进程镂空来绕过 Defender（风暴免杀已经实现了这一功能）。

根据前文进程镂空的介绍，我们的木马程序主要将一个现有的 exe（请使用 cs 或 msf 生成）替换到目标程序来运行，经过测试，由于我们的源码进行了加密，这个替换写入的过程并没有被 defender 查杀。被替换成木马的目标程序运行后出现恶意行为会被 defender 查杀，比如执行 shell 命令，由于只是查杀掉目标程序而不会查杀我们的木马程序，于是我想到了是否会存在白名单程序可以绕过 defender，所以利用脚本尝试了虚拟机当前运行中的所有程序：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuYY8F0bYCia8LdDyZyvtI4RfWHHWneibFYKcARj9Jia1lSZfwZ7tM20sEs7xsrCa5HSrZKRIBwfJH5ibA/640?wx_fmt=png)image-20230501112014371

如图所示，从进程名可以看出我们镂空不同程序上线，但上线后大部分程序都会被 defender 查杀掉，但有一个程序出现了例外（winlogon.exe），它并没有被查杀掉，可以持续稳定上线：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuYY8F0bYCia8LdDyZyvtI4RfyE0ibXPPx3dYsI4UaldjcyAqLwibGF2GfTldLn31oibaic3Q04BDvDhMXw/640?wx_fmt=png)image-20230501112513128

于是我们单独镂空 winlogon.exe 进行测试，发现 defender 是会告警病毒威胁的，但只是提示重启，并不会主动查杀（可能是因为怕误杀导致系统不可用）

```
本文转自 https://blog.csdn.net/u013797594/article/details/130502682，如有侵权，请联系删除。

```

技术交流
====

### 知识星球

致力于红蓝对抗，实战攻防，星球不定时更新内外网攻防渗透技巧，以及最新学习研究成果等。常态化更新最新安全动态。专题更新奇技淫巧小 Tips 及实战案例。

涉及方向包括 Web 渗透、免杀绕过、内网攻防、代码审计、应急响应、云安全。星球中已发布 300+ 安全资源，针对网络安全成员的普遍水平，并为星友提供了教程、工具、POC&EXP 以及各种学习笔记等等。

![](https://mmbiz.qpic.cn/mmbiz_jpg/h8P1KUHOKuZHR0HeHaxgPlffiaYyrFGx4iadXU0pyXia0fVh9NXgWHBBibDHVWwgtc3ib0MG0SliaufqXQM6mISpKIAg/640?wx_fmt=jpeg)

### 学习圈子

一个引导大家一起成长，系统化学习的圈子。如果看到这里的师傅是基础不够扎实 / 技术不够全面 / 入行安全不久 / 有充足时间的初学者... 其中之一，那么欢迎加入我们的圈子。在圈子内会每周规划学习任务，提供资料、技术文档，供大家一起学习、交流，由浅入深、层层递进。（[点我了解详情](http://mp.weixin.qq.com/s?__biz=Mzg2ODYxMzY3OQ==&mid=2247498684&idx=1&sn=71c923f29d6431f6271398d435f96ae0&chksm=ceab10fcf9dc99ea174325e6982af84d0331aeee2cb0196ac11405acd44283c18da31e77d553&scene=21#wechat_redirect)）

![](https://mmbiz.qpic.cn/sz_mmbiz_png/h8P1KUHOKuYY8F0bYCia8LdDyZyvtI4RfY4gac59bJ2mUD9Zpa2ZrwdIov0icxBzlkUGXicvJaHiboMXByNVhWbhtQ/640?wx_fmt=png)

### 交流群

关注公众号回复 “**加群**”，添加 Z2OBot 好友，自动拉你加入 **Z2O 安全攻防交流群 (微信群)** 分享更多好东西。**（QQ 群可直接扫码添加）**

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKuYMO5aHRB3TbIy3xezlTAkbFzqIRfZNnicxSC23h1UmemDu9Jq38xrleA6NyoWBu1nAj0nmE6YXEHg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/mmbiz_png/h8P1KUHOKubCcJREicLMkEHIMkCDkGbfwqdiaWZUJtQ8ZNbMVFNTh7JyHdg69vRN2tBVbicNBAIWdgPQfjHoDxVmw/640?wx_fmt=png)

### 关注我们

**关注福利：**

**回复 “****app****" 获取  app 渗透和 app 抓包教程**

**回复 “****渗透字典** **" 获取 针对一些字典重新划分处理，收集了几个密码管理字典生成器用来扩展更多字典的仓库。**

**回复 “****书籍** **" 获取 网络安全相关经典书籍电子版 pdf**

****回复 “资料** **" 获取 网络安全、渗透测试相关资料文档****

点个【 在看 】，你最好看