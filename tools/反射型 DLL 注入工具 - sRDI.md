> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/bJcNCtoANQtXPVEhs01-yQ)

**转自：二向箔安全学院**

        题外话：这又是一篇受众范围很小的文章，贵在不凡，我相信这是一个长期存在的对抗技术，知已知彼，斗智斗勇，特精选此文，共同学习。因为涉及到国家层面 “最后一公里” 的技术对抗，所以技术难度高，你要有足够的思想准备和充足的体力来完成。  

看到某厂商介绍的 “蔓灵花”(Bitter)，长期针对中国及巴基斯坦的政府、军工、电力、核等部门发动网络攻击，具有较强的政治背景。在介绍中提到了 “反射式 Dll 注入”，这是自 2017 年流行到如今的攻击方式，估计还会持续很长一段时间；这种方式是“无文件” 攻击的一种，也是 Dll 注入的推陈出新的结合体，了解它有着很现实的重大意义，现推荐这篇。

**引言：**常规的 DLL 注入方式相信大家都很熟悉了，利用 CreateRemoteThread 这一函数在目标进程中开始一个新的线程，这个线程执行系统的 API 函数 LoadLibrary，之后 DLL 就被装载到目标进程中了。然而，由于这一技术被大量的恶意软件利用，各种安全对 DLL 注入这一块自然是严加看守，而常规的注入方式太过于套路化 (CreateRemoteThread+ LoadLibrary)，导致它十分容易被检测出来。同时，常规的 DLL 注入方式还需要目标 DLL 必须存在磁盘上，而文件一旦 “落地” 就也存在着被杀毒软件查杀的风险。

####     **一、DLL 注入**   

####     首先，我们需要了解什么是反射型 DLL 注入。DLL 注入就是将 DLL 放进某个进程的地址空间里，让它成为那个进程的一部分。要实现 DLL 注入，首先需要打开目标进程。

    DLL 注入也被很多合法软件广泛的使用，但恶意软件通常采用 DLL 注入在另一进程的存储空间内伪装其操作。DLL 注入是一个过程，该过程使另一个正在运行的进程加载并执行注入者的任何代码。看上去相当的危险，但它也有很多合法用途。例如，没有它，debug 调试器就不能运行。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpJmUWLfXbvt1xIn8iamibGUAnKOuPVQuia6kUr1ich0icGC7Spx1e7lLJ9ZWWAyPrG26lUXHo3TvS7AssQ/640?wx_fmt=png)

实现 DLL 注入可参考：http://blog.opensecurityresearch.com/2013/01/windows-dll-injection-basics.html

**1、反射型 DLL 注入**

反射 DLL 注入用于将 DLL 加载到进程中，而不必将其放置在主机的文件系统上。   
    反射 DLL 注入的过程如下：  
    1) 使用 RWX 权限打开目标进程，并为 DLL 分配足够大的内存；  
    2) 将 DLL 复制到分配的内存空间中；  
    3) 计算 DLL 中用于执行反射加载的导出的内存偏移量；  
    4) 使用反射性加载器函数的偏移地址作为入口，调用 CreateRemoteThread(或 RtlCreateUserThread) 开始在远程进程中执行；  
    5) 反射式加载器功能使用适当的 CPU 寄存器查找目标进程的进程环境块 (PEB)，并使用该寄存器在内存 kernel32.dll 和任何其他所需库中查找地址；  
    6) 解析的 KERNEL32 出口目录中找到所需的 API 功能，如内存地址 LoadLibraryA，GetProcAddress 和 VirtualAlloc；  
    7) 然后使用这些函数将 DLL(自身) 正确加载到内存中，并调用其入口点 DllMain。  
    这一过程比较复杂，值得深思。

反射型 DLL 注入：https://github.com/stephenfewer/ReflectiveDLLInjection

反射型 DLL 注入的假设是，调用 DLL 的入口点足以执行 DLL 的全部功能。但是，往往并非如此。Microsoft 建议开发人员尽量减少在 DllMain 中的工作量，并进行 “延迟初始化”，避免加载其他库或创建新线程。然后，主要入口点位于另一个函数中，该函数在 DLL 加载后将单独调用。

  
    有人提出一种更强大的 DLL 注入技术，该技术试图遵循 Microsoft 概述的 DLL 最佳实践。它通过向目标进程动态写入一些引导程序 Shellcode 来实现此目的，该进程将加载 DLL(使用 LoadLibraryA)，然后查找并调用另一个导出的入口点函数 (使用 GetProcAddress)。尽管这是对传统 DLL 注入的重大改进，但不是反射型的。

  
    因此，将这一技术进行改进，来实现更完美的反射型 DLL 注入。

来源：https://disman.tl/2015/01/30/an-improved-reflective-dll-injection-technique.html

 **2、怎样实现反射型 DLL 注入？**

其基本过程如下：

1) 打开目标进程并分配内存；  
    2) 将 DLL 复制到分配的内存中；  
    3) 将入口点函数名称的哈希值和该函数的所有参数复制到 DLL 之后的内存空间中。  
    4) 复制一些引导程序的 shellcode，该 shellcode 调用带有指向在第 3 步中复制的数据的指针的修改的反射式加载器。  
    5) 使用 shellcode 开头的地址作为入口点，在目标进程中创建一个远程线程。

需要引导程序 Shellcode 的原因是由于我们能够使用 Stephen Fewer 的原始反射 DLL 注入技术传递给反射加载器的数据量有限。

CreateRemoteThread 具有以下声明：  
HANDLE WINAPI CreateRemoteThread(

  _In_   HANDLE hProcess,

  _In_   LPSECURITY_ATTRIBUTES lpThreadAttributes,

  _In_   SIZE_T dwStackSize,

  _In_   LPTHREAD_START_ROUTINE lpStartAddress,

  _In_   LPVOID lpParameter,

  _In_   DWORD dwCreationFlags,

  _Out_  LPDWORD lpThreadId

);

其中 LPTHREAD_START_ROUTINE lpStartAddress 是所创建的线程的执行入口点。该函数的原型为：

typedef DWORD (__stdcall *LPTHREAD_START_ROUTINE) (

[in] LPVOID lpThreadParameter

);

如上，这仅需要一个 LPVOID 参数。反射型 DLL 注入技术将反射型加载器的地址 CreateRemoteThread 作为 lpStartAddress 参数传递，因此它只能传递单个 void 指针。这将有利于反射型加载器仅调用 DllMain，而后者将 void 指针作为其 lpvReserved 参数。

但是，如果我们希望反射型加载器在加载 DLL 之后调用其他导出，则需要为其提供更多信息！我们将通过使用一些引导程序 Shellcode 将其他参数传递给反射型加载器函数来实现。因此反射型加载器函数将声明：

DWORD WINAPI ReflectiveLoader(LPVOID lpParameter, LPVOID lpLibraryAddress, DWORD dwFunctionHash, LPVOID lpUserData, DWORD nUserdataLen);

在这里的 dwFunctionHash 是要调用的导出函数名称的哈希值，lpUserData 是一堆数据（大小为 nUserdataLen），当反射加载程序调用导出函数时，我们将其传递给该函数。

下面，我们不仅要在 DLL 的远程进程中分配内存，我们还要包括用于 shellcode（64 字节就足够了）和一定的数据空间：

DWORD nBufferSize = dwLength // size of the DLL

    + nUserdataLen

    + 64; // shellcode buffer

// alloc memory (RWX) in the host process for the image...

lpRemoteLibraryBuffer = VirtualAllocEx(hProcess, NULL, nBufferSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

if (!lpRemoteLibraryBuffer)    break;

printf("Allocated memory address in remote process: 0x%p\n", lpRemoteLibraryBuffer);

// write the image into the host process...

if (!WriteProcessMemory(hProcess, lpRemoteLibraryBuffer, lpBuffer, dwLength, NULL))    break;

ULONG_PTR uiReflectiveLoaderAddr = (ULONG_PTR)lpRemoteLibraryBuffer + dwReflectiveLoaderOffset;

// write our userdata blob into the host process

ULONG_PTR userdataAddr = (ULONG_PTR)lpRemoteLibraryBuffer + dwLength;

if (!WriteProcessMemory(hProcess, (LPVOID)userdataAddr, lpUserdata, nUserdataLen, NULL))    break;

ULONG_PTR uiShellcodeAddr = userdataAddr + nUserdataLen;

Shellcode 将有两个目标：  
     1) 使用我们的附加参数调用反射型加载器函数；  
     2)ExitThread() 进行适当的清理，以便我们可以从调用过程中获取线程的退出代码。

首先，我们获得的内存地址 ExitThread，该内存地址对于每个进程都应该相同（因为大多数（几乎所有）进程都加载了 kernel32.dll）。

HMODULE kernel32 = LoadLibraryA("kernel32.dll");

FARPROC exitthread = GetProcAddress(kernel32, "ExitThread");

接下来，我们将引导程序 Shellcode 写入缓冲区，然后将其写入分配的远程进程内存空间。shellcode 的 x86 版本很简单，因为我们只需要在调用反射加载程序之前以相反的顺序（按照__stdcall 调用约定）将参数推入堆栈即可，x64 shellcode 更为复杂，因为调用约定要求使用寄存器来传递参数。

最后，我们将 shellcode 写入远程进程，并创建一个使用 shellcode 地址作为入口点的远程线程：

// finally, write our shellcode into the host process

if (!WriteProcessMemory(hProcess, (LPVOID)uiShellcodeAddr, bootstrap, i, NULL))

    break;

// Make sure our changes are written right away

FlushInstructionCache(hProcess, lpRemoteLibraryBuffer, nBufferSize);

// create a remote thread in the host process to call the ReflectiveLoader!

hThread = CreateRemoteThread(hProcess, NULL, 1024 * 1024, (LPTHREAD_START_ROUTINE)uiShellcodeAddr, lpParameter, (DWORD)NULL, &dwThreadId);

反射型加载器功能本身与 Fewer 的原始版本相比没有太大变化，除了传递给它的附加参数以及随后在 DLL 中调用选择的导出的部分外。加载 DLL 之后，它将调用 DllMain（理想情况下为 null），然后调用我们的导出。

下面就介绍今天的主角：

 **二、sRDI✨（Shellcode 反射 DLL 注入）**
---------------------------------

它可以基于 Shellcode 实现反射型 DLL 注入，并且能够将 DLL 转换为独立的 Shellcode。

项目地址：https://github.com/monoxgas/sRDI

如果我们不想接触磁盘，则需要某种注入技术。可以写一个反射型加载的 DLL，但是反射性 DLL 注入会留下可以检测到的内存伪像。

而 sRDI 可以把一个普通的 DLL 文件转换为一段不依赖任何位置的 Shellcode。

相对于标准 RDI，使用 sRDI 的一些优点：

. 你可以转换任何 DLL 为无位置依赖的 shellcode，并且可以使用标准的 shellcode 注入技术来使用它；  
    . 你的 DLL 中不需要写任何反射加载器代码，因为反射加载器是在 DLL 外部的 shellcode 中实现的；  
    . 合理使用权限，没有大量的 RWX 权限数据；  
    . 还可以根据选项，抹掉 PE 头特征。

**组成简介**🎨

sRDI 的所有功能基于以下两个组件：

1) 一个 C 语言项目，可将 PE Loader 编译为 Shellcode；  
     2) 转换代码负责将 DLL、RDI 和用户数据进行绑定，由以下元素组成：  
    .ShellcodeRDI：编译 DLL 加载器的 Shellcode；  
    .NativeLoader：需要时将 DLL 转换为 shellcode，然后注入内存;  
   .DotNetLoader：NativeLoader 的 C＃ 实现；  
   .Python \ ConvertToShellcode.py：将 DLL 转换为 shellcode；  
    .Python \ EncodeBlobs.py：对已编译的 sRDI 进行编码，进行静态嵌入；  
   .PowerShell \ ConvertTo-Shellcode.ps1：将 DLL 转换为 shellcode；  
    .FunctionTest：导入 sRDI 的 C 函数，进行调试测试；           .TestDLL：示例 DLL，包括两个导出函数，用于后续的加载和调用；

DLL 不需要使用 RDI 进行编译，但是该技术具有交叉兼容性。

**优势**💎

＃1 – 隐秘的持久性

. 使用服务器端 Python 代码 (sRDI) 将 RAT 转换为 shellcode；  
     . 将 shellcode 写入注册表；  
    . 设置计划的任务以执行基本的加载程序 DLL；  
      . 加载程序读取 shellcode 并注入（少于 20 行 C 代码）；

优点： RAT 或加载器都不需要了解 RDI 或使用 RDI 进行编译。装载机可以保持小巧而简单，避免警告。

#2 – 侧面加载

1) 让你的 RAT 在内存中运行  
    2) 编写 DLL 以执行额外的功能  
    3) 将 DLL 转换为 shellcode(使用 sRDI) 并本地注入  
    4) 使用 GetProcAddressR 查找导出的函数  
    5) 执行 X 次附加功能，而无需重新加载 DLL

优点： 使您的初始工具更轻巧，并根据需要添加功能。加载一次 DLL 并像使用其他任何 DLL 一样使用它。

＃3 – 依赖关系

1) 从磁盘读取现有的合法 API DLL  
    2) 将 DLL 转换为 shellcode（使用 sRDI）并将其加载到内存中  
    3) 使用 GetProcAddress 查找所需的功能；

**优点**： 避免使用监视工具来检测 LoadLibrary 调用。访问 API 函数而不会泄漏信息。(WinInet，PSApi，TlHelp32，GdiPlus)

**使用**✔

**使用 python 将 DLL 转换为 shellcode**

from ShellcodeRDI import *

dll = open("TestDLL_x86.dll", 'rb').read()  
shellcode = ConvertToShellcode(dll)

**使用 C＃ 加载程序将 DLL 加载到内存中**

DotNetLoader.exe TestDLL_x64.dll

**使用 python 脚本转换 DLL 并使用本机 EXE 加载**

python ConvertToShellcode.py TestDLL_x64.dll  
NativeLoader.exe TestDLL_x64.bin

**使用 powershell 转换 DLL 并使用 Invoke-Shellcode 加载**

Import-Module .\Invoke-Shellcode.ps1

Import-Module .\ConvertTo-Shellcode.ps1

Invoke-Shellcode -Shellcode (ConvertTo-Shellcode -File TestDLL_x64.dll)

**搭建**🔨

sRDI 是使用 Visual Studio 2015（v140）和 Windows SDK 8.1 构建的。python 脚本是使用 Python 3 编写的。

Python 和 Powershell 脚本位于：

· Python\ConvertToShellcode.py

· PowerShell\ConvertTo-Shellcode.ps1  
  

构建项目后，其他二进制文件将位于：

· bin\NativeLoader.exe

· bin\DotNetLoader.exe

· bin\TestDLL_<arch>.dll

· bin\ShellcodeRDI_<arch>.bin

     **测试 test⌛  
**   让我们编译一个简单的 x86 DLL，执行弹出 2 个记事本进程：![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpJmUWLfXbvt1xIn8iamibGUAn3hxQZlnmkSDumJYl0m7U0e5XoSpR8XqOsibIdDTulHdZ5yVzfU5vf8Q/640?wx_fmt=png)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    将 DLL 转换为 shellcode。我们将得到一个以十进制值表示的 shellcode 字节数组：  
$sc = ConvertTo-Shellcode \\VBOXSVR\Experiments\messagebox\messagebox\Debug\messagebox.dll

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpJmUWLfXbvt1xIn8iamibGUAneDHSMDkmstHnY4G6oFuozd9ah7nRSMiaUctcwHGvRXPXWNYsEI1S5Yw/640?wx_fmt=png)  
让我们将它们转换为十六进制：  
$sc2 = $sc | % {write-output ([System.String]::Format('{0:X2}', $_)) }

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpJmUWLfXbvt1xIn8iamibGUAns4b1RABV1WGO3IAcbcq49Fa0opVgPkVhPr7RFw8fBx8hwwRiaUSf6Dg/640?wx_fmt=png)  
将它们全部加入并打印到文本文件：  
$sc2 -join "" > shell.txt

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpJmUWLfXbvt1xIn8iamibGUAnNWob1q8MztvbictMuhUibWZicROIwjgXDOGDUlnjVCP5ia3T7oljGIJyiag/640?wx_fmt=png)  
使用我们之前获得的 shellcode 创建一个新的二进制文件：![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpJmUWLfXbvt1xIn8iamibGUAnPJe5Re0j4uXLx110PS1aLTia3DHRsmtQ0opSFdniaRDlmFcuw7nl0sWQ/640?wx_fmt=png)

    为了加载和执行 shellcode，我们将把它作为资源放入二进制文件中。从 PE 资源加载和执行 Shellcode：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpJmUWLfXbvt1xIn8iamibGUAnf4Vok9IFXNAc7g0ODwO1tdMMppXJ4grrh8hgSSthft403tXU4BhCxA/640?wx_fmt=png)  
编译并运行二进制文件。如果 shellcode 成功运行，我们应该会看到两个 notepad.exe 进程弹出窗口：![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpJmUWLfXbvt1xIn8iamibGUAnZsJ18gpnTxw3ic7NqpUZQLxdVJ2E5Ol7u961z4fQVE6kqt7M6HpLpSg/640?wx_fmt=png)