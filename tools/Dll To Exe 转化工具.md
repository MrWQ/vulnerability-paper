> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/LS8Rk-0e7Ykpj_1FvSdHUg)

    在看雪最近的文章《网络拉取内存加载 C# 木马》最后总结中提到：全流程就是 Exe 运行了一个 shellcode，shellcode 中执行了 C# 的 dll，所以主程序就是一个加载器而已。

    上面 Exe 加载执行了 Dll，主要是为了内存执行达到无文件落地目的。转化下语言，有种场景，可以将 Dll 转换成 Exe 文件，多了一种利用。

    还是上文中那个老外的思路和框架，他提出了一种 DllToExe 的方法，那就再熟悉下 PE 吧。我觉得还不错，推荐。

**一、下载地址：**

https://github.com/hasherezade/dll_to_exe

**二、程序分析**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLWyKEO5LT7f9G96yEhPF8xNOYkXUPtTUACgd2LDXLgQ30FQZe3iawawwfbibRwa9jtCWOkn3icdrK4A/640?wx_fmt=png)

通杀 32 位和 64 位 Dll 程序；

用 vs2019 生成个最简单的 C++ 的 “Hello world!” 程序，如，本程序的“dll_to_exe ConsoleApplication32.dll ca32.exe” 和 “dll_to_exe ConsoleApplication64.dll ca64.exe”。

以前都是分析 32 位的程序，这次分析下 ca64.exe，也来看看 64 位的 PE 结构。

用 x64 加载 64 位程序，首先映入眼帘的是一段 C++ 编译器标志性的跳转，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLWyKEO5LT7f9G96yEhPF8x7L5JOjyAJQcO8xMicFUyCIydN0QGxvBwntXnfRnrFq8syhibibortibviaA/640?wx_fmt=png)

通过 

add rsp , 38

ret

进行长距离跳转，来到，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLWyKEO5LT7f9G96yEhPF8x10P4fY86zac6S8BVN1GTsLtdZcj6EeKrzVKrEpeAufTwpEyrCC2p1w/640?wx_fmt=png)

满是这样的代码的地方，不用管，直接 F8 下一步，直到来到这里的大循环，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLWyKEO5LT7f9G96yEhPF8x9uIRjz6PunqjREJwN2fQEJseK05CwTTibKrYwviaqfPSr7FWvfNTtqcQ/640?wx_fmt=png)

注意 jmp 要跳了，如果要回跳，就断在下面的 mov ecx 那行，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLWyKEO5LT7f9G96yEhPF8xYuvBpfVcutCKkiclias4c21H5DZT6sn3aaTlSGrlqMqnvvTbOpdFxKMw/640?wx_fmt=png)

果然，出来了，来到了正常的入口，因为我们看到了 “EntryPoint” 的入口标识。

我将上图的代码码下来，看看是啥，  

mov rcx,qword ptr gs:[60]

mov rcx,qword ptr ds:[rcx+10]

mov rdi,rcx

mov edx,1

mov rbx,rdx

xor r8,r8

jmp ...

ret

这段可能不熟悉，那我们来看看对应的 32 位的代码，

mov eax,dword ptr fs:[30]  

mov eax,dword ptr ds:[eax+8]

push 0

push 1

push eax

call ...

ret

看到这个 fs:[30]，有印象了吗，我上三篇文章中多次提到的 PEB 啊！

ds:[eax+8]，干什么用的？对照 PEB 结构体，发现是取 ImageBaseAddress，原来程序体的入口，一 jmp 或 一 call，就是调用原程序啊！

**三、程序原理**

整个流程就象是这样的，在正常的 PE 前面加上一段 PE Loader，将 Dll 转换下，就成为了 Exe 程序了。如图，

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpLWyKEO5LT7f9G96yEhPF8xcp0BU5DlcC0e8SaqD8bLnK18A0WuR6yQxBhNzRzZP6qCBqibrjuUVqQ/640?wx_fmt=png)

**四、程序源码**

int main(int argc, char *argv[])

{

    char *filename = argv[1];

    char *outfile = argv[2];

    PeHandler hndl(filename);

    hndl.setDll(); 

    if (hndl.dllToExePatch()) {

        std::cout <<"[OK] Converted successfuly."<< std::endl;

    } else {

        std::cout << "Could not convert!" << std::endl;

        return -1;

    }

    if (hndl.savePe(outfile)) {

        std::cout <<"[OK] Module dumped to:" << outfile << std::endl;

    }

    return 0;

}

将程序内无关判断去掉了，看主要内容。

程序写得非常精悍，清晰可读性强。  

一路下来，三个函数完成工作：

1.setDll()：设置 NT_Headers 中的 Exe 标识；

2.dllToExePatch()：利用插桩技术将那段 stub 插入到 Cave 中去，并计算 eip 指向其作为 EntryPoint；

3.savePe()：写入文件。

至此，dllToExe 分析完了，这次分析得是 64 位的逆向代码以及源码内容，我分析得非常详细，算是一篇教学式文章了。

通过以上四篇文章，我们重温了 C++ 的编程代码、C++ 编译器的汇编模样、CMake 的编译模式、PE 体系知识等内容，因为以前写过病毒、杀毒软件，所以对这套流程异常熟悉，也异常亲切；以前都是用汇编来构建，现在看到用 C++ 来构建，还是很有收获的，尤其是这种思想。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2hnvgPYNzpIiawurepkJibRVKefVIEeVLON4yYxAQic3N3gyopqrVefq4GkZY17xAyrvo3M8qEMj6a6SuqibnNoJKg/640?wx_fmt=png)